["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/readable-stream/lib/_stream_readable.js"],"~:js","shadow$provide[153]=function(S,A,V,q){function F(g,m,w){if(\"function\"===typeof g.prependListener)return g.prependListener(m,w);if(g._events&&g._events[m])P(g._events[m])?g._events[m].unshift(w):g._events[m]=[w,g._events[m]];else g.on(m,w)}function G(g,m){J=J||A(151);g=g||{};m=m instanceof J;this.objectMode=!!g.objectMode;m&&(this.objectMode=this.objectMode||!!g.readableObjectMode);var w=g.highWaterMark,x=g.readableHighWaterMark,z=this.objectMode?16:16384;this.highWaterMark=w||0===w?w:m&&(x||0===x)?\nx:z;this.highWaterMark=Math.floor(this.highWaterMark);this.buffer=new c;this.length=0;this.pipes=null;this.pipesCount=0;this.flowing=null;this.reading=this.endEmitted=this.ended=!1;this.sync=!0;this.destroyed=this.resumeScheduled=this.readableListening=this.emittedReadable=this.needReadable=!1;this.defaultEncoding=g.defaultEncoding||\"utf8\";this.awaitDrain=0;this.readingMore=!1;this.encoding=this.decoder=null;g.encoding&&(d||(d=A(152).StringDecoder),this.decoder=new d(g.encoding),this.encoding=g.encoding)}\nfunction r(g){J=J||A(151);if(!(this instanceof r))return new r(g);this._readableState=new G(g,this);this.readable=!0;g&&(\"function\"===typeof g.read&&(this._read=g.read),\"function\"===typeof g.destroy&&(this._destroy=g.destroy));T.call(this)}function y(g,m,w,x,z){var v=g._readableState;if(null===m)v.reading=!1,v.ended||(v.decoder&&(m=v.decoder.end())&&m.length&&(v.buffer.push(m),v.length+=v.objectMode?1:m.length),v.ended=!0,p(g));else{if(!z){z=m;var R;N.isBuffer(z)||z instanceof a||\"string\"===typeof z||\nvoid 0===z||v.objectMode||(R=new TypeError(\"Invalid non-string/buffer chunk\"));var O=R}O?g.emit(\"error\",O):v.objectMode||m&&0<m.length?(\"string\"===typeof m||v.objectMode||Object.getPrototypeOf(m)===N.prototype||(m=N.from(m)),x?v.endEmitted?g.emit(\"error\",Error(\"stream.unshift() after end event\")):e(g,v,m,!0):v.ended?g.emit(\"error\",Error(\"stream.push() after EOF\")):(v.reading=!1,v.decoder&&!w?(m=v.decoder.write(m),v.objectMode||0!==m.length?e(g,v,m,!1):v.readingMore||(v.readingMore=!0,M.nextTick(l,\ng,v))):e(g,v,m,!1))):x||(v.reading=!1)}return!v.ended&&(v.needReadable||v.length<v.highWaterMark||0===v.length)}function e(g,m,w,x){m.flowing&&0===m.length&&!m.sync?(g.emit(\"data\",w),g.read(0)):(m.length+=m.objectMode?1:w.length,x?m.buffer.unshift(w):m.buffer.push(w),m.needReadable&&p(g));m.readingMore||(m.readingMore=!0,M.nextTick(l,g,m))}function u(g,m){if(0>=g||0===m.length&&m.ended)return 0;if(m.objectMode)return 1;if(g!==g)return m.flowing&&m.length?m.buffer.head.data.length:m.length;if(g>m.highWaterMark){var w=\ng;8388608<=w?w=8388608:(w--,w|=w>>>1,w|=w>>>2,w|=w>>>4,w|=w>>>8,w|=w>>>16,w++);m.highWaterMark=w}return g<=m.length?g:m.ended?m.length:(m.needReadable=!0,0)}function p(g){var m=g._readableState;m.needReadable=!1;m.emittedReadable||(b(\"emitReadable\",m.flowing),m.emittedReadable=!0,m.sync?M.nextTick(n,g):n(g))}function n(g){b(\"emit readable\");g.emit(\"readable\");B(g)}function l(g,m){for(var w=m.length;!m.reading&&!m.flowing&&!m.ended&&m.length<m.highWaterMark&&(b(\"maybeReadMore read 0\"),g.read(0),w!==\nm.length);)w=m.length;m.readingMore=!1}function h(g){return function(){var m=g._readableState;b(\"pipeOnDrain\",m.awaitDrain);m.awaitDrain&&m.awaitDrain--;0===m.awaitDrain&&g.listeners(\"data\").length&&(m.flowing=!0,B(g))}}function k(g){b(\"readable nexttick read 0\");g.read(0)}function t(g,m){m.reading||(b(\"resume read 0\"),g.read(0));m.resumeScheduled=!1;m.awaitDrain=0;g.emit(\"resume\");B(g);m.flowing&&!m.reading&&g.read(0)}function B(g){var m=g._readableState;for(b(\"flow\",m.flowing);m.flowing&&null!==\ng.read(););}function E(g,m){if(0===m.length)return null;if(m.objectMode)var w=m.buffer.shift();else if(!g||g>=m.length)w=m.decoder?m.buffer.join(\"\"):1===m.buffer.length?m.buffer.head.data:m.buffer.concat(m.length),m.buffer.clear();else{w=m.buffer;m=m.decoder;if(g<w.head.data.length)m=w.head.data.slice(0,g),w.head.data=w.head.data.slice(g);else{if(g===w.head.data.length)w=w.shift();else if(m){m=w.head;var x=1,z=m.data;for(g-=z.length;m=m.next;){var v=m.data,R=g>v.length?v.length:g;z=R===v.length?z+\nv:z+v.slice(0,g);g-=R;if(0===g){R===v.length?(++x,w.head=m.next?m.next:w.tail=null):(w.head=m,m.data=v.slice(R));break}++x}w.length-=x;w=z}else{m=N.allocUnsafe(g);x=w.head;z=1;x.data.copy(m);for(g-=x.data.length;x=x.next;){v=x.data;R=g>v.length?v.length:g;v.copy(m,m.length-g,0,R);g-=R;if(0===g){R===v.length?(++z,w.head=x.next?x.next:w.tail=null):(w.head=x,x.data=v.slice(R));break}++z}w.length-=z;w=m}m=w}w=m}return w}function H(g){var m=g._readableState;if(0<m.length)throw Error('\"endReadable()\" called on non-empty stream');\nm.endEmitted||(m.ended=!0,M.nextTick(D,m,g))}function D(g,m){g.endEmitted||0!==g.length||(g.endEmitted=!0,m.readable=!1,m.emit(\"end\"))}function C(g,m){for(var w=0,x=g.length;w<x;w++)if(g[w]===m)return w;return-1}var I=A(1);\"use strict\";var M=A(142);V.exports=r;var P=A(52),J;r.ReadableState=G;A(113);var T=A(143),N=A(144).Buffer,a=(\"undefined\"!==typeof S?S:\"undefined\"!==typeof window?window:\"undefined\"!==typeof self?self:{}).Uint8Array||function(){};S=Object.create(A(147));S.inherits=A(76);V=A(6);var b=\nvoid 0;b=V&&V.debuglog?V.debuglog(\"stream\"):function(){};var c=A(148);V=A(149);var d;S.inherits(r,T);var f=[\"error\",\"close\",\"destroy\",\"pause\",\"resume\"];Object.defineProperty(r.prototype,\"destroyed\",{get:function(){return void 0===this._readableState?!1:this._readableState.destroyed},set:function(g){this._readableState&&(this._readableState.destroyed=g)}});r.prototype.destroy=V.destroy;r.prototype._undestroy=V.undestroy;r.prototype._destroy=function(g,m){this.push(null);m(g)};r.prototype.push=function(g,\nm){var w=this._readableState;if(w.objectMode)var x=!0;else\"string\"===typeof g&&(m=m||w.defaultEncoding,m!==w.encoding&&(g=N.from(g,m),m=\"\"),x=!0);return y(this,g,m,!1,x)};r.prototype.unshift=function(g){return y(this,g,null,!0,!1)};r.prototype.isPaused=function(){return!1===this._readableState.flowing};r.prototype.setEncoding=function(g){d||(d=A(152).StringDecoder);this._readableState.decoder=new d(g);this._readableState.encoding=g;return this};r.prototype.read=function(g){b(\"read\",g);g=parseInt(g,\n10);var m=this._readableState,w=g;0!==g&&(m.emittedReadable=!1);if(0===g&&m.needReadable&&(m.length>=m.highWaterMark||m.ended))return b(\"read: emitReadable\",m.length,m.ended),0===m.length&&m.ended?H(this):p(this),null;g=u(g,m);if(0===g&&m.ended)return 0===m.length&&H(this),null;var x=m.needReadable;b(\"need readable\",x);if(0===m.length||m.length-g<m.highWaterMark)x=!0,b(\"length less than watermark\",x);m.ended||m.reading?b(\"reading or ended\",!1):x&&(b(\"do read\"),m.reading=!0,m.sync=!0,0===m.length&&\n(m.needReadable=!0),this._read(m.highWaterMark),m.sync=!1,m.reading||(g=u(w,m)));x=0<g?E(g,m):null;null===x?(m.needReadable=!0,g=0):m.length-=g;0===m.length&&(m.ended||(m.needReadable=!0),w!==g&&m.ended&&H(this));null!==x&&this.emit(\"data\",x);return x};r.prototype._read=function(g){this.emit(\"error\",Error(\"_read() is not implemented\"))};r.prototype.pipe=function(g,m){function w(Y,aa){b(\"onunpipe\");Y===Q&&aa&&!1===aa.hasUnpiped&&(aa.hasUnpiped=!0,b(\"cleanup\"),g.removeListener(\"close\",R),g.removeListener(\"finish\",\nO),g.removeListener(\"drain\",Z),g.removeListener(\"error\",v),g.removeListener(\"unpipe\",w),Q.removeListener(\"end\",x),Q.removeListener(\"end\",L),Q.removeListener(\"data\",z),da=!0,!W.awaitDrain||g._writableState&&!g._writableState.needDrain||Z())}function x(){b(\"onend\");g.end()}function z(Y){b(\"ondata\");X=!1;!1!==g.write(Y)||X||((1===W.pipesCount&&W.pipes===g||1<W.pipesCount&&-1!==C(W.pipes,g))&&!da&&(b(\"false write response, pause\",W.awaitDrain),W.awaitDrain++,X=!0),Q.pause())}function v(Y){b(\"onerror\",\nY);L();g.removeListener(\"error\",v);0===g.listeners(\"error\").length&&g.emit(\"error\",Y)}function R(){g.removeListener(\"finish\",O);L()}function O(){b(\"onfinish\");g.removeListener(\"close\",R);L()}function L(){b(\"unpipe\");Q.unpipe(g)}var Q=this,W=this._readableState;switch(W.pipesCount){case 0:W.pipes=g;break;case 1:W.pipes=[W.pipes,g];break;default:W.pipes.push(g)}W.pipesCount+=1;b(\"pipe count\\x3d%d opts\\x3d%j\",W.pipesCount,m);m=m&&!1===m.end||g===I.stdout||g===I.stderr?L:x;if(W.endEmitted)M.nextTick(m);\nelse Q.once(\"end\",m);g.on(\"unpipe\",w);var Z=h(Q);g.on(\"drain\",Z);var da=!1,X=!1;Q.on(\"data\",z);F(g,\"error\",v);g.once(\"close\",R);g.once(\"finish\",O);g.emit(\"pipe\",Q);W.flowing||(b(\"pipe resume\"),Q.resume());return g};r.prototype.unpipe=function(g){var m=this._readableState,w={hasUnpiped:!1};if(0===m.pipesCount)return this;if(1===m.pipesCount){if(g&&g!==m.pipes)return this;g||(g=m.pipes);m.pipes=null;m.pipesCount=0;m.flowing=!1;g&&g.emit(\"unpipe\",this,w);return this}if(!g){g=m.pipes;w=m.pipesCount;m.pipes=\nnull;m.pipesCount=0;m.flowing=!1;for(m=0;m<w;m++)g[m].emit(\"unpipe\",this,{hasUnpiped:!1});return this}var x=C(m.pipes,g);if(-1===x)return this;m.pipes.splice(x,1);--m.pipesCount;1===m.pipesCount&&(m.pipes=m.pipes[0]);g.emit(\"unpipe\",this,w);return this};r.prototype.on=function(g,m){m=T.prototype.on.call(this,g,m);\"data\"===g?!1!==this._readableState.flowing&&this.resume():\"readable\"===g&&(g=this._readableState,g.endEmitted||g.readableListening||(g.readableListening=g.needReadable=!0,g.emittedReadable=\n!1,g.reading?g.length&&p(this):M.nextTick(k,this)));return m};r.prototype.addListener=r.prototype.on;r.prototype.resume=function(){var g=this._readableState;g.flowing||(b(\"resume\"),g.flowing=!0,g.resumeScheduled||(g.resumeScheduled=!0,M.nextTick(t,this,g)));return this};r.prototype.pause=function(){b(\"call pause flowing\\x3d%j\",this._readableState.flowing);!1!==this._readableState.flowing&&(b(\"pause\"),this._readableState.flowing=!1,this.emit(\"pause\"));return this};r.prototype.wrap=function(g){var m=\nthis,w=this._readableState,x=!1;g.on(\"end\",function(){b(\"wrapped end\");if(w.decoder&&!w.ended){var v=w.decoder.end();v&&v.length&&m.push(v)}m.push(null)});g.on(\"data\",function(v){b(\"wrapped data\");w.decoder&&(v=w.decoder.write(v));w.objectMode&&(null===v||void 0===v)||!(w.objectMode||v&&v.length)||m.push(v)||(x=!0,g.pause())});for(var z in g)void 0===this[z]&&\"function\"===typeof g[z]&&(this[z]=function(v){return function(){return g[v].apply(g,arguments)}}(z));for(z=0;z<f.length;z++)g.on(f[z],this.emit.bind(this,\nf[z]));this._read=function(v){b(\"wrapped _read\",v);x&&(x=!1,g.resume())};return this};Object.defineProperty(r.prototype,\"readableHighWaterMark\",{enumerable:!1,get:function(){return this._readableState.highWaterMark}});r._fromList=E}","~:source","shadow$provide[153] = function(global,require,module,exports) {\nvar process = require('process');\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, { hasUnpiped: false });\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$process$browser","~$module$node_modules$events$events","~$shadow$empty","~$shadow.js","~$module$node_modules$inherits$inherits_browser","~$module$node_modules$readable_stream$lib$_stream_duplex","~$module$node_modules$readable_stream$node_modules$string_decoder$lib$string_decoder","~$module$node_modules$util$util","~$module$node_modules$readable_stream$lib$internal$streams$destroy","~$module$node_modules$isarray$index","~$module$node_modules$readable_stream$lib$internal$streams$BufferList","~$module$node_modules$readable_stream$lib$internal$streams$stream_browser","~$module$node_modules$process_nextick_args$index","~$module$node_modules$readable_stream$node_modules$safe_buffer$index"]],"~:properties",["^5",["_destroy","tail","_readableState","reading","emittedReadable","_undestroy","_fromList","awaitDrain","readable","pipesCount","defaultEncoding","ended","setEncoding","resumeScheduled","encoding","read","push","flowing","wrap","_read","buffer","unshift","sync","destroy","unpipe","enumerable","addListener","hasUnpiped","pause","inherits","readingMore","needReadable","pipe","on","highWaterMark","pipes","length","head","endEmitted","isPaused","readableHighWaterMark","set","destroyed","objectMode","data","get","decoder","ReadableState","readableListening","resume"]],"~:compiled-at",1695041440815,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$readable_stream$lib$_stream_readable.js\",\n\"lineCount\":21,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/readable-stream/lib/_stream_readable.js\"],\n\"sourcesContent\":[\"shadow$provide[153] = function(global,require,module,exports) {\\nvar process = require('process');\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n'use strict';\\n\\n/*<replacement>*/\\n\\nvar pna = require('process-nextick-args');\\n/*</replacement>*/\\n\\nmodule.exports = Readable;\\n\\n/*<replacement>*/\\nvar isArray = require('isarray');\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar Duplex;\\n/*</replacement>*/\\n\\nReadable.ReadableState = ReadableState;\\n\\n/*<replacement>*/\\nvar EE = require('events').EventEmitter;\\n\\nvar EElistenerCount = function (emitter, type) {\\n  return emitter.listeners(type).length;\\n};\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar Stream = require('./internal/streams/stream');\\n/*</replacement>*/\\n\\n/*<replacement>*/\\n\\nvar Buffer = require('safe-buffer').Buffer;\\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\\nfunction _uint8ArrayToBuffer(chunk) {\\n  return Buffer.from(chunk);\\n}\\nfunction _isUint8Array(obj) {\\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\\n}\\n\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar util = Object.create(require('core-util-is'));\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar debugUtil = require('util');\\nvar debug = void 0;\\nif (debugUtil && debugUtil.debuglog) {\\n  debug = debugUtil.debuglog('stream');\\n} else {\\n  debug = function () {};\\n}\\n/*</replacement>*/\\n\\nvar BufferList = require('./internal/streams/BufferList');\\nvar destroyImpl = require('./internal/streams/destroy');\\nvar StringDecoder;\\n\\nutil.inherits(Readable, Stream);\\n\\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\\n\\nfunction prependListener(emitter, event, fn) {\\n  // Sadly this is not cacheable as some libraries bundle their own\\n  // event emitter implementation with them.\\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\\n\\n  // This is a hack to make sure that our error handler is attached before any\\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\\n  // to continue to work with older versions of Node.js that do not include\\n  // the prependListener() method. The goal is to eventually remove this hack.\\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\\n}\\n\\nfunction ReadableState(options, stream) {\\n  Duplex = Duplex || require('./_stream_duplex');\\n\\n  options = options || {};\\n\\n  // Duplex streams are both readable and writable, but share\\n  // the same options object.\\n  // However, some cases require setting options to different\\n  // values for the readable and the writable sides of the duplex stream.\\n  // These options can be provided separately as readableXXX and writableXXX.\\n  var isDuplex = stream instanceof Duplex;\\n\\n  // object stream flag. Used to make read(n) ignore n and to\\n  // make all the buffer merging and length checks go away\\n  this.objectMode = !!options.objectMode;\\n\\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\\n\\n  // the point at which it stops calling _read() to fill the buffer\\n  // Note: 0 is a valid value, means \\\"don't call _read preemptively ever\\\"\\n  var hwm = options.highWaterMark;\\n  var readableHwm = options.readableHighWaterMark;\\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\\n\\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\\n\\n  // cast to ints.\\n  this.highWaterMark = Math.floor(this.highWaterMark);\\n\\n  // A linked list is used to store data chunks instead of an array because the\\n  // linked list can remove elements from the beginning faster than\\n  // array.shift()\\n  this.buffer = new BufferList();\\n  this.length = 0;\\n  this.pipes = null;\\n  this.pipesCount = 0;\\n  this.flowing = null;\\n  this.ended = false;\\n  this.endEmitted = false;\\n  this.reading = false;\\n\\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\\n  // immediately, or on a later tick.  We set this to true at first, because\\n  // any actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first read call.\\n  this.sync = true;\\n\\n  // whenever we return null, then we set a flag to say\\n  // that we're awaiting a 'readable' event emission.\\n  this.needReadable = false;\\n  this.emittedReadable = false;\\n  this.readableListening = false;\\n  this.resumeScheduled = false;\\n\\n  // has it been destroyed\\n  this.destroyed = false;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // the number of writers that are awaiting a drain event in .pipe()s\\n  this.awaitDrain = 0;\\n\\n  // if true, a maybeReadMore has been scheduled\\n  this.readingMore = false;\\n\\n  this.decoder = null;\\n  this.encoding = null;\\n  if (options.encoding) {\\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\\n    this.decoder = new StringDecoder(options.encoding);\\n    this.encoding = options.encoding;\\n  }\\n}\\n\\nfunction Readable(options) {\\n  Duplex = Duplex || require('./_stream_duplex');\\n\\n  if (!(this instanceof Readable)) return new Readable(options);\\n\\n  this._readableState = new ReadableState(options, this);\\n\\n  // legacy\\n  this.readable = true;\\n\\n  if (options) {\\n    if (typeof options.read === 'function') this._read = options.read;\\n\\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\\n  }\\n\\n  Stream.call(this);\\n}\\n\\nObject.defineProperty(Readable.prototype, 'destroyed', {\\n  get: function () {\\n    if (this._readableState === undefined) {\\n      return false;\\n    }\\n    return this._readableState.destroyed;\\n  },\\n  set: function (value) {\\n    // we ignore the value if the stream\\n    // has not been initialized yet\\n    if (!this._readableState) {\\n      return;\\n    }\\n\\n    // backward compatibility, the user is explicitly\\n    // managing destroyed\\n    this._readableState.destroyed = value;\\n  }\\n});\\n\\nReadable.prototype.destroy = destroyImpl.destroy;\\nReadable.prototype._undestroy = destroyImpl.undestroy;\\nReadable.prototype._destroy = function (err, cb) {\\n  this.push(null);\\n  cb(err);\\n};\\n\\n// Manually shove something into the read() buffer.\\n// This returns true if the highWaterMark has not been hit yet,\\n// similar to how Writable.write() returns true if you should\\n// write() some more.\\nReadable.prototype.push = function (chunk, encoding) {\\n  var state = this._readableState;\\n  var skipChunkCheck;\\n\\n  if (!state.objectMode) {\\n    if (typeof chunk === 'string') {\\n      encoding = encoding || state.defaultEncoding;\\n      if (encoding !== state.encoding) {\\n        chunk = Buffer.from(chunk, encoding);\\n        encoding = '';\\n      }\\n      skipChunkCheck = true;\\n    }\\n  } else {\\n    skipChunkCheck = true;\\n  }\\n\\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\\n};\\n\\n// Unshift should *always* be something directly out of read()\\nReadable.prototype.unshift = function (chunk) {\\n  return readableAddChunk(this, chunk, null, true, false);\\n};\\n\\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\\n  var state = stream._readableState;\\n  if (chunk === null) {\\n    state.reading = false;\\n    onEofChunk(stream, state);\\n  } else {\\n    var er;\\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\\n    if (er) {\\n      stream.emit('error', er);\\n    } else if (state.objectMode || chunk && chunk.length > 0) {\\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\\n        chunk = _uint8ArrayToBuffer(chunk);\\n      }\\n\\n      if (addToFront) {\\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\\n      } else if (state.ended) {\\n        stream.emit('error', new Error('stream.push() after EOF'));\\n      } else {\\n        state.reading = false;\\n        if (state.decoder && !encoding) {\\n          chunk = state.decoder.write(chunk);\\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\\n        } else {\\n          addChunk(stream, state, chunk, false);\\n        }\\n      }\\n    } else if (!addToFront) {\\n      state.reading = false;\\n    }\\n  }\\n\\n  return needMoreData(state);\\n}\\n\\nfunction addChunk(stream, state, chunk, addToFront) {\\n  if (state.flowing && state.length === 0 && !state.sync) {\\n    stream.emit('data', chunk);\\n    stream.read(0);\\n  } else {\\n    // update the buffer info.\\n    state.length += state.objectMode ? 1 : chunk.length;\\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\\n\\n    if (state.needReadable) emitReadable(stream);\\n  }\\n  maybeReadMore(stream, state);\\n}\\n\\nfunction chunkInvalid(state, chunk) {\\n  var er;\\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\\n    er = new TypeError('Invalid non-string/buffer chunk');\\n  }\\n  return er;\\n}\\n\\n// if it's past the high water mark, we can push in some more.\\n// Also, if we have no data yet, we can stand some\\n// more bytes.  This is to work around cases where hwm=0,\\n// such as the repl.  Also, if the push() triggered a\\n// readable event, and the user called read(largeNumber) such that\\n// needReadable was set, then we ought to push more, so that another\\n// 'readable' event will be triggered.\\nfunction needMoreData(state) {\\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\\n}\\n\\nReadable.prototype.isPaused = function () {\\n  return this._readableState.flowing === false;\\n};\\n\\n// backwards compatibility.\\nReadable.prototype.setEncoding = function (enc) {\\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\\n  this._readableState.decoder = new StringDecoder(enc);\\n  this._readableState.encoding = enc;\\n  return this;\\n};\\n\\n// Don't raise the hwm > 8MB\\nvar MAX_HWM = 0x800000;\\nfunction computeNewHighWaterMark(n) {\\n  if (n >= MAX_HWM) {\\n    n = MAX_HWM;\\n  } else {\\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\\n    // tiny amounts\\n    n--;\\n    n |= n >>> 1;\\n    n |= n >>> 2;\\n    n |= n >>> 4;\\n    n |= n >>> 8;\\n    n |= n >>> 16;\\n    n++;\\n  }\\n  return n;\\n}\\n\\n// This function is designed to be inlinable, so please take care when making\\n// changes to the function body.\\nfunction howMuchToRead(n, state) {\\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\\n  if (state.objectMode) return 1;\\n  if (n !== n) {\\n    // Only flow one buffer at a time\\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\\n  }\\n  // If we're asking for more than the current hwm, then raise the hwm.\\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\\n  if (n <= state.length) return n;\\n  // Don't have enough\\n  if (!state.ended) {\\n    state.needReadable = true;\\n    return 0;\\n  }\\n  return state.length;\\n}\\n\\n// you can override either this method, or the async _read(n) below.\\nReadable.prototype.read = function (n) {\\n  debug('read', n);\\n  n = parseInt(n, 10);\\n  var state = this._readableState;\\n  var nOrig = n;\\n\\n  if (n !== 0) state.emittedReadable = false;\\n\\n  // if we're doing read(0) to trigger a readable event, but we\\n  // already have a bunch of data in the buffer, then just trigger\\n  // the 'readable' event and move on.\\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\\n    debug('read: emitReadable', state.length, state.ended);\\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\\n    return null;\\n  }\\n\\n  n = howMuchToRead(n, state);\\n\\n  // if we've ended, and we're now clear, then finish it up.\\n  if (n === 0 && state.ended) {\\n    if (state.length === 0) endReadable(this);\\n    return null;\\n  }\\n\\n  // All the actual chunk generation logic needs to be\\n  // *below* the call to _read.  The reason is that in certain\\n  // synthetic stream cases, such as passthrough streams, _read\\n  // may be a completely synchronous operation which may change\\n  // the state of the read buffer, providing enough data when\\n  // before there was *not* enough.\\n  //\\n  // So, the steps are:\\n  // 1. Figure out what the state of things will be after we do\\n  // a read from the buffer.\\n  //\\n  // 2. If that resulting state will trigger a _read, then call _read.\\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\\n  // deeply ugly to write APIs this way, but that still doesn't mean\\n  // that the Readable class should behave improperly, as streams are\\n  // designed to be sync/async agnostic.\\n  // Take note if the _read call is sync or async (ie, if the read call\\n  // has returned yet), so that we know whether or not it's safe to emit\\n  // 'readable' etc.\\n  //\\n  // 3. Actually pull the requested chunks out of the buffer and return.\\n\\n  // if we need a readable event, then we need to do some reading.\\n  var doRead = state.needReadable;\\n  debug('need readable', doRead);\\n\\n  // if we currently have less than the highWaterMark, then also read some\\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\\n    doRead = true;\\n    debug('length less than watermark', doRead);\\n  }\\n\\n  // however, if we've ended, then there's no point, and if we're already\\n  // reading, then it's unnecessary.\\n  if (state.ended || state.reading) {\\n    doRead = false;\\n    debug('reading or ended', doRead);\\n  } else if (doRead) {\\n    debug('do read');\\n    state.reading = true;\\n    state.sync = true;\\n    // if the length is currently zero, then we *need* a readable event.\\n    if (state.length === 0) state.needReadable = true;\\n    // call internal read method\\n    this._read(state.highWaterMark);\\n    state.sync = false;\\n    // If _read pushed data synchronously, then `reading` will be false,\\n    // and we need to re-evaluate how much data we can return to the user.\\n    if (!state.reading) n = howMuchToRead(nOrig, state);\\n  }\\n\\n  var ret;\\n  if (n > 0) ret = fromList(n, state);else ret = null;\\n\\n  if (ret === null) {\\n    state.needReadable = true;\\n    n = 0;\\n  } else {\\n    state.length -= n;\\n  }\\n\\n  if (state.length === 0) {\\n    // If we have nothing in the buffer, then we want to know\\n    // as soon as we *do* get something into the buffer.\\n    if (!state.ended) state.needReadable = true;\\n\\n    // If we tried to read() past the EOF, then emit end on the next tick.\\n    if (nOrig !== n && state.ended) endReadable(this);\\n  }\\n\\n  if (ret !== null) this.emit('data', ret);\\n\\n  return ret;\\n};\\n\\nfunction onEofChunk(stream, state) {\\n  if (state.ended) return;\\n  if (state.decoder) {\\n    var chunk = state.decoder.end();\\n    if (chunk && chunk.length) {\\n      state.buffer.push(chunk);\\n      state.length += state.objectMode ? 1 : chunk.length;\\n    }\\n  }\\n  state.ended = true;\\n\\n  // emit 'readable' now to make sure it gets picked up.\\n  emitReadable(stream);\\n}\\n\\n// Don't emit readable right away in sync mode, because this can trigger\\n// another read() call => stack overflow.  This way, it might trigger\\n// a nextTick recursion warning, but that's not so bad.\\nfunction emitReadable(stream) {\\n  var state = stream._readableState;\\n  state.needReadable = false;\\n  if (!state.emittedReadable) {\\n    debug('emitReadable', state.flowing);\\n    state.emittedReadable = true;\\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\\n  }\\n}\\n\\nfunction emitReadable_(stream) {\\n  debug('emit readable');\\n  stream.emit('readable');\\n  flow(stream);\\n}\\n\\n// at this point, the user has presumably seen the 'readable' event,\\n// and called read() to consume some data.  that may have triggered\\n// in turn another _read(n) call, in which case reading = true if\\n// it's in progress.\\n// However, if we're not ended, or reading, and the length < hwm,\\n// then go ahead and try to read some more preemptively.\\nfunction maybeReadMore(stream, state) {\\n  if (!state.readingMore) {\\n    state.readingMore = true;\\n    pna.nextTick(maybeReadMore_, stream, state);\\n  }\\n}\\n\\nfunction maybeReadMore_(stream, state) {\\n  var len = state.length;\\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\\n    debug('maybeReadMore read 0');\\n    stream.read(0);\\n    if (len === state.length)\\n      // didn't get any data, stop spinning.\\n      break;else len = state.length;\\n  }\\n  state.readingMore = false;\\n}\\n\\n// abstract method.  to be overridden in specific implementation classes.\\n// call cb(er, data) where data is <= n in length.\\n// for virtual (non-string, non-buffer) streams, \\\"length\\\" is somewhat\\n// arbitrary, and perhaps not very meaningful.\\nReadable.prototype._read = function (n) {\\n  this.emit('error', new Error('_read() is not implemented'));\\n};\\n\\nReadable.prototype.pipe = function (dest, pipeOpts) {\\n  var src = this;\\n  var state = this._readableState;\\n\\n  switch (state.pipesCount) {\\n    case 0:\\n      state.pipes = dest;\\n      break;\\n    case 1:\\n      state.pipes = [state.pipes, dest];\\n      break;\\n    default:\\n      state.pipes.push(dest);\\n      break;\\n  }\\n  state.pipesCount += 1;\\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\\n\\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\\n\\n  var endFn = doEnd ? onend : unpipe;\\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\\n\\n  dest.on('unpipe', onunpipe);\\n  function onunpipe(readable, unpipeInfo) {\\n    debug('onunpipe');\\n    if (readable === src) {\\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\\n        unpipeInfo.hasUnpiped = true;\\n        cleanup();\\n      }\\n    }\\n  }\\n\\n  function onend() {\\n    debug('onend');\\n    dest.end();\\n  }\\n\\n  // when the dest drains, it reduces the awaitDrain counter\\n  // on the source.  This would be more elegant with a .once()\\n  // handler in flow(), but adding and removing repeatedly is\\n  // too slow.\\n  var ondrain = pipeOnDrain(src);\\n  dest.on('drain', ondrain);\\n\\n  var cleanedUp = false;\\n  function cleanup() {\\n    debug('cleanup');\\n    // cleanup event handlers once the pipe is broken\\n    dest.removeListener('close', onclose);\\n    dest.removeListener('finish', onfinish);\\n    dest.removeListener('drain', ondrain);\\n    dest.removeListener('error', onerror);\\n    dest.removeListener('unpipe', onunpipe);\\n    src.removeListener('end', onend);\\n    src.removeListener('end', unpipe);\\n    src.removeListener('data', ondata);\\n\\n    cleanedUp = true;\\n\\n    // if the reader is waiting for a drain event from this\\n    // specific writer, then it would cause it to never start\\n    // flowing again.\\n    // So, if this is awaiting a drain, then we just call it now.\\n    // If we don't know, then assume that we are waiting for one.\\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\\n  }\\n\\n  // If the user pushes more data while we're writing to dest then we'll end up\\n  // in ondata again. However, we only want to increase awaitDrain once because\\n  // dest will only emit one 'drain' event for the multiple writes.\\n  // => Introduce a guard on increasing awaitDrain.\\n  var increasedAwaitDrain = false;\\n  src.on('data', ondata);\\n  function ondata(chunk) {\\n    debug('ondata');\\n    increasedAwaitDrain = false;\\n    var ret = dest.write(chunk);\\n    if (false === ret && !increasedAwaitDrain) {\\n      // If the user unpiped during `dest.write()`, it is possible\\n      // to get stuck in a permanently paused state if that write\\n      // also returned false.\\n      // => Check whether `dest` is still a piping destination.\\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\\n        debug('false write response, pause', state.awaitDrain);\\n        state.awaitDrain++;\\n        increasedAwaitDrain = true;\\n      }\\n      src.pause();\\n    }\\n  }\\n\\n  // if the dest has an error, then stop piping into it.\\n  // however, don't suppress the throwing behavior for this.\\n  function onerror(er) {\\n    debug('onerror', er);\\n    unpipe();\\n    dest.removeListener('error', onerror);\\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\\n  }\\n\\n  // Make sure our error handler is attached before userland ones.\\n  prependListener(dest, 'error', onerror);\\n\\n  // Both close and finish should trigger unpipe, but only once.\\n  function onclose() {\\n    dest.removeListener('finish', onfinish);\\n    unpipe();\\n  }\\n  dest.once('close', onclose);\\n  function onfinish() {\\n    debug('onfinish');\\n    dest.removeListener('close', onclose);\\n    unpipe();\\n  }\\n  dest.once('finish', onfinish);\\n\\n  function unpipe() {\\n    debug('unpipe');\\n    src.unpipe(dest);\\n  }\\n\\n  // tell the dest that it's being piped to\\n  dest.emit('pipe', src);\\n\\n  // start the flow if it hasn't been started already.\\n  if (!state.flowing) {\\n    debug('pipe resume');\\n    src.resume();\\n  }\\n\\n  return dest;\\n};\\n\\nfunction pipeOnDrain(src) {\\n  return function () {\\n    var state = src._readableState;\\n    debug('pipeOnDrain', state.awaitDrain);\\n    if (state.awaitDrain) state.awaitDrain--;\\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\\n      state.flowing = true;\\n      flow(src);\\n    }\\n  };\\n}\\n\\nReadable.prototype.unpipe = function (dest) {\\n  var state = this._readableState;\\n  var unpipeInfo = { hasUnpiped: false };\\n\\n  // if we're not piping anywhere, then do nothing.\\n  if (state.pipesCount === 0) return this;\\n\\n  // just one destination.  most common case.\\n  if (state.pipesCount === 1) {\\n    // passed in one, but it's not the right one.\\n    if (dest && dest !== state.pipes) return this;\\n\\n    if (!dest) dest = state.pipes;\\n\\n    // got a match.\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\\n    return this;\\n  }\\n\\n  // slow case. multiple pipe destinations.\\n\\n  if (!dest) {\\n    // remove all.\\n    var dests = state.pipes;\\n    var len = state.pipesCount;\\n    state.pipes = null;\\n    state.pipesCount = 0;\\n    state.flowing = false;\\n\\n    for (var i = 0; i < len; i++) {\\n      dests[i].emit('unpipe', this, { hasUnpiped: false });\\n    }return this;\\n  }\\n\\n  // try to find the right one.\\n  var index = indexOf(state.pipes, dest);\\n  if (index === -1) return this;\\n\\n  state.pipes.splice(index, 1);\\n  state.pipesCount -= 1;\\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\\n\\n  dest.emit('unpipe', this, unpipeInfo);\\n\\n  return this;\\n};\\n\\n// set up data events if they are asked for\\n// Ensure readable listeners eventually get something\\nReadable.prototype.on = function (ev, fn) {\\n  var res = Stream.prototype.on.call(this, ev, fn);\\n\\n  if (ev === 'data') {\\n    // Start flowing on next tick if stream isn't explicitly paused\\n    if (this._readableState.flowing !== false) this.resume();\\n  } else if (ev === 'readable') {\\n    var state = this._readableState;\\n    if (!state.endEmitted && !state.readableListening) {\\n      state.readableListening = state.needReadable = true;\\n      state.emittedReadable = false;\\n      if (!state.reading) {\\n        pna.nextTick(nReadingNextTick, this);\\n      } else if (state.length) {\\n        emitReadable(this);\\n      }\\n    }\\n  }\\n\\n  return res;\\n};\\nReadable.prototype.addListener = Readable.prototype.on;\\n\\nfunction nReadingNextTick(self) {\\n  debug('readable nexttick read 0');\\n  self.read(0);\\n}\\n\\n// pause() and resume() are remnants of the legacy readable stream API\\n// If the user uses them, then switch into old mode.\\nReadable.prototype.resume = function () {\\n  var state = this._readableState;\\n  if (!state.flowing) {\\n    debug('resume');\\n    state.flowing = true;\\n    resume(this, state);\\n  }\\n  return this;\\n};\\n\\nfunction resume(stream, state) {\\n  if (!state.resumeScheduled) {\\n    state.resumeScheduled = true;\\n    pna.nextTick(resume_, stream, state);\\n  }\\n}\\n\\nfunction resume_(stream, state) {\\n  if (!state.reading) {\\n    debug('resume read 0');\\n    stream.read(0);\\n  }\\n\\n  state.resumeScheduled = false;\\n  state.awaitDrain = 0;\\n  stream.emit('resume');\\n  flow(stream);\\n  if (state.flowing && !state.reading) stream.read(0);\\n}\\n\\nReadable.prototype.pause = function () {\\n  debug('call pause flowing=%j', this._readableState.flowing);\\n  if (false !== this._readableState.flowing) {\\n    debug('pause');\\n    this._readableState.flowing = false;\\n    this.emit('pause');\\n  }\\n  return this;\\n};\\n\\nfunction flow(stream) {\\n  var state = stream._readableState;\\n  debug('flow', state.flowing);\\n  while (state.flowing && stream.read() !== null) {}\\n}\\n\\n// wrap an old-style stream as the async data source.\\n// This is *not* part of the readable stream interface.\\n// It is an ugly unfortunate mess of history.\\nReadable.prototype.wrap = function (stream) {\\n  var _this = this;\\n\\n  var state = this._readableState;\\n  var paused = false;\\n\\n  stream.on('end', function () {\\n    debug('wrapped end');\\n    if (state.decoder && !state.ended) {\\n      var chunk = state.decoder.end();\\n      if (chunk && chunk.length) _this.push(chunk);\\n    }\\n\\n    _this.push(null);\\n  });\\n\\n  stream.on('data', function (chunk) {\\n    debug('wrapped data');\\n    if (state.decoder) chunk = state.decoder.write(chunk);\\n\\n    // don't skip over falsy values in objectMode\\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\\n\\n    var ret = _this.push(chunk);\\n    if (!ret) {\\n      paused = true;\\n      stream.pause();\\n    }\\n  });\\n\\n  // proxy all the other methods.\\n  // important when wrapping filters and duplexes.\\n  for (var i in stream) {\\n    if (this[i] === undefined && typeof stream[i] === 'function') {\\n      this[i] = function (method) {\\n        return function () {\\n          return stream[method].apply(stream, arguments);\\n        };\\n      }(i);\\n    }\\n  }\\n\\n  // proxy certain important events.\\n  for (var n = 0; n < kProxyEvents.length; n++) {\\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\\n  }\\n\\n  // when we try to consume some more bytes, simply unpause the\\n  // underlying stream.\\n  this._read = function (n) {\\n    debug('wrapped _read', n);\\n    if (paused) {\\n      paused = false;\\n      stream.resume();\\n    }\\n  };\\n\\n  return this;\\n};\\n\\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\\n  // making it explicit this property is not enumerable\\n  // because otherwise some prototype manipulation in\\n  // userland will fail\\n  enumerable: false,\\n  get: function () {\\n    return this._readableState.highWaterMark;\\n  }\\n});\\n\\n// exposed for testing purposes only.\\nReadable._fromList = fromList;\\n\\n// Pluck off n bytes from an array of buffers.\\n// Length is the combined lengths of all the buffers in the list.\\n// This function is designed to be inlinable, so please take care when making\\n// changes to the function body.\\nfunction fromList(n, state) {\\n  // nothing buffered\\n  if (state.length === 0) return null;\\n\\n  var ret;\\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\\n    // read it all, truncate the list\\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\\n    state.buffer.clear();\\n  } else {\\n    // read part of list\\n    ret = fromListPartial(n, state.buffer, state.decoder);\\n  }\\n\\n  return ret;\\n}\\n\\n// Extracts only enough buffered data to satisfy the amount requested.\\n// This function is designed to be inlinable, so please take care when making\\n// changes to the function body.\\nfunction fromListPartial(n, list, hasStrings) {\\n  var ret;\\n  if (n < list.head.data.length) {\\n    // slice is the same for buffers and strings\\n    ret = list.head.data.slice(0, n);\\n    list.head.data = list.head.data.slice(n);\\n  } else if (n === list.head.data.length) {\\n    // first chunk is a perfect match\\n    ret = list.shift();\\n  } else {\\n    // result spans more than one buffer\\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\\n  }\\n  return ret;\\n}\\n\\n// Copies a specified amount of characters from the list of buffered data\\n// chunks.\\n// This function is designed to be inlinable, so please take care when making\\n// changes to the function body.\\nfunction copyFromBufferString(n, list) {\\n  var p = list.head;\\n  var c = 1;\\n  var ret = p.data;\\n  n -= ret.length;\\n  while (p = p.next) {\\n    var str = p.data;\\n    var nb = n > str.length ? str.length : n;\\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\\n    n -= nb;\\n    if (n === 0) {\\n      if (nb === str.length) {\\n        ++c;\\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\\n      } else {\\n        list.head = p;\\n        p.data = str.slice(nb);\\n      }\\n      break;\\n    }\\n    ++c;\\n  }\\n  list.length -= c;\\n  return ret;\\n}\\n\\n// Copies a specified amount of bytes from the list of buffered data chunks.\\n// This function is designed to be inlinable, so please take care when making\\n// changes to the function body.\\nfunction copyFromBuffer(n, list) {\\n  var ret = Buffer.allocUnsafe(n);\\n  var p = list.head;\\n  var c = 1;\\n  p.data.copy(ret);\\n  n -= p.data.length;\\n  while (p = p.next) {\\n    var buf = p.data;\\n    var nb = n > buf.length ? buf.length : n;\\n    buf.copy(ret, ret.length - n, 0, nb);\\n    n -= nb;\\n    if (n === 0) {\\n      if (nb === buf.length) {\\n        ++c;\\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\\n      } else {\\n        list.head = p;\\n        p.data = buf.slice(nb);\\n      }\\n      break;\\n    }\\n    ++c;\\n  }\\n  list.length -= c;\\n  return ret;\\n}\\n\\nfunction endReadable(stream) {\\n  var state = stream._readableState;\\n\\n  // If we get here before consuming all the bytes, then that is a\\n  // bug in node.  Should never happen.\\n  if (state.length > 0) throw new Error('\\\"endReadable()\\\" called on non-empty stream');\\n\\n  if (!state.endEmitted) {\\n    state.ended = true;\\n    pna.nextTick(endReadableNT, state, stream);\\n  }\\n}\\n\\nfunction endReadableNT(state, stream) {\\n  // Check that we didn't get one last unshift.\\n  if (!state.endEmitted && state.length === 0) {\\n    state.endEmitted = true;\\n    stream.readable = false;\\n    stream.emit('end');\\n  }\\n}\\n\\nfunction indexOf(xs, x) {\\n  for (var i = 0, l = xs.length; i < l; i++) {\\n    if (xs[i] === x) return i;\\n  }\\n  return -1;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"prependListener\",\"emitter\",\"event\",\"fn\",\"_events\",\"isArray\",\"unshift\",\"on\",\"ReadableState\",\"options\",\"stream\",\"Duplex\",\"isDuplex\",\"objectMode\",\"readableObjectMode\",\"hwm\",\"highWaterMark\",\"readableHwm\",\"readableHighWaterMark\",\"defaultHwm\",\"Math\",\"floor\",\"buffer\",\"BufferList\",\"length\",\"pipes\",\"pipesCount\",\"flowing\",\"reading\",\"endEmitted\",\"ended\",\"sync\",\"destroyed\",\"resumeScheduled\",\"readableListening\",\"emittedReadable\",\"needReadable\",\"defaultEncoding\",\"awaitDrain\",\"readingMore\",\"encoding\",\"decoder\",\"StringDecoder\",\"Readable\",\"_readableState\",\"readable\",\"read\",\"_read\",\"destroy\",\"_destroy\",\"Stream\",\"call\",\"readableAddChunk\",\"chunk\",\"addToFront\",\"skipChunkCheck\",\"state\",\"end\",\"push\",\"emitReadable\",\"er\",\"Buffer\",\"isBuffer\",\"OurUint8Array\",\"undefined\",\"TypeError\",\"emit\",\"Object\",\"getPrototypeOf\",\"prototype\",\"from\",\"Error\",\"addChunk\",\"write\",\"pna\",\"nextTick\",\"maybeReadMore_\",\"howMuchToRead\",\"n\",\"head\",\"data\",\"MAX_HWM\",\"debug\",\"emitReadable_\",\"flow\",\"len\",\"pipeOnDrain\",\"src\",\"listeners\",\"type\",\"nReadingNextTick\",\"self\",\"resume_\",\"fromList\",\"ret\",\"shift\",\"join\",\"concat\",\"clear\",\"list\",\"slice\",\"p\",\"c\",\"next\",\"str\",\"nb\",\"tail\",\"allocUnsafe\",\"copy\",\"buf\",\"endReadable\",\"endReadableNT\",\"indexOf\",\"xs\",\"x\",\"i\",\"l\",\"process\",\"Uint8Array\",\"window\",\"util\",\"create\",\"inherits\",\"debugUtil\",\"debuglog\",\"destroyImpl\",\"kProxyEvents\",\"defineProperty\",\"get\",\"set\",\"value\",\"_undestroy\",\"undestroy\",\"Readable.prototype._destroy\",\"err\",\"cb\",\"Readable.prototype.push\",\"Readable.prototype.unshift\",\"isPaused\",\"Readable.prototype.isPaused\",\"setEncoding\",\"Readable.prototype.setEncoding\",\"enc\",\"Readable.prototype.read\",\"parseInt\",\"nOrig\",\"doRead\",\"Readable.prototype._read\",\"pipe\",\"Readable.prototype.pipe\",\"dest\",\"pipeOpts\",\"onunpipe\",\"unpipeInfo\",\"hasUnpiped\",\"removeListener\",\"onclose\",\"onfinish\",\"ondrain\",\"onerror\",\"onend\",\"unpipe\",\"ondata\",\"cleanedUp\",\"_writableState\",\"needDrain\",\"increasedAwaitDrain\",\"pause\",\"endFn\",\"stdout\",\"stderr\",\"once\",\"resume\",\"Readable.prototype.unpipe\",\"dests\",\"index\",\"splice\",\"Readable.prototype.on\",\"ev\",\"res\",\"addListener\",\"Readable.prototype.resume\",\"Readable.prototype.pause\",\"wrap\",\"Readable.prototype.wrap\",\"_this\",\"paused\",\"method\",\"apply\",\"arguments\",\"bind\",\"this._read\",\"enumerable\",\"_fromList\"]\n}\n"]