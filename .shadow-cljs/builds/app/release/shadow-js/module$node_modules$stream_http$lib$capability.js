["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/stream-http/lib/capability.js"],"~:js","shadow$provide[298]=function(S,A,V,q){function F(){if(void 0!==y)return y;if(S.XMLHttpRequest){y=new S.XMLHttpRequest;try{y.open(\"GET\",S.XDomainRequest?\"/\":\"https://example.com\")}catch(e){y=null}}else y=null;return y}function G(e){var u=F();if(!u)return!1;try{return u.responseType=e,u.responseType===e}catch(p){}return!1}function r(e){return\"function\"===typeof e}q.fetch=r(S.fetch)&&r(S.ReadableStream);q.writableStream=r(S.WritableStream);q.abortController=r(S.AbortController);q.blobConstructor=!1;\ntry{new Blob([new ArrayBuffer(1)]),q.blobConstructor=!0}catch(e){}V=(A=\"undefined\"!==typeof S.ArrayBuffer)&&r(S.ArrayBuffer.prototype.slice);q.arraybuffer=q.fetch||A&&G(\"arraybuffer\");q.msstream=!q.fetch&&V&&G(\"ms-stream\");q.mozchunkedarraybuffer=!q.fetch&&A&&G(\"moz-chunked-arraybuffer\");q.overrideMimeType=q.fetch||(F()?r(F().overrideMimeType):!1);q.vbArray=r(S.VBArray);var y=null}","~:source","shadow$provide[298] = function(global,require,module,exports) {\nexports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.writableStream = isFunction(global.WritableStream)\n\nexports.abortController = isFunction(global.AbortController)\n\nexports.blobConstructor = false\ntry {\n\tnew Blob([new ArrayBuffer(1)])\n\texports.blobConstructor = true\n} catch (e) {}\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\n// Safari 7.1 appears to have fixed this bug.\nvar haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'\nvar haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&\n\tcheckTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nexports.vbArray = isFunction(global.VBArray)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["abortController","mozchunkedarraybuffer","fetch","vbArray","overrideMimeType","responseType","msstream","blobConstructor","arraybuffer","writableStream"]],"~:compiled-at",1695041440891,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$stream_http$lib$capability.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAiB9DC,QAASA,EAAO,EAAG,CAElB,GAAYC,IAAAA,EAAZ,GAAIC,CAAJ,CAAuB,MAAOA,EAE9B,IAAIN,CAAOO,CAAAA,cAAX,CAA2B,CAC1BD,CAAA,CAAM,IAAIN,CAAOO,CAAAA,cAIjB,IAAI,CACHD,CAAIE,CAAAA,IAAJ,CAAS,KAAT,CAAgBR,CAAOS,CAAAA,cAAP,CAAwB,GAAxB,CAA8B,qBAA9C,CADG,CAEF,MAAMC,CAAN,CAAS,CACVJ,CAAA,CAAM,IADI,CAPe,CAA3B,IAYCA,EAAA,CAAM,IAEP,OAAOA,EAlBW,CAqBnBK,QAASA,EAAiB,CAACC,CAAD,CAAO,CAChC,IAAIN,EAAMF,CAAA,EACV,IAAI,CAACE,CAAL,CAAU,MAAO,CAAA,CACjB,IAAI,CAEH,MADAA,EAAIO,CAAAA,YACG,CADYD,CACZ,CAAAN,CAAIO,CAAAA,YAAJ,GAAqBD,CAFzB,CAGF,MAAOF,CAAP,CAAU,EACZ,MAAO,CAAA,CAPyB,CA+BjCI,QAASA,EAAW,CAACC,CAAD,CAAQ,CAC3B,MAAwB,UAAxB,GAAO,MAAOA,EADa,CApE5BZ,CAAQa,CAAAA,KAAR,CAAgBF,CAAA,CAAWd,CAAOgB,CAAAA,KAAlB,CAAhB,EAA4CF,CAAA,CAAWd,CAAOiB,CAAAA,cAAlB,CAE5Cd,EAAQe,CAAAA,cAAR,CAAyBJ,CAAA,CAAWd,CAAOmB,CAAAA,cAAlB,CAEzBhB,EAAQiB,CAAAA,eAAR,CAA0BN,CAAA,CAAWd,CAAOqB,CAAAA,eAAlB,CAE1BlB,EAAQmB,CAAAA,eAAR,CAA0B,CAAA,CAC1B;GAAI,CACH,IAAIC,IAAJ,CAAS,CAAC,IAAIC,WAAJ,CAAgB,CAAhB,CAAD,CAAT,CACA,CAAArB,CAAQmB,CAAAA,eAAR,CAA0B,CAAA,CAFvB,CAGF,MAAOZ,CAAP,CAAU,EAwCRe,CAAAA,EADAC,CACAD,CADgD,WAChDA,GADkB,MAAOzB,EAAOwB,CAAAA,WAChCC,GAA+BX,CAAA,CAAWd,CAAOwB,CAAAA,WAAYG,CAAAA,SAAUC,CAAAA,KAAxC,CAInCzB,EAAQ0B,CAAAA,WAAR,CAAsB1B,CAAQa,CAAAA,KAA9B,EAAwCU,CAAxC,EAA2Df,CAAA,CAAiB,aAAjB,CAI3DR,EAAQ2B,CAAAA,QAAR,CAAmB,CAAC3B,CAAQa,CAAAA,KAA5B,EAAqCS,CAArC,EAAkDd,CAAA,CAAiB,WAAjB,CAClDR,EAAQ4B,CAAAA,qBAAR,CAAgC,CAAC5B,CAAQa,CAAAA,KAAzC,EAAkDU,CAAlD,EACCf,CAAA,CAAiB,yBAAjB,CAIDR,EAAQ6B,CAAAA,gBAAR,CAA2B7B,CAAQa,CAAAA,KAAnC,GAA6CZ,CAAA,EAAA,CAAWU,CAAA,CAAWV,CAAA,EAAS4B,CAAAA,gBAApB,CAAX,CAAmD,CAAA,CAAhG,CAEA7B,EAAQ8B,CAAAA,OAAR,CAAkBnB,CAAA,CAAWd,CAAOkC,CAAAA,OAAlB,CAMlB,KAAA5B,EAAM,IAzEwD;\",\n\"sources\":[\"node_modules/stream-http/lib/capability.js\"],\n\"sourcesContent\":[\"shadow$provide[298] = function(global,require,module,exports) {\\nexports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\\n\\nexports.writableStream = isFunction(global.WritableStream)\\n\\nexports.abortController = isFunction(global.AbortController)\\n\\nexports.blobConstructor = false\\ntry {\\n\\tnew Blob([new ArrayBuffer(1)])\\n\\texports.blobConstructor = true\\n} catch (e) {}\\n\\n// The xhr request to example.com may violate some restrictive CSP configurations,\\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\\n// and assume support for certain features below.\\nvar xhr\\nfunction getXHR () {\\n\\t// Cache the xhr value\\n\\tif (xhr !== undefined) return xhr\\n\\n\\tif (global.XMLHttpRequest) {\\n\\t\\txhr = new global.XMLHttpRequest()\\n\\t\\t// If XDomainRequest is available (ie only, where xhr might not work\\n\\t\\t// cross domain), use the page location. Otherwise use example.com\\n\\t\\t// Note: this doesn't actually make an http request.\\n\\t\\ttry {\\n\\t\\t\\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\\n\\t\\t} catch(e) {\\n\\t\\t\\txhr = null\\n\\t\\t}\\n\\t} else {\\n\\t\\t// Service workers don't have XHR\\n\\t\\txhr = null\\n\\t}\\n\\treturn xhr\\n}\\n\\nfunction checkTypeSupport (type) {\\n\\tvar xhr = getXHR()\\n\\tif (!xhr) return false\\n\\ttry {\\n\\t\\txhr.responseType = type\\n\\t\\treturn xhr.responseType === type\\n\\t} catch (e) {}\\n\\treturn false\\n}\\n\\n// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\\n// Safari 7.1 appears to have fixed this bug.\\nvar haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'\\nvar haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)\\n\\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\\n// checkTypeSupport(), since that calls getXHR().\\nexports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))\\n\\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\\n// be used if it's available, just return false for these to avoid the warnings.\\nexports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')\\nexports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&\\n\\tcheckTypeSupport('moz-chunked-arraybuffer')\\n\\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\\n// getXHR().\\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\\n\\nexports.vbArray = isFunction(global.VBArray)\\n\\nfunction isFunction (value) {\\n\\treturn typeof value === 'function'\\n}\\n\\nxhr = null // Help gc\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getXHR\",\"undefined\",\"xhr\",\"XMLHttpRequest\",\"open\",\"XDomainRequest\",\"e\",\"checkTypeSupport\",\"type\",\"responseType\",\"isFunction\",\"value\",\"fetch\",\"ReadableStream\",\"writableStream\",\"WritableStream\",\"abortController\",\"AbortController\",\"blobConstructor\",\"Blob\",\"ArrayBuffer\",\"haveSlice\",\"haveArrayBuffer\",\"prototype\",\"slice\",\"arraybuffer\",\"msstream\",\"mozchunkedarraybuffer\",\"overrideMimeType\",\"vbArray\",\"VBArray\"]\n}\n"]