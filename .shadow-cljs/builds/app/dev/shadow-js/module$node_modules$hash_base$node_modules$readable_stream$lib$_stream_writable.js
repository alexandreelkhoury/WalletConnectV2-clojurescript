["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js"],"~:js","shadow$provide.module$node_modules$hash_base$node_modules$readable_stream$lib$_stream_writable=function(global,require,module,exports){function CorkedRequest(state){var _this=this;this.entry=this.next=null;this.finish=function(){var entry=_this.entry;for(_this.entry=null;entry;){var cb=entry.callback;state.pendingcb--;cb(void 0);entry=entry.next}state.corkedRequestsFree.next=_this}}function nop(){}function WritableState(options,stream,isDuplex){Duplex=Duplex||require(\"module$node_modules$hash_base$node_modules$readable_stream$lib$_stream_duplex\");\noptions=options||{};\"boolean\"!==typeof isDuplex&&(isDuplex=stream instanceof Duplex);this.objectMode=!!options.objectMode;isDuplex&&(this.objectMode=this.objectMode||!!options.writableObjectMode);this.highWaterMark=getHighWaterMark(this,options,\"writableHighWaterMark\",isDuplex);this.destroyed=this.finished=this.ended=this.ending=this.needDrain=this.finalCalled=!1;this.decodeStrings=!1!==options.decodeStrings;this.defaultEncoding=options.defaultEncoding||\"utf8\";this.length=0;this.writing=!1;this.corked=\n0;this.sync=!0;this.bufferProcessing=!1;this.onwrite=function(er){var state=stream._writableState,sync=state.sync,cb=state.writecb;if(\"function\"!==typeof cb)throw new ERR_MULTIPLE_CALLBACK;state.writing=!1;state.writecb=null;state.length-=state.writelen;state.writelen=0;er?(--state.pendingcb,sync?(process.nextTick(cb,er),process.nextTick(finishMaybe,stream,state),stream._writableState.errorEmitted=!0,errorOrDestroy(stream,er)):(cb(er),stream._writableState.errorEmitted=!0,errorOrDestroy(stream,er),\nfinishMaybe(stream,state))):((er=needFinish(state)||stream.destroyed)||state.corked||state.bufferProcessing||!state.bufferedRequest||clearBuffer(stream,state),sync?process.nextTick(afterWrite,stream,state,er,cb):afterWrite(stream,state,er,cb))};this.writecb=null;this.writelen=0;this.lastBufferedRequest=this.bufferedRequest=null;this.pendingcb=0;this.errorEmitted=this.prefinished=!1;this.emitClose=!1!==options.emitClose;this.autoDestroy=!!options.autoDestroy;this.bufferedRequestCount=0;this.corkedRequestsFree=\nnew CorkedRequest(this)}function Writable(options){Duplex=Duplex||require(\"module$node_modules$hash_base$node_modules$readable_stream$lib$_stream_duplex\");var isDuplex=this instanceof Duplex;if(!isDuplex&&!realHasInstance.call(Writable,this))return new Writable(options);this._writableState=new WritableState(options,this,isDuplex);this.writable=!0;options&&(\"function\"===typeof options.write&&(this._write=options.write),\"function\"===typeof options.writev&&(this._writev=options.writev),\"function\"===\ntypeof options.destroy&&(this._destroy=options.destroy),\"function\"===typeof options.final&&(this._final=options.final));Stream.call(this)}function doWrite(stream,state,writev,len,chunk,encoding,cb){state.writelen=len;state.writecb=cb;state.writing=!0;state.sync=!0;if(state.destroyed)state.onwrite(new ERR_STREAM_DESTROYED(\"write\"));else writev?stream._writev(chunk,state.onwrite):stream._write(chunk,encoding,state.onwrite);state.sync=!1}function afterWrite(stream,state,finished,cb){!finished&&0===state.length&&\nstate.needDrain&&(state.needDrain=!1,stream.emit(\"drain\"));state.pendingcb--;cb();finishMaybe(stream,state)}function clearBuffer(stream,state){state.bufferProcessing=!0;var entry=state.bufferedRequest;if(stream._writev&&entry&&entry.next){var buffer=Array(state.bufferedRequestCount),holder=state.corkedRequestsFree;holder.entry=entry;for(var count=0,allBuffers=!0;entry;)buffer[count]=entry,entry.isBuf||(allBuffers=!1),entry=entry.next,count+=1;buffer.allBuffers=allBuffers;doWrite(stream,state,!0,state.length,\nbuffer,\"\",holder.finish);state.pendingcb++;state.lastBufferedRequest=null;holder.next?(state.corkedRequestsFree=holder.next,holder.next=null):state.corkedRequestsFree=new CorkedRequest(state);state.bufferedRequestCount=0}else{for(;entry&&(buffer=entry.chunk,doWrite(stream,state,!1,state.objectMode?1:buffer.length,buffer,entry.encoding,entry.callback),entry=entry.next,state.bufferedRequestCount--,!state.writing););null===entry&&(state.lastBufferedRequest=null)}state.bufferedRequest=entry;state.bufferProcessing=\n!1}function needFinish(state){return state.ending&&0===state.length&&null===state.bufferedRequest&&!state.finished&&!state.writing}function callFinal(stream,state){stream._final(function(err){state.pendingcb--;err&&errorOrDestroy(stream,err);state.prefinished=!0;stream.emit(\"prefinish\");finishMaybe(stream,state)})}function finishMaybe(stream,state){var need=needFinish(state);need&&(state.prefinished||state.finalCalled||(\"function\"!==typeof stream._final||state.destroyed?(state.prefinished=!0,stream.emit(\"prefinish\")):\n(state.pendingcb++,state.finalCalled=!0,process.nextTick(callFinal,stream,state))),0===state.pendingcb&&(state.finished=!0,stream.emit(\"finish\"),state.autoDestroy&&(state=stream._readableState,(!state||state.autoDestroy&&state.endEmitted)&&stream.destroy())));return need}var process=require(\"module$node_modules$process$browser\");\"use strict\";module.exports=Writable;var Duplex;Writable.WritableState=WritableState;var internalUtil={deprecate:require(\"module$node_modules$util_deprecate$browser\")},Stream=\nrequire(\"module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$stream_browser\"),Buffer=require(\"module$node_modules$buffer$index\").Buffer,OurUint8Array=(\"undefined\"!==typeof global?global:\"undefined\"!==typeof window?window:\"undefined\"!==typeof self?self:{}).Uint8Array||function(){};global=require(\"module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$destroy\");var getHighWaterMark=require(\"module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$state\").getHighWaterMark;\nmodule=require(\"module$node_modules$hash_base$node_modules$readable_stream$errors\").codes;var ERR_INVALID_ARG_TYPE=module.ERR_INVALID_ARG_TYPE,ERR_METHOD_NOT_IMPLEMENTED=module.ERR_METHOD_NOT_IMPLEMENTED,ERR_MULTIPLE_CALLBACK=module.ERR_MULTIPLE_CALLBACK,ERR_STREAM_CANNOT_PIPE=module.ERR_STREAM_CANNOT_PIPE,ERR_STREAM_DESTROYED=module.ERR_STREAM_DESTROYED,ERR_STREAM_NULL_VALUES=module.ERR_STREAM_NULL_VALUES,ERR_STREAM_WRITE_AFTER_END=module.ERR_STREAM_WRITE_AFTER_END,ERR_UNKNOWN_ENCODING=module.ERR_UNKNOWN_ENCODING,\nerrorOrDestroy=global.errorOrDestroy;require(\"module$node_modules$inherits$inherits_browser\")(Writable,Stream);WritableState.prototype.getBuffer=function(){for(var current=this.bufferedRequest,out=[];current;)out.push(current),current=current.next;return out};(function(){try{Object.defineProperty(WritableState.prototype,\"buffer\",{get:internalUtil.deprecate(function(){return this.getBuffer()},\"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.\",\"DEP0003\")})}catch(_){}})();if(\"function\"===\ntypeof Symbol&&Symbol.hasInstance&&\"function\"===typeof Function.prototype[Symbol.hasInstance]){var realHasInstance=Function.prototype[Symbol.hasInstance];Object.defineProperty(Writable,Symbol.hasInstance,{value:function(object){return realHasInstance.call(this,object)?!0:this!==Writable?!1:object&&object._writableState instanceof WritableState}})}else realHasInstance=function(object){return object instanceof this};Writable.prototype.pipe=function(){errorOrDestroy(this,new ERR_STREAM_CANNOT_PIPE)};\nWritable.prototype.write=function(chunk,encoding,cb$jscomp$0){var state=this._writableState,ret=!1,JSCompiler_temp;if(JSCompiler_temp=!state.objectMode)JSCompiler_temp=chunk,JSCompiler_temp=Buffer.isBuffer(JSCompiler_temp)||JSCompiler_temp instanceof OurUint8Array;JSCompiler_temp&&!Buffer.isBuffer(chunk)&&(chunk=Buffer.from(chunk));\"function\"===typeof encoding&&(cb$jscomp$0=encoding,encoding=null);JSCompiler_temp?encoding=\"buffer\":encoding||(encoding=state.defaultEncoding);\"function\"!==typeof cb$jscomp$0&&\n(cb$jscomp$0=nop);if(state.ending)state=cb$jscomp$0,cb$jscomp$0=new ERR_STREAM_WRITE_AFTER_END,errorOrDestroy(this,cb$jscomp$0),process.nextTick(state,cb$jscomp$0);else{var JSCompiler_temp$jscomp$0;if(!(JSCompiler_temp$jscomp$0=JSCompiler_temp)){JSCompiler_temp$jscomp$0=chunk;var cb=cb$jscomp$0,er;null===JSCompiler_temp$jscomp$0?er=new ERR_STREAM_NULL_VALUES:\"string\"===typeof JSCompiler_temp$jscomp$0||state.objectMode||(er=new ERR_INVALID_ARG_TYPE(\"chunk\",[\"string\",\"Buffer\"],JSCompiler_temp$jscomp$0));\ner?(errorOrDestroy(this,er),process.nextTick(cb,er),JSCompiler_temp$jscomp$0=!1):JSCompiler_temp$jscomp$0=!0}JSCompiler_temp$jscomp$0&&(state.pendingcb++,ret=JSCompiler_temp,ret||(er=chunk,state.objectMode||!1===state.decodeStrings||\"string\"!==typeof er||(er=Buffer.from(er,encoding)),chunk!==er&&(ret=!0,encoding=\"buffer\",chunk=er)),JSCompiler_temp=state.objectMode?1:chunk.length,state.length+=JSCompiler_temp,er=state.length<state.highWaterMark,er||(state.needDrain=!0),state.writing||state.corked?\n(JSCompiler_temp=state.lastBufferedRequest,state.lastBufferedRequest={chunk,encoding,isBuf:ret,callback:cb$jscomp$0,next:null},JSCompiler_temp?JSCompiler_temp.next=state.lastBufferedRequest:state.bufferedRequest=state.lastBufferedRequest,state.bufferedRequestCount+=1):doWrite(this,state,!1,JSCompiler_temp,chunk,encoding,cb$jscomp$0),ret=er)}return ret};Writable.prototype.cork=function(){this._writableState.corked++};Writable.prototype.uncork=function(){var state=this._writableState;state.corked&&\n(state.corked--,state.writing||state.corked||state.bufferProcessing||!state.bufferedRequest||clearBuffer(this,state))};Writable.prototype.setDefaultEncoding=function(encoding){\"string\"===typeof encoding&&(encoding=encoding.toLowerCase());if(!(-1<\"hex utf8 utf-8 ascii binary base64 ucs2 ucs-2 utf16le utf-16le raw\".split(\" \").indexOf((encoding+\"\").toLowerCase())))throw new ERR_UNKNOWN_ENCODING(encoding);this._writableState.defaultEncoding=encoding;return this};Object.defineProperty(Writable.prototype,\n\"writableBuffer\",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}});Object.defineProperty(Writable.prototype,\"writableHighWaterMark\",{enumerable:!1,get:function(){return this._writableState.highWaterMark}});Writable.prototype._write=function(chunk,encoding,cb){cb(new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\"))};Writable.prototype._writev=null;Writable.prototype.end=function(chunk,encoding,cb){var state=this._writableState;\"function\"===typeof chunk?(cb=chunk,encoding=\nchunk=null):\"function\"===typeof encoding&&(cb=encoding,encoding=null);null!==chunk&&void 0!==chunk&&this.write(chunk,encoding);state.corked&&(state.corked=1,this.uncork());if(!state.ending){chunk=cb;state.ending=!0;finishMaybe(this,state);if(chunk)if(state.finished)process.nextTick(chunk);else this.once(\"finish\",chunk);state.ended=!0;this.writable=!1}return this};Object.defineProperty(Writable.prototype,\"writableLength\",{enumerable:!1,get:function(){return this._writableState.length}});Object.defineProperty(Writable.prototype,\n\"destroyed\",{enumerable:!1,get:function(){return void 0===this._writableState?!1:this._writableState.destroyed},set:function(value){this._writableState&&(this._writableState.destroyed=value)}});Writable.prototype.destroy=global.destroy;Writable.prototype._undestroy=global.undestroy;Writable.prototype._destroy=function(err,cb){cb(err)}}","~:source","shadow$provide[\"module$node_modules$hash_base$node_modules$readable_stream$lib$_stream_writable\"] = function(global,require,module,exports) {\nvar process = require('process');\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$hash_base$node_modules$readable_stream$errors","~$module$node_modules$hash_base$node_modules$readable_stream$lib$_stream_duplex","~$module$node_modules$process$browser","~$module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$stream_browser","~$module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$destroy","~$shadow.js","~$module$node_modules$inherits$inherits_browser","~$module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$state","~$module$node_modules$buffer$index","~$module$node_modules$util_deprecate$browser"]],"~:properties",["^5",["WritableState","callback","writelen","entry","_destroy","bufferedRequestCount","allBuffers","getBuffer","deprecate","next","prefinished","corked","_undestroy","needDrain","writecb","finalCalled","defaultEncoding","ended","encoding","bufferedRequest","onwrite","writableLength","buffer","chunk","writing","value","sync","destroy","enumerable","finish","pendingcb","writable","_write","pipe","highWaterMark","length","cork","_writableState","_writev","lastBufferedRequest","corkedRequestsFree","autoDestroy","writableBuffer","set","bufferProcessing","ending","errorEmitted","isBuf","uncork","destroyed","decodeStrings","write","_final","objectMode","get","end","writableHighWaterMark","emitClose","finished","setDefaultEncoding"]],"~:compiled-at",1695040653537,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hash_base$node_modules$readable_stream$lib$_stream_writable.js\",\n\"lineCount\":22,\n\"mappings\":\"AAAAA,cAAA,CAAA,+EAAA,CAAoG,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAyC5IC,QAASA,cAAa,CAACC,KAAD,CAAQ,CAC5B,IAAIC,MAAQ,IAEZ,KAAKC,CAAAA,KAAL,CADA,IAAKC,CAAAA,IACL,CADY,IAEZ,KAAKC,CAAAA,MAAL,CAAcC,QAAS,EAAG,CA8iB1B,IAAIH,MA7iBaD,KA6iBGC,CAAAA,KAEpB,KA/iBiBD,KA8iBTC,CAAAA,KACR,CADgB,IAChB,CAAOA,KAAP,CAAA,CAAc,CACZ,IAAII,GAAKJ,KAAMK,CAAAA,QAhjBOP,MAijBhBQ,CAAAA,SAAN,EACAF,GAAA,CAljBAG,IAAA,EAkjBA,CACAP,MAAA,CAAQA,KAAMC,CAAAA,IAJF,CA/iBUH,KAujBlBU,CAAAA,kBAAmBP,CAAAA,IAAzB,CAvjBiBF,KADS,CAJE,CAgD9BU,QAASA,IAAG,EAAG,EACfC,QAASA,cAAa,CAACC,OAAD,CAAUC,MAAV,CAAkBC,QAAlB,CAA4B,CAChDC,MAAA,CAASA,MAAT,EAAmBpB,OAAA,CAAQ,+EAAR,CACnBiB;OAAA,CAAUA,OAAV,EAAqB,EAOG,UAAxB,GAAI,MAAOE,SAAX,GAAmCA,QAAnC,CAA8CD,MAA9C,WAAgEE,OAAhE,CAIA,KAAKC,CAAAA,UAAL,CAAkB,CAAC,CAACJ,OAAQI,CAAAA,UACxBF,SAAJ,GAAc,IAAKE,CAAAA,UAAnB,CAAgC,IAAKA,CAAAA,UAArC,EAAmD,CAAC,CAACJ,OAAQK,CAAAA,kBAA7D,CAKA,KAAKC,CAAAA,aAAL,CAAqBC,gBAAA,CAAiB,IAAjB,CAAuBP,OAAvB,CAAgC,uBAAhC,CAAyDE,QAAzD,CAerB,KAAKM,CAAAA,SAAL,CAHA,IAAKC,CAAAA,QAGL,CALA,IAAKC,CAAAA,KAKL,CAPA,IAAKC,CAAAA,MAOL,CATA,IAAKC,CAAAA,SASL,CAZA,IAAKC,CAAAA,WAYL,CAZmB,CAAA,CAkBnB,KAAKC,CAAAA,aAAL,CADyC,CAAA,CACzC,GADed,OAAQc,CAAAA,aAMvB,KAAKC,CAAAA,eAAL,CAAuBf,OAAQe,CAAAA,eAA/B,EAAkD,MAKlD,KAAKC,CAAAA,MAAL,CAAc,CAGd,KAAKC,CAAAA,OAAL,CAAe,CAAA,CAGf,KAAKC,CAAAA,MAAL;AAAc,CAMd,KAAKC,CAAAA,IAAL,CAAY,CAAA,CAKZ,KAAKC,CAAAA,gBAAL,CAAwB,CAAA,CAGxB,KAAKC,CAAAA,OAAL,CAAeC,QAAS,CAACC,EAAD,CAAK,CAuQ7B,IAAIpC,MAtQMc,MAsQSuB,CAAAA,cAAnB,CACIL,KAAOhC,KAAMgC,CAAAA,IADjB,CAEI1B,GAAKN,KAAMsC,CAAAA,OACf,IAAkB,UAAlB,GAAI,MAAOhC,GAAX,CAA8B,KAAM,KAAIiC,qBAAV,CACXvC,KAVb8B,CAAAA,OAAN,CAAgB,CAAA,CAUG9B,MATbsC,CAAAA,OAAN,CAAgB,IASGtC,MARb6B,CAAAA,MAAN,EAQmB7B,KARGwC,CAAAA,QAQHxC,MAPbwC,CAAAA,QAAN,CAAiB,CAnQCJ,GA2QlB,EAjCA,EAiC6BpC,KAjCrBQ,CAAAA,SACR,CAgCoCwB,IAhCpC,EAGES,OAAQC,CAAAA,QAAR,CA6B4CpC,EA7B5C,CA9OgB8B,EA8OhB,CAKA,CAFAK,OAAQC,CAAAA,QAAR,CAAiBC,WAAjB,CAjPQ7B,MAiPR,CA0B2Bd,KA1B3B,CAEA,CAnPQc,MAkPDuB,CAAAA,cAAeO,CAAAA,YACtB,CADqC,CAAA,CACrC,CAAAC,cAAA,CAnPQ/B,MAmPR,CAnPgBsB,EAmPhB,CARF,GAgC8C9B,EApB5C,CAvPgB8B,EAuPhB,CAKA,CA5PQtB,MAwPDuB,CAAAA,cAAeO,CAAAA,YAItB,CAJqC,CAAA,CAIrC,CAHAC,cAAA,CAzPQ/B,MAyPR,CAzPgBsB,EAyPhB,CAGA;AAAAO,WAAA,CA5PQ7B,MA4PR,CAe2Bd,KAf3B,CAjBF,CAgCA,GAME,CAJIsB,EAIJ,CAJewB,UAAA,CAAW9C,KAAX,CAIf,EAjRQc,MA6QmCO,CAAAA,SAI3C,GAHkBrB,KAAM+B,CAAAA,MAGxB,EAHmC/B,KAAMiC,CAAAA,gBAGzC,EAHmEc,CAAN/C,KAAM+C,CAAAA,eAGnE,EAFEC,WAAA,CA/QMlC,MA+QN,CAAoBd,KAApB,CAEF,CAAIgC,IAAJ,CACES,OAAQC,CAAAA,QAAR,CAAiBO,UAAjB,CAlRMnC,MAkRN,CAAqCd,KAArC,CAA4CsB,EAA5C,CAAsDhB,EAAtD,CADF,CAGE2C,UAAA,CApRMnC,MAoRN,CAAmBd,KAAnB,CAA0BsB,EAA1B,CAAoChB,EAApC,CATJ,CA5Q6B,CAK7B,KAAKgC,CAAAA,OAAL,CAAe,IAGf,KAAKE,CAAAA,QAAL,CAAgB,CAEhB,KAAKU,CAAAA,mBAAL,CADA,IAAKH,CAAAA,eACL,CADuB,IAKvB,KAAKvC,CAAAA,SAAL,CAAiB,CAOjB,KAAKoC,CAAAA,YAAL,CAHA,IAAKO,CAAAA,WAGL,CAHmB,CAAA,CAMnB,KAAKC,CAAAA,SAAL,CAAuC,CAAA,CAAvC,GAAiBvC,OAAQuC,CAAAA,SAGzB,KAAKC,CAAAA,WAAL,CAAmB,CAAC,CAACxC,OAAQwC,CAAAA,WAG7B,KAAKC,CAAAA,oBAAL,CAA4B,CAI5B,KAAK5C,CAAAA,kBAAL;AAA0B,IAAIX,aAAJ,CAAkB,IAAlB,CAxGsB,CA8IlDwD,QAASA,SAAQ,CAAC1C,OAAD,CAAU,CACzBG,MAAA,CAASA,MAAT,EAAmBpB,OAAA,CAAQ,+EAAR,CAYnB,KAAImB,SAAW,IAAXA,WAA2BC,OAC/B,IAAI,CAACD,QAAL,EAAiB,CAACyC,eAAgBC,CAAAA,IAAhB,CAAqBF,QAArB,CAA+B,IAA/B,CAAlB,CAAwD,MAAO,KAAIA,QAAJ,CAAa1C,OAAb,CAC/D,KAAKwB,CAAAA,cAAL,CAAsB,IAAIzB,aAAJ,CAAkBC,OAAlB,CAA2B,IAA3B,CAAiCE,QAAjC,CAGtB,KAAK2C,CAAAA,QAAL,CAAgB,CAAA,CACZ7C,QAAJ,GAC+B,UAG7B,GAHI,MAAOA,QAAQ8C,CAAAA,KAGnB,GAHyC,IAAKC,CAAAA,MAG9C,CAHuD/C,OAAQ8C,CAAAA,KAG/D,EAF8B,UAE9B,GAFI,MAAO9C,QAAQgD,CAAAA,MAEnB,GAF0C,IAAKC,CAAAA,OAE/C,CAFyDjD,OAAQgD,CAAAA,MAEjE,EAD+B,UAC/B;AADI,MAAOhD,QAAQkD,CAAAA,OACnB,GAD2C,IAAKC,CAAAA,QAChD,CAD2DnD,OAAQkD,CAAAA,OACnE,EAA6B,UAA7B,GAAI,MAAOlD,QAAQoD,CAAAA,KAAnB,GAAyC,IAAKC,CAAAA,MAA9C,CAAuDrD,OAAQoD,CAAAA,KAA/D,CAJF,CAMAE,OAAOV,CAAAA,IAAP,CAAY,IAAZ,CAzByB,CA0J3BW,QAASA,QAAO,CAACtD,MAAD,CAASd,KAAT,CAAgB6D,MAAhB,CAAwBQ,GAAxB,CAA6BC,KAA7B,CAAoCC,QAApC,CAA8CjE,EAA9C,CAAkD,CAChEN,KAAMwC,CAAAA,QAAN,CAAiB6B,GACjBrE,MAAMsC,CAAAA,OAAN,CAAgBhC,EAChBN,MAAM8B,CAAAA,OAAN,CAAgB,CAAA,CAChB9B,MAAMgC,CAAAA,IAAN,CAAa,CAAA,CACb,IAAIhC,KAAMqB,CAAAA,SAAV,CAAqBrB,KAAMkC,CAAAA,OAAN,CAAc,IAAIsC,oBAAJ,CAAyB,OAAzB,CAAd,CAArB,KAA+EX,OAAJ,CAAY/C,MAAOgD,CAAAA,OAAP,CAAeQ,KAAf,CAAsBtE,KAAMkC,CAAAA,OAA5B,CAAZ,CAAsDpB,MAAO8C,CAAAA,MAAP,CAAcU,KAAd,CAAqBC,QAArB,CAA+BvE,KAAMkC,CAAAA,OAArC,CACjIlC,MAAMgC,CAAAA,IAAN,CAAa,CAAA,CANmD,CAuDlEiB,QAASA,WAAU,CAACnC,MAAD,CAASd,KAAT,CAAgBsB,QAAhB,CAA0BhB,EAA1B,CAA8B,CAC3C,CAACgB,QAAL,EAUqB,CAVrB,GAAoCtB,KAU1B6B,CAAAA,MAVV;AAAoC7B,KAUJyB,CAAAA,SAVhC,GAAoCzB,KAW5ByB,CAAAA,SACN,CADkB,CAAA,CAClB,CAZ0BX,MAYnB2D,CAAAA,IAAP,CAAY,OAAZ,CAZF,CACAzE,MAAMQ,CAAAA,SAAN,EACAF,GAAA,EACAqC,YAAA,CAAY7B,MAAZ,CAAoBd,KAApB,CAJ+C,CAkBjDgD,QAASA,YAAW,CAAClC,MAAD,CAASd,KAAT,CAAgB,CAClCA,KAAMiC,CAAAA,gBAAN,CAAyB,CAAA,CACzB,KAAI/B,MAAQF,KAAM+C,CAAAA,eAClB,IAAIjC,MAAOgD,CAAAA,OAAX,EAAsB5D,KAAtB,EAA+BA,KAAMC,CAAAA,IAArC,CAA2C,CAGzC,IAAIuE,OAAaC,KAAJ,CADL3E,KAAMsD,CAAAA,oBACD,CAAb,CACIsB,OAAS5E,KAAMU,CAAAA,kBACnBkE,OAAO1E,CAAAA,KAAP,CAAeA,KAGf,KAFA,IAAI2E,MAAQ,CAAZ,CACIC,WAAa,CAAA,CACjB,CAAO5E,KAAP,CAAA,CACEwE,MAAA,CAAOG,KAAP,CAGA,CAHgB3E,KAGhB,CAFKA,KAAM6E,CAAAA,KAEX,GAFkBD,UAElB,CAF+B,CAAA,CAE/B,EADA5E,KACA,CADQA,KAAMC,CAAAA,IACd,CAAA0E,KAAA,EAAS,CAEXH,OAAOI,CAAAA,UAAP,CAAoBA,UACpBV,QAAA,CAAQtD,MAAR,CAAgBd,KAAhB,CAAuB,CAAA,CAAvB,CAA6BA,KAAM6B,CAAAA,MAAnC;AAA2C6C,MAA3C,CAAmD,EAAnD,CAAuDE,MAAOxE,CAAAA,MAA9D,CAIAJ,MAAMQ,CAAAA,SAAN,EACAR,MAAMkD,CAAAA,mBAAN,CAA4B,IACxB0B,OAAOzE,CAAAA,IAAX,EACEH,KAAMU,CAAAA,kBACN,CAD2BkE,MAAOzE,CAAAA,IAClC,CAAAyE,MAAOzE,CAAAA,IAAP,CAAc,IAFhB,EAIEH,KAAMU,CAAAA,kBAJR,CAI6B,IAAIX,aAAJ,CAAkBC,KAAlB,CAE7BA,MAAMsD,CAAAA,oBAAN,CAA6B,CA3BY,CAA3C,IA4BO,CAEL,IAAA,CAAOpD,KAAP,GACMoE,MAWMxC,CAXE5B,KAAMoE,CAAAA,KAWRxC,CAPVsC,OAAA,CAAQtD,MAAR,CAAgBd,KAAhB,CAAuB,CAAA,CAAvB,CADUA,KAAMiB,CAAAA,UAANoD,CAAmB,CAAnBA,CAAuBC,MAAMzC,CAAAA,MACvC,CAAmCyC,MAAnC,CAHepE,KAAMqE,CAAAA,QAGrB,CAFSrE,KAAMK,CAAAA,QAEf,CAOUuB,CANV5B,KAMU4B,CANF5B,KAAMC,CAAAA,IAMJ2B,CALV9B,KAAMsD,CAAAA,oBAAN,EAKUxB,CAAAA,CAAN9B,KAAM8B,CAAAA,OAZZ,EAAA,EAgBc,IAAd,GAAI5B,KAAJ,GAAoBF,KAAMkD,CAAAA,mBAA1B,CAAgD,IAAhD,CAlBK,CAoBPlD,KAAM+C,CAAAA,eAAN,CAAwB7C,KACxBF,MAAMiC,CAAAA,gBAAN;AAAyB,CAAA,CApDS,CAyFpCa,QAASA,WAAU,CAAC9C,KAAD,CAAQ,CACzB,MAAOA,MAAMwB,CAAAA,MAAb,EAAwC,CAAxC,GAAuBxB,KAAM6B,CAAAA,MAA7B,EAAuE,IAAvE,GAA6C7B,KAAM+C,CAAAA,eAAnD,EAA+E,CAAC/C,KAAMsB,CAAAA,QAAtF,EAAkG,CAACtB,KAAM8B,CAAAA,OADhF,CAG3BkD,QAASA,UAAS,CAAClE,MAAD,CAASd,KAAT,CAAgB,CAChCc,MAAOoD,CAAAA,MAAP,CAAc,QAAS,CAACzD,GAAD,CAAM,CAC3BT,KAAMQ,CAAAA,SAAN,EACIC,IAAJ,EACEoC,cAAA,CAAe/B,MAAf,CAAuBL,GAAvB,CAEFT,MAAMmD,CAAAA,WAAN,CAAoB,CAAA,CACpBrC,OAAO2D,CAAAA,IAAP,CAAY,WAAZ,CACA9B,YAAA,CAAY7B,MAAZ,CAAoBd,KAApB,CAP2B,CAA7B,CADgC,CAuBlC2C,QAASA,YAAW,CAAC7B,MAAD,CAASd,KAAT,CAAgB,CAClC,IAAIiF,KAAOnC,UAAA,CAAW9C,KAAX,CACPiF,KAAJ,GACoBjF,KAdTmD,CAAAA,WAeT,EADkBnD,KAda0B,CAAAA,WAe/B,GAd6B,UAA7B,GAAI,MAaMZ,OAbQoD,CAAAA,MAAlB,EAakBlE,KAbgCqB,CAAAA,SAAlD,EAakBrB,KARVmD,CAAAA,WACN,CADoB,CAAA,CACpB,CAOQrC,MAPD2D,CAAAA,IAAP,CAAY,WAAZ,CANF;CAakBzE,KAZVQ,CAAAA,SAAN,EAEA,CAUgBR,KAXV0B,CAAAA,WACN,CADoB,CAAA,CACpB,CAAAe,OAAQC,CAAAA,QAAR,CAAiBsC,SAAjB,CAUQlE,MAVR,CAUgBd,KAVhB,CAHF,CAcA,EAAwB,CAAxB,GAAIA,KAAMQ,CAAAA,SAAV,GACER,KAAMsB,CAAAA,QAEN,CAFiB,CAAA,CAEjB,CADAR,MAAO2D,CAAAA,IAAP,CAAY,QAAZ,CACA,CAAIzE,KAAMqD,CAAAA,WAAV,GAGM6B,KACJ,CADapE,MAAOqE,CAAAA,cACpB,EAAI,CAACD,KAAL,EAAeA,KAAO7B,CAAAA,WAAtB,EAAqC6B,KAAOE,CAAAA,UAA5C,GACEtE,MAAOiD,CAAAA,OAAP,EALJ,CAHF,CAFF,CAeA,OAAOkB,KAjB2B,CA7jBpC,IAAIxC,QAAU7C,OAAA,CAAQ,qCAAR,CA0Bd,aAEAC,OAAOC,CAAAA,OAAP,CAAiByD,QAuBjB,KAAIvC,MAGJuC,SAAS3C,CAAAA,aAAT,CAAyBA,aAGzB,KAAIyE,aAAe,CACjBC,UAAW1F,OAAA,CAAQ,4CAAR,CADM,CAAnB,CAMIuE;AAASvE,OAAA,CAAQ,gGAAR,CANb,CASI2F,OAAS3F,OAAA,CAAQ,kCAAR,CAAkB2F,CAAAA,MAT/B,CAUIC,cAA4IC,CAAzG,WAAlB,GAAA,MAAO9F,OAAP,CAAgCA,MAAhC,CAA2D,WAAlB,GAAA,MAAO+F,OAAP,CAAgCA,MAAhC,CAAyD,WAAhB,GAAA,MAAOC,KAAP,CAA8BA,IAA9B,CAAqC,EAAIF,EAAAA,UAA5ID,EAA0J,QAAS,EAAG,EAOtKI,OAAAA,CAAchG,OAAA,CAAQ,yFAAR,CAClB,KACEwB,iBADaxB,OAAAiG,CAAQ,uFAARA,CACezE,CAAAA,gBAC1B0E;MAAAA,CAAiBlG,OAAA,CAAQ,mEAAR,CAAqBmG,CAAAA,KA9EkG,KA+E1IC,qBAAuBF,MAAeE,CAAAA,oBA/EoG,CAgF1IC,2BAA6BH,MAAeG,CAAAA,0BAhF8F,CAiF1I1D,sBAAwBuD,MAAevD,CAAAA,qBAjFmG,CAkF1I2D,uBAAyBJ,MAAeI,CAAAA,sBAlFkG,CAmF1I1B,qBAAuBsB,MAAetB,CAAAA,oBAnFoG,CAoF1I2B,uBAAyBL,MAAeK,CAAAA,sBApFkG,CAqF1IC,2BAA6BN,MAAeM,CAAAA,0BArF8F,CAsF1IC,qBAAuBP,MAAeO,CAAAA,oBAtFoG;AAuFxIxD,eAAiB+C,MAAY/C,CAAAA,cACjCjD,QAAA,CAAQ,+CAAR,CAAA,CAAoB2D,QAApB,CAA8BY,MAA9B,CA4GAvD,cAAc0F,CAAAA,SAAUC,CAAAA,SAAxB,CAAoCC,QAAkB,EAAG,CAGvD,IAFA,IAAIC,QAAU,IAAK1D,CAAAA,eAAnB,CACI2D,IAAM,EACV,CAAOD,OAAP,CAAA,CACEC,GAAIC,CAAAA,IAAJ,CAASF,OAAT,CACA,CAAAA,OAAA,CAAUA,OAAQtG,CAAAA,IAEpB,OAAOuG,IAPgD,CASxD,UAAS,EAAG,CACX,GAAI,CACFE,MAAOC,CAAAA,cAAP,CAAsBjG,aAAc0F,CAAAA,SAApC,CAA+C,QAA/C,CAAyD,CACvDQ,IAAKzB,YAAaC,CAAAA,SAAb,CAAuByB,QAAkC,EAAG,CAC/D,MAAO,KAAKR,CAAAA,SAAL,EADwD,CAA5D,CAEF,4EAFE,CAEiF,SAFjF,CADkD,CAAzD,CADE,CAMF,MAAOS,CAAP,CAAU,EAPD,CAAZ,CAAD,EAaA,IAAsB,UAAtB;AAAI,MAAOC,OAAX,EAAoCA,MAAOC,CAAAA,WAA3C,EAA4G,UAA5G,GAA0D,MAAOC,SAASb,CAAAA,SAAT,CAAmBW,MAAOC,CAAAA,WAA1B,CAAjE,CAAwH,CACtH,IAAA1D,gBAAkB2D,QAASb,CAAAA,SAAT,CAAmBW,MAAOC,CAAAA,WAA1B,CAClBN,OAAOC,CAAAA,cAAP,CAAsBtD,QAAtB,CAAgC0D,MAAOC,CAAAA,WAAvC,CAAoD,CAClDE,MAAOA,QAAc,CAACC,MAAD,CAAS,CAC5B,MAAI7D,gBAAgBC,CAAAA,IAAhB,CAAqB,IAArB,CAA2B4D,MAA3B,CAAJ,CAA+C,CAAA,CAA/C,CACI,IAAJ,GAAa9D,QAAb,CAA8B,CAAA,CAA9B,CACO8D,MADP,EACiBA,MAAOhF,CAAAA,cADxB,WACkDzB,cAHtB,CADoB,CAApD,CAFsH,CAAxH,IAUE4C,gBAAA,CAAkBA,QAAwB,CAAC6D,MAAD,CAAS,CACjD,MAAOA,OAAP,WAAyB,KADwB,CAiCrD9D,SAAS+C,CAAAA,SAAUgB,CAAAA,IAAnB,CAA0BC,QAAS,EAAG,CACpC1E,cAAA,CAAe,IAAf,CAAqB,IAAIqD,sBAAzB,CADoC,CA2BtC3C;QAAS+C,CAAAA,SAAU3C,CAAAA,KAAnB,CAA2B6D,QAAS,CAAClD,KAAD,CAAQC,QAAR,CAAkBjE,WAAlB,CAAsB,CACxD,IAAIN,MAAQ,IAAKqC,CAAAA,cAAjB,CACIoF,IAAM,CAAA,CADV,CAEY,eAAA,IAAA,eAAA,CAAA,CAAA,KAAA,CAAA,UAAA,CAAqB,eA1NjC,CA0NiC,KA1NjC,CAAA,eAAA,CAAOlC,MAAOmC,CAAAA,QAAP,CAAgBC,eAAhB,CAAP,EAA+BA,eAA/B,WAA8CnC,cA2N1CT,gBAAJ,EAAa,CAACQ,MAAOmC,CAAAA,QAAP,CAAgBpD,KAAhB,CAAd,GACEA,KADF,CA9NOiB,MAAOqC,CAAAA,IAAP,CA+NuBtD,KA/NvB,CA8NP,CAGwB,WAAxB,GAAI,MAAOC,SAAX,GACEjE,WACA,CADKiE,QACL,CAAAA,QAAA,CAAW,IAFb,CAIIQ,gBAAJ,CAAWR,QAAX,CAAsB,QAAtB,CAAyCA,QAAzC,GAAmDA,QAAnD,CAA8DvE,KAAM4B,CAAAA,eAApE,CACkB,WAAlB,GAAI,MAAOtB,YAAX;CAA8BA,WAA9B,CAAmCK,GAAnC,CACA,IAAIX,KAAMwB,CAAAA,MAAV,CAAsClB,KAjCtC,CAiCsCA,WAjCtC,CAHI8B,WAGJ,CAHS,IAAIgE,0BAGb,CADAvD,cAAA,CAkCgC/B,IAlChC,CAAuBsB,WAAvB,CACA,CAAAK,OAAQC,CAAAA,QAAR,CAAiBpC,KAAjB,CAAqB8B,WAArB,CAiCA,KAA+C,CAAI,IAAA,wBAAA,IAAA2C,EAAAA,wBAAAA,CAAAA,eAAAA,CAAA,CAAA,CAAS,wBAAA,CAAA,KAAA,KAAA,GAAA,WAAA,CA1BxD3C,EACU,KAAd,GAAIkC,wBAAJ,CACElC,EADF,CACO,IAAI+D,sBADX,CAE4B,QAF5B,GAEW,MAAO7B,yBAFlB,EAyB4DtE,KAvBbiB,CAAAA,UAF/C,GAGEmB,EAHF,CAGO,IAAI4D,oBAAJ,CAAyB,OAAzB,CAAkC,CAAC,QAAD,CAAW,QAAX,CAAlC,CAAwD1B,wBAAxD,CAHP,CAKIlC;EAAJ,EACES,cAAA,CAmB0D/B,IAnB1D,CAAuBsB,EAAvB,CAEA,CADAK,OAAQC,CAAAA,QAAR,CAAiBpC,EAAjB,CAAqB8B,EAArB,CACA,CAAA,wBAAA,CAAO,CAAA,CAHT,EAKA,wBALA,CAKO,CAAA,CAe4C,CAAA,wBAAJ,GAC7CpC,KAAMQ,CAAAA,SAAN,EAkFF,CAjFmCuE,GAiFnC,CAjFmCA,eAiFnC,CA/BKA,GA+BL,GA9BoCT,EAClC,CADkCA,KAClC,CApD0BtE,KA+BjBiB,CAAAA,UAqBT,EArB+C,CAAA,CAqB/C,GApD0BjB,KA+BG2B,CAAAA,aAqB7B,EArByE,QAqBzE,GArBwD,MAAO2C,GAqB/D,GApBAA,EAoBA,CApBQiB,MAAOqC,CAAAA,IAAP,CAAYtD,EAAZ,CAmBiCC,QAnBjC,CAoBR,EAAID,KAAJ,GAAcuD,EAAd,GACE9C,GAEA,CAFQ,CAAA,CAER,CADAR,QACA,CADW,QACX,CAAAD,KAAA,CAAQuD,EAHV,CA6BF,EAvBIxD,eAuBJ,CAjF4BrE,KA0DZiB,CAAAA,UAAN,CAAmB,CAAnB,CAAuBqD,KAAMzC,CAAAA,MAuBvC,CAjF4B7B,KA2DtB6B,CAAAA,MAsBN,EAtBgBwC,eAsBhB,CArBIoD,EAqBJ,CAjF4BzH,KA4DZ6B,CAAAA,MAqBhB,CAjF4B7B,KA4DGmB,CAAAA,aAqB/B,CAnBKsG,EAmBL,GAjF4BzH,KA8DZyB,CAAAA,SAmBhB,CAnB4B,CAAA,CAmB5B,EAjF4BzB,KA+DlB8B,CAAAA,OAAV,EA/D4B9B,KA+DD+B,CAAAA,MAA3B;CACM+F,eAaJ,CA7E0B9H,KAgETkD,CAAAA,mBAajB,CA7E0BlD,KAiEpBkD,CAAAA,mBAYN,CAZ4B,CACnBoB,KADmB,CAEhBC,QAFgB,CAG1BQ,MAAOA,GAHmB,CAI1BxE,SAAUD,WAJgB,CAK1BH,KAAM,IALoB,CAY5B,CALI2H,eAAJ,CACEA,eAAK3H,CAAAA,IADP,CAxE0BH,KAyENkD,CAAAA,mBADpB,CAxE0BlD,KA2ElB+C,CAAAA,eAHR,CAxE0B/C,KA2EMkD,CAAAA,mBAEhC,CA7E0BlD,KA6EpBsD,CAAAA,oBAAN,EAA8B,CAdhC,EAgBEc,OAAA,CA/EoBtD,IA+EpB,CA/E0Bd,KA+E1B,CAAuB,CAAA,CAAvB,CAA8BqE,eAA9B,CAAmCC,KAAnC,CAA0CC,QAA1C,CAAoDjE,WAApD,CAEF,CAAA,GAAA,CAAOmH,EAnFwC,CAAA,CAI/C,MAAOA,IAjBiD,CAmB1DlE,SAAS+C,CAAAA,SAAUyB,CAAAA,IAAnB,CAA0BC,QAAS,EAAG,CACpC,IAAK3F,CAAAA,cAAeN,CAAAA,MAApB,EADoC,CAGtCwB,SAAS+C,CAAAA,SAAU2B,CAAAA,MAAnB,CAA4BC,QAAS,EAAG,CACtC,IAAIlI,MAAQ,IAAKqC,CAAAA,cACbrC,MAAM+B,CAAAA,MAAV;CACE/B,KAAM+B,CAAAA,MAAN,EACA,CAAK/B,KAAM8B,CAAAA,OAAX,EAAuB9B,KAAM+B,CAAAA,MAA7B,EAAwC/B,KAAMiC,CAAAA,gBAA9C,EAAwEc,CAAN/C,KAAM+C,CAAAA,eAAxE,EAAyFC,WAAA,CAAY,IAAZ,CAAkBhD,KAAlB,CAF3F,CAFsC,CAOxCuD,SAAS+C,CAAAA,SAAU6B,CAAAA,kBAAnB,CAAwCC,QAA2B,CAAC7D,QAAD,CAAW,CAEpD,QAAxB,GAAI,MAAOA,SAAX,GAAkCA,QAAlC,CAA6CA,QAAS8D,CAAAA,WAAT,EAA7C,CACA,IAAI,EAAgJ,CAAC,CAAjJ,CAAE,oEAAA,CAAA,KAAA,CAAA,GAAA,CAAqGC,CAAAA,OAArG,CAA6HD,CAAf9D,QAAe8D,CAAJ,EAAIA,EAAAA,WAAhB,EAA7G,CAAF,CAAJ,CAAyJ,KAAM,KAAIhC,oBAAJ,CAAyB9B,QAAzB,CAAN,CACzJ,IAAKlC,CAAAA,cAAeT,CAAAA,eAApB,CAAsC2C,QACtC,OAAO,KALqE,CAO9EqC,OAAOC,CAAAA,cAAP,CAAsBtD,QAAS+C,CAAAA,SAA/B;AAA0C,gBAA1C,CAA4D,CAI1DiC,WAAY,CAAA,CAJ8C,CAK1DzB,IAAKA,QAAY,EAAG,CAClB,MAAO,KAAKzE,CAAAA,cAAZ,EAA8B,IAAKA,CAAAA,cAAekE,CAAAA,SAApB,EADZ,CALsC,CAA5D,CAeAK,OAAOC,CAAAA,cAAP,CAAsBtD,QAAS+C,CAAAA,SAA/B,CAA0C,uBAA1C,CAAmE,CAIjEiC,WAAY,CAAA,CAJqD,CAKjEzB,IAAKA,QAAY,EAAG,CAClB,MAAO,KAAKzE,CAAAA,cAAelB,CAAAA,aADT,CAL6C,CAAnE,CA8KAoC,SAAS+C,CAAAA,SAAU1C,CAAAA,MAAnB,CAA4B4E,QAAS,CAAClE,KAAD,CAAQC,QAAR,CAAkBjE,EAAlB,CAAsB,CACzDA,EAAA,CAAG,IAAI2F,0BAAJ,CAA+B,UAA/B,CAAH,CADyD,CAG3D1C,SAAS+C,CAAAA,SAAUxC,CAAAA,OAAnB,CAA6B,IAC7BP,SAAS+C,CAAAA,SAAUmC,CAAAA,GAAnB,CAAyBC,QAAS,CAACpE,KAAD,CAAQC,QAAR,CAAkBjE,EAAlB,CAAsB,CACtD,IAAIN,MAAQ,IAAKqC,CAAAA,cACI,WAArB,GAAI,MAAOiC,MAAX,EACEhE,EAEA,CAFKgE,KAEL,CAAAC,QAAA;AADAD,KACA,CADQ,IAFV,EAI+B,UAJ/B,GAIW,MAAOC,SAJlB,GAKEjE,EACA,CADKiE,QACL,CAAAA,QAAA,CAAW,IANb,CAQc,KAAd,GAAID,KAAJ,EAAgCqE,IAAAA,EAAhC,GAAsBrE,KAAtB,EAA2C,IAAKX,CAAAA,KAAL,CAAWW,KAAX,CAAkBC,QAAlB,CAGvCvE,MAAM+B,CAAAA,MAAV,GACE/B,KAAM+B,CAAAA,MACN,CADe,CACf,CAAA,IAAKkG,CAAAA,MAAL,EAFF,CAMA,IAAI,CAACjI,KAAMwB,CAAAA,MAAX,CAAmB,CAAyBlB,KAAAA,CAAAA,EAAPN,MA0D/BwB,CAAAA,MAAN,CAAe,CAAA,CACfmB,YAAA,CA3D+B7B,IA2D/B,CA3DqCd,KA2DrC,CACA,IAAIM,KAAJ,CACE,GA7DmCN,KA6DzBsB,CAAAA,QAAV,CAAoBmB,OAAQC,CAAAA,QAAR,CAAiBpC,KAAjB,CAApB,KA7D6BQ,KA6DwB8H,CAAAA,IAAP,CAAY,QAAZ,CAAsBtI,KAAtB,CA7DXN,MA+D/BuB,CAAAA,KAAN,CAAc,CAAA,CA/DiBT,KAgExB4C,CAAAA,QAAP,CAAkB,CAAA,CAhEC,CACnB,MAAO,KApB+C,CAsBxDkD,OAAOC,CAAAA,cAAP,CAAsBtD,QAAS+C,CAAAA,SAA/B,CAA0C,gBAA1C,CAA4D,CAI1DiC,WAAY,CAAA,CAJ8C,CAK1DzB,IAAKA,QAAY,EAAG,CAClB,MAAO,KAAKzE,CAAAA,cAAeR,CAAAA,MADT,CALsC,CAA5D,CA4EA+E,OAAOC,CAAAA,cAAP,CAAsBtD,QAAS+C,CAAAA,SAA/B;AAA0C,WAA1C,CAAuD,CAIrDiC,WAAY,CAAA,CAJyC,CAKrDzB,IAAKA,QAAY,EAAG,CAClB,MAA4B6B,KAAAA,EAA5B,GAAI,IAAKtG,CAAAA,cAAT,CACS,CAAA,CADT,CAGO,IAAKA,CAAAA,cAAehB,CAAAA,SAJT,CALiC,CAWrDwH,IAAKA,QAAY,CAACzB,KAAD,CAAQ,CAGlB,IAAK/E,CAAAA,cAAV,GAMA,IAAKA,CAAAA,cAAehB,CAAAA,SANpB,CAMgC+F,KANhC,CAHuB,CAX4B,CAAvD,CAuBA7D,SAAS+C,CAAAA,SAAUvC,CAAAA,OAAnB,CAA6B6B,MAAY7B,CAAAA,OACzCR,SAAS+C,CAAAA,SAAUwC,CAAAA,UAAnB,CAAgClD,MAAYmD,CAAAA,SAC5CxF,SAAS+C,CAAAA,SAAUtC,CAAAA,QAAnB,CAA8BgF,QAAS,CAACvI,GAAD,CAAMH,EAAN,CAAU,CAC/CA,EAAA,CAAGG,GAAH,CAD+C,CAhoB2F;\",\n\"sources\":[\"node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hash_base$node_modules$readable_stream$lib$_stream_writable\\\"] = function(global,require,module,exports) {\\nvar process = require('process');\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// A bit simpler than readable streams.\\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\\n// the drain event emission and buffering.\\n\\n'use strict';\\n\\nmodule.exports = Writable;\\n\\n/* <replacement> */\\nfunction WriteReq(chunk, encoding, cb) {\\n  this.chunk = chunk;\\n  this.encoding = encoding;\\n  this.callback = cb;\\n  this.next = null;\\n}\\n\\n// It seems a linked list but it is not\\n// there will be only 2 of these for each stream\\nfunction CorkedRequest(state) {\\n  var _this = this;\\n  this.next = null;\\n  this.entry = null;\\n  this.finish = function () {\\n    onCorkedFinish(_this, state);\\n  };\\n}\\n/* </replacement> */\\n\\n/*<replacement>*/\\nvar Duplex;\\n/*</replacement>*/\\n\\nWritable.WritableState = WritableState;\\n\\n/*<replacement>*/\\nvar internalUtil = {\\n  deprecate: require('util-deprecate')\\n};\\n/*</replacement>*/\\n\\n/*<replacement>*/\\nvar Stream = require('./internal/streams/stream');\\n/*</replacement>*/\\n\\nvar Buffer = require('buffer').Buffer;\\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\\nfunction _uint8ArrayToBuffer(chunk) {\\n  return Buffer.from(chunk);\\n}\\nfunction _isUint8Array(obj) {\\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\\n}\\nvar destroyImpl = require('./internal/streams/destroy');\\nvar _require = require('./internal/streams/state'),\\n  getHighWaterMark = _require.getHighWaterMark;\\nvar _require$codes = require('../errors').codes,\\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\\nrequire('inherits')(Writable, Stream);\\nfunction nop() {}\\nfunction WritableState(options, stream, isDuplex) {\\n  Duplex = Duplex || require('./_stream_duplex');\\n  options = options || {};\\n\\n  // Duplex streams are both readable and writable, but share\\n  // the same options object.\\n  // However, some cases require setting options to different\\n  // values for the readable and the writable sides of the duplex stream,\\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\\n\\n  // object stream flag to indicate whether or not this stream\\n  // contains buffers or objects.\\n  this.objectMode = !!options.objectMode;\\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\\n\\n  // the point at which write() starts returning false\\n  // Note: 0 is a valid value, means that we always return false if\\n  // the entire buffer is not flushed immediately on write()\\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\\n\\n  // if _final has been called\\n  this.finalCalled = false;\\n\\n  // drain event flag.\\n  this.needDrain = false;\\n  // at the start of calling end()\\n  this.ending = false;\\n  // when end() has been called, and returned\\n  this.ended = false;\\n  // when 'finish' is emitted\\n  this.finished = false;\\n\\n  // has it been destroyed\\n  this.destroyed = false;\\n\\n  // should we decode strings into buffers before passing to _write?\\n  // this is here so that some node-core streams can optimize string\\n  // handling at a lower level.\\n  var noDecode = options.decodeStrings === false;\\n  this.decodeStrings = !noDecode;\\n\\n  // Crypto is kind of old and crusty.  Historically, its default string\\n  // encoding is 'binary' so we have to make this configurable.\\n  // Everything else in the universe uses 'utf8', though.\\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\\n\\n  // not an actual buffer we keep track of, but a measurement\\n  // of how much we're waiting to get pushed to some underlying\\n  // socket or file.\\n  this.length = 0;\\n\\n  // a flag to see when we're in the middle of a write.\\n  this.writing = false;\\n\\n  // when true all writes will be buffered until .uncork() call\\n  this.corked = 0;\\n\\n  // a flag to be able to tell if the onwrite cb is called immediately,\\n  // or on a later tick.  We set this to true at first, because any\\n  // actions that shouldn't happen until \\\"later\\\" should generally also\\n  // not happen before the first write call.\\n  this.sync = true;\\n\\n  // a flag to know if we're processing previously buffered items, which\\n  // may call the _write() callback in the same tick, so that we don't\\n  // end up in an overlapped onwrite situation.\\n  this.bufferProcessing = false;\\n\\n  // the callback that's passed to _write(chunk,cb)\\n  this.onwrite = function (er) {\\n    onwrite(stream, er);\\n  };\\n\\n  // the callback that the user supplies to write(chunk,encoding,cb)\\n  this.writecb = null;\\n\\n  // the amount that is being written when _write is called.\\n  this.writelen = 0;\\n  this.bufferedRequest = null;\\n  this.lastBufferedRequest = null;\\n\\n  // number of pending user-supplied write callbacks\\n  // this must be 0 before 'finish' can be emitted\\n  this.pendingcb = 0;\\n\\n  // emit prefinish if the only thing we're waiting for is _write cbs\\n  // This is relevant for synchronous Transform streams\\n  this.prefinished = false;\\n\\n  // True if the error was already emitted and should not be thrown again\\n  this.errorEmitted = false;\\n\\n  // Should close be emitted on destroy. Defaults to true.\\n  this.emitClose = options.emitClose !== false;\\n\\n  // Should .destroy() be called after 'finish' (and potentially 'end')\\n  this.autoDestroy = !!options.autoDestroy;\\n\\n  // count buffered requests\\n  this.bufferedRequestCount = 0;\\n\\n  // allocate the first CorkedRequest, there is always\\n  // one allocated and free to use, and we maintain at most two\\n  this.corkedRequestsFree = new CorkedRequest(this);\\n}\\nWritableState.prototype.getBuffer = function getBuffer() {\\n  var current = this.bufferedRequest;\\n  var out = [];\\n  while (current) {\\n    out.push(current);\\n    current = current.next;\\n  }\\n  return out;\\n};\\n(function () {\\n  try {\\n    Object.defineProperty(WritableState.prototype, 'buffer', {\\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\\n        return this.getBuffer();\\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\\n    });\\n  } catch (_) {}\\n})();\\n\\n// Test _writableState for inheritance to account for Duplex streams,\\n// whose prototype chain only points to Readable.\\nvar realHasInstance;\\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\\n  realHasInstance = Function.prototype[Symbol.hasInstance];\\n  Object.defineProperty(Writable, Symbol.hasInstance, {\\n    value: function value(object) {\\n      if (realHasInstance.call(this, object)) return true;\\n      if (this !== Writable) return false;\\n      return object && object._writableState instanceof WritableState;\\n    }\\n  });\\n} else {\\n  realHasInstance = function realHasInstance(object) {\\n    return object instanceof this;\\n  };\\n}\\nfunction Writable(options) {\\n  Duplex = Duplex || require('./_stream_duplex');\\n\\n  // Writable ctor is applied to Duplexes, too.\\n  // `realHasInstance` is necessary because using plain `instanceof`\\n  // would return false, as no `_writableState` property is attached.\\n\\n  // Trying to use the custom `instanceof` for Writable here will also break the\\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\\n  // `_writableState` that would lead to infinite recursion.\\n\\n  // Checking for a Stream.Duplex instance is faster here instead of inside\\n  // the WritableState constructor, at least with V8 6.5\\n  var isDuplex = this instanceof Duplex;\\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\\n  this._writableState = new WritableState(options, this, isDuplex);\\n\\n  // legacy.\\n  this.writable = true;\\n  if (options) {\\n    if (typeof options.write === 'function') this._write = options.write;\\n    if (typeof options.writev === 'function') this._writev = options.writev;\\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\\n    if (typeof options.final === 'function') this._final = options.final;\\n  }\\n  Stream.call(this);\\n}\\n\\n// Otherwise people can pipe Writable streams, which is just wrong.\\nWritable.prototype.pipe = function () {\\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\\n};\\nfunction writeAfterEnd(stream, cb) {\\n  var er = new ERR_STREAM_WRITE_AFTER_END();\\n  // TODO: defer error events consistently everywhere, not just the cb\\n  errorOrDestroy(stream, er);\\n  process.nextTick(cb, er);\\n}\\n\\n// Checks that a user-supplied chunk is valid, especially for the particular\\n// mode the stream is in. Currently this means that `null` is never accepted\\n// and undefined/non-string values are only allowed in object mode.\\nfunction validChunk(stream, state, chunk, cb) {\\n  var er;\\n  if (chunk === null) {\\n    er = new ERR_STREAM_NULL_VALUES();\\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\\n  }\\n  if (er) {\\n    errorOrDestroy(stream, er);\\n    process.nextTick(cb, er);\\n    return false;\\n  }\\n  return true;\\n}\\nWritable.prototype.write = function (chunk, encoding, cb) {\\n  var state = this._writableState;\\n  var ret = false;\\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\\n  if (isBuf && !Buffer.isBuffer(chunk)) {\\n    chunk = _uint8ArrayToBuffer(chunk);\\n  }\\n  if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\\n  if (typeof cb !== 'function') cb = nop;\\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\\n    state.pendingcb++;\\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\\n  }\\n  return ret;\\n};\\nWritable.prototype.cork = function () {\\n  this._writableState.corked++;\\n};\\nWritable.prototype.uncork = function () {\\n  var state = this._writableState;\\n  if (state.corked) {\\n    state.corked--;\\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\\n  }\\n};\\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\\n  // node::ParseEncoding() requires lower case.\\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\\n  this._writableState.defaultEncoding = encoding;\\n  return this;\\n};\\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\\n  // making it explicit this property is not enumerable\\n  // because otherwise some prototype manipulation in\\n  // userland will fail\\n  enumerable: false,\\n  get: function get() {\\n    return this._writableState && this._writableState.getBuffer();\\n  }\\n});\\nfunction decodeChunk(state, chunk, encoding) {\\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\\n    chunk = Buffer.from(chunk, encoding);\\n  }\\n  return chunk;\\n}\\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\\n  // making it explicit this property is not enumerable\\n  // because otherwise some prototype manipulation in\\n  // userland will fail\\n  enumerable: false,\\n  get: function get() {\\n    return this._writableState.highWaterMark;\\n  }\\n});\\n\\n// if we're already writing something, then just put this\\n// in the queue, and wait our turn.  Otherwise, call _write\\n// If we return false, then we need a drain event, so set that flag.\\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\\n  if (!isBuf) {\\n    var newChunk = decodeChunk(state, chunk, encoding);\\n    if (chunk !== newChunk) {\\n      isBuf = true;\\n      encoding = 'buffer';\\n      chunk = newChunk;\\n    }\\n  }\\n  var len = state.objectMode ? 1 : chunk.length;\\n  state.length += len;\\n  var ret = state.length < state.highWaterMark;\\n  // we must ensure that previous needDrain will not be reset to false.\\n  if (!ret) state.needDrain = true;\\n  if (state.writing || state.corked) {\\n    var last = state.lastBufferedRequest;\\n    state.lastBufferedRequest = {\\n      chunk: chunk,\\n      encoding: encoding,\\n      isBuf: isBuf,\\n      callback: cb,\\n      next: null\\n    };\\n    if (last) {\\n      last.next = state.lastBufferedRequest;\\n    } else {\\n      state.bufferedRequest = state.lastBufferedRequest;\\n    }\\n    state.bufferedRequestCount += 1;\\n  } else {\\n    doWrite(stream, state, false, len, chunk, encoding, cb);\\n  }\\n  return ret;\\n}\\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\\n  state.writelen = len;\\n  state.writecb = cb;\\n  state.writing = true;\\n  state.sync = true;\\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\\n  state.sync = false;\\n}\\nfunction onwriteError(stream, state, sync, er, cb) {\\n  --state.pendingcb;\\n  if (sync) {\\n    // defer the callback if we are being called synchronously\\n    // to avoid piling up things on the stack\\n    process.nextTick(cb, er);\\n    // this can emit finish, and it will always happen\\n    // after error\\n    process.nextTick(finishMaybe, stream, state);\\n    stream._writableState.errorEmitted = true;\\n    errorOrDestroy(stream, er);\\n  } else {\\n    // the caller expect this to happen before if\\n    // it is async\\n    cb(er);\\n    stream._writableState.errorEmitted = true;\\n    errorOrDestroy(stream, er);\\n    // this can emit finish, but finish must\\n    // always follow error\\n    finishMaybe(stream, state);\\n  }\\n}\\nfunction onwriteStateUpdate(state) {\\n  state.writing = false;\\n  state.writecb = null;\\n  state.length -= state.writelen;\\n  state.writelen = 0;\\n}\\nfunction onwrite(stream, er) {\\n  var state = stream._writableState;\\n  var sync = state.sync;\\n  var cb = state.writecb;\\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\\n  onwriteStateUpdate(state);\\n  if (er) onwriteError(stream, state, sync, er, cb);else {\\n    // Check if we're actually ready to finish, but don't emit yet\\n    var finished = needFinish(state) || stream.destroyed;\\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\\n      clearBuffer(stream, state);\\n    }\\n    if (sync) {\\n      process.nextTick(afterWrite, stream, state, finished, cb);\\n    } else {\\n      afterWrite(stream, state, finished, cb);\\n    }\\n  }\\n}\\nfunction afterWrite(stream, state, finished, cb) {\\n  if (!finished) onwriteDrain(stream, state);\\n  state.pendingcb--;\\n  cb();\\n  finishMaybe(stream, state);\\n}\\n\\n// Must force callback to be called on nextTick, so that we don't\\n// emit 'drain' before the write() consumer gets the 'false' return\\n// value, and has a chance to attach a 'drain' listener.\\nfunction onwriteDrain(stream, state) {\\n  if (state.length === 0 && state.needDrain) {\\n    state.needDrain = false;\\n    stream.emit('drain');\\n  }\\n}\\n\\n// if there's something in the buffer waiting, then process it\\nfunction clearBuffer(stream, state) {\\n  state.bufferProcessing = true;\\n  var entry = state.bufferedRequest;\\n  if (stream._writev && entry && entry.next) {\\n    // Fast case, write everything using _writev()\\n    var l = state.bufferedRequestCount;\\n    var buffer = new Array(l);\\n    var holder = state.corkedRequestsFree;\\n    holder.entry = entry;\\n    var count = 0;\\n    var allBuffers = true;\\n    while (entry) {\\n      buffer[count] = entry;\\n      if (!entry.isBuf) allBuffers = false;\\n      entry = entry.next;\\n      count += 1;\\n    }\\n    buffer.allBuffers = allBuffers;\\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\\n\\n    // doWrite is almost always async, defer these to save a bit of time\\n    // as the hot path ends with doWrite\\n    state.pendingcb++;\\n    state.lastBufferedRequest = null;\\n    if (holder.next) {\\n      state.corkedRequestsFree = holder.next;\\n      holder.next = null;\\n    } else {\\n      state.corkedRequestsFree = new CorkedRequest(state);\\n    }\\n    state.bufferedRequestCount = 0;\\n  } else {\\n    // Slow case, write chunks one-by-one\\n    while (entry) {\\n      var chunk = entry.chunk;\\n      var encoding = entry.encoding;\\n      var cb = entry.callback;\\n      var len = state.objectMode ? 1 : chunk.length;\\n      doWrite(stream, state, false, len, chunk, encoding, cb);\\n      entry = entry.next;\\n      state.bufferedRequestCount--;\\n      // if we didn't call the onwrite immediately, then\\n      // it means that we need to wait until it does.\\n      // also, that means that the chunk and cb are currently\\n      // being processed, so move the buffer counter past them.\\n      if (state.writing) {\\n        break;\\n      }\\n    }\\n    if (entry === null) state.lastBufferedRequest = null;\\n  }\\n  state.bufferedRequest = entry;\\n  state.bufferProcessing = false;\\n}\\nWritable.prototype._write = function (chunk, encoding, cb) {\\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\\n};\\nWritable.prototype._writev = null;\\nWritable.prototype.end = function (chunk, encoding, cb) {\\n  var state = this._writableState;\\n  if (typeof chunk === 'function') {\\n    cb = chunk;\\n    chunk = null;\\n    encoding = null;\\n  } else if (typeof encoding === 'function') {\\n    cb = encoding;\\n    encoding = null;\\n  }\\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\\n\\n  // .end() fully uncorks\\n  if (state.corked) {\\n    state.corked = 1;\\n    this.uncork();\\n  }\\n\\n  // ignore unnecessary end() calls.\\n  if (!state.ending) endWritable(this, state, cb);\\n  return this;\\n};\\nObject.defineProperty(Writable.prototype, 'writableLength', {\\n  // making it explicit this property is not enumerable\\n  // because otherwise some prototype manipulation in\\n  // userland will fail\\n  enumerable: false,\\n  get: function get() {\\n    return this._writableState.length;\\n  }\\n});\\nfunction needFinish(state) {\\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\\n}\\nfunction callFinal(stream, state) {\\n  stream._final(function (err) {\\n    state.pendingcb--;\\n    if (err) {\\n      errorOrDestroy(stream, err);\\n    }\\n    state.prefinished = true;\\n    stream.emit('prefinish');\\n    finishMaybe(stream, state);\\n  });\\n}\\nfunction prefinish(stream, state) {\\n  if (!state.prefinished && !state.finalCalled) {\\n    if (typeof stream._final === 'function' && !state.destroyed) {\\n      state.pendingcb++;\\n      state.finalCalled = true;\\n      process.nextTick(callFinal, stream, state);\\n    } else {\\n      state.prefinished = true;\\n      stream.emit('prefinish');\\n    }\\n  }\\n}\\nfunction finishMaybe(stream, state) {\\n  var need = needFinish(state);\\n  if (need) {\\n    prefinish(stream, state);\\n    if (state.pendingcb === 0) {\\n      state.finished = true;\\n      stream.emit('finish');\\n      if (state.autoDestroy) {\\n        // In case of duplex streams we need a way to detect\\n        // if the readable side is ready for autoDestroy as well\\n        var rState = stream._readableState;\\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\\n          stream.destroy();\\n        }\\n      }\\n    }\\n  }\\n  return need;\\n}\\nfunction endWritable(stream, state, cb) {\\n  state.ending = true;\\n  finishMaybe(stream, state);\\n  if (cb) {\\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\\n  }\\n  state.ended = true;\\n  stream.writable = false;\\n}\\nfunction onCorkedFinish(corkReq, state, err) {\\n  var entry = corkReq.entry;\\n  corkReq.entry = null;\\n  while (entry) {\\n    var cb = entry.callback;\\n    state.pendingcb--;\\n    cb(err);\\n    entry = entry.next;\\n  }\\n\\n  // reuse the free corkReq.\\n  state.corkedRequestsFree.next = corkReq;\\n}\\nObject.defineProperty(Writable.prototype, 'destroyed', {\\n  // making it explicit this property is not enumerable\\n  // because otherwise some prototype manipulation in\\n  // userland will fail\\n  enumerable: false,\\n  get: function get() {\\n    if (this._writableState === undefined) {\\n      return false;\\n    }\\n    return this._writableState.destroyed;\\n  },\\n  set: function set(value) {\\n    // we ignore the value if the stream\\n    // has not been initialized yet\\n    if (!this._writableState) {\\n      return;\\n    }\\n\\n    // backward compatibility, the user is explicitly\\n    // managing destroyed\\n    this._writableState.destroyed = value;\\n  }\\n});\\nWritable.prototype.destroy = destroyImpl.destroy;\\nWritable.prototype._undestroy = destroyImpl.undestroy;\\nWritable.prototype._destroy = function (err, cb) {\\n  cb(err);\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"CorkedRequest\",\"state\",\"_this\",\"entry\",\"next\",\"finish\",\"this.finish\",\"cb\",\"callback\",\"pendingcb\",\"err\",\"corkedRequestsFree\",\"nop\",\"WritableState\",\"options\",\"stream\",\"isDuplex\",\"Duplex\",\"objectMode\",\"writableObjectMode\",\"highWaterMark\",\"getHighWaterMark\",\"destroyed\",\"finished\",\"ended\",\"ending\",\"needDrain\",\"finalCalled\",\"decodeStrings\",\"defaultEncoding\",\"length\",\"writing\",\"corked\",\"sync\",\"bufferProcessing\",\"onwrite\",\"this.onwrite\",\"er\",\"_writableState\",\"writecb\",\"ERR_MULTIPLE_CALLBACK\",\"writelen\",\"process\",\"nextTick\",\"finishMaybe\",\"errorEmitted\",\"errorOrDestroy\",\"needFinish\",\"bufferedRequest\",\"clearBuffer\",\"afterWrite\",\"lastBufferedRequest\",\"prefinished\",\"emitClose\",\"autoDestroy\",\"bufferedRequestCount\",\"Writable\",\"realHasInstance\",\"call\",\"writable\",\"write\",\"_write\",\"writev\",\"_writev\",\"destroy\",\"_destroy\",\"final\",\"_final\",\"Stream\",\"doWrite\",\"len\",\"chunk\",\"encoding\",\"ERR_STREAM_DESTROYED\",\"emit\",\"buffer\",\"Array\",\"holder\",\"count\",\"allBuffers\",\"isBuf\",\"callFinal\",\"need\",\"rState\",\"_readableState\",\"endEmitted\",\"internalUtil\",\"deprecate\",\"Buffer\",\"OurUint8Array\",\"Uint8Array\",\"window\",\"self\",\"destroyImpl\",\"_require\",\"_require$codes\",\"codes\",\"ERR_INVALID_ARG_TYPE\",\"ERR_METHOD_NOT_IMPLEMENTED\",\"ERR_STREAM_CANNOT_PIPE\",\"ERR_STREAM_NULL_VALUES\",\"ERR_STREAM_WRITE_AFTER_END\",\"ERR_UNKNOWN_ENCODING\",\"prototype\",\"getBuffer\",\"WritableState.prototype.getBuffer\",\"current\",\"out\",\"push\",\"Object\",\"defineProperty\",\"get\",\"writableStateBufferGetter\",\"_\",\"Symbol\",\"hasInstance\",\"Function\",\"value\",\"object\",\"pipe\",\"Writable.prototype.pipe\",\"Writable.prototype.write\",\"ret\",\"isBuffer\",\"obj\",\"from\",\"newChunk\",\"last\",\"cork\",\"Writable.prototype.cork\",\"uncork\",\"Writable.prototype.uncork\",\"setDefaultEncoding\",\"Writable.prototype.setDefaultEncoding\",\"toLowerCase\",\"indexOf\",\"enumerable\",\"Writable.prototype._write\",\"end\",\"Writable.prototype.end\",\"undefined\",\"once\",\"set\",\"_undestroy\",\"undestroy\",\"Writable.prototype._destroy\"]\n}\n"]