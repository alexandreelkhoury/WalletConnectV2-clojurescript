shadow$provide.module$node_modules$$noble$curves$abstract$weierstrass=function(global,require,module,exports){function validatePointOpts(curve){curve=(0,curve_js_1.validateBasic)(curve);ut.validateObject(curve,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const {endo,Fp,a}=curve;if(endo){if(!Fp.eql(a,Fp.ZERO))throw Error("Endomorphism can only be defined for Koblitz curves that have a\x3d0");
if("object"!==typeof endo||"bigint"!==typeof endo.beta||"function"!==typeof endo.splitScalar)throw Error("Expected endomorphism with beta: bigint and splitScalar: function");}return Object.freeze({...curve})}function weierstrassPoints(opts){function weierstrassEquation(x){const {a,b}=CURVE;var x2=Fp.sqr(x);x2=Fp.mul(x2,x);return Fp.add(Fp.add(x2,Fp.mul(x,a)),b)}function isWithinCurveOrder(num){return"bigint"===typeof num&&_0n<num&&num<CURVE.n}function assertGE(num){if(!isWithinCurveOrder(num))throw Error("Expected valid bigint: 0 \x3c bigint \x3c curve.n");
}function normPrivateKeyToScalar(key){const {allowedPrivateKeyLengths:lengths,nByteLength,wrapPrivateKey,n}=CURVE;if(lengths&&"bigint"!==typeof key){key instanceof Uint8Array&&(key=ut.bytesToHex(key));if("string"!==typeof key||!lengths.includes(key.length))throw Error("Invalid key");key=key.padStart(2*nByteLength,"0")}let num;try{num="bigint"===typeof key?key:ut.bytesToNumberBE((0,utils_js_1.ensureBytes)("private key",key,nByteLength))}catch(error){throw Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
}wrapPrivateKey&&(num=mod.mod(num,n));assertGE(num);return num}function assertPrjPoint(other){if(!(other instanceof Point))throw Error("ProjectivePoint expected");}const CURVE=validatePointOpts(opts),{Fp}=CURVE,toBytes=CURVE.toBytes||((_c,point,_isCompressed)=>{_c=point.toAffine();return ut.concatBytes(Uint8Array.from([4]),Fp.toBytes(_c.x),Fp.toBytes(_c.y))}),fromBytes=CURVE.fromBytes||(bytes=>{var tail=bytes.subarray(1);bytes=Fp.fromBytes(tail.subarray(0,Fp.BYTES));tail=Fp.fromBytes(tail.subarray(Fp.BYTES,
2*Fp.BYTES));return{x:bytes,y:tail}});if(!Fp.eql(Fp.sqr(CURVE.Gy),weierstrassEquation(CURVE.Gx)))throw Error("bad generator point: equation left !\x3d right");const pointPrecomputes=new Map;class Point{constructor(px,py,pz){this.px=px;this.py=py;this.pz=pz;if(null==px||!Fp.isValid(px))throw Error("x required");if(null==py||!Fp.isValid(py))throw Error("y required");if(null==pz||!Fp.isValid(pz))throw Error("z required");}static fromAffine(p){const {x,y}=p||{};if(!p||!Fp.isValid(x)||!Fp.isValid(y))throw Error("invalid affine point");
if(p instanceof Point)throw Error("projective point not allowed");return Fp.eql(x,Fp.ZERO)&&Fp.eql(y,Fp.ZERO)?Point.ZERO:new Point(x,y,Fp.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(points){const toInv=Fp.invertBatch(points.map(p=>p.pz));return points.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)}static fromHex(hex){hex=Point.fromAffine(fromBytes((0,utils_js_1.ensureBytes)("pointHex",hex)));hex.assertValidity();return hex}static fromPrivateKey(privateKey){return Point.BASE.multiply(normPrivateKeyToScalar(privateKey))}_setWindowSize(windowSize){this._WINDOW_SIZE=
windowSize;pointPrecomputes.delete(this)}assertValidity(){if(this.is0()){if(CURVE.allowInfinityPoint&&!Fp.is0(this.py))return;throw Error("bad point: ZERO");}const {x,y}=this.toAffine();if(!Fp.isValid(x)||!Fp.isValid(y))throw Error("bad point: x or y not FE");const left=Fp.sqr(y),right=weierstrassEquation(x);if(!Fp.eql(left,right))throw Error("bad point: equation left !\x3d right");if(!this.isTorsionFree())throw Error("bad point: not in prime-order subgroup");}hasEvenY(){const {y}=this.toAffine();
if(Fp.isOdd)return!Fp.isOdd(y);throw Error("Field doesn't support isOdd");}equals(other){assertPrjPoint(other);const {px:X1,py:Y1,pz:Z1}=this,{px:X2,py:Y2,pz:Z2}=other;other=Fp.eql(Fp.mul(X1,Z2),Fp.mul(X2,Z1));const U2=Fp.eql(Fp.mul(Y1,Z2),Fp.mul(Y2,Z1));return other&&U2}negate(){return new Point(this.px,Fp.neg(this.py),this.pz)}double(){const {a,b}=CURVE,b3=Fp.mul(b,_3n),{px:X1,py:Y1,pz:Z1}=this;let X3,Y3,Z3,t0=Fp.mul(X1,X1),t1=Fp.mul(Y1,Y1),t2=Fp.mul(Z1,Z1),t3=Fp.mul(X1,Y1);t3=Fp.add(t3,t3);Z3=
Fp.mul(X1,Z1);Z3=Fp.add(Z3,Z3);X3=Fp.mul(a,Z3);Y3=Fp.mul(b3,t2);Y3=Fp.add(X3,Y3);X3=Fp.sub(t1,Y3);Y3=Fp.add(t1,Y3);Y3=Fp.mul(X3,Y3);X3=Fp.mul(t3,X3);Z3=Fp.mul(b3,Z3);t2=Fp.mul(a,t2);t3=Fp.sub(t0,t2);t3=Fp.mul(a,t3);t3=Fp.add(t3,Z3);Z3=Fp.add(t0,t0);t0=Fp.add(Z3,t0);t0=Fp.add(t0,t2);t0=Fp.mul(t0,t3);Y3=Fp.add(Y3,t0);t2=Fp.mul(Y1,Z1);t2=Fp.add(t2,t2);t0=Fp.mul(t2,t3);X3=Fp.sub(X3,t0);Z3=Fp.mul(t2,t1);Z3=Fp.add(Z3,Z3);Z3=Fp.add(Z3,Z3);return new Point(X3,Y3,Z3)}add(other){assertPrjPoint(other);const {px:X1,
py:Y1,pz:Z1}=this,{px:X2,py:Y2,pz:Z2}=other;let Y3,Z3;const a=CURVE.a,b3=Fp.mul(CURVE.b,_3n);let t0=Fp.mul(X1,X2),t1=Fp.mul(Y1,Y2),t2=Fp.mul(Z1,Z2),t3=Fp.add(X1,Y1),t4=Fp.add(X2,Y2);t3=Fp.mul(t3,t4);t4=Fp.add(t0,t1);t3=Fp.sub(t3,t4);t4=Fp.add(X1,Z1);let t5=Fp.add(X2,Z2);t4=Fp.mul(t4,t5);t5=Fp.add(t0,t2);t4=Fp.sub(t4,t5);t5=Fp.add(Y1,Z1);other=Fp.add(Y2,Z2);t5=Fp.mul(t5,other);other=Fp.add(t1,t2);t5=Fp.sub(t5,other);Z3=Fp.mul(a,t4);other=Fp.mul(b3,t2);Z3=Fp.add(other,Z3);other=Fp.sub(t1,Z3);Z3=Fp.add(t1,
Z3);Y3=Fp.mul(other,Z3);t1=Fp.add(t0,t0);t1=Fp.add(t1,t0);t2=Fp.mul(a,t2);t4=Fp.mul(b3,t4);t1=Fp.add(t1,t2);t2=Fp.sub(t0,t2);t2=Fp.mul(a,t2);t4=Fp.add(t4,t2);t0=Fp.mul(t1,t4);Y3=Fp.add(Y3,t0);t0=Fp.mul(t5,t4);other=Fp.mul(t3,other);other=Fp.sub(other,t0);t0=Fp.mul(t3,t1);Z3=Fp.mul(t5,Z3);Z3=Fp.add(Z3,t0);return new Point(other,Y3,Z3)}subtract(other){return this.add(other.negate())}is0(){return this.equals(Point.ZERO)}wNAF(n){return wnaf.wNAFCached(this,pointPrecomputes,n,comp=>{const toInv=Fp.invertBatch(comp.map(p=>
p.pz));return comp.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)})}multiplyUnsafe(n){var I=Point.ZERO;if(n===_0n)return I;assertGE(n);if(n===_1n)return this;const {endo}=CURVE;if(!endo)return wnaf.unsafeLadder(this,n);let {k1neg,k1,k2neg,k2}=endo.splitScalar(n);n=I;let d=this;for(;k1>_0n||k2>_0n;)k1&_1n&&(n=n.add(d)),k2&_1n&&(I=I.add(d)),d=d.double(),k1>>=_1n,k2>>=_1n;k1neg&&(n=n.negate());k2neg&&(I=I.negate());I=new Point(Fp.mul(I.px,endo.beta),I.py,I.pz);return n.add(I)}multiply(scalar){assertGE(scalar);
({endo:fake}=CURVE);if(fake){const {k1neg,k1,k2neg,k2}=fake.splitScalar(scalar);let {p:k1p,f:f1p}=this.wNAF(k1),{p:k2p,f:f2p}=this.wNAF(k2);k1p=wnaf.constTimeNegate(k1neg,k1p);k2p=wnaf.constTimeNegate(k2neg,k2p);k2p=new Point(Fp.mul(k2p.px,fake.beta),k2p.py,k2p.pz);scalar=k1p.add(k2p);var fake=f1p.add(f2p)}else{const {p,f}=this.wNAF(scalar);scalar=p;fake=f}return Point.normalizeZ([scalar,fake])[0]}multiplyAndAddUnsafe(Q,a$jscomp$0,b){const G=Point.BASE,mul=(P,a)=>a!==_0n&&a!==_1n&&P.equals(G)?P.multiply(a):
P.multiplyUnsafe(a);Q=mul(this,a$jscomp$0).add(mul(Q,b));return Q.is0()?void 0:Q}toAffine(iz){const {px:x,py:y,pz:z}=this,is0=this.is0();null==iz&&(iz=is0?Fp.ONE:Fp.inv(z));const ax=Fp.mul(x,iz),ay=Fp.mul(y,iz);iz=Fp.mul(z,iz);if(is0)return{x:Fp.ZERO,y:Fp.ZERO};if(!Fp.eql(iz,Fp.ONE))throw Error("invZ was invalid");return{x:ax,y:ay}}isTorsionFree(){const {h:cofactor,isTorsionFree}=CURVE;if(cofactor===_1n)return!0;if(isTorsionFree)return isTorsionFree(Point,this);throw Error("isTorsionFree() has not been declared for the elliptic curve");
}clearCofactor(){const {h:cofactor,clearCofactor}=CURVE;return cofactor===_1n?this:clearCofactor?clearCofactor(Point,this):this.multiplyUnsafe(CURVE.h)}toRawBytes(isCompressed=!0){this.assertValidity();return toBytes(Point,this,isCompressed)}toHex(isCompressed=!0){return ut.bytesToHex(this.toRawBytes(isCompressed))}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy,Fp.ONE);Point.ZERO=new Point(Fp.ZERO,Fp.ONE,Fp.ZERO);opts=CURVE.nBitLength;const wnaf=(0,curve_js_1.wNAF)(Point,CURVE.endo?Math.ceil(opts/2):opts);
return{CURVE,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}}function validateOpts(curve){curve=(0,curve_js_1.validateBasic)(curve);ut.validateObject(curve,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"});return Object.freeze({lowS:!0,...curve})}function SWUFpSqrtRatio(Fp,Z){var q=Fp.ORDER,l=_0n;for(let o=q-_1n;o%_2n===_0n;o/=_2n)l+=_1n;const c1$jscomp$0=l,_2n_pow_c1_1=_2n<<c1$jscomp$0-_1n-_1n;
l=_2n_pow_c1_1*_2n;q=(q-_1n)/l;const c3=(q-_1n)/_2n,c4=l-_1n,c6=Fp.pow(Z,q),c7=Fp.pow(Z,(q+_1n)/_2n);q=(u,v)=>{let tv1=c6;var tv2=Fp.pow(v,c4);let tv3=Fp.sqr(tv2);tv3=Fp.mul(tv3,v);var tv5=Fp.mul(u,tv3);tv5=Fp.pow(tv5,c3);tv5=Fp.mul(tv5,tv2);tv2=Fp.mul(tv5,v);tv3=Fp.mul(tv5,u);u=Fp.mul(tv3,tv2);tv5=Fp.pow(u,_2n_pow_c1_1);v=Fp.eql(tv5,Fp.ONE);tv2=Fp.mul(tv3,c7);tv5=Fp.mul(u,tv1);tv3=Fp.cmov(tv2,tv3,v);u=Fp.cmov(tv5,u,v);for(tv5=c1$jscomp$0;tv5>_1n;tv5--){tv2=tv5-_2n;tv2=_2n<<tv2-_1n;let tvv5=Fp.pow(u,
tv2);const e1=Fp.eql(tvv5,Fp.ONE);tv2=Fp.mul(tv3,tv1);tv1=Fp.mul(tv1,tv1);tvv5=Fp.mul(u,tv1);tv3=Fp.cmov(tv2,tv3,e1);u=Fp.cmov(tvv5,u,e1)}return{isValid:v,value:tv3}};if(Fp.ORDER%_4n===_3n){const c1=(Fp.ORDER-_3n)/_4n,c2=Fp.sqrt(Fp.neg(Z));q=(u,v)=>{var tv1=Fp.sqr(v),tv2=Fp.mul(u,v);tv1=Fp.mul(tv1,tv2);tv1=Fp.pow(tv1,c1);tv1=Fp.mul(tv1,tv2);tv2=Fp.mul(tv1,c2);v=Fp.mul(Fp.sqr(tv1),v);u=Fp.eql(v,u);tv1=Fp.cmov(tv2,tv1,u);return{isValid:u,value:tv1}}}return q}Object.defineProperty(exports,"__esModule",
{value:!0});exports.mapToCurveSimpleSWU=exports.SWUFpSqrtRatio=exports.weierstrass=exports.weierstrassPoints=exports.DER=void 0;const mod=require("module$node_modules$$noble$curves$abstract$modular"),ut=require("module$node_modules$$noble$curves$abstract$utils"),utils_js_1=require("module$node_modules$$noble$curves$abstract$utils"),curve_js_1=require("module$node_modules$$noble$curves$abstract$curve"),{bytesToNumberBE:b2n,hexToBytes:h2b}=ut;exports.DER={Err:class extends Error{constructor(m=""){super(m)}},
_parseInt(data){const {Err:E}=exports.DER;if(2>data.length||2!==data[0])throw new E("Invalid signature integer tag");const len=data[1],res=data.subarray(2,len+2);if(!len||res.length!==len)throw new E("Invalid signature integer: wrong length");if(res[0]&128)throw new E("Invalid signature integer: negative");if(0===res[0]&&!(res[1]&128))throw new E("Invalid signature integer: unnecessary leading zero");return{d:b2n(res),l:data.subarray(len+2)}},toSig(hex){const {Err:E}=exports.DER;hex="string"===typeof hex?
h2b(hex):hex;if(!(hex instanceof Uint8Array))throw Error("ui8a expected");let l=hex.length;if(2>l||48!=hex[0])throw new E("Invalid signature tag");if(hex[1]!==l-2)throw new E("Invalid signature: incorrect length");const {d:r,l:sBytes}=exports.DER._parseInt(hex.subarray(2)),{d:s,l:rBytesLeft}=exports.DER._parseInt(sBytes);if(rBytesLeft.length)throw new E("Invalid signature: left bytes after parsing");return{r,s}},hexFromSig(sig){var slice=s=>Number.parseInt(s[0],16)&8?"00"+s:s;const h=num=>{num=num.toString(16);
return num.length&1?`0${num}`:num},s$jscomp$0=slice(h(sig.s));sig=slice(h(sig.r));slice=s$jscomp$0.length/2;const rhl=sig.length/2,sl=h(slice),rl=h(rhl);return`30${h(rhl+slice+4)}02${rl}${sig}02${sl}${s$jscomp$0}`}};const _0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_4n=BigInt(4);exports.weierstrassPoints=weierstrassPoints;exports.weierstrass=function(curveDef){function modN(a){return mod.mod(a,CURVE_ORDER)}function isProbPub(item){const arr=item instanceof Uint8Array,str="string"===typeof item,
len=(arr||str)&&item.length;return arr?len===compressedLen||len===uncompressedLen:str?len===2*compressedLen||len===2*uncompressedLen:item instanceof Point?!0:!1}function int2octets(num){if("bigint"!==typeof num)throw Error("bigint expected");if(!(_0n<=num&&num<ORDER_MASK))throw Error(`bigint expected < 2^${CURVE.nBitLength}`);return ut.numberToBytesBE(num,CURVE.nByteLength)}function prepSig(msgHash,privateKey,opts=defaultSigOpts){if(["recovered","canonical"].some(k=>k in opts))throw Error("sign() legacy options not supported");
const {hash,randomBytes}=CURVE;let {lowS,prehash,extraEntropy:ent}=opts;null==lowS&&(lowS=!0);msgHash=(0,utils_js_1.ensureBytes)("msgHash",msgHash);prehash&&(msgHash=(0,utils_js_1.ensureBytes)("prehashed msgHash",hash(msgHash)));const h1int=bits2int_modN(msgHash),d=normPrivateKeyToScalar(privateKey);msgHash=[int2octets(d),int2octets(h1int)];null!=ent&&(privateKey=!0===ent?randomBytes(Fp.BYTES):ent,msgHash.push((0,utils_js_1.ensureBytes)("extraEntropy",privateKey)));return{seed:ut.concatBytes(...msgHash),
k2sig:function(kBytes){kBytes=bits2int(kBytes);if(isWithinCurveOrder(kBytes)){var ik=mod.invert(kBytes,CURVE_ORDER),q=Point.BASE.multiply(kBytes).toAffine();kBytes=modN(q.x);if(kBytes!==_0n&&(ik=modN(ik*modN(h1int+kBytes*d)),ik!==_0n)){q=(q.x===kBytes?0:2)|Number(q.y&_1n);var normS=ik;lowS&&ik>CURVE_ORDER>>_1n&&(normS=ik>CURVE_ORDER>>_1n?modN(-ik):ik,q^=1);return new Signature(kBytes,normS,q)}}}}}const CURVE=validateOpts(curveDef),{Fp,n:CURVE_ORDER}=CURVE,compressedLen=Fp.BYTES+1,uncompressedLen=
2*Fp.BYTES+1,{ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}=weierstrassPoints({...CURVE,toBytes(_c,point,isCompressed){_c=point.toAffine();const x=Fp.toBytes(_c.x),cat=ut.concatBytes;return isCompressed?cat(Uint8Array.from([point.hasEvenY()?2:3]),x):cat(Uint8Array.from([4]),x,Fp.toBytes(_c.y))},fromBytes(bytes){var len=bytes.length,head=bytes[0];bytes=bytes.subarray(1);if(len!==compressedLen||2!==head&&3!==head){if(len===uncompressedLen&&4===head)return head=
Fp.fromBytes(bytes.subarray(0,Fp.BYTES)),len=Fp.fromBytes(bytes.subarray(Fp.BYTES,2*Fp.BYTES)),{x:head,y:len};throw Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);}len=ut.bytesToNumberBE(bytes);if(!(_0n<len&&len<Fp.ORDER))throw Error("Point is not on curve");bytes=weierstrassEquation(len);bytes=Fp.sqrt(bytes);1===(head&1)!==((bytes&_1n)===_1n)&&(bytes=Fp.neg(bytes));return{x:len,y:bytes}}});class Signature{constructor(r,
s,recovery){this.r=r;this.s=s;this.recovery=recovery;this.assertValidity()}static fromCompact(hex){const l=CURVE.nByteLength;hex=(0,utils_js_1.ensureBytes)("compactSignature",hex,2*l);return new Signature(ut.bytesToNumberBE(hex.slice(0,l)),ut.bytesToNumberBE(hex.slice(l,2*l)))}static fromDER(hex){const {r,s}=exports.DER.toSig((0,utils_js_1.ensureBytes)("DER",hex));return new Signature(r,s)}assertValidity(){if(!isWithinCurveOrder(this.r))throw Error("r must be 0 \x3c r \x3c CURVE.n");if(!isWithinCurveOrder(this.s))throw Error("s must be 0 \x3c s \x3c CURVE.n");
}addRecoveryBit(recovery){return new Signature(this.r,this.s,recovery)}recoverPublicKey(msgHash){const {r,s,recovery:rec}=this;var h=bits2int_modN((0,utils_js_1.ensureBytes)("msgHash",msgHash));if(null==rec||![0,1,2,3].includes(rec))throw Error("recovery id invalid");var radj=2===rec||3===rec?r+CURVE.n:r;if(radj>=Fp.ORDER)throw Error("recovery id 2 or 3 invalid");msgHash=Point.fromHex((0===(rec&1)?"02":"03")+ut.bytesToHex(ut.numberToBytesBE(radj,CURVE.nByteLength)));radj=mod.invert(radj,CURVE_ORDER);
h=modN(-h*radj);radj=modN(s*radj);msgHash=Point.BASE.multiplyAndAddUnsafe(msgHash,h,radj);if(!msgHash)throw Error("point at infinify");msgHash.assertValidity();return msgHash}hasHighS(){return this.s>CURVE_ORDER>>_1n}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return ut.hexToBytes(this.toDERHex())}toDERHex(){return exports.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ut.hexToBytes(this.toCompactHex())}toCompactHex(){return ut.bytesToHex(ut.numberToBytesBE(this.r,
CURVE.nByteLength))+ut.bytesToHex(ut.numberToBytesBE(this.s,CURVE.nByteLength))}}curveDef={isValidPrivateKey(privateKey){try{return normPrivateKeyToScalar(privateKey),!0}catch(error){return!1}},normPrivateKeyToScalar,randomPrivateKey:()=>{const length=mod.getMinHashLength(CURVE.n);return mod.mapHashToField(CURVE.randomBytes(length),CURVE.n)},precompute(windowSize=8,point=Point.BASE){point._setWindowSize(windowSize);point.multiply(BigInt(3));return point}};const bits2int=CURVE.bits2int||function(bytes){const num=
ut.bytesToNumberBE(bytes);bytes=8*bytes.length-CURVE.nBitLength;return 0<bytes?num>>BigInt(bytes):num},bits2int_modN=CURVE.bits2int_modN||function(bytes){return modN(bits2int(bytes))},ORDER_MASK=ut.bitMask(CURVE.nBitLength),defaultSigOpts={lowS:CURVE.lowS,prehash:!1},defaultVerOpts={lowS:CURVE.lowS,prehash:!1};Point.BASE._setWindowSize(8);return{CURVE,getPublicKey:function(privateKey,isCompressed=!0){return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)},getSharedSecret:function(privateA,
publicB,isCompressed=!0){if(isProbPub(privateA))throw Error("first arg must be private key");if(!isProbPub(publicB))throw Error("second arg must be public key");return Point.fromHex(publicB).multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed)},sign:function(msgHash,privKey,opts=defaultSigOpts){const {seed,k2sig}=prepSig(msgHash,privKey,opts);msgHash=CURVE;return ut.createHmacDrbg(msgHash.hash.outputLen,msgHash.nByteLength,msgHash.hmac)(seed,k2sig)},verify:function(signature,msgHash,
publicKey,opts=defaultVerOpts){msgHash=(0,utils_js_1.ensureBytes)("msgHash",msgHash);publicKey=(0,utils_js_1.ensureBytes)("publicKey",publicKey);if("strict"in opts)throw Error("options.strict was renamed to lowS");const {lowS,prehash}=opts;opts=void 0;try{if("string"===typeof signature||signature instanceof Uint8Array)try{opts=Signature.fromDER(signature)}catch(derError){if(!(derError instanceof exports.DER.Err))throw derError;opts=Signature.fromCompact(signature)}else if("object"===typeof signature&&
"bigint"===typeof signature.r&&"bigint"===typeof signature.s){const {r,s}=signature;opts=new Signature(r,s)}else throw Error("PARSE");var P=Point.fromHex(publicKey)}catch(error){if("PARSE"===error.message)throw Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(lowS&&opts.hasHighS())return!1;prehash&&(msgHash=CURVE.hash(msgHash));const {r:r$jscomp$0,s:s$jscomp$0}=opts;msgHash=bits2int_modN(msgHash);signature=mod.invert(s$jscomp$0,CURVE_ORDER);msgHash=modN(msgHash*
signature);signature=modN(r$jscomp$0*signature);return(P=Point.BASE.multiplyAndAddUnsafe(P,msgHash,signature)?.toAffine())?modN(P.x)===r$jscomp$0:!1},ProjectivePoint:Point,Signature,utils:curveDef}};exports.SWUFpSqrtRatio=SWUFpSqrtRatio;exports.mapToCurveSimpleSWU=function(Fp,opts){mod.validateField(Fp);if(!Fp.isValid(opts.A)||!Fp.isValid(opts.B)||!Fp.isValid(opts.Z))throw Error("mapToCurveSimpleSWU: invalid opts");const sqrtRatio=SWUFpSqrtRatio(Fp,opts.Z);if(!Fp.isOdd)throw Error("Fp.isOdd is not implemented!");
return u=>{let tv2,tv3,tv4;let tv6;var tv1=Fp.sqr(u);tv1=Fp.mul(tv1,opts.Z);tv2=Fp.sqr(tv1);tv2=Fp.add(tv2,tv1);tv3=Fp.add(tv2,Fp.ONE);tv3=Fp.mul(tv3,opts.B);tv4=Fp.cmov(opts.Z,Fp.neg(tv2),!Fp.eql(tv2,Fp.ZERO));tv4=Fp.mul(tv4,opts.A);tv2=Fp.sqr(tv3);tv6=Fp.sqr(tv4);var tv5=Fp.mul(tv6,opts.A);tv2=Fp.add(tv2,tv5);tv2=Fp.mul(tv2,tv3);tv6=Fp.mul(tv6,tv4);tv5=Fp.mul(tv6,opts.B);tv2=Fp.add(tv2,tv5);tv5=Fp.mul(tv1,tv3);const {isValid,value}=sqrtRatio(tv2,tv6);tv1=Fp.mul(tv1,u);tv1=Fp.mul(tv1,value);tv5=
Fp.cmov(tv5,tv3,isValid);tv1=Fp.cmov(tv1,value,isValid);u=Fp.isOdd(u)===Fp.isOdd(tv1);tv1=Fp.cmov(Fp.neg(tv1),tv1,u);tv5=Fp.div(tv5,tv4);return{x:tv5,y:tv1}}}}
//# sourceMappingURL=module$node_modules$$noble$curves$abstract$weierstrass.js.map
