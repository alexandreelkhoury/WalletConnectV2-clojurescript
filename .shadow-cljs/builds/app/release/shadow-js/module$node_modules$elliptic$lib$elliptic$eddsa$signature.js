["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/elliptic/lib/elliptic/eddsa/signature.js"],"~:js","shadow$provide[100]=function(S,A,V,q){function F(u,p){this.eddsa=u;\"object\"!==typeof p&&(p=e(p));Array.isArray(p)&&(p={R:p.slice(0,u.encodingLength),S:p.slice(u.encodingLength)});y(p.R&&p.S,\"Signature without R or S\");u.isPoint(p.R)&&(this._R=p.R);p.S instanceof G&&(this._S=p.S);this._Rencoded=Array.isArray(p.R)?p.R:p.Rencoded;this._Sencoded=Array.isArray(p.S)?p.S:p.Sencoded}var G=A(70),r=A(73),y=r.assert;S=r.cachedProperty;var e=r.parseBytes;S(F,\"S\",function(){return this.eddsa.decodeInt(this.Sencoded())});\nS(F,\"R\",function(){return this.eddsa.decodePoint(this.Rencoded())});S(F,\"Rencoded\",function(){return this.eddsa.encodePoint(this.R())});S(F,\"Sencoded\",function(){return this.eddsa.encodeInt(this.S())});F.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())};F.prototype.toHex=function(){return r.encode(this.toBytes(),\"hex\").toUpperCase()};V.exports=F}","~:source","shadow$provide[100] = function(global,require,module,exports) {\n'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\nvar cachedProperty = utils.cachedProperty;\nvar parseBytes = utils.parseBytes;\n\n/**\n* @param {EDDSA} eddsa - eddsa instance\n* @param {Array<Bytes>|Object} sig -\n* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes\n* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes\n* @param {Array<Bytes>} [sig.Rencoded] - R point encoded\n* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded\n*/\nfunction Signature(eddsa, sig) {\n  this.eddsa = eddsa;\n\n  if (typeof sig !== 'object')\n    sig = parseBytes(sig);\n\n  if (Array.isArray(sig)) {\n    sig = {\n      R: sig.slice(0, eddsa.encodingLength),\n      S: sig.slice(eddsa.encodingLength),\n    };\n  }\n\n  assert(sig.R && sig.S, 'Signature without R or S');\n\n  if (eddsa.isPoint(sig.R))\n    this._R = sig.R;\n  if (sig.S instanceof BN)\n    this._S = sig.S;\n\n  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;\n  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;\n}\n\ncachedProperty(Signature, 'S', function S() {\n  return this.eddsa.decodeInt(this.Sencoded());\n});\n\ncachedProperty(Signature, 'R', function R() {\n  return this.eddsa.decodePoint(this.Rencoded());\n});\n\ncachedProperty(Signature, 'Rencoded', function Rencoded() {\n  return this.eddsa.encodePoint(this.R());\n});\n\ncachedProperty(Signature, 'Sencoded', function Sencoded() {\n  return this.eddsa.encodeInt(this.S());\n});\n\nSignature.prototype.toBytes = function toBytes() {\n  return this.Rencoded().concat(this.Sencoded());\n};\n\nSignature.prototype.toHex = function toHex() {\n  return utils.encode(this.toBytes(), 'hex').toUpperCase();\n};\n\nmodule.exports = Signature;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$elliptic$node_modules$bn_js$lib$bn","~$module$node_modules$elliptic$lib$elliptic$utils"]],"~:properties",["^5",["_Rencoded","eddsa","S","_S","R","toHex","toBytes","_R","_Sencoded"]],"~:compiled-at",1695041440755,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$elliptic$lib$elliptic$eddsa$signature.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAiB9DC,QAASA,EAAS,CAACC,CAAD,CAAQC,CAAR,CAAa,CAC7B,IAAKD,CAAAA,KAAL,CAAaA,CAEM,SAAnB,GAAI,MAAOC,EAAX,GACEA,CADF,CACQC,CAAA,CAAWD,CAAX,CADR,CAGIE,MAAMC,CAAAA,OAAN,CAAcH,CAAd,CAAJ,GACEA,CADF,CACQ,CACJI,EAAGJ,CAAIK,CAAAA,KAAJ,CAAU,CAAV,CAAaN,CAAMO,CAAAA,cAAnB,CADC,CAEJC,EAAGP,CAAIK,CAAAA,KAAJ,CAAUN,CAAMO,CAAAA,cAAhB,CAFC,CADR,CAOAE,EAAA,CAAOR,CAAII,CAAAA,CAAX,EAAgBJ,CAAIO,CAAAA,CAApB,CAAuB,0BAAvB,CAEIR,EAAMU,CAAAA,OAAN,CAAcT,CAAII,CAAAA,CAAlB,CAAJ,GACE,IAAKM,CAAAA,EADP,CACYV,CAAII,CAAAA,CADhB,CAEIJ,EAAIO,CAAAA,CAAR,WAAqBI,EAArB,GACE,IAAKC,CAAAA,EADP,CACYZ,CAAIO,CAAAA,CADhB,CAGA,KAAKM,CAAAA,SAAL,CAAiBX,KAAMC,CAAAA,OAAN,CAAcH,CAAII,CAAAA,CAAlB,CAAA,CAAuBJ,CAAII,CAAAA,CAA3B,CAA+BJ,CAAIc,CAAAA,QACpD,KAAKC,CAAAA,SAAL,CAAiBb,KAAMC,CAAAA,OAAN,CAAcH,CAAIO,CAAAA,CAAlB,CAAA,CAAuBP,CAAIO,CAAAA,CAA3B,CAA+BP,CAAIgB,CAAAA,QArBvB,CAd/B,IAAIL,EAAKhB,CAAA,CAAQ,EAAR,CAAT,CACIsB,EAAQtB,CAAA,CAAQ,EAAR,CADZ,CAEIa,EAASS,CAAMT,CAAAA,MACfU,EAAAA,CAAiBD,CAAMC,CAAAA,cAC3B,KAAIjB,EAAagB,CAAMhB,CAAAA,UAkCvBiB,EAAA,CAAepB,CAAf,CAA0B,GAA1B,CAA+BS,QAAU,EAAG,CAC1C,MAAO,KAAKR,CAAAA,KAAMoB,CAAAA,SAAX,CAAqB,IAAKH,CAAAA,QAAL,EAArB,CADmC,CAA5C,CAIAE;CAAA,CAAepB,CAAf,CAA0B,GAA1B,CAA+BM,QAAU,EAAG,CAC1C,MAAO,KAAKL,CAAAA,KAAMqB,CAAAA,WAAX,CAAuB,IAAKN,CAAAA,QAAL,EAAvB,CADmC,CAA5C,CAIAI,EAAA,CAAepB,CAAf,CAA0B,UAA1B,CAAsCgB,QAAiB,EAAG,CACxD,MAAO,KAAKf,CAAAA,KAAMsB,CAAAA,WAAX,CAAuB,IAAKjB,CAAAA,CAAL,EAAvB,CADiD,CAA1D,CAIAc,EAAA,CAAepB,CAAf,CAA0B,UAA1B,CAAsCkB,QAAiB,EAAG,CACxD,MAAO,KAAKjB,CAAAA,KAAMuB,CAAAA,SAAX,CAAqB,IAAKf,CAAAA,CAAL,EAArB,CADiD,CAA1D,CAIAT,EAAUyB,CAAAA,SAAUC,CAAAA,OAApB,CAA8BC,QAAgB,EAAG,CAC/C,MAAO,KAAKX,CAAAA,QAAL,EAAgBY,CAAAA,MAAhB,CAAuB,IAAKV,CAAAA,QAAL,EAAvB,CADwC,CAIjDlB,EAAUyB,CAAAA,SAAUI,CAAAA,KAApB,CAA4BC,QAAc,EAAG,CAC3C,MAAOX,EAAMY,CAAAA,MAAN,CAAa,IAAKL,CAAAA,OAAL,EAAb,CAA6B,KAA7B,CAAoCM,CAAAA,WAApC,EADoC,CAI7ClC,EAAOC,CAAAA,OAAP,CAAiBC,CAjE6C;\",\n\"sources\":[\"node_modules/elliptic/lib/elliptic/eddsa/signature.js\"],\n\"sourcesContent\":[\"shadow$provide[100] = function(global,require,module,exports) {\\n'use strict';\\n\\nvar BN = require('bn.js');\\nvar utils = require('../utils');\\nvar assert = utils.assert;\\nvar cachedProperty = utils.cachedProperty;\\nvar parseBytes = utils.parseBytes;\\n\\n/**\\n* @param {EDDSA} eddsa - eddsa instance\\n* @param {Array<Bytes>|Object} sig -\\n* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes\\n* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes\\n* @param {Array<Bytes>} [sig.Rencoded] - R point encoded\\n* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded\\n*/\\nfunction Signature(eddsa, sig) {\\n  this.eddsa = eddsa;\\n\\n  if (typeof sig !== 'object')\\n    sig = parseBytes(sig);\\n\\n  if (Array.isArray(sig)) {\\n    sig = {\\n      R: sig.slice(0, eddsa.encodingLength),\\n      S: sig.slice(eddsa.encodingLength),\\n    };\\n  }\\n\\n  assert(sig.R && sig.S, 'Signature without R or S');\\n\\n  if (eddsa.isPoint(sig.R))\\n    this._R = sig.R;\\n  if (sig.S instanceof BN)\\n    this._S = sig.S;\\n\\n  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;\\n  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;\\n}\\n\\ncachedProperty(Signature, 'S', function S() {\\n  return this.eddsa.decodeInt(this.Sencoded());\\n});\\n\\ncachedProperty(Signature, 'R', function R() {\\n  return this.eddsa.decodePoint(this.Rencoded());\\n});\\n\\ncachedProperty(Signature, 'Rencoded', function Rencoded() {\\n  return this.eddsa.encodePoint(this.R());\\n});\\n\\ncachedProperty(Signature, 'Sencoded', function Sencoded() {\\n  return this.eddsa.encodeInt(this.S());\\n});\\n\\nSignature.prototype.toBytes = function toBytes() {\\n  return this.Rencoded().concat(this.Sencoded());\\n};\\n\\nSignature.prototype.toHex = function toHex() {\\n  return utils.encode(this.toBytes(), 'hex').toUpperCase();\\n};\\n\\nmodule.exports = Signature;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Signature\",\"eddsa\",\"sig\",\"parseBytes\",\"Array\",\"isArray\",\"R\",\"slice\",\"encodingLength\",\"S\",\"assert\",\"isPoint\",\"_R\",\"BN\",\"_S\",\"_Rencoded\",\"Rencoded\",\"_Sencoded\",\"Sencoded\",\"utils\",\"cachedProperty\",\"decodeInt\",\"decodePoint\",\"encodePoint\",\"encodeInt\",\"prototype\",\"toBytes\",\"Signature.prototype.toBytes\",\"concat\",\"toHex\",\"Signature.prototype.toHex\",\"encode\",\"toUpperCase\"]\n}\n"]