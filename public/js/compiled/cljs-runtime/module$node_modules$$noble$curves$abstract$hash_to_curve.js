shadow$provide.module$node_modules$$noble$curves$abstract$hash_to_curve=function(global,require,module,exports){function i2osp(value,length){if(0>value||value>=1<<8*length)throw Error(`bad I2OSP call: value=${value} length=${length}`);const res=Array.from({length}).fill(0);for(--length;0<=length;length--)res[length]=value&255,value>>>=8;return new Uint8Array(res)}function isBytes(item){if(!(item instanceof Uint8Array))throw Error("Uint8Array expected");}function isNum(item){if(!Number.isSafeInteger(item))throw Error("number expected");
}function expand_message_xmd(msg,DST,lenInBytes,H){isBytes(msg);isBytes(DST);isNum(lenInBytes);255<DST.length&&(DST=H((0,utils_js_1.concatBytes)((0,utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"),DST)));const {outputLen:b_in_bytes,blockLen:r_in_bytes}=H,ell=Math.ceil(lenInBytes/b_in_bytes);if(255<ell)throw Error("Invalid xmd length");DST=(0,utils_js_1.concatBytes)(DST,i2osp(DST.length,1));var Z_pad=i2osp(0,r_in_bytes),l_i_b_str=i2osp(lenInBytes,2);const b=Array(ell);msg=H((0,utils_js_1.concatBytes)(Z_pad,
msg,l_i_b_str,i2osp(0,1),DST));b[0]=H((0,utils_js_1.concatBytes)(msg,i2osp(1,1),DST));for(Z_pad=1;Z_pad<=ell;Z_pad++){l_i_b_str=msg;var b$jscomp$0=b[Z_pad-1];const arr=new Uint8Array(l_i_b_str.length);for(let i=0;i<l_i_b_str.length;i++)arr[i]=l_i_b_str[i]^b$jscomp$0[i];l_i_b_str=[arr,i2osp(Z_pad+1,1),DST];b[Z_pad]=H((0,utils_js_1.concatBytes)(...l_i_b_str))}return(0,utils_js_1.concatBytes)(...b).slice(0,lenInBytes)}function expand_message_xof(msg,DST,lenInBytes,k,H){isBytes(msg);isBytes(DST);isNum(lenInBytes);
255<DST.length&&(DST=H.create({dkLen:Math.ceil(2*k/8)}).update((0,utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest());if(65535<lenInBytes||255<DST.length)throw Error("expand_message_xof: invalid lenInBytes");return H.create({dkLen:lenInBytes}).update(msg).update(i2osp(lenInBytes,2)).update(DST).update(i2osp(DST.length,1)).digest()}function hash_to_field(msg,count,options){(0,utils_js_1.validateObject)(options,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",
hash:"hash"});const {p,k,m,hash,expand,DST:_DST}=options;isBytes(msg);isNum(count);if(_DST instanceof Uint8Array)options=_DST;else if("string"===typeof _DST)options=(0,utils_js_1.utf8ToBytes)(_DST);else throw Error("DST must be Uint8Array or string");var DST=options;options=p.toString(2).length;options=Math.ceil((options+k)/8);var len_in_bytes=count*m*options;if("xmd"===expand)msg=expand_message_xmd(msg,DST,len_in_bytes,hash);else if("xof"===expand)msg=expand_message_xof(msg,DST,len_in_bytes,k,hash);
else if("_internal_pass"!==expand)throw Error('expand must be "xmd" or "xof"');DST=Array(count);for(len_in_bytes=0;len_in_bytes<count;len_in_bytes++){const e=Array(m);for(let j=0;j<m;j++){var elm_offset=options*(j+len_in_bytes*m);elm_offset=msg.subarray(elm_offset,elm_offset+options);e[j]=(0,modular_js_1.mod)(os2ip(elm_offset),p)}DST[len_in_bytes]=e}return DST}Object.defineProperty(exports,"__esModule",{value:!0});exports.createHasher=exports.isogenyMap=exports.hash_to_field=exports.expand_message_xof=
exports.expand_message_xmd=void 0;const modular_js_1=require("module$node_modules$$noble$curves$abstract$modular"),utils_js_1=require("module$node_modules$$noble$curves$abstract$utils"),os2ip=utils_js_1.bytesToNumberBE;exports.expand_message_xmd=expand_message_xmd;exports.expand_message_xof=expand_message_xof;exports.hash_to_field=hash_to_field;exports.isogenyMap=function(field,map){const COEFF=map.map(i=>Array.from(i).reverse());return(x,y)=>{const [xNum,xDen,yNum,yDen]=COEFF.map(val=>val.reduce((acc,
i)=>field.add(field.mul(acc,x),i)));x=field.div(xNum,xDen);y=field.mul(y,field.div(yNum,yDen));return{x,y}}};exports.createHasher=function(Point,mapToCurve,def){if("function"!==typeof mapToCurve)throw Error("mapToCurve() must be defined");return{hashToCurve(msg,options){options=hash_to_field(msg,2,{...def,DST:def.DST,...options});msg=Point.fromAffine(mapToCurve(options[0]));options=Point.fromAffine(mapToCurve(options[1]));msg=msg.add(options).clearCofactor();msg.assertValidity();return msg},encodeToCurve(msg,
options){msg=hash_to_field(msg,1,{...def,DST:def.encodeDST,...options});msg=Point.fromAffine(mapToCurve(msg[0])).clearCofactor();msg.assertValidity();return msg}}}}
//# sourceMappingURL=module$node_modules$$noble$curves$abstract$hash_to_curve.js.map
