shadow$provide.module$node_modules$$noble$curves$abstract$curve=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.validateBasic=exports.wNAF=void 0;const modular_js_1=require("module$node_modules$$noble$curves$abstract$modular"),utils_js_1=require("module$node_modules$$noble$curves$abstract$utils"),_0n=BigInt(0),_1n=BigInt(1);exports.wNAF=function(c,bits){const constTimeNegate=(condition,item)=>{const neg=item.negate();return condition?neg:item};
return{constTimeNegate,unsafeLadder(elm,n){let p=c.ZERO;for(;n>_0n;)n&_1n&&(p=p.add(elm)),elm=elm.double(),n>>=_1n;return p},precomputeWindow(elm,W){const {windows,windowSize}={windows:Math.ceil(bits/W)+1,windowSize:2**(W-1)};W=[];let base;for(let window=0;window<windows;window++){base=elm;W.push(base);for(let i=1;i<windowSize;i++)base=base.add(elm),W.push(base);elm=base.double()}return W},wNAF(W,precomputes,n){const {windows,windowSize}={windows:Math.ceil(bits/W)+1,windowSize:2**(W-1)};let p=c.ZERO,
f=c.BASE;const mask=BigInt(2**W-1),maxNumber=2**W;W=BigInt(W);for(let window=0;window<windows;window++){var offset=window*windowSize;let wbits=Number(n&mask);n>>=W;wbits>windowSize&&(wbits-=maxNumber,n+=_1n);const offset1=offset;offset=offset+Math.abs(wbits)-1;const cond1=0!==window%2,cond2=0>wbits;0===wbits?f=f.add(constTimeNegate(cond1,precomputes[offset1])):p=p.add(constTimeNegate(cond2,precomputes[offset]))}return{p,f}},wNAFCached(P,precomputesMap,n,transform){const W=P._WINDOW_SIZE||1;let comp=
precomputesMap.get(P);comp||(comp=this.precomputeWindow(P,W),1!==W&&precomputesMap.set(P,transform(comp)));return this.wNAF(W,comp,n)}}};exports.validateBasic=function(curve){(0,modular_js_1.validateField)(curve.Fp);(0,utils_js_1.validateObject)(curve,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"});return Object.freeze({...(0,modular_js_1.nLength)(curve.n,curve.nBitLength),...curve,p:curve.Fp.ORDER})}}
//# sourceMappingURL=module$node_modules$$noble$curves$abstract$curve.js.map
