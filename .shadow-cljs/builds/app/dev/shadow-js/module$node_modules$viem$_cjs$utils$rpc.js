["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/viem/_cjs/utils/rpc.js"],"~:js","shadow$provide.module$node_modules$viem$_cjs$utils$rpc=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.rpc=exports.getSocket=exports.socketsCache=void 0;const isomorphic_ws_1=require(\"module$node_modules$viem$node_modules$isomorphic_ws$browser\"),request_js_1=require(\"module$node_modules$viem$_cjs$errors$request\"),createBatchScheduler_js_1=require(\"module$node_modules$viem$_cjs$utils$promise$createBatchScheduler\"),withTimeout_js_1=require(\"module$node_modules$viem$_cjs$utils$promise$withTimeout\"),\nstringify_js_1=require(\"module$node_modules$viem$_cjs$utils$stringify\");let id=0;exports.socketsCache=new Map;exports.getSocket=async function(url){let socket=exports.socketsCache.get(url);if(socket)return socket;var {schedule}=(0,createBatchScheduler_js_1.createBatchScheduler)({id:url,fn:async()=>{let WebSocket_=isomorphic_ws_1.default;isomorphic_ws_1.default.constructor||(WebSocket_=isomorphic_ws_1.default.WebSocket);const webSocket=new WebSocket_(url),requests=new Map,subscriptions=new Map,onMessage=\n({data})=>{var message=JSON.parse(data);const isSubscription=\"eth_subscription\"===message.method;message=isSubscription?message.params.subscription:message.id;const cache=isSubscription?subscriptions:requests,callback=cache.get(message);callback&&callback({data});isSubscription||cache.delete(message)},onClose=()=>{exports.socketsCache.delete(url);webSocket.removeEventListener(\"close\",onClose);webSocket.removeEventListener(\"message\",onMessage)};webSocket.addEventListener(\"close\",onClose);webSocket.addEventListener(\"message\",\nonMessage);webSocket.readyState===isomorphic_ws_1.default.CONNECTING&&await new Promise((resolve,reject)=>{webSocket&&(webSocket.onopen=resolve,webSocket.onerror=reject)});socket=Object.assign(webSocket,{requests,subscriptions});exports.socketsCache.set(url,socket);return[socket]}});[,[schedule]]=await schedule();return schedule};exports.rpc={http:async function(url,{body:body$jscomp$0,fetchOptions={},timeout=1E4}){const {headers,method,signal:signal_}=fetchOptions;try{const response=await (0,withTimeout_js_1.withTimeout)(async({signal})=>\nawait fetch(url,{...fetchOptions,body:Array.isArray(body$jscomp$0)?(0,stringify_js_1.stringify)(body$jscomp$0.map(body=>({jsonrpc:\"2.0\",id:body.id??id++,...body}))):(0,stringify_js_1.stringify)({jsonrpc:\"2.0\",id:body$jscomp$0.id??id++,...body$jscomp$0}),headers:{...headers,\"Content-Type\":\"application/json\"},method:method||\"POST\",signal:signal_||(0<timeout?signal:void 0)}),{errorInstance:new request_js_1.TimeoutError({body:body$jscomp$0,url}),timeout,signal:!0});let data;data=response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")?\nawait response.json():await response.text();if(!response.ok)throw new request_js_1.HttpRequestError({body:body$jscomp$0,details:(0,stringify_js_1.stringify)(data.error)||response.statusText,headers:response.headers,status:response.status,url});return data}catch(err){if(err instanceof request_js_1.HttpRequestError)throw err;if(err instanceof request_js_1.TimeoutError)throw err;throw new request_js_1.HttpRequestError({body:body$jscomp$0,details:err.message,url});}},webSocket:function(socket,{body,onResponse}){if(socket.readyState===\nsocket.CLOSED||socket.readyState===socket.CLOSING)throw new request_js_1.WebSocketRequestError({body,url:socket.url,details:\"Socket is closed.\"});const id_=id++,callback=({data})=>{data=JSON.parse(data);if(\"number\"!==typeof data.id||id_===data.id)onResponse?.(data),\"eth_subscribe\"===body.method&&\"string\"===typeof data.result&&socket.subscriptions.set(data.result,callback),\"eth_unsubscribe\"===body.method&&socket.subscriptions.delete(body.params?.[0])};socket.requests.set(id_,callback);socket.send(JSON.stringify({jsonrpc:\"2.0\",\n...body,id:id_}));return socket},webSocketAsync:async function(socket,{body,timeout=1E4}){return(0,withTimeout_js_1.withTimeout)(()=>new Promise(onResponse=>exports.rpc.webSocket(socket,{body,onResponse})),{errorInstance:new request_js_1.TimeoutError({body,url:socket.url}),timeout})}}}","~:source","shadow$provide[\"module$node_modules$viem$_cjs$utils$rpc\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rpc = exports.getSocket = exports.socketsCache = void 0;\nconst isomorphic_ws_1 = require(\"isomorphic-ws\");\nconst request_js_1 = require(\"../errors/request.js\");\nconst createBatchScheduler_js_1 = require(\"./promise/createBatchScheduler.js\");\nconst withTimeout_js_1 = require(\"./promise/withTimeout.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nlet id = 0;\nasync function http(url, { body, fetchOptions = {}, timeout = 10000 }) {\n    const { headers, method, signal: signal_ } = fetchOptions;\n    try {\n        const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {\n            const response = await fetch(url, {\n                ...fetchOptions,\n                body: Array.isArray(body)\n                    ? (0, stringify_js_1.stringify)(body.map((body) => ({\n                        jsonrpc: '2.0',\n                        id: body.id ?? id++,\n                        ...body,\n                    })))\n                    : (0, stringify_js_1.stringify)({ jsonrpc: '2.0', id: body.id ?? id++, ...body }),\n                headers: {\n                    ...headers,\n                    'Content-Type': 'application/json',\n                },\n                method: method || 'POST',\n                signal: signal_ || (timeout > 0 ? signal : undefined),\n            });\n            return response;\n        }, {\n            errorInstance: new request_js_1.TimeoutError({ body, url }),\n            timeout,\n            signal: true,\n        });\n        let data;\n        if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n            data = await response.json();\n        }\n        else {\n            data = await response.text();\n        }\n        if (!response.ok) {\n            throw new request_js_1.HttpRequestError({\n                body,\n                details: (0, stringify_js_1.stringify)(data.error) || response.statusText,\n                headers: response.headers,\n                status: response.status,\n                url,\n            });\n        }\n        return data;\n    }\n    catch (err) {\n        if (err instanceof request_js_1.HttpRequestError)\n            throw err;\n        if (err instanceof request_js_1.TimeoutError)\n            throw err;\n        throw new request_js_1.HttpRequestError({\n            body,\n            details: err.message,\n            url,\n        });\n    }\n}\nexports.socketsCache = new Map();\nasync function getSocket(url) {\n    let socket = exports.socketsCache.get(url);\n    if (socket)\n        return socket;\n    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({\n        id: url,\n        fn: async () => {\n            let WebSocket_ = isomorphic_ws_1.default;\n            if (!isomorphic_ws_1.default.constructor)\n                WebSocket_ = isomorphic_ws_1.default.WebSocket;\n            const webSocket = new WebSocket_(url);\n            const requests = new Map();\n            const subscriptions = new Map();\n            const onMessage = ({ data }) => {\n                const message = JSON.parse(data);\n                const isSubscription = message.method === 'eth_subscription';\n                const id = isSubscription ? message.params.subscription : message.id;\n                const cache = isSubscription ? subscriptions : requests;\n                const callback = cache.get(id);\n                if (callback)\n                    callback({ data });\n                if (!isSubscription)\n                    cache.delete(id);\n            };\n            const onClose = () => {\n                exports.socketsCache.delete(url);\n                webSocket.removeEventListener('close', onClose);\n                webSocket.removeEventListener('message', onMessage);\n            };\n            webSocket.addEventListener('close', onClose);\n            webSocket.addEventListener('message', onMessage);\n            if (webSocket.readyState === isomorphic_ws_1.default.CONNECTING) {\n                await new Promise((resolve, reject) => {\n                    if (!webSocket)\n                        return;\n                    webSocket.onopen = resolve;\n                    webSocket.onerror = reject;\n                });\n            }\n            socket = Object.assign(webSocket, {\n                requests,\n                subscriptions,\n            });\n            exports.socketsCache.set(url, socket);\n            return [socket];\n        },\n    });\n    const [_, [socket_]] = await schedule();\n    return socket_;\n}\nexports.getSocket = getSocket;\nfunction webSocket(socket, { body, onResponse }) {\n    if (socket.readyState === socket.CLOSED ||\n        socket.readyState === socket.CLOSING)\n        throw new request_js_1.WebSocketRequestError({\n            body,\n            url: socket.url,\n            details: 'Socket is closed.',\n        });\n    const id_ = id++;\n    const callback = ({ data }) => {\n        const message = JSON.parse(data);\n        if (typeof message.id === 'number' && id_ !== message.id)\n            return;\n        onResponse?.(message);\n        if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n            socket.subscriptions.set(message.result, callback);\n        }\n        if (body.method === 'eth_unsubscribe') {\n            socket.subscriptions.delete(body.params?.[0]);\n        }\n    };\n    socket.requests.set(id_, callback);\n    socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }));\n    return socket;\n}\nasync function webSocketAsync(socket, { body, timeout = 10000 }) {\n    return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse) => exports.rpc.webSocket(socket, {\n        body,\n        onResponse,\n    })), {\n        errorInstance: new request_js_1.TimeoutError({ body, url: socket.url }),\n        timeout,\n    });\n}\nexports.rpc = {\n    http,\n    webSocket,\n    webSocketAsync,\n};\n//# sourceMappingURL=rpc.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$viem$_cjs$utils$promise$createBatchScheduler","~$shadow.js","~$module$node_modules$viem$_cjs$utils$stringify","~$module$node_modules$viem$_cjs$utils$promise$withTimeout","~$module$node_modules$viem$_cjs$errors$request","~$module$node_modules$viem$node_modules$isomorphic_ws$browser"]],"~:properties",["^5",["url","onerror","body","webSocketAsync","method","__esModule","http","socketsCache","webSocket","id","fn","getSocket","signal","value","onResponse","status","timeout","onopen","rpc","details","jsonrpc","errorInstance","data","requests","subscriptions","headers"]],"~:compiled-at",1695111490286,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$viem$_cjs$utils$rpc.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/viem/_cjs/utils/rpc.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$viem$_cjs$utils$rpc\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.rpc = exports.getSocket = exports.socketsCache = void 0;\\nconst isomorphic_ws_1 = require(\\\"isomorphic-ws\\\");\\nconst request_js_1 = require(\\\"../errors/request.js\\\");\\nconst createBatchScheduler_js_1 = require(\\\"./promise/createBatchScheduler.js\\\");\\nconst withTimeout_js_1 = require(\\\"./promise/withTimeout.js\\\");\\nconst stringify_js_1 = require(\\\"./stringify.js\\\");\\nlet id = 0;\\nasync function http(url, { body, fetchOptions = {}, timeout = 10000 }) {\\n    const { headers, method, signal: signal_ } = fetchOptions;\\n    try {\\n        const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {\\n            const response = await fetch(url, {\\n                ...fetchOptions,\\n                body: Array.isArray(body)\\n                    ? (0, stringify_js_1.stringify)(body.map((body) => ({\\n                        jsonrpc: '2.0',\\n                        id: body.id ?? id++,\\n                        ...body,\\n                    })))\\n                    : (0, stringify_js_1.stringify)({ jsonrpc: '2.0', id: body.id ?? id++, ...body }),\\n                headers: {\\n                    ...headers,\\n                    'Content-Type': 'application/json',\\n                },\\n                method: method || 'POST',\\n                signal: signal_ || (timeout > 0 ? signal : undefined),\\n            });\\n            return response;\\n        }, {\\n            errorInstance: new request_js_1.TimeoutError({ body, url }),\\n            timeout,\\n            signal: true,\\n        });\\n        let data;\\n        if (response.headers.get('Content-Type')?.startsWith('application/json')) {\\n            data = await response.json();\\n        }\\n        else {\\n            data = await response.text();\\n        }\\n        if (!response.ok) {\\n            throw new request_js_1.HttpRequestError({\\n                body,\\n                details: (0, stringify_js_1.stringify)(data.error) || response.statusText,\\n                headers: response.headers,\\n                status: response.status,\\n                url,\\n            });\\n        }\\n        return data;\\n    }\\n    catch (err) {\\n        if (err instanceof request_js_1.HttpRequestError)\\n            throw err;\\n        if (err instanceof request_js_1.TimeoutError)\\n            throw err;\\n        throw new request_js_1.HttpRequestError({\\n            body,\\n            details: err.message,\\n            url,\\n        });\\n    }\\n}\\nexports.socketsCache = new Map();\\nasync function getSocket(url) {\\n    let socket = exports.socketsCache.get(url);\\n    if (socket)\\n        return socket;\\n    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({\\n        id: url,\\n        fn: async () => {\\n            let WebSocket_ = isomorphic_ws_1.default;\\n            if (!isomorphic_ws_1.default.constructor)\\n                WebSocket_ = isomorphic_ws_1.default.WebSocket;\\n            const webSocket = new WebSocket_(url);\\n            const requests = new Map();\\n            const subscriptions = new Map();\\n            const onMessage = ({ data }) => {\\n                const message = JSON.parse(data);\\n                const isSubscription = message.method === 'eth_subscription';\\n                const id = isSubscription ? message.params.subscription : message.id;\\n                const cache = isSubscription ? subscriptions : requests;\\n                const callback = cache.get(id);\\n                if (callback)\\n                    callback({ data });\\n                if (!isSubscription)\\n                    cache.delete(id);\\n            };\\n            const onClose = () => {\\n                exports.socketsCache.delete(url);\\n                webSocket.removeEventListener('close', onClose);\\n                webSocket.removeEventListener('message', onMessage);\\n            };\\n            webSocket.addEventListener('close', onClose);\\n            webSocket.addEventListener('message', onMessage);\\n            if (webSocket.readyState === isomorphic_ws_1.default.CONNECTING) {\\n                await new Promise((resolve, reject) => {\\n                    if (!webSocket)\\n                        return;\\n                    webSocket.onopen = resolve;\\n                    webSocket.onerror = reject;\\n                });\\n            }\\n            socket = Object.assign(webSocket, {\\n                requests,\\n                subscriptions,\\n            });\\n            exports.socketsCache.set(url, socket);\\n            return [socket];\\n        },\\n    });\\n    const [_, [socket_]] = await schedule();\\n    return socket_;\\n}\\nexports.getSocket = getSocket;\\nfunction webSocket(socket, { body, onResponse }) {\\n    if (socket.readyState === socket.CLOSED ||\\n        socket.readyState === socket.CLOSING)\\n        throw new request_js_1.WebSocketRequestError({\\n            body,\\n            url: socket.url,\\n            details: 'Socket is closed.',\\n        });\\n    const id_ = id++;\\n    const callback = ({ data }) => {\\n        const message = JSON.parse(data);\\n        if (typeof message.id === 'number' && id_ !== message.id)\\n            return;\\n        onResponse?.(message);\\n        if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\\n            socket.subscriptions.set(message.result, callback);\\n        }\\n        if (body.method === 'eth_unsubscribe') {\\n            socket.subscriptions.delete(body.params?.[0]);\\n        }\\n    };\\n    socket.requests.set(id_, callback);\\n    socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }));\\n    return socket;\\n}\\nasync function webSocketAsync(socket, { body, timeout = 10000 }) {\\n    return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse) => exports.rpc.webSocket(socket, {\\n        body,\\n        onResponse,\\n    })), {\\n        errorInstance: new request_js_1.TimeoutError({ body, url: socket.url }),\\n        timeout,\\n    });\\n}\\nexports.rpc = {\\n    http,\\n    webSocket,\\n    webSocketAsync,\\n};\\n//# sourceMappingURL=rpc.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"rpc\",\"getSocket\",\"socketsCache\",\"isomorphic_ws_1\",\"request_js_1\",\"createBatchScheduler_js_1\",\"withTimeout_js_1\",\"stringify_js_1\",\"id\",\"Map\",\"url\",\"socket\",\"get\",\"schedule\",\"createBatchScheduler\",\"fn\",\"WebSocket_\",\"default\",\"constructor\",\"WebSocket\",\"webSocket\",\"requests\",\"subscriptions\",\"onMessage\",\"data\",\"message\",\"JSON\",\"parse\",\"isSubscription\",\"method\",\"params\",\"subscription\",\"cache\",\"callback\",\"delete\",\"onClose\",\"removeEventListener\",\"addEventListener\",\"readyState\",\"CONNECTING\",\"Promise\",\"resolve\",\"reject\",\"onopen\",\"onerror\",\"assign\",\"set\",\"socket_\",\"http\",\"body\",\"fetchOptions\",\"timeout\",\"headers\",\"signal_\",\"response\",\"withTimeout\",\"signal\",\"fetch\",\"Array\",\"isArray\",\"stringify\",\"map\",\"jsonrpc\",\"undefined\",\"errorInstance\",\"TimeoutError\",\"startsWith\",\"json\",\"text\",\"ok\",\"HttpRequestError\",\"details\",\"error\",\"statusText\",\"status\",\"err\",\"onResponse\",\"CLOSED\",\"CLOSING\",\"WebSocketRequestError\",\"id_\",\"result\",\"send\",\"webSocketAsync\"]\n}\n"]