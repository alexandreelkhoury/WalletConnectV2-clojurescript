["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/readable-stream/lib/_stream_transform.js"],"~:js","shadow$provide[154]=function(S,A,V,q){function F(u,p){var n=this._transformState;n.transforming=!1;var l=n.writecb;if(!l)return this.emit(\"error\",Error(\"write callback called multiple times\"));n.writechunk=null;n.writecb=null;null!=p&&this.push(p);l(u);u=this._readableState;u.reading=!1;(u.needReadable||u.length<u.highWaterMark)&&this._read(u.highWaterMark)}function G(u){if(!(this instanceof G))return new G(u);e.call(this,u);this._transformState={afterTransform:F.bind(this),needTransform:!1,transforming:!1,\nwritecb:null,writechunk:null,writeencoding:null};this._readableState.needReadable=!0;this._readableState.sync=!1;u&&(\"function\"===typeof u.transform&&(this._transform=u.transform),\"function\"===typeof u.flush&&(this._flush=u.flush));this.on(\"prefinish\",r)}function r(){var u=this;\"function\"===typeof this._flush?this._flush(function(p,n){y(u,p,n)}):y(this,null,null)}function y(u,p,n){if(p)return u.emit(\"error\",p);null!=n&&u.push(n);if(u._writableState.length)throw Error(\"Calling transform done when ws.length !\\x3d 0\");\nif(u._transformState.transforming)throw Error(\"Calling transform done when still transforming\");return u.push(null)}V.exports=G;var e=A(151);S=Object.create(A(147));S.inherits=A(76);S.inherits(G,e);G.prototype.push=function(u,p){this._transformState.needTransform=!1;return e.prototype.push.call(this,u,p)};G.prototype._transform=function(u,p,n){throw Error(\"_transform() is not implemented\");};G.prototype._write=function(u,p,n){var l=this._transformState;l.writecb=n;l.writechunk=u;l.writeencoding=p;\nl.transforming||(u=this._readableState,(l.needTransform||u.needReadable||u.length<u.highWaterMark)&&this._read(u.highWaterMark))};G.prototype._read=function(u){u=this._transformState;null!==u.writechunk&&u.writecb&&!u.transforming?(u.transforming=!0,this._transform(u.writechunk,u.writeencoding,u.afterTransform)):u.needTransform=!0};G.prototype._destroy=function(u,p){var n=this;e.prototype._destroy.call(this,u,function(l){p(l);n.emit(\"close\")})}}","~:source","shadow$provide[154] = function(global,require,module,exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$inherits$inherits_browser","~$module$node_modules$readable_stream$lib$_stream_duplex","~$module$node_modules$util$util"]],"~:properties",["^5",["_destroy","writeencoding","reading","writecb","transforming","push","_transformState","writechunk","_read","_transform","sync","needTransform","_flush","inherits","needReadable","_write","afterTransform"]],"~:compiled-at",1695041440816,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$readable_stream$lib$_stream_transform.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/readable-stream/lib/_stream_transform.js\"],\n\"sourcesContent\":[\"shadow$provide[154] = function(global,require,module,exports) {\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// a transform stream is a readable/writable stream where you do\\n// something with the data.  Sometimes it's called a \\\"filter\\\",\\n// but that's not a great name for it, since that implies a thing where\\n// some bits pass through, and others are simply ignored.  (That would\\n// be a valid example of a transform, of course.)\\n//\\n// While the output is causally related to the input, it's not a\\n// necessarily symmetric or synchronous transformation.  For example,\\n// a zlib stream might take multiple plain-text writes(), and then\\n// emit a single compressed chunk some time in the future.\\n//\\n// Here's how this works:\\n//\\n// The Transform stream has all the aspects of the readable and writable\\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\\n// internally, and returns false if there's a lot of pending writes\\n// buffered up.  When you call read(), that calls _read(n) until\\n// there's enough pending readable data buffered up.\\n//\\n// In a transform stream, the written data is placed in a buffer.  When\\n// _read(n) is called, it transforms the queued up data, calling the\\n// buffered _write cb's as it consumes chunks.  If consuming a single\\n// written chunk would result in multiple output chunks, then the first\\n// outputted bit calls the readcb, and subsequent chunks just go into\\n// the read buffer, and will cause it to emit 'readable' if necessary.\\n//\\n// This way, back-pressure is actually determined by the reading side,\\n// since _read has to be called to start processing a new chunk.  However,\\n// a pathological inflate type of transform can cause excessive buffering\\n// here.  For example, imagine a stream where every byte of input is\\n// interpreted as an integer from 0-255, and then results in that many\\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\\n// 1kb of data being output.  In this case, you could write a very small\\n// amount of input, and end up with a very large amount of output.  In\\n// such a pathological inflating mechanism, there'd be no way to tell\\n// the system to stop doing the transform.  A single 4MB write could\\n// cause the system to run out of memory.\\n//\\n// However, even in such a pathological case, only a single written chunk\\n// would be consumed, and then the rest would wait (un-transformed) until\\n// the results of the previous transformed chunk were consumed.\\n\\n'use strict';\\n\\nmodule.exports = Transform;\\n\\nvar Duplex = require('./_stream_duplex');\\n\\n/*<replacement>*/\\nvar util = Object.create(require('core-util-is'));\\nutil.inherits = require('inherits');\\n/*</replacement>*/\\n\\nutil.inherits(Transform, Duplex);\\n\\nfunction afterTransform(er, data) {\\n  var ts = this._transformState;\\n  ts.transforming = false;\\n\\n  var cb = ts.writecb;\\n\\n  if (!cb) {\\n    return this.emit('error', new Error('write callback called multiple times'));\\n  }\\n\\n  ts.writechunk = null;\\n  ts.writecb = null;\\n\\n  if (data != null) // single equals check for both `null` and `undefined`\\n    this.push(data);\\n\\n  cb(er);\\n\\n  var rs = this._readableState;\\n  rs.reading = false;\\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\\n    this._read(rs.highWaterMark);\\n  }\\n}\\n\\nfunction Transform(options) {\\n  if (!(this instanceof Transform)) return new Transform(options);\\n\\n  Duplex.call(this, options);\\n\\n  this._transformState = {\\n    afterTransform: afterTransform.bind(this),\\n    needTransform: false,\\n    transforming: false,\\n    writecb: null,\\n    writechunk: null,\\n    writeencoding: null\\n  };\\n\\n  // start out asking for a readable event once data is transformed.\\n  this._readableState.needReadable = true;\\n\\n  // we have implemented the _read method, and done the other things\\n  // that Readable wants before the first _read call, so unset the\\n  // sync guard flag.\\n  this._readableState.sync = false;\\n\\n  if (options) {\\n    if (typeof options.transform === 'function') this._transform = options.transform;\\n\\n    if (typeof options.flush === 'function') this._flush = options.flush;\\n  }\\n\\n  // When the writable side finishes, then flush out anything remaining.\\n  this.on('prefinish', prefinish);\\n}\\n\\nfunction prefinish() {\\n  var _this = this;\\n\\n  if (typeof this._flush === 'function') {\\n    this._flush(function (er, data) {\\n      done(_this, er, data);\\n    });\\n  } else {\\n    done(this, null, null);\\n  }\\n}\\n\\nTransform.prototype.push = function (chunk, encoding) {\\n  this._transformState.needTransform = false;\\n  return Duplex.prototype.push.call(this, chunk, encoding);\\n};\\n\\n// This is the part where you do stuff!\\n// override this function in implementation classes.\\n// 'chunk' is an input chunk.\\n//\\n// Call `push(newChunk)` to pass along transformed output\\n// to the readable side.  You may call 'push' zero or more times.\\n//\\n// Call `cb(err)` when you are done with this chunk.  If you pass\\n// an error, then that'll put the hurt on the whole operation.  If you\\n// never call cb(), then you'll never get another chunk.\\nTransform.prototype._transform = function (chunk, encoding, cb) {\\n  throw new Error('_transform() is not implemented');\\n};\\n\\nTransform.prototype._write = function (chunk, encoding, cb) {\\n  var ts = this._transformState;\\n  ts.writecb = cb;\\n  ts.writechunk = chunk;\\n  ts.writeencoding = encoding;\\n  if (!ts.transforming) {\\n    var rs = this._readableState;\\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\\n  }\\n};\\n\\n// Doesn't matter what the args are here.\\n// _transform does all the work.\\n// That we got here means that the readable side wants more data.\\nTransform.prototype._read = function (n) {\\n  var ts = this._transformState;\\n\\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\\n    ts.transforming = true;\\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\\n  } else {\\n    // mark that we need a transform, so that any data that comes in\\n    // will get processed, now that we've asked for it.\\n    ts.needTransform = true;\\n  }\\n};\\n\\nTransform.prototype._destroy = function (err, cb) {\\n  var _this2 = this;\\n\\n  Duplex.prototype._destroy.call(this, err, function (err2) {\\n    cb(err2);\\n    _this2.emit('close');\\n  });\\n};\\n\\nfunction done(stream, er, data) {\\n  if (er) return stream.emit('error', er);\\n\\n  if (data != null) // single equals check for both `null` and `undefined`\\n    stream.push(data);\\n\\n  // if there's nothing in the write buffer, then that means\\n  // that nothing more will ever be provided\\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\\n\\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\\n\\n  return stream.push(null);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"afterTransform\",\"er\",\"data\",\"ts\",\"_transformState\",\"transforming\",\"cb\",\"writecb\",\"emit\",\"Error\",\"writechunk\",\"push\",\"rs\",\"_readableState\",\"reading\",\"needReadable\",\"length\",\"highWaterMark\",\"_read\",\"Transform\",\"options\",\"Duplex\",\"call\",\"bind\",\"needTransform\",\"writeencoding\",\"sync\",\"transform\",\"_transform\",\"flush\",\"_flush\",\"on\",\"prefinish\",\"_this\",\"done\",\"stream\",\"_writableState\",\"util\",\"Object\",\"create\",\"inherits\",\"prototype\",\"Transform.prototype.push\",\"chunk\",\"encoding\",\"Transform.prototype._transform\",\"_write\",\"Transform.prototype._write\",\"Transform.prototype._read\",\"n\",\"_destroy\",\"Transform.prototype._destroy\",\"err\",\"_this2\",\"err2\"]\n}\n"]