["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/browserify-zlib/lib/index.js"],"~:js","shadow$provide.module$node_modules$browserify_zlib$lib$index=function(global,require,module,exports){function zlibBuffer(engine,buffer,callback){function flow(){for(var chunk;null!==(chunk=engine.read());)buffers.push(chunk),nread+=chunk.length;engine.once(\"readable\",flow)}function onEnd(){var buf,err=null;nread>=kMaxLength?err=new RangeError(kRangeErrorMessage):buf=Buffer.concat(buffers,nread);buffers=[];engine.close();callback(err,buf)}var buffers=[],nread=0;engine.on(\"error\",function(err){engine.removeListener(\"end\",\nonEnd);engine.removeListener(\"readable\",flow);callback(err)});engine.on(\"end\",onEnd);engine.end(buffer);flow()}function zlibBufferSync(engine,buffer){\"string\"===typeof buffer&&(buffer=Buffer.from(buffer));if(!Buffer.isBuffer(buffer))throw new TypeError(\"Not a string or buffer\");return engine._processChunk(buffer,engine._finishFlushFlag)}function Deflate(opts){if(!(this instanceof Deflate))return new Deflate(opts);Zlib.call(this,opts,binding.DEFLATE)}function Inflate(opts){if(!(this instanceof Inflate))return new Inflate(opts);\nZlib.call(this,opts,binding.INFLATE)}function Gzip(opts){if(!(this instanceof Gzip))return new Gzip(opts);Zlib.call(this,opts,binding.GZIP)}function Gunzip(opts){if(!(this instanceof Gunzip))return new Gunzip(opts);Zlib.call(this,opts,binding.GUNZIP)}function DeflateRaw(opts){if(!(this instanceof DeflateRaw))return new DeflateRaw(opts);Zlib.call(this,opts,binding.DEFLATERAW)}function InflateRaw(opts){if(!(this instanceof InflateRaw))return new InflateRaw(opts);Zlib.call(this,opts,binding.INFLATERAW)}\nfunction Unzip(opts){if(!(this instanceof Unzip))return new Unzip(opts);Zlib.call(this,opts,binding.UNZIP)}function isValidFlushFlag(flag){return flag===binding.Z_NO_FLUSH||flag===binding.Z_PARTIAL_FLUSH||flag===binding.Z_SYNC_FLUSH||flag===binding.Z_FULL_FLUSH||flag===binding.Z_FINISH||flag===binding.Z_BLOCK}function Zlib(opts,mode){var _this=this;this._opts=opts=opts||{};this._chunkSize=opts.chunkSize||exports.Z_DEFAULT_CHUNK;Transform.call(this,opts);if(opts.flush&&!isValidFlushFlag(opts.flush))throw Error(\"Invalid flush flag: \"+\nopts.flush);if(opts.finishFlush&&!isValidFlushFlag(opts.finishFlush))throw Error(\"Invalid flush flag: \"+opts.finishFlush);this._flushFlag=opts.flush||binding.Z_NO_FLUSH;this._finishFlushFlag=\"undefined\"!==typeof opts.finishFlush?opts.finishFlush:binding.Z_FINISH;if(opts.chunkSize&&(opts.chunkSize<exports.Z_MIN_CHUNK||opts.chunkSize>exports.Z_MAX_CHUNK))throw Error(\"Invalid chunk size: \"+opts.chunkSize);if(opts.windowBits&&(opts.windowBits<exports.Z_MIN_WINDOWBITS||opts.windowBits>exports.Z_MAX_WINDOWBITS))throw Error(\"Invalid windowBits: \"+\nopts.windowBits);if(opts.level&&(opts.level<exports.Z_MIN_LEVEL||opts.level>exports.Z_MAX_LEVEL))throw Error(\"Invalid compression level: \"+opts.level);if(opts.memLevel&&(opts.memLevel<exports.Z_MIN_MEMLEVEL||opts.memLevel>exports.Z_MAX_MEMLEVEL))throw Error(\"Invalid memLevel: \"+opts.memLevel);if(opts.strategy&&opts.strategy!=exports.Z_FILTERED&&opts.strategy!=exports.Z_HUFFMAN_ONLY&&opts.strategy!=exports.Z_RLE&&opts.strategy!=exports.Z_FIXED&&opts.strategy!=exports.Z_DEFAULT_STRATEGY)throw Error(\"Invalid strategy: \"+\nopts.strategy);if(opts.dictionary&&!Buffer.isBuffer(opts.dictionary))throw Error(\"Invalid dictionary: it should be a Buffer instance\");this._handle=new binding.Zlib(mode);var self=this;this._hadError=!1;this._handle.onerror=function(message,errno){_close(self);self._hadError=!0;message=Error(message);message.errno=errno;message.code=exports.codes[errno];self.emit(\"error\",message)};mode=exports.Z_DEFAULT_COMPRESSION;\"number\"===typeof opts.level&&(mode=opts.level);var strategy=exports.Z_DEFAULT_STRATEGY;\n\"number\"===typeof opts.strategy&&(strategy=opts.strategy);this._handle.init(opts.windowBits||exports.Z_DEFAULT_WINDOWBITS,mode,opts.memLevel||exports.Z_DEFAULT_MEMLEVEL,strategy,opts.dictionary);this._buffer=Buffer.allocUnsafe(this._chunkSize);this._offset=0;this._level=mode;this._strategy=strategy;this.once(\"end\",this.close);Object.defineProperty(this,\"_closed\",{get:function(){return!_this._handle},configurable:!0,enumerable:!0})}function _close(engine,callback){callback&&process.nextTick(callback);\nengine._handle&&(engine._handle.close(),engine._handle=null)}function emitCloseNT(self){self.emit(\"close\")}var process=require(\"module$node_modules$process$browser\");\"use strict\";var Buffer=require(\"module$node_modules$buffer$index\").Buffer,Transform=require(\"module$node_modules$stream_browserify$index\").Transform,binding=require(\"module$node_modules$browserify_zlib$lib$binding\");global=require(\"module$node_modules$util$util\");var assert=require(\"module$node_modules$assert$assert\").ok,kMaxLength=\nrequire(\"module$node_modules$buffer$index\").kMaxLength,kRangeErrorMessage=\"Cannot create final Buffer. It would be larger than 0x\"+kMaxLength.toString(16)+\" bytes\";binding.Z_MIN_WINDOWBITS=8;binding.Z_MAX_WINDOWBITS=15;binding.Z_DEFAULT_WINDOWBITS=15;binding.Z_MIN_CHUNK=64;binding.Z_MAX_CHUNK=Infinity;binding.Z_DEFAULT_CHUNK=16384;binding.Z_MIN_MEMLEVEL=1;binding.Z_MAX_MEMLEVEL=9;binding.Z_DEFAULT_MEMLEVEL=8;binding.Z_MIN_LEVEL=-1;binding.Z_MAX_LEVEL=9;binding.Z_DEFAULT_LEVEL=binding.Z_DEFAULT_COMPRESSION;\nrequire=Object.keys(binding);for(module=0;module<require.length;module++){var bkey=require[module];bkey.match(/^Z/)&&Object.defineProperty(exports,bkey,{enumerable:!0,value:binding[bkey],writable:!1})}require={Z_OK:binding.Z_OK,Z_STREAM_END:binding.Z_STREAM_END,Z_NEED_DICT:binding.Z_NEED_DICT,Z_ERRNO:binding.Z_ERRNO,Z_STREAM_ERROR:binding.Z_STREAM_ERROR,Z_DATA_ERROR:binding.Z_DATA_ERROR,Z_MEM_ERROR:binding.Z_MEM_ERROR,Z_BUF_ERROR:binding.Z_BUF_ERROR,Z_VERSION_ERROR:binding.Z_VERSION_ERROR};module=\nObject.keys(require);for(bkey=0;bkey<module.length;bkey++){var ckey=module[bkey];require[require[ckey]]=ckey}Object.defineProperty(exports,\"codes\",{enumerable:!0,value:Object.freeze(require),writable:!1});exports.Deflate=Deflate;exports.Inflate=Inflate;exports.Gzip=Gzip;exports.Gunzip=Gunzip;exports.DeflateRaw=DeflateRaw;exports.InflateRaw=InflateRaw;exports.Unzip=Unzip;exports.createDeflate=function(o){return new Deflate(o)};exports.createInflate=function(o){return new Inflate(o)};exports.createDeflateRaw=\nfunction(o){return new DeflateRaw(o)};exports.createInflateRaw=function(o){return new InflateRaw(o)};exports.createGzip=function(o){return new Gzip(o)};exports.createGunzip=function(o){return new Gunzip(o)};exports.createUnzip=function(o){return new Unzip(o)};exports.deflate=function(buffer,opts,callback){\"function\"===typeof opts&&(callback=opts,opts={});return zlibBuffer(new Deflate(opts),buffer,callback)};exports.deflateSync=function(buffer,opts){return zlibBufferSync(new Deflate(opts),buffer)};\nexports.gzip=function(buffer,opts,callback){\"function\"===typeof opts&&(callback=opts,opts={});return zlibBuffer(new Gzip(opts),buffer,callback)};exports.gzipSync=function(buffer,opts){return zlibBufferSync(new Gzip(opts),buffer)};exports.deflateRaw=function(buffer,opts,callback){\"function\"===typeof opts&&(callback=opts,opts={});return zlibBuffer(new DeflateRaw(opts),buffer,callback)};exports.deflateRawSync=function(buffer,opts){return zlibBufferSync(new DeflateRaw(opts),buffer)};exports.unzip=function(buffer,\nopts,callback){\"function\"===typeof opts&&(callback=opts,opts={});return zlibBuffer(new Unzip(opts),buffer,callback)};exports.unzipSync=function(buffer,opts){return zlibBufferSync(new Unzip(opts),buffer)};exports.inflate=function(buffer,opts,callback){\"function\"===typeof opts&&(callback=opts,opts={});return zlibBuffer(new Inflate(opts),buffer,callback)};exports.inflateSync=function(buffer,opts){return zlibBufferSync(new Inflate(opts),buffer)};exports.gunzip=function(buffer,opts,callback){\"function\"===\ntypeof opts&&(callback=opts,opts={});return zlibBuffer(new Gunzip(opts),buffer,callback)};exports.gunzipSync=function(buffer,opts){return zlibBufferSync(new Gunzip(opts),buffer)};exports.inflateRaw=function(buffer,opts,callback){\"function\"===typeof opts&&(callback=opts,opts={});return zlibBuffer(new InflateRaw(opts),buffer,callback)};exports.inflateRawSync=function(buffer,opts){return zlibBufferSync(new InflateRaw(opts),buffer)};global.inherits(Zlib,Transform);Zlib.prototype.params=function(level,\nstrategy,callback){if(level<exports.Z_MIN_LEVEL||level>exports.Z_MAX_LEVEL)throw new RangeError(\"Invalid compression level: \"+level);if(strategy!=exports.Z_FILTERED&&strategy!=exports.Z_HUFFMAN_ONLY&&strategy!=exports.Z_RLE&&strategy!=exports.Z_FIXED&&strategy!=exports.Z_DEFAULT_STRATEGY)throw new TypeError(\"Invalid strategy: \"+strategy);if(this._level!==level||this._strategy!==strategy){var self=this;this.flush(binding.Z_SYNC_FLUSH,function(){assert(self._handle,\"zlib binding closed\");self._handle.params(level,\nstrategy);self._hadError||(self._level=level,self._strategy=strategy,callback&&callback())})}else process.nextTick(callback)};Zlib.prototype.reset=function(){assert(this._handle,\"zlib binding closed\");return this._handle.reset()};Zlib.prototype._flush=function(callback){this._transform(Buffer.alloc(0),\"\",callback)};Zlib.prototype.flush=function(kind,callback){var _this2=this,ws=this._writableState;if(\"function\"===typeof kind||void 0===kind&&!callback)callback=kind,kind=binding.Z_FULL_FLUSH;if(ws.ended)callback&&\nprocess.nextTick(callback);else if(ws.ending){if(callback)this.once(\"end\",callback)}else if(ws.needDrain){if(callback)this.once(\"drain\",function(){return _this2.flush(kind,callback)})}else this._flushFlag=kind,this.write(Buffer.alloc(0),\"\",callback)};Zlib.prototype.close=function(callback){_close(this,callback);process.nextTick(emitCloseNT,this)};Zlib.prototype._transform=function(chunk,encoding,cb){encoding=this._writableState;var flushFlag=(encoding.ending||encoding.ended)&&(!chunk||encoding.length===\nchunk.length);if(null!==chunk&&!Buffer.isBuffer(chunk))return cb(Error(\"invalid input\"));if(!this._handle)return cb(Error(\"zlib binding closed\"));flushFlag?flushFlag=this._finishFlushFlag:(flushFlag=this._flushFlag,chunk.length>=encoding.length&&(this._flushFlag=this._opts.flush||binding.Z_NO_FLUSH));this._processChunk(chunk,flushFlag,cb)};Zlib.prototype._processChunk=function(chunk,flushFlag,cb){function callback(availInAfter,availOutAfter){this&&(this.callback=this.buffer=null);if(!self._hadError){var have=\navailOutBefore-availOutAfter;assert(0<=have,\"have should not go down\");if(0<have){var out=self._buffer.slice(self._offset,self._offset+have);self._offset+=have;async?self.push(out):(buffers.push(out),nread+=out.length)}if(0===availOutAfter||self._offset>=self._chunkSize)availOutBefore=self._chunkSize,self._offset=0,self._buffer=Buffer.allocUnsafe(self._chunkSize);if(0===availOutAfter){inOff+=availInBefore-availInAfter;availInBefore=availInAfter;if(!async)return!0;availInAfter=self._handle.write(flushFlag,\nchunk,inOff,availInBefore,self._buffer,self._offset,self._chunkSize);availInAfter.callback=callback;availInAfter.buffer=chunk}else{if(!async)return!1;cb()}}}var availInBefore=chunk&&chunk.length,availOutBefore=this._chunkSize-this._offset,inOff=0,self=this,async=\"function\"===typeof cb;if(!async){var buffers=[],nread=0,error;this.on(\"error\",function(er){error=er});assert(this._handle,\"zlib binding closed\");do var res=this._handle.writeSync(flushFlag,chunk,inOff,availInBefore,this._buffer,this._offset,\navailOutBefore);while(!this._hadError&&callback(res[0],res[1]));if(this._hadError)throw error;if(nread>=kMaxLength)throw _close(this),new RangeError(kRangeErrorMessage);res=Buffer.concat(buffers,nread);_close(this);return res}assert(this._handle,\"zlib binding closed\");res=this._handle.write(flushFlag,chunk,inOff,availInBefore,this._buffer,this._offset,availOutBefore);res.buffer=chunk;res.callback=callback};global.inherits(Deflate,Zlib);global.inherits(Inflate,Zlib);global.inherits(Gzip,Zlib);global.inherits(Gunzip,\nZlib);global.inherits(DeflateRaw,Zlib);global.inherits(InflateRaw,Zlib);global.inherits(Unzip,Zlib)}","~:source","shadow$provide[\"module$node_modules$browserify_zlib$lib$index\"] = function(global,require,module,exports) {\nvar process = require('process');\n'use strict';\n\nvar Buffer = require('buffer').Buffer;\nvar Transform = require('stream').Transform;\nvar binding = require('./binding');\nvar util = require('util');\nvar assert = require('assert').ok;\nvar kMaxLength = require('buffer').kMaxLength;\nvar kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = 16 * 1024;\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nvar bkeys = Object.keys(binding);\nfor (var bk = 0; bk < bkeys.length; bk++) {\n  var bkey = bkeys[bk];\n  if (bkey.match(/^Z/)) {\n    Object.defineProperty(exports, bkey, {\n      enumerable: true, value: binding[bkey], writable: false\n    });\n  }\n}\n\n// translation table for return codes.\nvar codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nvar ckeys = Object.keys(codes);\nfor (var ck = 0; ck < ckeys.length; ck++) {\n  var ckey = ckeys[ck];\n  codes[codes[ckey]] = ckey;\n}\n\nObject.defineProperty(exports, 'codes', {\n  enumerable: true, value: Object.freeze(codes), writable: false\n});\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function (o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function (o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function (o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function (o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function (o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function (o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function (o) {\n  return new Unzip(o);\n};\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf;\n    var err = null;\n\n    if (nread >= kMaxLength) {\n      err = new RangeError(kRangeErrorMessage);\n    } else {\n      buf = Buffer.concat(buffers, nread);\n    }\n\n    buffers = [];\n    engine.close();\n    callback(err, buf);\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer);\n\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\n\n  var flushFlag = engine._finishFlushFlag;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\nfunction isValidFlushFlag(flag) {\n  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  var _this = this;\n\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush && !isValidFlushFlag(opts.flush)) {\n    throw new Error('Invalid flush flag: ' + opts.flush);\n  }\n  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n    throw new Error('Invalid flush flag: ' + opts.finishFlush);\n  }\n\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._handle = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._handle.onerror = function (message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    _close(self);\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\n\n  this._buffer = Buffer.allocUnsafe(this._chunkSize);\n  this._offset = 0;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n\n  Object.defineProperty(this, '_closed', {\n    get: function () {\n      return !_this._handle;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function (level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function () {\n      assert(self._handle, 'zlib binding closed');\n      self._handle.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function () {\n  assert(this._handle, 'zlib binding closed');\n  return this._handle.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function (callback) {\n  this._transform(Buffer.alloc(0), '', callback);\n};\n\nZlib.prototype.flush = function (kind, callback) {\n  var _this2 = this;\n\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || kind === undefined && !callback) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback) process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback) this.once('end', callback);\n  } else if (ws.needDrain) {\n    if (callback) {\n      this.once('drain', function () {\n        return _this2.flush(kind, callback);\n      });\n    }\n  } else {\n    this._flushFlag = kind;\n    this.write(Buffer.alloc(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function (callback) {\n  _close(this, callback);\n  process.nextTick(emitCloseNT, this);\n};\n\nfunction _close(engine, callback) {\n  if (callback) process.nextTick(callback);\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) return;\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nfunction emitCloseNT(self) {\n  self.emit('close');\n}\n\nZlib.prototype._transform = function (chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));\n\n  if (!this._handle) return cb(new Error('zlib binding closed'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\n  // (or whatever flag was provided using opts.finishFlush).\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last) flushFlag = this._finishFlushFlag;else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function (er) {\n      error = er;\n    });\n\n    assert(this._handle, 'zlib binding closed');\n    do {\n      var res = this._handle.writeSync(flushFlag, chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    if (nread >= kMaxLength) {\n      _close(this);\n      throw new RangeError(kRangeErrorMessage);\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    _close(this);\n\n    return buf;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n  var req = this._handle.write(flushFlag, chunk, // in\n  inOff, // in_off\n  availInBefore, // in_len\n  this._buffer, // out\n  this._offset, //out_off\n  availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    // When the callback is used in an async write, the callback's\n    // context is the `req` object that was created. The req object\n    // is === this._handle, and that's why it's important to null\n    // out the values after they are done being used. `this._handle`\n    // can stay in memory longer than the callback and buffer are needed.\n    if (this) {\n      this.buffer = null;\n      this.callback = null;\n    }\n\n    if (self._hadError) return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n\n      if (!async) return true;\n\n      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async) return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$process$browser","~$module$node_modules$browserify_zlib$lib$binding","~$shadow.js","~$module$node_modules$assert$assert","~$module$node_modules$stream_browserify$index","~$module$node_modules$util$util","~$module$node_modules$buffer$index"]],"~:properties",["^5",["callback","Deflate","_handle","Z_MIN_CHUNK","createGzip","_buffer","onerror","Z_MIN_MEMLEVEL","params","Z_BUF_ERROR","Z_DEFAULT_MEMLEVEL","_hadError","inflate","Z_MAX_MEMLEVEL","codes","Gunzip","_flushFlag","errno","deflateRaw","Z_MIN_WINDOWBITS","gzipSync","gzip","createDeflate","flush","DeflateRaw","inflateSync","reset","createUnzip","_offset","_level","Z_NEED_DICT","Z_OK","Z_DEFAULT_WINDOWBITS","_transform","Z_DEFAULT_LEVEL","buffer","Z_MAX_LEVEL","configurable","Z_MAX_WINDOWBITS","value","gunzipSync","Unzip","enumerable","Z_MEM_ERROR","Z_VERSION_ERROR","Z_STREAM_ERROR","_flush","writable","InflateRaw","Inflate","_processChunk","Z_DEFAULT_CHUNK","unzipSync","createInflate","createInflateRaw","Z_DATA_ERROR","close","gunzip","inflateRaw","_opts","unzip","Z_MIN_LEVEL","_strategy","_finishFlushFlag","deflate","_closed","Z_MAX_CHUNK","deflateRawSync","createGunzip","Z_STREAM_END","deflateSync","get","inflateRawSync","code","Gzip","Z_ERRNO","_chunkSize","createDeflateRaw"]],"~:compiled-at",1695040653765,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$browserify_zlib$lib$index.js\",\n\"lineCount\":24,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/browserify-zlib/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$browserify_zlib$lib$index\\\"] = function(global,require,module,exports) {\\nvar process = require('process');\\n'use strict';\\n\\nvar Buffer = require('buffer').Buffer;\\nvar Transform = require('stream').Transform;\\nvar binding = require('./binding');\\nvar util = require('util');\\nvar assert = require('assert').ok;\\nvar kMaxLength = require('buffer').kMaxLength;\\nvar kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';\\n\\n// zlib doesn't provide these, so kludge them in following the same\\n// const naming scheme zlib uses.\\nbinding.Z_MIN_WINDOWBITS = 8;\\nbinding.Z_MAX_WINDOWBITS = 15;\\nbinding.Z_DEFAULT_WINDOWBITS = 15;\\n\\n// fewer than 64 bytes per chunk is stupid.\\n// technically it could work with as few as 8, but even 64 bytes\\n// is absurdly low.  Usually a MB or more is best.\\nbinding.Z_MIN_CHUNK = 64;\\nbinding.Z_MAX_CHUNK = Infinity;\\nbinding.Z_DEFAULT_CHUNK = 16 * 1024;\\n\\nbinding.Z_MIN_MEMLEVEL = 1;\\nbinding.Z_MAX_MEMLEVEL = 9;\\nbinding.Z_DEFAULT_MEMLEVEL = 8;\\n\\nbinding.Z_MIN_LEVEL = -1;\\nbinding.Z_MAX_LEVEL = 9;\\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\\n\\n// expose all the zlib constants\\nvar bkeys = Object.keys(binding);\\nfor (var bk = 0; bk < bkeys.length; bk++) {\\n  var bkey = bkeys[bk];\\n  if (bkey.match(/^Z/)) {\\n    Object.defineProperty(exports, bkey, {\\n      enumerable: true, value: binding[bkey], writable: false\\n    });\\n  }\\n}\\n\\n// translation table for return codes.\\nvar codes = {\\n  Z_OK: binding.Z_OK,\\n  Z_STREAM_END: binding.Z_STREAM_END,\\n  Z_NEED_DICT: binding.Z_NEED_DICT,\\n  Z_ERRNO: binding.Z_ERRNO,\\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\\n};\\n\\nvar ckeys = Object.keys(codes);\\nfor (var ck = 0; ck < ckeys.length; ck++) {\\n  var ckey = ckeys[ck];\\n  codes[codes[ckey]] = ckey;\\n}\\n\\nObject.defineProperty(exports, 'codes', {\\n  enumerable: true, value: Object.freeze(codes), writable: false\\n});\\n\\nexports.Deflate = Deflate;\\nexports.Inflate = Inflate;\\nexports.Gzip = Gzip;\\nexports.Gunzip = Gunzip;\\nexports.DeflateRaw = DeflateRaw;\\nexports.InflateRaw = InflateRaw;\\nexports.Unzip = Unzip;\\n\\nexports.createDeflate = function (o) {\\n  return new Deflate(o);\\n};\\n\\nexports.createInflate = function (o) {\\n  return new Inflate(o);\\n};\\n\\nexports.createDeflateRaw = function (o) {\\n  return new DeflateRaw(o);\\n};\\n\\nexports.createInflateRaw = function (o) {\\n  return new InflateRaw(o);\\n};\\n\\nexports.createGzip = function (o) {\\n  return new Gzip(o);\\n};\\n\\nexports.createGunzip = function (o) {\\n  return new Gunzip(o);\\n};\\n\\nexports.createUnzip = function (o) {\\n  return new Unzip(o);\\n};\\n\\n// Convenience methods.\\n// compress/decompress a string or buffer in one step.\\nexports.deflate = function (buffer, opts, callback) {\\n  if (typeof opts === 'function') {\\n    callback = opts;\\n    opts = {};\\n  }\\n  return zlibBuffer(new Deflate(opts), buffer, callback);\\n};\\n\\nexports.deflateSync = function (buffer, opts) {\\n  return zlibBufferSync(new Deflate(opts), buffer);\\n};\\n\\nexports.gzip = function (buffer, opts, callback) {\\n  if (typeof opts === 'function') {\\n    callback = opts;\\n    opts = {};\\n  }\\n  return zlibBuffer(new Gzip(opts), buffer, callback);\\n};\\n\\nexports.gzipSync = function (buffer, opts) {\\n  return zlibBufferSync(new Gzip(opts), buffer);\\n};\\n\\nexports.deflateRaw = function (buffer, opts, callback) {\\n  if (typeof opts === 'function') {\\n    callback = opts;\\n    opts = {};\\n  }\\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\\n};\\n\\nexports.deflateRawSync = function (buffer, opts) {\\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\\n};\\n\\nexports.unzip = function (buffer, opts, callback) {\\n  if (typeof opts === 'function') {\\n    callback = opts;\\n    opts = {};\\n  }\\n  return zlibBuffer(new Unzip(opts), buffer, callback);\\n};\\n\\nexports.unzipSync = function (buffer, opts) {\\n  return zlibBufferSync(new Unzip(opts), buffer);\\n};\\n\\nexports.inflate = function (buffer, opts, callback) {\\n  if (typeof opts === 'function') {\\n    callback = opts;\\n    opts = {};\\n  }\\n  return zlibBuffer(new Inflate(opts), buffer, callback);\\n};\\n\\nexports.inflateSync = function (buffer, opts) {\\n  return zlibBufferSync(new Inflate(opts), buffer);\\n};\\n\\nexports.gunzip = function (buffer, opts, callback) {\\n  if (typeof opts === 'function') {\\n    callback = opts;\\n    opts = {};\\n  }\\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\\n};\\n\\nexports.gunzipSync = function (buffer, opts) {\\n  return zlibBufferSync(new Gunzip(opts), buffer);\\n};\\n\\nexports.inflateRaw = function (buffer, opts, callback) {\\n  if (typeof opts === 'function') {\\n    callback = opts;\\n    opts = {};\\n  }\\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\\n};\\n\\nexports.inflateRawSync = function (buffer, opts) {\\n  return zlibBufferSync(new InflateRaw(opts), buffer);\\n};\\n\\nfunction zlibBuffer(engine, buffer, callback) {\\n  var buffers = [];\\n  var nread = 0;\\n\\n  engine.on('error', onError);\\n  engine.on('end', onEnd);\\n\\n  engine.end(buffer);\\n  flow();\\n\\n  function flow() {\\n    var chunk;\\n    while (null !== (chunk = engine.read())) {\\n      buffers.push(chunk);\\n      nread += chunk.length;\\n    }\\n    engine.once('readable', flow);\\n  }\\n\\n  function onError(err) {\\n    engine.removeListener('end', onEnd);\\n    engine.removeListener('readable', flow);\\n    callback(err);\\n  }\\n\\n  function onEnd() {\\n    var buf;\\n    var err = null;\\n\\n    if (nread >= kMaxLength) {\\n      err = new RangeError(kRangeErrorMessage);\\n    } else {\\n      buf = Buffer.concat(buffers, nread);\\n    }\\n\\n    buffers = [];\\n    engine.close();\\n    callback(err, buf);\\n  }\\n}\\n\\nfunction zlibBufferSync(engine, buffer) {\\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer);\\n\\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\\n\\n  var flushFlag = engine._finishFlushFlag;\\n\\n  return engine._processChunk(buffer, flushFlag);\\n}\\n\\n// generic zlib\\n// minimal 2-byte header\\nfunction Deflate(opts) {\\n  if (!(this instanceof Deflate)) return new Deflate(opts);\\n  Zlib.call(this, opts, binding.DEFLATE);\\n}\\n\\nfunction Inflate(opts) {\\n  if (!(this instanceof Inflate)) return new Inflate(opts);\\n  Zlib.call(this, opts, binding.INFLATE);\\n}\\n\\n// gzip - bigger header, same deflate compression\\nfunction Gzip(opts) {\\n  if (!(this instanceof Gzip)) return new Gzip(opts);\\n  Zlib.call(this, opts, binding.GZIP);\\n}\\n\\nfunction Gunzip(opts) {\\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\\n  Zlib.call(this, opts, binding.GUNZIP);\\n}\\n\\n// raw - no header\\nfunction DeflateRaw(opts) {\\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\\n  Zlib.call(this, opts, binding.DEFLATERAW);\\n}\\n\\nfunction InflateRaw(opts) {\\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\\n  Zlib.call(this, opts, binding.INFLATERAW);\\n}\\n\\n// auto-detect header.\\nfunction Unzip(opts) {\\n  if (!(this instanceof Unzip)) return new Unzip(opts);\\n  Zlib.call(this, opts, binding.UNZIP);\\n}\\n\\nfunction isValidFlushFlag(flag) {\\n  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\\n}\\n\\n// the Zlib class they all inherit from\\n// This thing manages the queue of requests, and returns\\n// true or false if there is anything in the queue when\\n// you call the .write() method.\\n\\nfunction Zlib(opts, mode) {\\n  var _this = this;\\n\\n  this._opts = opts = opts || {};\\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\\n\\n  Transform.call(this, opts);\\n\\n  if (opts.flush && !isValidFlushFlag(opts.flush)) {\\n    throw new Error('Invalid flush flag: ' + opts.flush);\\n  }\\n  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\\n    throw new Error('Invalid flush flag: ' + opts.finishFlush);\\n  }\\n\\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\\n  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;\\n\\n  if (opts.chunkSize) {\\n    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\\n    }\\n  }\\n\\n  if (opts.windowBits) {\\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\\n    }\\n  }\\n\\n  if (opts.level) {\\n    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\\n      throw new Error('Invalid compression level: ' + opts.level);\\n    }\\n  }\\n\\n  if (opts.memLevel) {\\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\\n    }\\n  }\\n\\n  if (opts.strategy) {\\n    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {\\n      throw new Error('Invalid strategy: ' + opts.strategy);\\n    }\\n  }\\n\\n  if (opts.dictionary) {\\n    if (!Buffer.isBuffer(opts.dictionary)) {\\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\\n    }\\n  }\\n\\n  this._handle = new binding.Zlib(mode);\\n\\n  var self = this;\\n  this._hadError = false;\\n  this._handle.onerror = function (message, errno) {\\n    // there is no way to cleanly recover.\\n    // continuing only obscures problems.\\n    _close(self);\\n    self._hadError = true;\\n\\n    var error = new Error(message);\\n    error.errno = errno;\\n    error.code = exports.codes[errno];\\n    self.emit('error', error);\\n  };\\n\\n  var level = exports.Z_DEFAULT_COMPRESSION;\\n  if (typeof opts.level === 'number') level = opts.level;\\n\\n  var strategy = exports.Z_DEFAULT_STRATEGY;\\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\\n\\n  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\\n\\n  this._buffer = Buffer.allocUnsafe(this._chunkSize);\\n  this._offset = 0;\\n  this._level = level;\\n  this._strategy = strategy;\\n\\n  this.once('end', this.close);\\n\\n  Object.defineProperty(this, '_closed', {\\n    get: function () {\\n      return !_this._handle;\\n    },\\n    configurable: true,\\n    enumerable: true\\n  });\\n}\\n\\nutil.inherits(Zlib, Transform);\\n\\nZlib.prototype.params = function (level, strategy, callback) {\\n  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\\n    throw new RangeError('Invalid compression level: ' + level);\\n  }\\n  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {\\n    throw new TypeError('Invalid strategy: ' + strategy);\\n  }\\n\\n  if (this._level !== level || this._strategy !== strategy) {\\n    var self = this;\\n    this.flush(binding.Z_SYNC_FLUSH, function () {\\n      assert(self._handle, 'zlib binding closed');\\n      self._handle.params(level, strategy);\\n      if (!self._hadError) {\\n        self._level = level;\\n        self._strategy = strategy;\\n        if (callback) callback();\\n      }\\n    });\\n  } else {\\n    process.nextTick(callback);\\n  }\\n};\\n\\nZlib.prototype.reset = function () {\\n  assert(this._handle, 'zlib binding closed');\\n  return this._handle.reset();\\n};\\n\\n// This is the _flush function called by the transform class,\\n// internally, when the last chunk has been written.\\nZlib.prototype._flush = function (callback) {\\n  this._transform(Buffer.alloc(0), '', callback);\\n};\\n\\nZlib.prototype.flush = function (kind, callback) {\\n  var _this2 = this;\\n\\n  var ws = this._writableState;\\n\\n  if (typeof kind === 'function' || kind === undefined && !callback) {\\n    callback = kind;\\n    kind = binding.Z_FULL_FLUSH;\\n  }\\n\\n  if (ws.ended) {\\n    if (callback) process.nextTick(callback);\\n  } else if (ws.ending) {\\n    if (callback) this.once('end', callback);\\n  } else if (ws.needDrain) {\\n    if (callback) {\\n      this.once('drain', function () {\\n        return _this2.flush(kind, callback);\\n      });\\n    }\\n  } else {\\n    this._flushFlag = kind;\\n    this.write(Buffer.alloc(0), '', callback);\\n  }\\n};\\n\\nZlib.prototype.close = function (callback) {\\n  _close(this, callback);\\n  process.nextTick(emitCloseNT, this);\\n};\\n\\nfunction _close(engine, callback) {\\n  if (callback) process.nextTick(callback);\\n\\n  // Caller may invoke .close after a zlib error (which will null _handle).\\n  if (!engine._handle) return;\\n\\n  engine._handle.close();\\n  engine._handle = null;\\n}\\n\\nfunction emitCloseNT(self) {\\n  self.emit('close');\\n}\\n\\nZlib.prototype._transform = function (chunk, encoding, cb) {\\n  var flushFlag;\\n  var ws = this._writableState;\\n  var ending = ws.ending || ws.ended;\\n  var last = ending && (!chunk || ws.length === chunk.length);\\n\\n  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));\\n\\n  if (!this._handle) return cb(new Error('zlib binding closed'));\\n\\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\\n  // (or whatever flag was provided using opts.finishFlush).\\n  // If it's explicitly flushing at some other time, then we use\\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\\n  // goodness.\\n  if (last) flushFlag = this._finishFlushFlag;else {\\n    flushFlag = this._flushFlag;\\n    // once we've flushed the last of the queue, stop flushing and\\n    // go back to the normal behavior.\\n    if (chunk.length >= ws.length) {\\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\\n    }\\n  }\\n\\n  this._processChunk(chunk, flushFlag, cb);\\n};\\n\\nZlib.prototype._processChunk = function (chunk, flushFlag, cb) {\\n  var availInBefore = chunk && chunk.length;\\n  var availOutBefore = this._chunkSize - this._offset;\\n  var inOff = 0;\\n\\n  var self = this;\\n\\n  var async = typeof cb === 'function';\\n\\n  if (!async) {\\n    var buffers = [];\\n    var nread = 0;\\n\\n    var error;\\n    this.on('error', function (er) {\\n      error = er;\\n    });\\n\\n    assert(this._handle, 'zlib binding closed');\\n    do {\\n      var res = this._handle.writeSync(flushFlag, chunk, // in\\n      inOff, // in_off\\n      availInBefore, // in_len\\n      this._buffer, // out\\n      this._offset, //out_off\\n      availOutBefore); // out_len\\n    } while (!this._hadError && callback(res[0], res[1]));\\n\\n    if (this._hadError) {\\n      throw error;\\n    }\\n\\n    if (nread >= kMaxLength) {\\n      _close(this);\\n      throw new RangeError(kRangeErrorMessage);\\n    }\\n\\n    var buf = Buffer.concat(buffers, nread);\\n    _close(this);\\n\\n    return buf;\\n  }\\n\\n  assert(this._handle, 'zlib binding closed');\\n  var req = this._handle.write(flushFlag, chunk, // in\\n  inOff, // in_off\\n  availInBefore, // in_len\\n  this._buffer, // out\\n  this._offset, //out_off\\n  availOutBefore); // out_len\\n\\n  req.buffer = chunk;\\n  req.callback = callback;\\n\\n  function callback(availInAfter, availOutAfter) {\\n    // When the callback is used in an async write, the callback's\\n    // context is the `req` object that was created. The req object\\n    // is === this._handle, and that's why it's important to null\\n    // out the values after they are done being used. `this._handle`\\n    // can stay in memory longer than the callback and buffer are needed.\\n    if (this) {\\n      this.buffer = null;\\n      this.callback = null;\\n    }\\n\\n    if (self._hadError) return;\\n\\n    var have = availOutBefore - availOutAfter;\\n    assert(have >= 0, 'have should not go down');\\n\\n    if (have > 0) {\\n      var out = self._buffer.slice(self._offset, self._offset + have);\\n      self._offset += have;\\n      // serve some output to the consumer.\\n      if (async) {\\n        self.push(out);\\n      } else {\\n        buffers.push(out);\\n        nread += out.length;\\n      }\\n    }\\n\\n    // exhausted the output buffer, or used all the input create a new one.\\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\\n      availOutBefore = self._chunkSize;\\n      self._offset = 0;\\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\\n    }\\n\\n    if (availOutAfter === 0) {\\n      // Not actually done.  Need to reprocess.\\n      // Also, update the availInBefore to the availInAfter value,\\n      // so that if we have to hit it a third (fourth, etc.) time,\\n      // it'll have the correct byte counts.\\n      inOff += availInBefore - availInAfter;\\n      availInBefore = availInAfter;\\n\\n      if (!async) return true;\\n\\n      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\\n      newReq.callback = callback; // this same function\\n      newReq.buffer = chunk;\\n      return;\\n    }\\n\\n    if (!async) return false;\\n\\n    // finished with the chunk.\\n    cb();\\n  }\\n};\\n\\nutil.inherits(Deflate, Zlib);\\nutil.inherits(Inflate, Zlib);\\nutil.inherits(Gzip, Zlib);\\nutil.inherits(Gunzip, Zlib);\\nutil.inherits(DeflateRaw, Zlib);\\nutil.inherits(InflateRaw, Zlib);\\nutil.inherits(Unzip, Zlib);\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"zlibBuffer\",\"engine\",\"buffer\",\"callback\",\"flow\",\"chunk\",\"read\",\"buffers\",\"push\",\"nread\",\"length\",\"once\",\"onEnd\",\"buf\",\"err\",\"kMaxLength\",\"RangeError\",\"kRangeErrorMessage\",\"Buffer\",\"concat\",\"close\",\"on\",\"onError\",\"removeListener\",\"end\",\"zlibBufferSync\",\"from\",\"isBuffer\",\"TypeError\",\"_processChunk\",\"_finishFlushFlag\",\"Deflate\",\"opts\",\"Zlib\",\"call\",\"binding\",\"DEFLATE\",\"Inflate\",\"INFLATE\",\"Gzip\",\"GZIP\",\"Gunzip\",\"GUNZIP\",\"DeflateRaw\",\"DEFLATERAW\",\"InflateRaw\",\"INFLATERAW\",\"Unzip\",\"UNZIP\",\"isValidFlushFlag\",\"flag\",\"Z_NO_FLUSH\",\"Z_PARTIAL_FLUSH\",\"Z_SYNC_FLUSH\",\"Z_FULL_FLUSH\",\"Z_FINISH\",\"Z_BLOCK\",\"mode\",\"_this\",\"_opts\",\"_chunkSize\",\"chunkSize\",\"Z_DEFAULT_CHUNK\",\"Transform\",\"flush\",\"Error\",\"finishFlush\",\"_flushFlag\",\"Z_MIN_CHUNK\",\"Z_MAX_CHUNK\",\"windowBits\",\"Z_MIN_WINDOWBITS\",\"Z_MAX_WINDOWBITS\",\"level\",\"Z_MIN_LEVEL\",\"Z_MAX_LEVEL\",\"memLevel\",\"Z_MIN_MEMLEVEL\",\"Z_MAX_MEMLEVEL\",\"strategy\",\"Z_FILTERED\",\"Z_HUFFMAN_ONLY\",\"Z_RLE\",\"Z_FIXED\",\"Z_DEFAULT_STRATEGY\",\"dictionary\",\"_handle\",\"self\",\"_hadError\",\"onerror\",\"this._handle.onerror\",\"message\",\"errno\",\"_close\",\"error\",\"code\",\"codes\",\"emit\",\"Z_DEFAULT_COMPRESSION\",\"init\",\"Z_DEFAULT_WINDOWBITS\",\"Z_DEFAULT_MEMLEVEL\",\"_buffer\",\"allocUnsafe\",\"_offset\",\"_level\",\"_strategy\",\"Object\",\"defineProperty\",\"get\",\"configurable\",\"enumerable\",\"process\",\"nextTick\",\"emitCloseNT\",\"util\",\"assert\",\"ok\",\"toString\",\"Infinity\",\"Z_DEFAULT_LEVEL\",\"bkeys\",\"keys\",\"bk\",\"bkey\",\"match\",\"value\",\"writable\",\"Z_OK\",\"Z_STREAM_END\",\"Z_NEED_DICT\",\"Z_ERRNO\",\"Z_STREAM_ERROR\",\"Z_DATA_ERROR\",\"Z_MEM_ERROR\",\"Z_BUF_ERROR\",\"Z_VERSION_ERROR\",\"ckeys\",\"ck\",\"ckey\",\"freeze\",\"createDeflate\",\"exports.createDeflate\",\"o\",\"createInflate\",\"exports.createInflate\",\"createDeflateRaw\",\"exports.createDeflateRaw\",\"createInflateRaw\",\"exports.createInflateRaw\",\"createGzip\",\"exports.createGzip\",\"createGunzip\",\"exports.createGunzip\",\"createUnzip\",\"exports.createUnzip\",\"deflate\",\"exports.deflate\",\"deflateSync\",\"exports.deflateSync\",\"gzip\",\"exports.gzip\",\"gzipSync\",\"exports.gzipSync\",\"deflateRaw\",\"exports.deflateRaw\",\"deflateRawSync\",\"exports.deflateRawSync\",\"unzip\",\"exports.unzip\",\"unzipSync\",\"exports.unzipSync\",\"inflate\",\"exports.inflate\",\"inflateSync\",\"exports.inflateSync\",\"gunzip\",\"exports.gunzip\",\"gunzipSync\",\"exports.gunzipSync\",\"inflateRaw\",\"exports.inflateRaw\",\"inflateRawSync\",\"exports.inflateRawSync\",\"inherits\",\"prototype\",\"params\",\"Zlib.prototype.params\",\"reset\",\"Zlib.prototype.reset\",\"_flush\",\"Zlib.prototype._flush\",\"_transform\",\"alloc\",\"Zlib.prototype.flush\",\"kind\",\"_this2\",\"ws\",\"_writableState\",\"undefined\",\"ended\",\"ending\",\"needDrain\",\"write\",\"Zlib.prototype.close\",\"Zlib.prototype._transform\",\"encoding\",\"cb\",\"last\",\"flushFlag\",\"Zlib.prototype._processChunk\",\"availInAfter\",\"availOutAfter\",\"have\",\"availOutBefore\",\"out\",\"slice\",\"async\",\"inOff\",\"availInBefore\",\"newReq\",\"er\",\"res\",\"writeSync\",\"req\"]\n}\n"]