["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/address/lib/index.js"],"~:js","shadow$provide[26]=function(S,A,V,q){function F(k){(0,y.isHexString)(k,20)||n.throwArgumentError(\"invalid address\",\"address\",k);k=k.toLowerCase();k=k.substring(2).split(\"\");for(var t=new Uint8Array(40),B=0;40>B;B++)t[B]=k[B].charCodeAt(0);t=(0,y.arrayify)((0,u.keccak256)(t));for(B=0;40>B;B+=2)8<=t[B>>1]>>4&&(k[B]=k[B].toUpperCase()),8<=(t[B>>1]&15)&&(k[B+1]=k[B+1].toUpperCase());return\"0x\"+k.join(\"\")}function G(k){k=k.toUpperCase();k=k.substring(4)+k.substring(0,2)+\"00\";for(k=k.split(\"\").map(function(B){return l[B]}).join(\"\");k.length>=\nh;){var t=k.substring(0,h);k=parseInt(t,10)%97+k.substring(t.length)}for(k=String(98-parseInt(k,10)%97);2>k.length;)k=\"0\"+k;return k}function r(k){var t=null;\"string\"!==typeof k&&n.throwArgumentError(\"invalid address\",\"address\",k);if(k.match(/^(0x)?[0-9a-fA-F]{40}$/))\"0x\"!==k.substring(0,2)&&(k=\"0x\"+k),t=F(k),k.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&t!==k&&n.throwArgumentError(\"bad address checksum\",\"address\",k);else if(k.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){k.substring(2,4)!==G(k)&&n.throwArgumentError(\"bad icap checksum\",\n\"address\",k);for(t=(0,e._base36To16)(k.substring(4));40>t.length;)t=\"0\"+t;t=F(\"0x\"+t)}else n.throwArgumentError(\"invalid address\",\"address\",k);return t}Object.defineProperty(q,\"__esModule\",{value:!0});q.getCreate2Address=q.getContractAddress=q.getIcapAddress=q.isAddress=q.getAddress=void 0;var y=A(11),e=A(15),u=A(22),p=A(24);S=A(9);A=A(25);var n=new S.Logger(A.version),l={};for(A=0;10>A;A++)l[String(A)]=String(A);for(A=0;26>A;A++)l[String.fromCharCode(65+A)]=String(10+A);A=Math;S=A.floor;V=Math.log10?\nMath.log10(9007199254740991):Math.log(9007199254740991)/Math.LN10;var h=S.call(A,V);q.getAddress=r;q.isAddress=function(k){try{return r(k),!0}catch(t){}return!1};q.getIcapAddress=function(k){for(k=(0,e._base16To36)(r(k).substring(2)).toUpperCase();30>k.length;)k=\"0\"+k;return\"XE\"+G(\"XE00\"+k)+k};q.getContractAddress=function(k){var t=null;try{t=r(k.from)}catch(B){n.throwArgumentError(\"missing from address\",\"transaction\",k)}k=(0,y.stripZeros)((0,y.arrayify)(e.BigNumber.from(k.nonce).toHexString()));\nreturn r((0,y.hexDataSlice)((0,u.keccak256)((0,p.encode)([t,k])),12))};q.getCreate2Address=function(k,t,B){32!==(0,y.hexDataLength)(t)&&n.throwArgumentError(\"salt must be 32 bytes\",\"salt\",t);32!==(0,y.hexDataLength)(B)&&n.throwArgumentError(\"initCodeHash must be 32 bytes\",\"initCodeHash\",B);return r((0,y.hexDataSlice)((0,u.keccak256)((0,y.concat)([\"0xff\",r(k),t,B])),12))}}","~:source","shadow$provide[26] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;\nvar bytes_1 = require(\"@ethersproject/bytes\");\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\nvar keccak256_1 = require(\"@ethersproject/keccak256\");\nvar rlp_1 = require(\"@ethersproject/rlp\");\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction getChecksumAddress(address) {\n    if (!(0, bytes_1.isHexString)(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    var chars = address.substring(2).split(\"\");\n    var expanded = new Uint8Array(40);\n    for (var i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));\n    for (var i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nvar ibanLookup = {};\nfor (var i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (var i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nvar safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    var expanded = address.split(\"\").map(function (c) { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        var block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    var checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nfunction getAddress(address) {\n    var result = null;\n    if (typeof (address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n        // Maybe ICAP? (we only support direct mode)\n    }\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = (0, bignumber_1._base36To16)(address.substring(4));\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    }\n    else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nexports.getAddress = getAddress;\nfunction isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexports.isAddress = isAddress;\nfunction getIcapAddress(address) {\n    var base36 = (0, bignumber_1._base16To36)(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\nexports.getIcapAddress = getIcapAddress;\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n    var from = null;\n    try {\n        from = getAddress(transaction.from);\n    }\n    catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));\n}\nexports.getContractAddress = getContractAddress;\nfunction getCreate2Address(from, salt, initCodeHash) {\n    if ((0, bytes_1.hexDataLength)(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\nexports.getCreate2Address = getCreate2Address;\n//# sourceMappingURL=index.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$ethersproject$rlp$lib$index","~$shadow.js","~$module$node_modules$$ethersproject$bytes$lib$index","~$module$node_modules$$ethersproject$bignumber$lib$index","~$module$node_modules$$ethersproject$keccak256$lib$index","~$module$node_modules$$ethersproject$address$lib$_version","~$module$node_modules$$ethersproject$logger$lib$index"]],"~:properties",["^5",["getIcapAddress","__esModule","getContractAddress","getAddress","value","getCreate2Address","isAddress"]],"~:compiled-at",1695041440689,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$address$lib$index.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@ethersproject/address/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[26] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;\\nvar bytes_1 = require(\\\"@ethersproject/bytes\\\");\\nvar bignumber_1 = require(\\\"@ethersproject/bignumber\\\");\\nvar keccak256_1 = require(\\\"@ethersproject/keccak256\\\");\\nvar rlp_1 = require(\\\"@ethersproject/rlp\\\");\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"./_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\nfunction getChecksumAddress(address) {\\n    if (!(0, bytes_1.isHexString)(address, 20)) {\\n        logger.throwArgumentError(\\\"invalid address\\\", \\\"address\\\", address);\\n    }\\n    address = address.toLowerCase();\\n    var chars = address.substring(2).split(\\\"\\\");\\n    var expanded = new Uint8Array(40);\\n    for (var i = 0; i < 40; i++) {\\n        expanded[i] = chars[i].charCodeAt(0);\\n    }\\n    var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));\\n    for (var i = 0; i < 40; i += 2) {\\n        if ((hashed[i >> 1] >> 4) >= 8) {\\n            chars[i] = chars[i].toUpperCase();\\n        }\\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\\n            chars[i + 1] = chars[i + 1].toUpperCase();\\n        }\\n    }\\n    return \\\"0x\\\" + chars.join(\\\"\\\");\\n}\\n// Shims for environments that are missing some required constants and functions\\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\\nfunction log10(x) {\\n    if (Math.log10) {\\n        return Math.log10(x);\\n    }\\n    return Math.log(x) / Math.LN10;\\n}\\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\\n// Create lookup table\\nvar ibanLookup = {};\\nfor (var i = 0; i < 10; i++) {\\n    ibanLookup[String(i)] = String(i);\\n}\\nfor (var i = 0; i < 26; i++) {\\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\\n}\\n// How many decimal digits can we process? (for 64-bit float, this is 15)\\nvar safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\\nfunction ibanChecksum(address) {\\n    address = address.toUpperCase();\\n    address = address.substring(4) + address.substring(0, 2) + \\\"00\\\";\\n    var expanded = address.split(\\\"\\\").map(function (c) { return ibanLookup[c]; }).join(\\\"\\\");\\n    // Javascript can handle integers safely up to 15 (decimal) digits\\n    while (expanded.length >= safeDigits) {\\n        var block = expanded.substring(0, safeDigits);\\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\\n    }\\n    var checksum = String(98 - (parseInt(expanded, 10) % 97));\\n    while (checksum.length < 2) {\\n        checksum = \\\"0\\\" + checksum;\\n    }\\n    return checksum;\\n}\\n;\\nfunction getAddress(address) {\\n    var result = null;\\n    if (typeof (address) !== \\\"string\\\") {\\n        logger.throwArgumentError(\\\"invalid address\\\", \\\"address\\\", address);\\n    }\\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\\n        // Missing the 0x prefix\\n        if (address.substring(0, 2) !== \\\"0x\\\") {\\n            address = \\\"0x\\\" + address;\\n        }\\n        result = getChecksumAddress(address);\\n        // It is a checksummed address with a bad checksum\\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\\n            logger.throwArgumentError(\\\"bad address checksum\\\", \\\"address\\\", address);\\n        }\\n        // Maybe ICAP? (we only support direct mode)\\n    }\\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\\n        // It is an ICAP address with a bad checksum\\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\\n            logger.throwArgumentError(\\\"bad icap checksum\\\", \\\"address\\\", address);\\n        }\\n        result = (0, bignumber_1._base36To16)(address.substring(4));\\n        while (result.length < 40) {\\n            result = \\\"0\\\" + result;\\n        }\\n        result = getChecksumAddress(\\\"0x\\\" + result);\\n    }\\n    else {\\n        logger.throwArgumentError(\\\"invalid address\\\", \\\"address\\\", address);\\n    }\\n    return result;\\n}\\nexports.getAddress = getAddress;\\nfunction isAddress(address) {\\n    try {\\n        getAddress(address);\\n        return true;\\n    }\\n    catch (error) { }\\n    return false;\\n}\\nexports.isAddress = isAddress;\\nfunction getIcapAddress(address) {\\n    var base36 = (0, bignumber_1._base16To36)(getAddress(address).substring(2)).toUpperCase();\\n    while (base36.length < 30) {\\n        base36 = \\\"0\\\" + base36;\\n    }\\n    return \\\"XE\\\" + ibanChecksum(\\\"XE00\\\" + base36) + base36;\\n}\\nexports.getIcapAddress = getIcapAddress;\\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\\nfunction getContractAddress(transaction) {\\n    var from = null;\\n    try {\\n        from = getAddress(transaction.from);\\n    }\\n    catch (error) {\\n        logger.throwArgumentError(\\\"missing from address\\\", \\\"transaction\\\", transaction);\\n    }\\n    var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));\\n    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));\\n}\\nexports.getContractAddress = getContractAddress;\\nfunction getCreate2Address(from, salt, initCodeHash) {\\n    if ((0, bytes_1.hexDataLength)(salt) !== 32) {\\n        logger.throwArgumentError(\\\"salt must be 32 bytes\\\", \\\"salt\\\", salt);\\n    }\\n    if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {\\n        logger.throwArgumentError(\\\"initCodeHash must be 32 bytes\\\", \\\"initCodeHash\\\", initCodeHash);\\n    }\\n    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([\\\"0xff\\\", getAddress(from), salt, initCodeHash])), 12));\\n}\\nexports.getCreate2Address = getCreate2Address;\\n//# sourceMappingURL=index.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getChecksumAddress\",\"address\",\"bytes_1\",\"isHexString\",\"logger\",\"throwArgumentError\",\"toLowerCase\",\"chars\",\"substring\",\"split\",\"expanded\",\"Uint8Array\",\"i\",\"charCodeAt\",\"hashed\",\"arrayify\",\"keccak256_1\",\"keccak256\",\"toUpperCase\",\"join\",\"ibanChecksum\",\"map\",\"c\",\"ibanLookup\",\"length\",\"safeDigits\",\"block\",\"parseInt\",\"checksum\",\"String\",\"getAddress\",\"result\",\"match\",\"bignumber_1\",\"_base36To16\",\"Object\",\"defineProperty\",\"value\",\"getCreate2Address\",\"getContractAddress\",\"getIcapAddress\",\"isAddress\",\"rlp_1\",\"logger_1\",\"_version_1\",\"Logger\",\"version\",\"fromCharCode\",\"Math\",\"floor\",\"log10\",\"MAX_SAFE_INTEGER\",\"log\",\"LN10\",\"error\",\"base36\",\"_base16To36\",\"transaction\",\"from\",\"nonce\",\"stripZeros\",\"BigNumber\",\"toHexString\",\"hexDataSlice\",\"encode\",\"salt\",\"initCodeHash\",\"hexDataLength\",\"concat\"]\n}\n"]