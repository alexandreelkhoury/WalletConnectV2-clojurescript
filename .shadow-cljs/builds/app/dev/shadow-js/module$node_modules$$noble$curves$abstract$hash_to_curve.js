["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@noble/curves/abstract/hash-to-curve.js"],"~:js","shadow$provide.module$node_modules$$noble$curves$abstract$hash_to_curve=function(global,require,module,exports){function i2osp(value,length){if(0>value||value>=1<<8*length)throw Error(`bad I2OSP call: value=${value} length=${length}`);const res=Array.from({length}).fill(0);for(--length;0<=length;length--)res[length]=value&255,value>>>=8;return new Uint8Array(res)}function isBytes(item){if(!(item instanceof Uint8Array))throw Error(\"Uint8Array expected\");}function isNum(item){if(!Number.isSafeInteger(item))throw Error(\"number expected\");\n}function expand_message_xmd(msg,DST,lenInBytes,H){isBytes(msg);isBytes(DST);isNum(lenInBytes);255<DST.length&&(DST=H((0,utils_js_1.concatBytes)((0,utils_js_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"),DST)));const {outputLen:b_in_bytes,blockLen:r_in_bytes}=H,ell=Math.ceil(lenInBytes/b_in_bytes);if(255<ell)throw Error(\"Invalid xmd length\");DST=(0,utils_js_1.concatBytes)(DST,i2osp(DST.length,1));var Z_pad=i2osp(0,r_in_bytes),l_i_b_str=i2osp(lenInBytes,2);const b=Array(ell);msg=H((0,utils_js_1.concatBytes)(Z_pad,\nmsg,l_i_b_str,i2osp(0,1),DST));b[0]=H((0,utils_js_1.concatBytes)(msg,i2osp(1,1),DST));for(Z_pad=1;Z_pad<=ell;Z_pad++){l_i_b_str=msg;var b$jscomp$0=b[Z_pad-1];const arr=new Uint8Array(l_i_b_str.length);for(let i=0;i<l_i_b_str.length;i++)arr[i]=l_i_b_str[i]^b$jscomp$0[i];l_i_b_str=[arr,i2osp(Z_pad+1,1),DST];b[Z_pad]=H((0,utils_js_1.concatBytes)(...l_i_b_str))}return(0,utils_js_1.concatBytes)(...b).slice(0,lenInBytes)}function expand_message_xof(msg,DST,lenInBytes,k,H){isBytes(msg);isBytes(DST);isNum(lenInBytes);\n255<DST.length&&(DST=H.create({dkLen:Math.ceil(2*k/8)}).update((0,utils_js_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest());if(65535<lenInBytes||255<DST.length)throw Error(\"expand_message_xof: invalid lenInBytes\");return H.create({dkLen:lenInBytes}).update(msg).update(i2osp(lenInBytes,2)).update(DST).update(i2osp(DST.length,1)).digest()}function hash_to_field(msg,count,options){(0,utils_js_1.validateObject)(options,{DST:\"stringOrUint8Array\",p:\"bigint\",m:\"isSafeInteger\",k:\"isSafeInteger\",\nhash:\"hash\"});const {p,k,m,hash,expand,DST:_DST}=options;isBytes(msg);isNum(count);if(_DST instanceof Uint8Array)options=_DST;else if(\"string\"===typeof _DST)options=(0,utils_js_1.utf8ToBytes)(_DST);else throw Error(\"DST must be Uint8Array or string\");var DST=options;options=p.toString(2).length;options=Math.ceil((options+k)/8);var len_in_bytes=count*m*options;if(\"xmd\"===expand)msg=expand_message_xmd(msg,DST,len_in_bytes,hash);else if(\"xof\"===expand)msg=expand_message_xof(msg,DST,len_in_bytes,k,hash);\nelse if(\"_internal_pass\"!==expand)throw Error('expand must be \"xmd\" or \"xof\"');DST=Array(count);for(len_in_bytes=0;len_in_bytes<count;len_in_bytes++){const e=Array(m);for(let j=0;j<m;j++){var elm_offset=options*(j+len_in_bytes*m);elm_offset=msg.subarray(elm_offset,elm_offset+options);e[j]=(0,modular_js_1.mod)(os2ip(elm_offset),p)}DST[len_in_bytes]=e}return DST}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.createHasher=exports.isogenyMap=exports.hash_to_field=exports.expand_message_xof=\nexports.expand_message_xmd=void 0;const modular_js_1=require(\"module$node_modules$$noble$curves$abstract$modular\"),utils_js_1=require(\"module$node_modules$$noble$curves$abstract$utils\"),os2ip=utils_js_1.bytesToNumberBE;exports.expand_message_xmd=expand_message_xmd;exports.expand_message_xof=expand_message_xof;exports.hash_to_field=hash_to_field;exports.isogenyMap=function(field,map){const COEFF=map.map(i=>Array.from(i).reverse());return(x,y)=>{const [xNum,xDen,yNum,yDen]=COEFF.map(val=>val.reduce((acc,\ni)=>field.add(field.mul(acc,x),i)));x=field.div(xNum,xDen);y=field.mul(y,field.div(yNum,yDen));return{x,y}}};exports.createHasher=function(Point,mapToCurve,def){if(\"function\"!==typeof mapToCurve)throw Error(\"mapToCurve() must be defined\");return{hashToCurve(msg,options){options=hash_to_field(msg,2,{...def,DST:def.DST,...options});msg=Point.fromAffine(mapToCurve(options[0]));options=Point.fromAffine(mapToCurve(options[1]));msg=msg.add(options).clearCofactor();msg.assertValidity();return msg},encodeToCurve(msg,\noptions){msg=hash_to_field(msg,1,{...def,DST:def.encodeDST,...options});msg=Point.fromAffine(mapToCurve(msg[0])).clearCofactor();msg.assertValidity();return msg}}}}","~:source","shadow$provide[\"module$node_modules$$noble$curves$abstract$hash_to_curve\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0, utils_js_1.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_js_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nexports.expand_message_xmd = expand_message_xmd;\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\nexports.expand_message_xof = expand_message_xof;\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0, utils_js_1.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexports.hash_to_field = hash_to_field;\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nexports.isogenyMap = isogenyMap;\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\nexports.createHasher = createHasher;\n//# sourceMappingURL=hash-to-curve.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$noble$curves$abstract$modular","~$shadow.js","~$module$node_modules$$noble$curves$abstract$utils"]],"~:properties",["^5",["isogenyMap","p","hash","x","__esModule","expand_message_xmd","value","DST","length","k","y","dkLen","createHasher","expand_message_xof","m","hash_to_field"]],"~:compiled-at",1695111490333,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$noble$curves$abstract$hash_to_curve.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@noble/curves/abstract/hash-to-curve.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$noble$curves$abstract$hash_to_curve\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;\\nconst modular_js_1 = require(\\\"./modular.js\\\");\\nconst utils_js_1 = require(\\\"./utils.js\\\");\\nfunction validateDST(dst) {\\n    if (dst instanceof Uint8Array)\\n        return dst;\\n    if (typeof dst === 'string')\\n        return (0, utils_js_1.utf8ToBytes)(dst);\\n    throw new Error('DST must be Uint8Array or string');\\n}\\n// Octet Stream to Integer. \\\"spec\\\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\\nconst os2ip = utils_js_1.bytesToNumberBE;\\n// Integer to Octet Stream (numberToBytesBE)\\nfunction i2osp(value, length) {\\n    if (value < 0 || value >= 1 << (8 * length)) {\\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\\n    }\\n    const res = Array.from({ length }).fill(0);\\n    for (let i = length - 1; i >= 0; i--) {\\n        res[i] = value & 0xff;\\n        value >>>= 8;\\n    }\\n    return new Uint8Array(res);\\n}\\nfunction strxor(a, b) {\\n    const arr = new Uint8Array(a.length);\\n    for (let i = 0; i < a.length; i++) {\\n        arr[i] = a[i] ^ b[i];\\n    }\\n    return arr;\\n}\\nfunction isBytes(item) {\\n    if (!(item instanceof Uint8Array))\\n        throw new Error('Uint8Array expected');\\n}\\nfunction isNum(item) {\\n    if (!Number.isSafeInteger(item))\\n        throw new Error('number expected');\\n}\\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\\n    isBytes(msg);\\n    isBytes(DST);\\n    isNum(lenInBytes);\\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\\n    if (DST.length > 255)\\n        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\\n    if (ell > 255)\\n        throw new Error('Invalid xmd length');\\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\\n    const Z_pad = i2osp(0, r_in_bytes);\\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\\n    const b = new Array(ell);\\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\\n    for (let i = 1; i <= ell; i++) {\\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\\n    }\\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\\n    return pseudo_random_bytes.slice(0, lenInBytes);\\n}\\nexports.expand_message_xmd = expand_message_xmd;\\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\\n// 1. The collision resistance of H MUST be at least k bits.\\n// 2. H MUST be an XOF that has been proved indifferentiable from\\n//    a random oracle under a reasonable cryptographic assumption.\\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\\n    isBytes(msg);\\n    isBytes(DST);\\n    isNum(lenInBytes);\\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\\n    if (DST.length > 255) {\\n        const dkLen = Math.ceil((2 * k) / 8);\\n        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\\n    }\\n    if (lenInBytes > 65535 || DST.length > 255)\\n        throw new Error('expand_message_xof: invalid lenInBytes');\\n    return (H.create({ dkLen: lenInBytes })\\n        .update(msg)\\n        .update(i2osp(lenInBytes, 2))\\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\\n        .update(DST)\\n        .update(i2osp(DST.length, 1))\\n        .digest());\\n}\\nexports.expand_message_xof = expand_message_xof;\\n/**\\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\\n * @param msg a byte string containing the message to hash\\n * @param count the number of elements of F to output\\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\\n */\\nfunction hash_to_field(msg, count, options) {\\n    (0, utils_js_1.validateObject)(options, {\\n        DST: 'stringOrUint8Array',\\n        p: 'bigint',\\n        m: 'isSafeInteger',\\n        k: 'isSafeInteger',\\n        hash: 'hash',\\n    });\\n    const { p, k, m, hash, expand, DST: _DST } = options;\\n    isBytes(msg);\\n    isNum(count);\\n    const DST = validateDST(_DST);\\n    const log2p = p.toString(2).length;\\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\\n    const len_in_bytes = count * m * L;\\n    let prb; // pseudo_random_bytes\\n    if (expand === 'xmd') {\\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\\n    }\\n    else if (expand === 'xof') {\\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\\n    }\\n    else if (expand === '_internal_pass') {\\n        // for internal tests only\\n        prb = msg;\\n    }\\n    else {\\n        throw new Error('expand must be \\\"xmd\\\" or \\\"xof\\\"');\\n    }\\n    const u = new Array(count);\\n    for (let i = 0; i < count; i++) {\\n        const e = new Array(m);\\n        for (let j = 0; j < m; j++) {\\n            const elm_offset = L * (j + i * m);\\n            const tv = prb.subarray(elm_offset, elm_offset + L);\\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\\n        }\\n        u[i] = e;\\n    }\\n    return u;\\n}\\nexports.hash_to_field = hash_to_field;\\nfunction isogenyMap(field, map) {\\n    // Make same order as in spec\\n    const COEFF = map.map((i) => Array.from(i).reverse());\\n    return (x, y) => {\\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\\n        x = field.div(xNum, xDen); // xNum / xDen\\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\\n        return { x, y };\\n    };\\n}\\nexports.isogenyMap = isogenyMap;\\nfunction createHasher(Point, mapToCurve, def) {\\n    if (typeof mapToCurve !== 'function')\\n        throw new Error('mapToCurve() must be defined');\\n    return {\\n        // Encodes byte string to elliptic curve.\\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\\n        hashToCurve(msg, options) {\\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\\n            const P = u0.add(u1).clearCofactor();\\n            P.assertValidity();\\n            return P;\\n        },\\n        // Encodes byte string to elliptic curve.\\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\\n        encodeToCurve(msg, options) {\\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\\n            P.assertValidity();\\n            return P;\\n        },\\n    };\\n}\\nexports.createHasher = createHasher;\\n//# sourceMappingURL=hash-to-curve.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"i2osp\",\"value\",\"length\",\"Error\",\"res\",\"Array\",\"from\",\"fill\",\"i\",\"Uint8Array\",\"isBytes\",\"item\",\"isNum\",\"Number\",\"isSafeInteger\",\"expand_message_xmd\",\"msg\",\"DST\",\"lenInBytes\",\"H\",\"utils_js_1\",\"concatBytes\",\"utf8ToBytes\",\"b_in_bytes\",\"r_in_bytes\",\"ell\",\"Math\",\"ceil\",\"DST_prime\",\"Z_pad\",\"l_i_b_str\",\"b\",\"b_0\",\"arr\",\"a\",\"args\",\"pseudo_random_bytes\",\"slice\",\"expand_message_xof\",\"k\",\"create\",\"dkLen\",\"update\",\"digest\",\"hash_to_field\",\"count\",\"options\",\"validateObject\",\"p\",\"m\",\"hash\",\"expand\",\"_DST\",\"log2p\",\"toString\",\"L\",\"len_in_bytes\",\"prb\",\"u\",\"e\",\"j\",\"elm_offset\",\"tv\",\"subarray\",\"modular_js_1\",\"mod\",\"os2ip\",\"Object\",\"defineProperty\",\"createHasher\",\"isogenyMap\",\"bytesToNumberBE\",\"field\",\"map\",\"COEFF\",\"reverse\",\"x\",\"y\",\"xNum\",\"xDen\",\"yNum\",\"yDen\",\"val\",\"reduce\",\"acc\",\"add\",\"mul\",\"div\",\"Point\",\"mapToCurve\",\"def\",\"hashToCurve\",\"u0\",\"fromAffine\",\"u1\",\"P\",\"clearCofactor\",\"assertValidity\",\"encodeToCurve\",\"encodeDST\"]\n}\n"]