["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/url/node_modules/punycode/punycode.js"],"~:js","shadow$provide[304]=function(S,A,V,q){(function(F){function G(J){throw RangeError(D[J]);}function r(J,T){for(var N=J.length,a=[];N--;)a[N]=T(J[N]);return a}function y(J,T){var N=J.split(\"@\"),a=\"\";1<N.length&&(a=N[0]+\"@\",J=N[1]);J=J.replace(H,\".\");J=J.split(\".\");T=r(J,T).join(\".\");return a+T}function e(J){for(var T=[],N=0,a=J.length,b,c;N<a;)b=J.charCodeAt(N++),55296<=b&&56319>=b&&N<a?(c=J.charCodeAt(N++),56320==(c&64512)?T.push(((b&1023)<<10)+(c&1023)+65536):(T.push(b),N--)):T.push(b);return T}function u(J){return r(J,\nfunction(T){var N=\"\";65535<T&&(T-=65536,N+=I(T>>>10&1023|55296),T=56320|T&1023);return N+=I(T)}).join(\"\")}function p(J,T,N){var a=0;J=N?C(J/700):J>>1;for(J+=C(J/T);455<J;a+=36)J=C(J/35);return C(a+36*J/(J+38))}function n(J){var T=[],N=J.length,a=0,b=128,c=72,d,f;var g=J.lastIndexOf(\"-\");0>g&&(g=0);for(d=0;d<g;++d)128<=J.charCodeAt(d)&&G(\"not-basic\"),T.push(J.charCodeAt(d));for(g=0<g?g+1:0;g<N;){d=a;var m=1;for(f=36;;f+=36){g>=N&&G(\"invalid-input\");var w=J.charCodeAt(g++);w=10>w-48?w-22:26>w-65?w-\n65:26>w-97?w-97:36;(36<=w||w>C((2147483647-a)/m))&&G(\"overflow\");a+=w*m;var x=f<=c?1:f>=c+26?26:f-c;if(w<x)break;w=36-x;m>C(2147483647/w)&&G(\"overflow\");m*=w}m=T.length+1;c=p(a-d,m,0==d);C(a/m)>2147483647-b&&G(\"overflow\");b+=C(a/m);a%=m;T.splice(a++,0,b)}return u(T)}function l(J){var T,N,a,b=[];J=e(J);var c=J.length;var d=128;var f=0;var g=72;for(a=0;a<c;++a){var m=J[a];128>m&&b.push(I(m))}for((T=N=b.length)&&b.push(\"-\");T<c;){var w=2147483647;for(a=0;a<c;++a)m=J[a],m>=d&&m<w&&(w=m);var x=T+1;w-d>\nC((2147483647-f)/x)&&G(\"overflow\");f+=(w-d)*x;d=w;for(a=0;a<c;++a)if(m=J[a],m<d&&2147483647<++f&&G(\"overflow\"),m==d){var z=f;for(w=36;;w+=36){m=w<=g?1:w>=g+26?26:w-g;if(z<m)break;var v=z-m;z=36-m;var R=b;m+=v%z;R.push.call(R,I(m+22+75*(26>m)-0));z=C(v/z)}b.push(I(z+22+75*(26>z)-0));g=p(f,x,T==N);f=0;++T}++f;++d}return b.join(\"\")}var h=\"object\"==typeof q&&q&&!q.nodeType&&q,k=\"object\"==typeof V&&V&&!V.nodeType&&V,t=\"object\"==typeof S&&S;if(t.global===t||t.window===t||t.self===t)F=t;var B=/^xn--/,E=\n/[^\\x20-\\x7E]/,H=/[\\x2E\\u3002\\uFF0E\\uFF61]/g,D={overflow:\"Overflow: input needs wider integers to process\",\"not-basic\":\"Illegal input \\x3e\\x3d 0x80 (not a basic code point)\",\"invalid-input\":\"Invalid input\"},C=Math.floor,I=String.fromCharCode,M;var P={version:\"1.3.2\",ucs2:{decode:e,encode:u},decode:n,encode:l,toASCII:function(J){return y(J,function(T){return E.test(T)?\"xn--\"+l(T):T})},toUnicode:function(J){return y(J,function(T){return B.test(T)?n(T.slice(4).toLowerCase()):T})}};if(\"function\"==typeof define&&\n\"object\"==typeof define.amd&&define.amd)define(\"punycode\",function(){return P});else if(h&&k)if(V.exports==h)k.exports=P;else for(M in P)P.hasOwnProperty(M)&&(h[M]=P[M]);else F.punycode=P})(this)}","~:source","shadow$provide[304] = function(global,require,module,exports) {\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["punycode"]],"~:compiled-at",1695041440893,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$url$node_modules$punycode$punycode.js\",\n\"lineCount\":6,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAE5D,SAAQ,CAACC,CAAD,CAAO,CAgEhBC,QAASA,EAAK,CAACC,CAAD,CAAO,CACpB,KAAMC,WAAA,CAAWC,CAAA,CAAOF,CAAP,CAAX,CAAN,CADoB,CAYrBG,QAASA,EAAG,CAACC,CAAD,CAAQC,CAAR,CAAY,CAGvB,IAFA,IAAIC,EAASF,CAAME,CAAAA,MAAnB,CACIC,EAAS,EACb,CAAOD,CAAA,EAAP,CAAA,CACCC,CAAA,CAAOD,CAAP,CAAA,CAAiBD,CAAA,CAAGD,CAAA,CAAME,CAAN,CAAH,CAElB,OAAOC,EANgB,CAmBxBC,QAASA,EAAS,CAACC,CAAD,CAASJ,CAAT,CAAa,CAC9B,IAAIK,EAAQD,CAAOE,CAAAA,KAAP,CAAa,GAAb,CAAZ,CACIJ,EAAS,EACM,EAAnB,CAAIG,CAAMJ,CAAAA,MAAV,GAGCC,CACA,CADSG,CAAA,CAAM,CAAN,CACT,CADoB,GACpB,CAAAD,CAAA,CAASC,CAAA,CAAM,CAAN,CAJV,CAOAD,EAAA,CAASA,CAAOG,CAAAA,OAAP,CAAeC,CAAf,CAAgC,GAAhC,CACLC,EAAAA,CAASL,CAAOE,CAAAA,KAAP,CAAa,GAAb,CACTI,EAAAA,CAAUZ,CAAA,CAAIW,CAAJ,CAAYT,CAAZ,CAAgBW,CAAAA,IAAhB,CAAqB,GAArB,CACd,OAAOT,EAAP,CAAgBQ,CAbc,CA6B/BE,QAASA,EAAU,CAACR,CAAD,CAAS,CAM3B,IAN2B,IACvBS,EAAS,EADc,CAEvBC,EAAU,CAFa,CAGvBb,EAASG,CAAOH,CAAAA,MAHO,CAIvBc,CAJuB,CAKvBC,CACJ,CAAOF,CAAP,CAAiBb,CAAjB,CAAA,CACCc,CACA,CADQX,CAAOa,CAAAA,UAAP,CAAkBH,CAAA,EAAlB,CACR,CAAa,KAAb,EAAIC,CAAJ,EAAgC,KAAhC,EAAuBA,CAAvB,EAA0CD,CAA1C,CAAoDb,CAApD,EAECe,CACA,CADQZ,CAAOa,CAAAA,UAAP,CAAkBH,CAAA,EAAlB,CACR,CAAwB,KAAxB,GAAKE,CAAL,CAAa,KAAb,EACCH,CAAOK,CAAAA,IAAP,GAAcH,CAAd,CAAsB,IAAtB,GAAgC,EAAhC,GAAuCC,CAAvC,CAA+C,IAA/C,EAAwD,KAAxD,CADD,EAKCH,CAAOK,CAAAA,IAAP,CAAYH,CAAZ,CACA,CAAAD,CAAA,EAND,CAHD,EAYCD,CAAOK,CAAAA,IAAP,CAAYH,CAAZ,CAGF,OAAOF,EAvBoB,CAkC5BM,QAASA,EAAU,CAACpB,CAAD,CAAQ,CAC1B,MAAOD,EAAA,CAAIC,CAAJ;AAAW,QAAQ,CAACgB,CAAD,CAAQ,CACjC,IAAIF,EAAS,EACD,MAAZ,CAAIE,CAAJ,GACCA,CAEA,EAFS,KAET,CADAF,CACA,EADUO,CAAA,CAAmBL,CAAnB,GAA6B,EAA7B,CAAkC,IAAlC,CAA0C,KAA1C,CACV,CAAAA,CAAA,CAAQ,KAAR,CAAiBA,CAAjB,CAAyB,IAH1B,CAMA,OADAF,EACA,EADUO,CAAA,CAAmBL,CAAnB,CAPuB,CAA3B,CASJJ,CAAAA,IATI,CASC,EATD,CADmB,CAyD3BU,QAASA,EAAK,CAACC,CAAD,CAAQC,CAAR,CAAmBC,CAAnB,CAA8B,CAC3C,IAAIC,EAAI,CACRH,EAAA,CAAQE,CAAA,CAAYE,CAAA,CAAMJ,CAAN,CA1LdK,GA0Lc,CAAZ,CAAkCL,CAAlC,EAA2C,CAEnD,KADAA,CACA,EADSI,CAAA,CAAMJ,CAAN,CAAcC,CAAd,CACT,CAAsC,GAAtC,CAA8BD,CAA9B,CAAiEG,CAAjE,EAhMMG,EAgMN,CACCN,CAAA,CAAQI,CAAA,CAAMJ,CAAN,CA3KMO,EA2KN,CAET,OAAOH,EAAA,CAAMD,CAAN,CAAW,EAAX,CAAgCH,CAAhC,EAAyCA,CAAzC,CAhMDQ,EAgMC,EAPoC,CAiB5CC,QAASA,EAAM,CAACC,CAAD,CAAQ,CAAA,IAElBnB,EAAS,EAFS,CAGlBoB,EAAcD,CAAM/B,CAAAA,MAHF,CAKlBiC,EAAI,CALc,CAMlBC,EA7MMC,GAuMY,CAOlBC,EA/MSC,EAwMS,CASlBC,CATkB,CAalBd,CAUJ,KAAAe,EAAQR,CAAMS,CAAAA,WAAN,CA7NGC,GA6NH,CACI,EAAZ,CAAIF,CAAJ,GACCA,CADD,CACS,CADT,CAIA,KAAKD,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBC,CAAhB,CAAuB,EAAED,CAAzB,CAE4B,GAG3B,EAHIP,CAAMf,CAAAA,UAAN,CAAiBsB,CAAjB,CAGJ,EAFC7C,CAAA,CAAM,WAAN,CAED,CAAAmB,CAAOK,CAAAA,IAAP,CAAYc,CAAMf,CAAAA,UAAN,CAAiBsB,CAAjB,CAAZ,CAMD,KAAKI,CAAL,CAAqB,CAAR,CAAAH,CAAA,CAAYA,CAAZ,CAAoB,CAApB,CAAwB,CAArC,CAAwCG,CAAxC,CAAgDV,CAAhD,CAAA,CAAwF,CAOlFW,CAAA,CAAOV,CAAG,KAAAW,EAAI,CAAnB,KAAsBpB,CAAtB,CA3PKG,EA2PL,CAAA,CAAoDH,CAApD,EA3PKG,EA2PL,CAA+D,CAE1De,CAAJ,EAAaV,CAAb,EACCvC,CAAA,CAAM,eAAN,CAGoB,KAAA,EAAAsC,CAAMf,CAAAA,UAAN,CAAiB0B,CAAA,EAAjB,CAvGvB,EAAA,CAAqB,EAArB,CAAIG,CAAJ,CAAgB,EAAhB,CACQA,CADR,CACoB,EADpB,CAGqB,EAArB,CAAIA,CAAJ,CAAgB,EAAhB,CACQA,CADR;AACoB,EADpB,CAGqB,EAArB,CAAIA,CAAJ,CAAgB,EAAhB,CACQA,CADR,CACoB,EADpB,CAhKMlB,EAmQJ,EAnQIA,EAmQJ,EAAImB,CAAJ,EAAqBA,CAArB,CAA6BrB,CAAA,EAtQvBsB,UAsQuB,CAAgBd,CAAhB,EAAqBW,CAArB,CAA7B,GACCnD,CAAA,CAAM,UAAN,CAGDwC,EAAA,EAAKa,CAAL,CAAaF,CACb,KAAAI,EAAIxB,CAAA,EAAKY,CAAL,CAvQAa,CAuQA,CAAoBzB,CAAA,EAAKY,CAAL,CAtQpBc,EAsQoB,CAtQpBA,EAsQoB,CAA0B1B,CAA1B,CAA8BY,CAEtD,IAAIU,CAAJ,CAAYE,CAAZ,CACC,KAGDG,EAAA,CA9QIxB,EA8QJ,CAAoBqB,CAChBJ,EAAJ,CAAQnB,CAAA,CAlRFsB,UAkRE,CAAeI,CAAf,CAAR,EACC1D,CAAA,CAAM,UAAN,CAGDmD,EAAA,EAAKO,CAxByD,CA4B/DC,CAAA,CAAMxC,CAAOZ,CAAAA,MAAb,CAAsB,CACtBoC,EAAA,CAAOhB,CAAA,CAAMa,CAAN,CAAUU,CAAV,CAAgBS,CAAhB,CAA6B,CAA7B,EAAqBT,CAArB,CAIHlB,EAAA,CAAMQ,CAAN,CAAUmB,CAAV,CAAJ,CA/ROL,UA+RP,CAA8Bb,CAA9B,EACCzC,CAAA,CAAM,UAAN,CAGDyC,EAAA,EAAKT,CAAA,CAAMQ,CAAN,CAAUmB,CAAV,CACLnB,EAAA,EAAKmB,CAGLxC,EAAOyC,CAAAA,MAAP,CAAcpB,CAAA,EAAd,CAAmB,CAAnB,CAAsBC,CAAtB,CAhDuF,CAoDxF,MAAOhB,EAAA,CAAWN,CAAX,CA3Fe,CAqGvB0C,QAASA,EAAM,CAACvB,CAAD,CAAQ,CAAA,IAGlBwB,CAHkB,CAIlBC,CAJkB,CAMlBlB,CANkB,CAYlB1B,EAAS,EASbmB,EAAA,CAAQpB,CAAA,CAAWoB,CAAX,CAGR,KAAAC,EAAcD,CAAM/B,CAAAA,MAGpB,KAAAkC,EAvUUC,GAwUV,KAAAd,EAAQ,CACR,KAAAe,EA1UaC,EA6Ub,KAAKC,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBN,CAAhB,CAA6B,EAAEM,CAA/B,CAAkC,CACjC,IAAAmB,EAAe1B,CAAA,CAAMO,CAAN,CACI,IAAnB,CAAImB,CAAJ,EACC7C,CAAOK,CAAAA,IAAP,CAAYE,CAAA,CAAmBsC,CAAnB,CAAZ,CAHgC,CAkBlC,KAXAF,CAWA,CAXiBC,CAWjB,CAX+B5C,CAAOZ,CAAAA,MAWtC,GAJCY,CAAOK,CAAAA,IAAP,CAzVUwB,GAyVV,CAID,CAAOc,CAAP,CAAwBvB,CAAxB,CAAA,CAAqC,CAI/B,IAAA0B,EA3WEX,UA2WP,KAAiBT,CAAjB,CAAqB,CAArB,CAAwBA,CAAxB,CAA4BN,CAA5B,CAAyC,EAAEM,CAA3C,CACCmB,CACA,CADe1B,CAAA,CAAMO,CAAN,CACf,CAAImB,CAAJ,EAAoBvB,CAApB,EAAyBuB,CAAzB,CAAwCC,CAAxC,GACCA,CADD,CACKD,CADL,CAOD,KAAAE,EAAwBJ,CAAxBI,CAAyC,CACrCD,EAAJ,CAAQxB,CAAR;AAAYT,CAAA,EArXLsB,UAqXK,CAAgB1B,CAAhB,EAAyBsC,CAAzB,CAAZ,EACClE,CAAA,CAAM,UAAN,CAGD4B,EAAA,GAAUqC,CAAV,CAAcxB,CAAd,EAAmByB,CACnBzB,EAAA,CAAIwB,CAEJ,KAAKpB,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBN,CAAhB,CAA6B,EAAEM,CAA/B,CAOC,GANAmB,CAMI,CANW1B,CAAA,CAAMO,CAAN,CAMX,CAJAmB,CAIA,CAJevB,CAIf,EAnYEa,UAmYF,CAJoB,EAAE1B,CAItB,EAHH5B,CAAA,CAAM,UAAN,CAGG,CAAAgE,CAAA,EAAgBvB,CAApB,CAAuB,CAEjB,IAAA0B,EAAIvC,CAAT,KAAgBG,CAAhB,CAlYGG,EAkYH,CAAA,CAA8CH,CAA9C,EAlYGG,EAkYH,CAAyD,CACxDqB,CAAA,CAAIxB,CAAA,EAAKY,CAAL,CAlYFa,CAkYE,CAAoBzB,CAAA,EAAKY,CAAL,CAjYtBc,EAiYsB,CAjYtBA,EAiYsB,CAA0B1B,CAA1B,CAA8BY,CACtD,IAAIwB,CAAJ,CAAQZ,CAAR,CACC,KAED,KAAAa,EAAUD,CAAVC,CAAcb,CACdG,EAAA,CAxYExB,EAwYF,CAAoBqB,CACpBpC,KAAAA,EAAAA,CACiCoC,EAAA,EAAIa,CAAJ,CAAcV,CAD/CvC,EAAOK,CAAAA,IAAP,CAAA,IAAA,CAAAL,CAAA,CACCO,CAAA,CAtNE2B,CAsNF,CAtNU,EAsNV,CAtNe,EAsNf,EAtN6B,EAsN7B,CAtNqBA,CAsNrB,EAtNoC,CAsNpC,CADD,CAGAc,EAAA,CAAInC,CAAA,CAAMoC,CAAN,CAAgBV,CAAhB,CAVoD,CAazDvC,CAAOK,CAAAA,IAAP,CAAYE,CAAA,CAAgCyC,CAAhC,CA3NA,EA2NA,CA3NK,EA2NL,EA3NmB,EA2NnB,CAAgCA,CAAhC,EA3N0B,CA2N1B,CAAZ,CACAxB,EAAA,CAAOhB,CAAA,CAAMC,CAAN,CAAasC,CAAb,CAAoCJ,CAApC,EAAsDC,CAAtD,CACPnC,EAAA,CAAQ,CACR,GAAEkC,CAlBoB,CAsBxB,EAAElC,CACF,GAAEa,CAnDkC,CAsDrC,MAAOtB,EAAOF,CAAAA,IAAP,CAAY,EAAZ,CAxGe,CA1UvB,IAAIoD,EAAgC,QAAhCA,EAAc,MAAOvE,EAArBuE,EAA4CvE,CAA5CuE,EACH,CAACvE,CAAQwE,CAAAA,QADND,EACkBvE,CADtB,CAEIyE,EAA8B,QAA9BA,EAAa,MAAO1E,EAApB0E,EAA0C1E,CAA1C0E,EACH,CAAC1E,CAAOyE,CAAAA,QADLC,EACiB1E,CAHrB,CAII2E,EAA8B,QAA9BA,EAAa,MAAO7E,EAApB6E,EAA0C7E,CAC9C,IACC6E,CAAW7E,CAAAA,MADZ,GACuB6E,CADvB,EAECA,CAAWC,CAAAA,MAFZ,GAEuBD,CAFvB,EAGCA,CAAWE,CAAAA,IAHZ,GAGqBF,CAHrB,CAKCzE,CAAA,CAAOyE,CAbQ,KAqChBG,EAAgB,OArCA,CAsChBC;AAAgB,cAtCA,CAuChB9D,EAAkB,2BAvCF,CA0ChBX,EAAS,CACR,SAAY,iDADJ,CAER,YAAa,sDAFL,CAGR,gBAAiB,eAHT,CA1CO,CAkDhB6B,EAAQ6C,IAAK7C,CAAAA,KAlDG,CAmDhBN,EAAqBoD,MAAOC,CAAAA,YAnDZ,CAsDhBC,CA2aA,KAAAC,EAAW,CAMV,QAAW,OAND,CAcV,KAAQ,CACP,OAAU/D,CADH,CAEP,OAAUO,CAFH,CAdE,CAkBV,OAAUY,CAlBA,CAmBV,OAAUwB,CAnBA,CAoBV,QA/BDqB,QAAgB,CAAC5C,CAAD,CAAQ,CACvB,MAAO7B,EAAA,CAAU6B,CAAV,CAAiB,QAAQ,CAAC5B,CAAD,CAAS,CACxC,MAAOkE,EAAcO,CAAAA,IAAd,CAAmBzE,CAAnB,CAAA,CACJ,MADI,CACKmD,CAAA,CAAOnD,CAAP,CADL,CAEJA,CAHqC,CAAlC,CADgB,CAWb,CAqBV,UAnDD0E,QAAkB,CAAC9C,CAAD,CAAQ,CACzB,MAAO7B,EAAA,CAAU6B,CAAV,CAAiB,QAAQ,CAAC5B,CAAD,CAAS,CACxC,MAAOiE,EAAcQ,CAAAA,IAAd,CAAmBzE,CAAnB,CAAA,CACJ2B,CAAA,CAAO3B,CAAO2E,CAAAA,KAAP,CAAa,CAAb,CAAgBC,CAAAA,WAAhB,EAAP,CADI,CAEJ5E,CAHqC,CAAlC,CADkB,CA8Bf,CA2BX,IACkB,UADlB,EACC,MAAO6E,OADR;AAEsB,QAFtB,EAEC,MAAOA,OAAOC,CAAAA,GAFf,EAGCD,MAAOC,CAAAA,GAHR,CAKCD,MAAA,CAAO,UAAP,CAAmB,QAAQ,EAAG,CAC7B,MAAON,EADsB,CAA9B,CALD,KAQO,IAAIZ,CAAJ,EAAmBE,CAAnB,CACN,GAAI1E,CAAOC,CAAAA,OAAX,EAAsBuE,CAAtB,CACCE,CAAWzE,CAAAA,OAAX,CAAqBmF,CADtB,KAGC,KAAKD,CAAL,GAAYC,EAAZ,CACCA,CAASQ,CAAAA,cAAT,CAAwBT,CAAxB,CAAA,GAAiCX,CAAA,CAAYW,CAAZ,CAAjC,CAAoDC,CAAA,CAASD,CAAT,CAApD,CALI,KASNjF,EAAKkF,CAAAA,QAAL,CAAgBA,CA7gBD,CAAf,CAAA,CAghBA,IAhhBA,CAF4D;\",\n\"sources\":[\"node_modules/url/node_modules/punycode/punycode.js\"],\n\"sourcesContent\":[\"shadow$provide[304] = function(global,require,module,exports) {\\n/*! https://mths.be/punycode v1.3.2 by @mathias */\\n;(function(root) {\\n\\n\\t/** Detect free variables */\\n\\tvar freeExports = typeof exports == 'object' && exports &&\\n\\t\\t!exports.nodeType && exports;\\n\\tvar freeModule = typeof module == 'object' && module &&\\n\\t\\t!module.nodeType && module;\\n\\tvar freeGlobal = typeof global == 'object' && global;\\n\\tif (\\n\\t\\tfreeGlobal.global === freeGlobal ||\\n\\t\\tfreeGlobal.window === freeGlobal ||\\n\\t\\tfreeGlobal.self === freeGlobal\\n\\t) {\\n\\t\\troot = freeGlobal;\\n\\t}\\n\\n\\t/**\\n\\t * The `punycode` object.\\n\\t * @name punycode\\n\\t * @type Object\\n\\t */\\n\\tvar punycode,\\n\\n\\t/** Highest positive signed 32-bit float value */\\n\\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\\n\\n\\t/** Bootstring parameters */\\n\\tbase = 36,\\n\\ttMin = 1,\\n\\ttMax = 26,\\n\\tskew = 38,\\n\\tdamp = 700,\\n\\tinitialBias = 72,\\n\\tinitialN = 128, // 0x80\\n\\tdelimiter = '-', // '\\\\x2D'\\n\\n\\t/** Regular expressions */\\n\\tregexPunycode = /^xn--/,\\n\\tregexNonASCII = /[^\\\\x20-\\\\x7E]/, // unprintable ASCII chars + non-ASCII chars\\n\\tregexSeparators = /[\\\\x2E\\\\u3002\\\\uFF0E\\\\uFF61]/g, // RFC 3490 separators\\n\\n\\t/** Error messages */\\n\\terrors = {\\n\\t\\t'overflow': 'Overflow: input needs wider integers to process',\\n\\t\\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\\n\\t\\t'invalid-input': 'Invalid input'\\n\\t},\\n\\n\\t/** Convenience shortcuts */\\n\\tbaseMinusTMin = base - tMin,\\n\\tfloor = Math.floor,\\n\\tstringFromCharCode = String.fromCharCode,\\n\\n\\t/** Temporary variable */\\n\\tkey;\\n\\n\\t/*--------------------------------------------------------------------------*/\\n\\n\\t/**\\n\\t * A generic error utility function.\\n\\t * @private\\n\\t * @param {String} type The error type.\\n\\t * @returns {Error} Throws a `RangeError` with the applicable error message.\\n\\t */\\n\\tfunction error(type) {\\n\\t\\tthrow RangeError(errors[type]);\\n\\t}\\n\\n\\t/**\\n\\t * A generic `Array#map` utility function.\\n\\t * @private\\n\\t * @param {Array} array The array to iterate over.\\n\\t * @param {Function} callback The function that gets called for every array\\n\\t * item.\\n\\t * @returns {Array} A new array of values returned by the callback function.\\n\\t */\\n\\tfunction map(array, fn) {\\n\\t\\tvar length = array.length;\\n\\t\\tvar result = [];\\n\\t\\twhile (length--) {\\n\\t\\t\\tresult[length] = fn(array[length]);\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/**\\n\\t * A simple `Array#map`-like wrapper to work with domain name strings or email\\n\\t * addresses.\\n\\t * @private\\n\\t * @param {String} domain The domain name or email address.\\n\\t * @param {Function} callback The function that gets called for every\\n\\t * character.\\n\\t * @returns {Array} A new string of characters returned by the callback\\n\\t * function.\\n\\t */\\n\\tfunction mapDomain(string, fn) {\\n\\t\\tvar parts = string.split('@');\\n\\t\\tvar result = '';\\n\\t\\tif (parts.length > 1) {\\n\\t\\t\\t// In email addresses, only the domain name should be punycoded. Leave\\n\\t\\t\\t// the local part (i.e. everything up to `@`) intact.\\n\\t\\t\\tresult = parts[0] + '@';\\n\\t\\t\\tstring = parts[1];\\n\\t\\t}\\n\\t\\t// Avoid `split(regex)` for IE8 compatibility. See #17.\\n\\t\\tstring = string.replace(regexSeparators, '\\\\x2E');\\n\\t\\tvar labels = string.split('.');\\n\\t\\tvar encoded = map(labels, fn).join('.');\\n\\t\\treturn result + encoded;\\n\\t}\\n\\n\\t/**\\n\\t * Creates an array containing the numeric code points of each Unicode\\n\\t * character in the string. While JavaScript uses UCS-2 internally,\\n\\t * this function will convert a pair of surrogate halves (each of which\\n\\t * UCS-2 exposes as separate characters) into a single code point,\\n\\t * matching UTF-16.\\n\\t * @see `punycode.ucs2.encode`\\n\\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n\\t * @memberOf punycode.ucs2\\n\\t * @name decode\\n\\t * @param {String} string The Unicode input string (UCS-2).\\n\\t * @returns {Array} The new array of code points.\\n\\t */\\n\\tfunction ucs2decode(string) {\\n\\t\\tvar output = [],\\n\\t\\t    counter = 0,\\n\\t\\t    length = string.length,\\n\\t\\t    value,\\n\\t\\t    extra;\\n\\t\\twhile (counter < length) {\\n\\t\\t\\tvalue = string.charCodeAt(counter++);\\n\\t\\t\\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\\n\\t\\t\\t\\t// high surrogate, and there is a next character\\n\\t\\t\\t\\textra = string.charCodeAt(counter++);\\n\\t\\t\\t\\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\\n\\t\\t\\t\\t\\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// unmatched surrogate; only append this code unit, in case the next\\n\\t\\t\\t\\t\\t// code unit is the high surrogate of a surrogate pair\\n\\t\\t\\t\\t\\toutput.push(value);\\n\\t\\t\\t\\t\\tcounter--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput.push(value);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn output;\\n\\t}\\n\\n\\t/**\\n\\t * Creates a string based on an array of numeric code points.\\n\\t * @see `punycode.ucs2.decode`\\n\\t * @memberOf punycode.ucs2\\n\\t * @name encode\\n\\t * @param {Array} codePoints The array of numeric code points.\\n\\t * @returns {String} The new Unicode string (UCS-2).\\n\\t */\\n\\tfunction ucs2encode(array) {\\n\\t\\treturn map(array, function(value) {\\n\\t\\t\\tvar output = '';\\n\\t\\t\\tif (value > 0xFFFF) {\\n\\t\\t\\t\\tvalue -= 0x10000;\\n\\t\\t\\t\\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\\n\\t\\t\\t\\tvalue = 0xDC00 | value & 0x3FF;\\n\\t\\t\\t}\\n\\t\\t\\toutput += stringFromCharCode(value);\\n\\t\\t\\treturn output;\\n\\t\\t}).join('');\\n\\t}\\n\\n\\t/**\\n\\t * Converts a basic code point into a digit/integer.\\n\\t * @see `digitToBasic()`\\n\\t * @private\\n\\t * @param {Number} codePoint The basic numeric code point value.\\n\\t * @returns {Number} The numeric value of a basic code point (for use in\\n\\t * representing integers) in the range `0` to `base - 1`, or `base` if\\n\\t * the code point does not represent a value.\\n\\t */\\n\\tfunction basicToDigit(codePoint) {\\n\\t\\tif (codePoint - 48 < 10) {\\n\\t\\t\\treturn codePoint - 22;\\n\\t\\t}\\n\\t\\tif (codePoint - 65 < 26) {\\n\\t\\t\\treturn codePoint - 65;\\n\\t\\t}\\n\\t\\tif (codePoint - 97 < 26) {\\n\\t\\t\\treturn codePoint - 97;\\n\\t\\t}\\n\\t\\treturn base;\\n\\t}\\n\\n\\t/**\\n\\t * Converts a digit/integer into a basic code point.\\n\\t * @see `basicToDigit()`\\n\\t * @private\\n\\t * @param {Number} digit The numeric value of a basic code point.\\n\\t * @returns {Number} The basic code point whose value (when used for\\n\\t * representing integers) is `digit`, which needs to be in the range\\n\\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\\n\\t * used; else, the lowercase form is used. The behavior is undefined\\n\\t * if `flag` is non-zero and `digit` has no uppercase form.\\n\\t */\\n\\tfunction digitToBasic(digit, flag) {\\n\\t\\t//  0..25 map to ASCII a..z or A..Z\\n\\t\\t// 26..35 map to ASCII 0..9\\n\\t\\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\\n\\t}\\n\\n\\t/**\\n\\t * Bias adaptation function as per section 3.4 of RFC 3492.\\n\\t * http://tools.ietf.org/html/rfc3492#section-3.4\\n\\t * @private\\n\\t */\\n\\tfunction adapt(delta, numPoints, firstTime) {\\n\\t\\tvar k = 0;\\n\\t\\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\\n\\t\\tdelta += floor(delta / numPoints);\\n\\t\\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\\n\\t\\t\\tdelta = floor(delta / baseMinusTMin);\\n\\t\\t}\\n\\t\\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\\n\\t}\\n\\n\\t/**\\n\\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\\n\\t * symbols.\\n\\t * @memberOf punycode\\n\\t * @param {String} input The Punycode string of ASCII-only symbols.\\n\\t * @returns {String} The resulting string of Unicode symbols.\\n\\t */\\n\\tfunction decode(input) {\\n\\t\\t// Don't use UCS-2\\n\\t\\tvar output = [],\\n\\t\\t    inputLength = input.length,\\n\\t\\t    out,\\n\\t\\t    i = 0,\\n\\t\\t    n = initialN,\\n\\t\\t    bias = initialBias,\\n\\t\\t    basic,\\n\\t\\t    j,\\n\\t\\t    index,\\n\\t\\t    oldi,\\n\\t\\t    w,\\n\\t\\t    k,\\n\\t\\t    digit,\\n\\t\\t    t,\\n\\t\\t    /** Cached calculation results */\\n\\t\\t    baseMinusT;\\n\\n\\t\\t// Handle the basic code points: let `basic` be the number of input code\\n\\t\\t// points before the last delimiter, or `0` if there is none, then copy\\n\\t\\t// the first basic code points to the output.\\n\\n\\t\\tbasic = input.lastIndexOf(delimiter);\\n\\t\\tif (basic < 0) {\\n\\t\\t\\tbasic = 0;\\n\\t\\t}\\n\\n\\t\\tfor (j = 0; j < basic; ++j) {\\n\\t\\t\\t// if it's not a basic code point\\n\\t\\t\\tif (input.charCodeAt(j) >= 0x80) {\\n\\t\\t\\t\\terror('not-basic');\\n\\t\\t\\t}\\n\\t\\t\\toutput.push(input.charCodeAt(j));\\n\\t\\t}\\n\\n\\t\\t// Main decoding loop: start just after the last delimiter if any basic code\\n\\t\\t// points were copied; start at the beginning otherwise.\\n\\n\\t\\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\\n\\n\\t\\t\\t// `index` is the index of the next character to be consumed.\\n\\t\\t\\t// Decode a generalized variable-length integer into `delta`,\\n\\t\\t\\t// which gets added to `i`. The overflow checking is easier\\n\\t\\t\\t// if we increase `i` as we go, then subtract off its starting\\n\\t\\t\\t// value at the end to obtain `delta`.\\n\\t\\t\\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\\n\\n\\t\\t\\t\\tif (index >= inputLength) {\\n\\t\\t\\t\\t\\terror('invalid-input');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdigit = basicToDigit(input.charCodeAt(index++));\\n\\n\\t\\t\\t\\tif (digit >= base || digit > floor((maxInt - i) / w)) {\\n\\t\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ti += digit * w;\\n\\t\\t\\t\\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\\n\\n\\t\\t\\t\\tif (digit < t) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbaseMinusT = base - t;\\n\\t\\t\\t\\tif (w > floor(maxInt / baseMinusT)) {\\n\\t\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tw *= baseMinusT;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tout = output.length + 1;\\n\\t\\t\\tbias = adapt(i - oldi, out, oldi == 0);\\n\\n\\t\\t\\t// `i` was supposed to wrap around from `out` to `0`,\\n\\t\\t\\t// incrementing `n` each time, so we'll fix that now:\\n\\t\\t\\tif (floor(i / out) > maxInt - n) {\\n\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t}\\n\\n\\t\\t\\tn += floor(i / out);\\n\\t\\t\\ti %= out;\\n\\n\\t\\t\\t// Insert `n` at position `i` of the output\\n\\t\\t\\toutput.splice(i++, 0, n);\\n\\n\\t\\t}\\n\\n\\t\\treturn ucs2encode(output);\\n\\t}\\n\\n\\t/**\\n\\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\\n\\t * Punycode string of ASCII-only symbols.\\n\\t * @memberOf punycode\\n\\t * @param {String} input The string of Unicode symbols.\\n\\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\\n\\t */\\n\\tfunction encode(input) {\\n\\t\\tvar n,\\n\\t\\t    delta,\\n\\t\\t    handledCPCount,\\n\\t\\t    basicLength,\\n\\t\\t    bias,\\n\\t\\t    j,\\n\\t\\t    m,\\n\\t\\t    q,\\n\\t\\t    k,\\n\\t\\t    t,\\n\\t\\t    currentValue,\\n\\t\\t    output = [],\\n\\t\\t    /** `inputLength` will hold the number of code points in `input`. */\\n\\t\\t    inputLength,\\n\\t\\t    /** Cached calculation results */\\n\\t\\t    handledCPCountPlusOne,\\n\\t\\t    baseMinusT,\\n\\t\\t    qMinusT;\\n\\n\\t\\t// Convert the input in UCS-2 to Unicode\\n\\t\\tinput = ucs2decode(input);\\n\\n\\t\\t// Cache the length\\n\\t\\tinputLength = input.length;\\n\\n\\t\\t// Initialize the state\\n\\t\\tn = initialN;\\n\\t\\tdelta = 0;\\n\\t\\tbias = initialBias;\\n\\n\\t\\t// Handle the basic code points\\n\\t\\tfor (j = 0; j < inputLength; ++j) {\\n\\t\\t\\tcurrentValue = input[j];\\n\\t\\t\\tif (currentValue < 0x80) {\\n\\t\\t\\t\\toutput.push(stringFromCharCode(currentValue));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\thandledCPCount = basicLength = output.length;\\n\\n\\t\\t// `handledCPCount` is the number of code points that have been handled;\\n\\t\\t// `basicLength` is the number of basic code points.\\n\\n\\t\\t// Finish the basic string - if it is not empty - with a delimiter\\n\\t\\tif (basicLength) {\\n\\t\\t\\toutput.push(delimiter);\\n\\t\\t}\\n\\n\\t\\t// Main encoding loop:\\n\\t\\twhile (handledCPCount < inputLength) {\\n\\n\\t\\t\\t// All non-basic code points < n have been handled already. Find the next\\n\\t\\t\\t// larger one:\\n\\t\\t\\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\\n\\t\\t\\t\\tcurrentValue = input[j];\\n\\t\\t\\t\\tif (currentValue >= n && currentValue < m) {\\n\\t\\t\\t\\t\\tm = currentValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\\n\\t\\t\\t// but guard against overflow\\n\\t\\t\\thandledCPCountPlusOne = handledCPCount + 1;\\n\\t\\t\\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\\n\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t}\\n\\n\\t\\t\\tdelta += (m - n) * handledCPCountPlusOne;\\n\\t\\t\\tn = m;\\n\\n\\t\\t\\tfor (j = 0; j < inputLength; ++j) {\\n\\t\\t\\t\\tcurrentValue = input[j];\\n\\n\\t\\t\\t\\tif (currentValue < n && ++delta > maxInt) {\\n\\t\\t\\t\\t\\terror('overflow');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (currentValue == n) {\\n\\t\\t\\t\\t\\t// Represent delta as a generalized variable-length integer\\n\\t\\t\\t\\t\\tfor (q = delta, k = base; /* no condition */; k += base) {\\n\\t\\t\\t\\t\\t\\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\\n\\t\\t\\t\\t\\t\\tif (q < t) {\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqMinusT = q - t;\\n\\t\\t\\t\\t\\t\\tbaseMinusT = base - t;\\n\\t\\t\\t\\t\\t\\toutput.push(\\n\\t\\t\\t\\t\\t\\t\\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\tq = floor(qMinusT / baseMinusT);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\\n\\t\\t\\t\\t\\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\\n\\t\\t\\t\\t\\tdelta = 0;\\n\\t\\t\\t\\t\\t++handledCPCount;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t++delta;\\n\\t\\t\\t++n;\\n\\n\\t\\t}\\n\\t\\treturn output.join('');\\n\\t}\\n\\n\\t/**\\n\\t * Converts a Punycode string representing a domain name or an email address\\n\\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\\n\\t * it doesn't matter if you call it on a string that has already been\\n\\t * converted to Unicode.\\n\\t * @memberOf punycode\\n\\t * @param {String} input The Punycoded domain name or email address to\\n\\t * convert to Unicode.\\n\\t * @returns {String} The Unicode representation of the given Punycode\\n\\t * string.\\n\\t */\\n\\tfunction toUnicode(input) {\\n\\t\\treturn mapDomain(input, function(string) {\\n\\t\\t\\treturn regexPunycode.test(string)\\n\\t\\t\\t\\t? decode(string.slice(4).toLowerCase())\\n\\t\\t\\t\\t: string;\\n\\t\\t});\\n\\t}\\n\\n\\t/**\\n\\t * Converts a Unicode string representing a domain name or an email address to\\n\\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\\n\\t * i.e. it doesn't matter if you call it with a domain that's already in\\n\\t * ASCII.\\n\\t * @memberOf punycode\\n\\t * @param {String} input The domain name or email address to convert, as a\\n\\t * Unicode string.\\n\\t * @returns {String} The Punycode representation of the given domain name or\\n\\t * email address.\\n\\t */\\n\\tfunction toASCII(input) {\\n\\t\\treturn mapDomain(input, function(string) {\\n\\t\\t\\treturn regexNonASCII.test(string)\\n\\t\\t\\t\\t? 'xn--' + encode(string)\\n\\t\\t\\t\\t: string;\\n\\t\\t});\\n\\t}\\n\\n\\t/*--------------------------------------------------------------------------*/\\n\\n\\t/** Define the public API */\\n\\tpunycode = {\\n\\t\\t/**\\n\\t\\t * A string representing the current Punycode.js version number.\\n\\t\\t * @memberOf punycode\\n\\t\\t * @type String\\n\\t\\t */\\n\\t\\t'version': '1.3.2',\\n\\t\\t/**\\n\\t\\t * An object of methods to convert from JavaScript's internal character\\n\\t\\t * representation (UCS-2) to Unicode code points, and back.\\n\\t\\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\\n\\t\\t * @memberOf punycode\\n\\t\\t * @type Object\\n\\t\\t */\\n\\t\\t'ucs2': {\\n\\t\\t\\t'decode': ucs2decode,\\n\\t\\t\\t'encode': ucs2encode\\n\\t\\t},\\n\\t\\t'decode': decode,\\n\\t\\t'encode': encode,\\n\\t\\t'toASCII': toASCII,\\n\\t\\t'toUnicode': toUnicode\\n\\t};\\n\\n\\t/** Expose `punycode` */\\n\\t// Some AMD build optimizers, like r.js, check for specific condition patterns\\n\\t// like the following:\\n\\tif (\\n\\t\\ttypeof define == 'function' &&\\n\\t\\ttypeof define.amd == 'object' &&\\n\\t\\tdefine.amd\\n\\t) {\\n\\t\\tdefine('punycode', function() {\\n\\t\\t\\treturn punycode;\\n\\t\\t});\\n\\t} else if (freeExports && freeModule) {\\n\\t\\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\\n\\t\\t\\tfreeModule.exports = punycode;\\n\\t\\t} else { // in Narwhal or RingoJS v0.7.0-\\n\\t\\t\\tfor (key in punycode) {\\n\\t\\t\\t\\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else { // in Rhino or a web browser\\n\\t\\troot.punycode = punycode;\\n\\t}\\n\\n}(this));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"root\",\"error\",\"type\",\"RangeError\",\"errors\",\"map\",\"array\",\"fn\",\"length\",\"result\",\"mapDomain\",\"string\",\"parts\",\"split\",\"replace\",\"regexSeparators\",\"labels\",\"encoded\",\"join\",\"ucs2decode\",\"output\",\"counter\",\"value\",\"extra\",\"charCodeAt\",\"push\",\"ucs2encode\",\"stringFromCharCode\",\"adapt\",\"delta\",\"numPoints\",\"firstTime\",\"k\",\"floor\",\"damp\",\"base\",\"baseMinusTMin\",\"skew\",\"decode\",\"input\",\"inputLength\",\"i\",\"n\",\"initialN\",\"bias\",\"initialBias\",\"j\",\"basic\",\"lastIndexOf\",\"delimiter\",\"index\",\"oldi\",\"w\",\"codePoint\",\"digit\",\"maxInt\",\"t\",\"tMin\",\"tMax\",\"baseMinusT\",\"out\",\"splice\",\"encode\",\"handledCPCount\",\"basicLength\",\"currentValue\",\"m\",\"handledCPCountPlusOne\",\"q\",\"qMinusT\",\"freeExports\",\"nodeType\",\"freeModule\",\"freeGlobal\",\"window\",\"self\",\"regexPunycode\",\"regexNonASCII\",\"Math\",\"String\",\"fromCharCode\",\"key\",\"punycode\",\"toASCII\",\"test\",\"toUnicode\",\"slice\",\"toLowerCase\",\"define\",\"amd\",\"hasOwnProperty\"]\n}\n"]