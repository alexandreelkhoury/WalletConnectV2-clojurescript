["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/viem/_cjs/utils/data/slice.js"],"~:js","shadow$provide.module$node_modules$viem$_cjs$utils$data$slice=function(global,require,module,exports){function assertStartOffset(value,start){if(\"number\"===typeof start&&0<start&&start>(0,size_js_1.size)(value)-1)throw new data_js_1.SliceOffsetOutOfBoundsError({offset:start,position:\"start\",size:(0,size_js_1.size)(value)});}function assertEndOffset(value,start,end){if(\"number\"===typeof start&&\"number\"===typeof end&&(0,size_js_1.size)(value)!==end-start)throw new data_js_1.SliceOffsetOutOfBoundsError({offset:end,\nposition:\"end\",size:(0,size_js_1.size)(value)});}function sliceBytes(value_,start,end,{strict}={}){assertStartOffset(value_,start);value_=value_.slice(start,end);strict&&assertEndOffset(value_,start,end);return value_}function sliceHex(value_,start,end,{strict}={}){assertStartOffset(value_,start);value_=`0x${value_.replace(\"0x\",\"\").slice(2*(start??0),2*(end??value_.length))}`;strict&&assertEndOffset(value_,start,end);return value_}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.sliceHex=\nexports.sliceBytes=exports.slice=void 0;const data_js_1=require(\"module$node_modules$viem$_cjs$errors$data\"),isHex_js_1=require(\"module$node_modules$viem$_cjs$utils$data$isHex\"),size_js_1=require(\"module$node_modules$viem$_cjs$utils$data$size\");exports.slice=function(value,start,end,{strict}={}){return(0,isHex_js_1.isHex)(value,{strict:!1})?sliceHex(value,start,end,{strict}):sliceBytes(value,start,end,{strict})};exports.sliceBytes=sliceBytes;exports.sliceHex=sliceHex}","~:source","shadow$provide[\"module$node_modules$viem$_cjs$utils$data$slice\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sliceHex = exports.sliceBytes = exports.slice = void 0;\nconst data_js_1 = require(\"../../errors/data.js\");\nconst isHex_js_1 = require(\"./isHex.js\");\nconst size_js_1 = require(\"./size.js\");\nfunction slice(value, start, end, { strict } = {}) {\n    if ((0, isHex_js_1.isHex)(value, { strict: false }))\n        return sliceHex(value, start, end, {\n            strict,\n        });\n    return sliceBytes(value, start, end, {\n        strict,\n    });\n}\nexports.slice = slice;\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > (0, size_js_1.size)(value) - 1)\n        throw new data_js_1.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: (0, size_js_1.size)(value),\n        });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        (0, size_js_1.size)(value) !== end - start) {\n        throw new data_js_1.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: (0, size_js_1.size)(value),\n        });\n    }\n}\nfunction sliceBytes(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = value_.slice(start, end);\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\nexports.sliceBytes = sliceBytes;\nfunction sliceHex(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = `0x${value_\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\nexports.sliceHex = sliceHex;\n//# sourceMappingURL=slice.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$viem$_cjs$errors$data","~$shadow.js","~$module$node_modules$viem$_cjs$utils$data$isHex","~$module$node_modules$viem$_cjs$utils$data$size"]],"~:properties",["^5",["offset","sliceHex","__esModule","sliceBytes","position","value","slice","strict","size"]],"~:compiled-at",1695111490231,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$viem$_cjs$utils$data$slice.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/viem/_cjs/utils/data/slice.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$viem$_cjs$utils$data$slice\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.sliceHex = exports.sliceBytes = exports.slice = void 0;\\nconst data_js_1 = require(\\\"../../errors/data.js\\\");\\nconst isHex_js_1 = require(\\\"./isHex.js\\\");\\nconst size_js_1 = require(\\\"./size.js\\\");\\nfunction slice(value, start, end, { strict } = {}) {\\n    if ((0, isHex_js_1.isHex)(value, { strict: false }))\\n        return sliceHex(value, start, end, {\\n            strict,\\n        });\\n    return sliceBytes(value, start, end, {\\n        strict,\\n    });\\n}\\nexports.slice = slice;\\nfunction assertStartOffset(value, start) {\\n    if (typeof start === 'number' && start > 0 && start > (0, size_js_1.size)(value) - 1)\\n        throw new data_js_1.SliceOffsetOutOfBoundsError({\\n            offset: start,\\n            position: 'start',\\n            size: (0, size_js_1.size)(value),\\n        });\\n}\\nfunction assertEndOffset(value, start, end) {\\n    if (typeof start === 'number' &&\\n        typeof end === 'number' &&\\n        (0, size_js_1.size)(value) !== end - start) {\\n        throw new data_js_1.SliceOffsetOutOfBoundsError({\\n            offset: end,\\n            position: 'end',\\n            size: (0, size_js_1.size)(value),\\n        });\\n    }\\n}\\nfunction sliceBytes(value_, start, end, { strict } = {}) {\\n    assertStartOffset(value_, start);\\n    const value = value_.slice(start, end);\\n    if (strict)\\n        assertEndOffset(value, start, end);\\n    return value;\\n}\\nexports.sliceBytes = sliceBytes;\\nfunction sliceHex(value_, start, end, { strict } = {}) {\\n    assertStartOffset(value_, start);\\n    const value = `0x${value_\\n        .replace('0x', '')\\n        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;\\n    if (strict)\\n        assertEndOffset(value, start, end);\\n    return value;\\n}\\nexports.sliceHex = sliceHex;\\n//# sourceMappingURL=slice.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"assertStartOffset\",\"value\",\"start\",\"size_js_1\",\"size\",\"data_js_1\",\"SliceOffsetOutOfBoundsError\",\"offset\",\"position\",\"assertEndOffset\",\"end\",\"sliceBytes\",\"value_\",\"strict\",\"slice\",\"sliceHex\",\"replace\",\"length\",\"Object\",\"defineProperty\",\"isHex_js_1\",\"isHex\"]\n}\n"]