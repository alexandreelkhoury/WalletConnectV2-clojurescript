["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/hdnode/lib/index.js"],"~:js","shadow$provide[281]=function(S,A,V,q){function F(J){return(0,n.hexZeroPad)((0,n.hexlify)(J),32)}function G(J){return p.Base58.encode((0,n.concat)([J,(0,n.hexDataSlice)((0,E.sha256)((0,E.sha256)(J)),0,4)]))}function r(J){if(null==J)return D.wordlists.en;if(\"string\"===typeof J){var T=D.wordlists[J];null==T&&C.throwArgumentError(\"unknown locale\",\"wordlist\",J);return T}return J}function y(J,T){T||(T=\"\");T=(0,h.toUtf8Bytes)(\"mnemonic\"+T,h.UnicodeNormalizationForm.NFKD);return(0,k.pbkdf2)((0,h.toUtf8Bytes)(J,\nh.UnicodeNormalizationForm.NFKD),T,2048,64,\"sha512\")}function e(J,T){T=r(T);C.checkNormalize();var N=T.split(J);if(0!==N.length%3)throw Error(\"invalid mnemonic\");J=(0,n.arrayify)(new Uint8Array(Math.ceil(11*N.length/8)));for(var a=0,b=0;b<N.length;b++){var c=T.getWordIndex(N[b].normalize(\"NFKD\"));if(-1===c)throw Error(\"invalid mnemonic\");for(var d=0;11>d;d++)c&1<<10-d&&(J[a>>3]|=1<<7-a%8),a++}T=32*N.length/3;N=N.length/3;N=(1<<N)-1<<8-N;if(((0,n.arrayify)((0,E.sha256)(J.slice(0,T/8)))[0]&N)!==(J[J.length-\n1]&N))throw Error(\"invalid checksum\");return(0,n.hexlify)(J.slice(0,T/8))}function u(J,T){T=r(T);J=(0,n.arrayify)(J);if(0!==J.length%4||16>J.length||32<J.length)throw Error(\"invalid entropy\");for(var N=[0],a=11,b=0;b<J.length;b++)8<a?(N[N.length-1]<<=8,N[N.length-1]|=J[b],a-=8):(N[N.length-1]<<=a,N[N.length-1]|=J[b]>>8-a,N.push(J[b]&(1<<8-a)-1),a+=3);a=J.length/4;J=(0,n.arrayify)((0,E.sha256)(J))[0]&(1<<a)-1<<8-a;N[N.length-1]<<=a;N[N.length-1]|=J>>8-a;return T.join(N.map(function(c){return T.getWord(c)}))}\nObject.defineProperty(q,\"__esModule\",{value:!0});q.getAccountPath=q.isValidMnemonic=q.entropyToMnemonic=q.mnemonicToEntropy=q.mnemonicToSeed=q.HDNode=q.defaultPath=void 0;var p=A(110),n=A(11),l=A(15),h=A(44),k=A(263),t=A(17),B=A(105),E=A(267),H=A(107),D=A(279);S=A(9);A=A(280);var C=new S.Logger(A.version),I=l.BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),M=(0,h.toUtf8Bytes)(\"Bitcoin seed\"),P={};q.defaultPath=\"m/44'/60'/0'/0/0\";A=function(){function J(T,N,a,b,\nc,d,f,g){if(T!==P)throw Error(\"HDNode constructor cannot be called directly\");N?(T=new B.SigningKey(N),(0,t.defineReadOnly)(this,\"privateKey\",T.privateKey),(0,t.defineReadOnly)(this,\"publicKey\",T.compressedPublicKey)):((0,t.defineReadOnly)(this,\"privateKey\",null),(0,t.defineReadOnly)(this,\"publicKey\",(0,n.hexlify)(a)));(0,t.defineReadOnly)(this,\"parentFingerprint\",b);(0,t.defineReadOnly)(this,\"fingerprint\",(0,n.hexDataSlice)((0,E.ripemd160)((0,E.sha256)(this.publicKey)),0,4));(0,t.defineReadOnly)(this,\n\"address\",(0,H.computeAddress)(this.publicKey));(0,t.defineReadOnly)(this,\"chainCode\",c);(0,t.defineReadOnly)(this,\"index\",d);(0,t.defineReadOnly)(this,\"depth\",f);null==g?((0,t.defineReadOnly)(this,\"mnemonic\",null),(0,t.defineReadOnly)(this,\"path\",null)):\"string\"===typeof g?((0,t.defineReadOnly)(this,\"mnemonic\",null),(0,t.defineReadOnly)(this,\"path\",g)):((0,t.defineReadOnly)(this,\"mnemonic\",g),(0,t.defineReadOnly)(this,\"path\",g.path))}Object.defineProperty(J.prototype,\"extendedKey\",{get:function(){if(256<=\nthis.depth)throw Error(\"Depth too large!\");return G((0,n.concat)([null!=this.privateKey?\"0x0488ADE4\":\"0x0488B21E\",(0,n.hexlify)(this.depth),this.parentFingerprint,(0,n.hexZeroPad)((0,n.hexlify)(this.index),4),this.chainCode,null!=this.privateKey?(0,n.concat)([\"0x00\",this.privateKey]):this.publicKey]))},enumerable:!1,configurable:!0});J.prototype.neuter=function(){return new J(P,null,this.publicKey,this.parentFingerprint,this.chainCode,this.index,this.depth,this.path)};J.prototype._derive=function(T){if(4294967295<\nT)throw Error(\"invalid index - \"+String(T));var N=this.path;N&&(N+=\"/\"+(T&2147483647));var a=new Uint8Array(37);if(T&2147483648){if(!this.privateKey)throw Error(\"cannot derive child of neutered node\");a.set((0,n.arrayify)(this.privateKey),1);N&&(N+=\"'\")}else a.set((0,n.arrayify)(this.publicKey));for(var b=24;0<=b;b-=8)a[33+(b>>3)]=T>>24-b&255;a=(0,n.arrayify)((0,E.computeHmac)(E.SupportedAlgorithm.sha512,this.chainCode,a));var c=a.slice(0,32);a=a.slice(32);var d=b=null;this.privateKey?b=F(l.BigNumber.from(c).add(this.privateKey).mod(I)):\nd=(new B.SigningKey((0,n.hexlify)(c)))._addPoint(this.publicKey);c=N;var f=this.mnemonic;f&&(c=Object.freeze({phrase:f.phrase,path:N,locale:f.locale||\"en\"}));return new J(P,b,d,this.fingerprint,F(a),T,this.depth+1,c)};J.prototype.derivePath=function(T){var N=T.split(\"/\");if(0===N.length||\"m\"===N[0]&&0!==this.depth)throw Error(\"invalid path - \"+T);\"m\"===N[0]&&N.shift();T=this;for(var a=0;a<N.length;a++){var b=N[a];if(b.match(/^[0-9]+'$/)){var c=parseInt(b.substring(0,b.length-1));if(2147483648<=c)throw Error(\"invalid path index - \"+\nb);T=T._derive(2147483648+c)}else if(b.match(/^[0-9]+$/)){c=parseInt(b);if(2147483648<=c)throw Error(\"invalid path index - \"+b);T=T._derive(c)}else throw Error(\"invalid path component - \"+b);}return T};J._fromSeed=function(T,N){T=(0,n.arrayify)(T);if(16>T.length||64<T.length)throw Error(\"invalid seed\");T=(0,n.arrayify)((0,E.computeHmac)(E.SupportedAlgorithm.sha512,M,T));return new J(P,F(T.slice(0,32)),null,\"0x00000000\",F(T.slice(32)),0,0,N)};J.fromMnemonic=function(T,N,a){a=r(a);T=u(e(T,a),a);return J._fromSeed(y(T,\nN),{phrase:T,path:\"m\",locale:a.locale})};J.fromSeed=function(T){return J._fromSeed(T,null)};J.fromExtendedKey=function(T){var N=p.Base58.decode(T);82===N.length&&G(N.slice(0,78))===T||C.throwArgumentError(\"invalid extended key\",\"extendedKey\",\"[REDACTED]\");T=N[4];var a=(0,n.hexlify)(N.slice(5,9)),b=parseInt((0,n.hexlify)(N.slice(9,13)).substring(2),16),c=(0,n.hexlify)(N.slice(13,45)),d=N.slice(45,78);switch((0,n.hexlify)(N.slice(0,4))){case \"0x0488b21e\":case \"0x043587cf\":return new J(P,null,(0,n.hexlify)(d),\na,c,b,T,null);case \"0x0488ade4\":case \"0x04358394 \":if(0===d[0])return new J(P,(0,n.hexlify)(d.slice(1)),null,a,c,b,T,null)}return C.throwArgumentError(\"invalid extended key\",\"extendedKey\",\"[REDACTED]\")};return J}();q.HDNode=A;q.mnemonicToSeed=y;q.mnemonicToEntropy=e;q.entropyToMnemonic=u;q.isValidMnemonic=function(J,T){try{return e(J,T),!0}catch(N){}return!1};q.getAccountPath=function(J){(\"number\"!==typeof J||0>J||2147483648<=J||J%1)&&C.throwArgumentError(\"invalid account index\",\"index\",J);return\"m/44'/60'/\"+\nJ+\"'/0/0\"}}","~:source","shadow$provide[281] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAccountPath = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.mnemonicToSeed = exports.HDNode = exports.defaultPath = void 0;\nvar basex_1 = require(\"@ethersproject/basex\");\nvar bytes_1 = require(\"@ethersproject/bytes\");\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\nvar strings_1 = require(\"@ethersproject/strings\");\nvar pbkdf2_1 = require(\"@ethersproject/pbkdf2\");\nvar properties_1 = require(\"@ethersproject/properties\");\nvar signing_key_1 = require(\"@ethersproject/signing-key\");\nvar sha2_1 = require(\"@ethersproject/sha2\");\nvar transactions_1 = require(\"@ethersproject/transactions\");\nvar wordlists_1 = require(\"@ethersproject/wordlists\");\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar N = bignumber_1.BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n// \"Bitcoin seed\"\nvar MasterSecret = (0, strings_1.toUtf8Bytes)(\"Bitcoin seed\");\nvar HardenedBit = 0x80000000;\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n    return ((1 << bits) - 1) << (8 - bits);\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n    return (1 << bits) - 1;\n}\nfunction bytes32(value) {\n    return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);\n}\nfunction base58check(data) {\n    return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));\n}\nfunction getWordlist(wordlist) {\n    if (wordlist == null) {\n        return wordlists_1.wordlists[\"en\"];\n    }\n    if (typeof (wordlist) === \"string\") {\n        var words = wordlists_1.wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n    return wordlist;\n}\nvar _constructorGuard = {};\nexports.defaultPath = \"m/44'/60'/0'/0/0\";\n;\nvar HDNode = /** @class */ (function () {\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    function HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n        if (privateKey) {\n            var signingKey = new signing_key_1.SigningKey(privateKey);\n            (0, properties_1.defineReadOnly)(this, \"privateKey\", signingKey.privateKey);\n            (0, properties_1.defineReadOnly)(this, \"publicKey\", signingKey.compressedPublicKey);\n        }\n        else {\n            (0, properties_1.defineReadOnly)(this, \"privateKey\", null);\n            (0, properties_1.defineReadOnly)(this, \"publicKey\", (0, bytes_1.hexlify)(publicKey));\n        }\n        (0, properties_1.defineReadOnly)(this, \"parentFingerprint\", parentFingerprint);\n        (0, properties_1.defineReadOnly)(this, \"fingerprint\", (0, bytes_1.hexDataSlice)((0, sha2_1.ripemd160)((0, sha2_1.sha256)(this.publicKey)), 0, 4));\n        (0, properties_1.defineReadOnly)(this, \"address\", (0, transactions_1.computeAddress)(this.publicKey));\n        (0, properties_1.defineReadOnly)(this, \"chainCode\", chainCode);\n        (0, properties_1.defineReadOnly)(this, \"index\", index);\n        (0, properties_1.defineReadOnly)(this, \"depth\", depth);\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            (0, properties_1.defineReadOnly)(this, \"mnemonic\", null);\n            (0, properties_1.defineReadOnly)(this, \"path\", null);\n        }\n        else if (typeof (mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            (0, properties_1.defineReadOnly)(this, \"mnemonic\", null);\n            (0, properties_1.defineReadOnly)(this, \"path\", mnemonicOrPath);\n        }\n        else {\n            // From a fully qualified source\n            (0, properties_1.defineReadOnly)(this, \"mnemonic\", mnemonicOrPath);\n            (0, properties_1.defineReadOnly)(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n    Object.defineProperty(HDNode.prototype, \"extendedKey\", {\n        get: function () {\n            // We only support the mainnet values for now, but if anyone needs\n            // testnet values, let me know. I believe current sentiment is that\n            // we should always use mainnet, and use BIP-44 to derive the network\n            //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n            //   - Testnet: public=0x043587CF, private=0x04358394\n            if (this.depth >= 256) {\n                throw new Error(\"Depth too large!\");\n            }\n            return base58check((0, bytes_1.concat)([\n                ((this.privateKey != null) ? \"0x0488ADE4\" : \"0x0488B21E\"),\n                (0, bytes_1.hexlify)(this.depth),\n                this.parentFingerprint,\n                (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(this.index), 4),\n                this.chainCode,\n                ((this.privateKey != null) ? (0, bytes_1.concat)([\"0x00\", this.privateKey]) : this.publicKey),\n            ]));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    HDNode.prototype.neuter = function () {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    };\n    HDNode.prototype._derive = function (index) {\n        if (index > 0xffffffff) {\n            throw new Error(\"invalid index - \" + String(index));\n        }\n        // Base path\n        var path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n        }\n        var data = new Uint8Array(37);\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n            // Data = 0x00 || ser_256(k_par)\n            data.set((0, bytes_1.arrayify)(this.privateKey), 1);\n            // Hardened path\n            if (path) {\n                path += \"'\";\n            }\n        }\n        else {\n            // Data = ser_p(point(k_par))\n            data.set((0, bytes_1.arrayify)(this.publicKey));\n        }\n        // Data += ser_32(i)\n        for (var i = 24; i >= 0; i -= 8) {\n            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\n        }\n        var I = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, this.chainCode, data));\n        var IL = I.slice(0, 32);\n        var IR = I.slice(32);\n        // The private key\n        var ki = null;\n        // The public key\n        var Ki = null;\n        if (this.privateKey) {\n            ki = bytes32(bignumber_1.BigNumber.from(IL).add(this.privateKey).mod(N));\n        }\n        else {\n            var ek = new signing_key_1.SigningKey((0, bytes_1.hexlify)(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n        var mnemonicOrPath = path;\n        var srcMnemonic = this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    };\n    HDNode.prototype.derivePath = function (path) {\n        var components = path.split(\"/\");\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n        if (components[0] === \"m\") {\n            components.shift();\n        }\n        var result = this;\n        for (var i = 0; i < components.length; i++) {\n            var component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                var index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) {\n                    throw new Error(\"invalid path index - \" + component);\n                }\n                result = result._derive(HardenedBit + index);\n            }\n            else if (component.match(/^[0-9]+$/)) {\n                var index = parseInt(component);\n                if (index >= HardenedBit) {\n                    throw new Error(\"invalid path index - \" + component);\n                }\n                result = result._derive(index);\n            }\n            else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n        return result;\n    };\n    HDNode._fromSeed = function (seed, mnemonic) {\n        var seedArray = (0, bytes_1.arrayify)(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) {\n            throw new Error(\"invalid seed\");\n        }\n        var I = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, MasterSecret, seedArray));\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    };\n    HDNode.fromMnemonic = function (mnemonic, password, wordlist) {\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    };\n    HDNode.fromSeed = function (seed) {\n        return HDNode._fromSeed(seed, null);\n    };\n    HDNode.fromExtendedKey = function (extendedKey) {\n        var bytes = basex_1.Base58.decode(extendedKey);\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n        var depth = bytes[4];\n        var parentFingerprint = (0, bytes_1.hexlify)(bytes.slice(5, 9));\n        var index = parseInt((0, bytes_1.hexlify)(bytes.slice(9, 13)).substring(2), 16);\n        var chainCode = (0, bytes_1.hexlify)(bytes.slice(13, 45));\n        var key = bytes.slice(45, 78);\n        switch ((0, bytes_1.hexlify)(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\":\n            case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, (0, bytes_1.hexlify)(key), parentFingerprint, chainCode, index, depth, null);\n            // Private Key\n            case \"0x0488ade4\":\n            case \"0x04358394 \":\n                if (key[0] !== 0) {\n                    break;\n                }\n                return new HDNode(_constructorGuard, (0, bytes_1.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    };\n    return HDNode;\n}());\nexports.HDNode = HDNode;\nfunction mnemonicToSeed(mnemonic, password) {\n    if (!password) {\n        password = \"\";\n    }\n    var salt = (0, strings_1.toUtf8Bytes)(\"mnemonic\" + password, strings_1.UnicodeNormalizationForm.NFKD);\n    return (0, pbkdf2_1.pbkdf2)((0, strings_1.toUtf8Bytes)(mnemonic, strings_1.UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = getWordlist(wordlist);\n    logger.checkNormalize();\n    var words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) {\n        throw new Error(\"invalid mnemonic\");\n    }\n    var entropy = (0, bytes_1.arrayify)(new Uint8Array(Math.ceil(11 * words.length / 8)));\n    var offset = 0;\n    for (var i = 0; i < words.length; i++) {\n        var index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) {\n            throw new Error(\"invalid mnemonic\");\n        }\n        for (var bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n    var entropyBits = 32 * words.length / 3;\n    var checksumBits = words.length / 3;\n    var checksumMask = getUpperMask(checksumBits);\n    var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n    return (0, bytes_1.hexlify)(entropy.slice(0, entropyBits / 8));\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n    wordlist = getWordlist(wordlist);\n    entropy = (0, bytes_1.arrayify)(entropy);\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n    var indices = [0];\n    var remainingBits = 11;\n    for (var i = 0; i < entropy.length; i++) {\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n            remainingBits -= 8;\n            // This byte will complete an 11-bit index\n        }\n        else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n            remainingBits += 3;\n        }\n    }\n    // Compute the checksum bits\n    var checksumBits = entropy.length / 4;\n    var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy))[0] & getUpperMask(checksumBits);\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n    return wordlist.join(indices.map(function (index) { return wordlist.getWord(index); }));\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction isValidMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexports.isValidMnemonic = isValidMnemonic;\nfunction getAccountPath(index) {\n    if (typeof (index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return \"m/44'/60'/\" + index + \"'/0/0\";\n}\nexports.getAccountPath = getAccountPath;\n//# sourceMappingURL=index.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$ethersproject$hdnode$lib$_version","~$module$node_modules$$ethersproject$signing_key$lib$index","~$module$node_modules$$ethersproject$strings$lib$index","~$module$node_modules$$ethersproject$pbkdf2$lib$index","~$module$node_modules$$ethersproject$sha2$lib$index","~$shadow.js","~$module$node_modules$$ethersproject$bytes$lib$index","~$module$node_modules$$ethersproject$bignumber$lib$index","~$module$node_modules$$ethersproject$transactions$lib$index","~$module$node_modules$$ethersproject$logger$lib$index","~$module$node_modules$$ethersproject$wordlists$lib$index","~$module$node_modules$$ethersproject$properties$lib$index","~$module$node_modules$$ethersproject$basex$lib$index"]],"~:properties",["^5",["defaultPath","phrase","__esModule","path","fromExtendedKey","configurable","locale","value","neuter","enumerable","extendedKey","isValidMnemonic","fromMnemonic","entropyToMnemonic","mnemonicToSeed","derivePath","_fromSeed","_derive","getAccountPath","HDNode","mnemonicToEntropy","get","fromSeed"]],"~:compiled-at",1695041440882,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$hdnode$lib$index.js\",\n\"lineCount\":13,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CA6B9DC,QAASA,EAAO,CAACC,CAAD,CAAQ,CACpB,MAAO,GAAIC,CAAQC,CAAAA,UAAZ,EAAwB,GAAID,CAAQE,CAAAA,OAAZ,EAAqBH,CAArB,CAAxB,CAAqD,EAArD,CADa,CAGxBI,QAASA,EAAW,CAACC,CAAD,CAAO,CACvB,MAAOC,EAAQC,CAAAA,MAAOC,CAAAA,MAAf,CAAsB,GAAIP,CAAQQ,CAAAA,MAAZ,EAAoB,CAACJ,CAAD,CAAO,GAAIJ,CAAQS,CAAAA,YAAZ,EAA0B,GAAIC,CAAOC,CAAAA,MAAX,EAAmB,GAAID,CAAOC,CAAAA,MAAX,EAAmBP,CAAnB,CAAnB,CAA1B,CAAwE,CAAxE,CAA2E,CAA3E,CAAP,CAApB,CAAtB,CADgB,CAG3BQ,QAASA,EAAW,CAACC,CAAD,CAAW,CAC3B,GAAgB,IAAhB,EAAIA,CAAJ,CACI,MAAOC,EAAYC,CAAAA,SAAZ,CAAA,EAEX,IAA0B,QAA1B,GAAI,MAAQF,EAAZ,CAAoC,CAChC,IAAIG,EAAQF,CAAYC,CAAAA,SAAZ,CAAsBF,CAAtB,CACC,KAAb,EAAIG,CAAJ,EACIC,CAAOC,CAAAA,kBAAP,CAA0B,gBAA1B,CAA4C,UAA5C,CAAwDL,CAAxD,CAEJ,OAAOG,EALyB,CAOpC,MAAOH,EAXoB,CA4N/BM,QAASA,EAAc,CAACC,CAAD,CAAWC,CAAX,CAAqB,CACnCA,CAAL,GACIA,CADJ,CACe,EADf,CAGIC,EAAAA,CAAO,GAAIC,CAAUC,CAAAA,WAAd,EAA2B,UAA3B,CAAwCH,CAAxC,CAAkDE,CAAUE,CAAAA,wBAAyBC,CAAAA,IAArF,CACX,OAAO,GAAIC,CAASC,CAAAA,MAAb,EAAqB,GAAIL,CAAUC,CAAAA,WAAd,EAA2BJ,CAA3B;AAAqCG,CAAUE,CAAAA,wBAAyBC,CAAAA,IAAxE,CAArB,CAAoGJ,CAApG,CAA0G,IAA1G,CAAgH,EAAhH,CAAoH,QAApH,CALiC,CAQ5CO,QAASA,EAAiB,CAACT,CAAD,CAAWP,CAAX,CAAqB,CAC3CA,CAAA,CAAWD,CAAA,CAAYC,CAAZ,CACXI,EAAOa,CAAAA,cAAP,EACA,KAAId,EAAQH,CAASkB,CAAAA,KAAT,CAAeX,CAAf,CACZ,IAA2B,CAA3B,GAAKJ,CAAMgB,CAAAA,MAAX,CAAoB,CAApB,CACI,KAAUC,MAAJ,CAAU,kBAAV,CAAN,CAEAC,CAAAA,CAAU,GAAIlC,CAAQmC,CAAAA,QAAZ,EAAsB,IAAIC,UAAJ,CAAeC,IAAKC,CAAAA,IAAL,CAAU,EAAV,CAAetB,CAAMgB,CAAAA,MAArB,CAA8B,CAA9B,CAAf,CAAtB,CAEd,KADA,IAAIO,EAAS,CAAb,CACSC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBxB,CAAMgB,CAAAA,MAA1B,CAAkCQ,CAAA,EAAlC,CAAuC,CACnC,IAAIC,EAAQ5B,CAAS6B,CAAAA,YAAT,CAAsB1B,CAAA,CAAMwB,CAAN,CAASG,CAAAA,SAAT,CAAmB,MAAnB,CAAtB,CACZ,IAAc,CAAC,CAAf,GAAIF,CAAJ,CACI,KAAUR,MAAJ,CAAU,kBAAV,CAAN,CAEJ,IAAK,IAAIW,EAAM,CAAf,CAAwB,EAAxB,CAAkBA,CAAlB,CAA4BA,CAAA,EAA5B,CACQH,CAGJ,CAHa,CAGb,EAHmB,EAGnB,CAHwBG,CAGxB,GAFIV,CAAA,CAAQK,CAAR,EAAkB,CAAlB,CAEJ,EAF6B,CAE7B,EAFmC,CAEnC,CAFwCA,CAExC,CAFiD,CAEjD,EAAAA,CAAA,EAT+B,CAYnCM,CAAAA,CAAc,EAAdA,CAAmB7B,CAAMgB,CAAAA,MAAzBa,CAAkC,CAClCC,EAAAA,CAAe9B,CAAMgB,CAAAA,MAArBc,CAA8B,CAC9BC,EAAAA,EAvQK,CAuQLA,EAA4BD,CAA5BC,EAvQkB,CAuQlBA,EAvQyB,CAuQzBA,CAA4BD,CAEhC,KADe,GAAI9C,CAAQmC,CAAAA,QAAZ,EAAsB,GAAIzB,CAAOC,CAAAA,MAAX,EAAmBuB,CAAQc,CAAAA,KAAR,CAAc,CAAd,CAAiBH,CAAjB,CAA+B,CAA/B,CAAnB,CAAtB,CAAA,CAA6E,CAA7E,CACf,CADiGE,CACjG,KAAkBb,CAAA,CAAQA,CAAQF,CAAAA,MAAhB;AAAyB,CAAzB,CAAlB,CAAgDe,CAAhD,EACI,KAAUd,MAAJ,CAAU,kBAAV,CAAN,CAEJ,MAAO,GAAIjC,CAAQE,CAAAA,OAAZ,EAAqBgC,CAAQc,CAAAA,KAAR,CAAc,CAAd,CAAiBH,CAAjB,CAA+B,CAA/B,CAArB,CA5BoC,CA+B/CI,QAASA,EAAiB,CAACf,CAAD,CAAUrB,CAAV,CAAoB,CAC1CA,CAAA,CAAWD,CAAA,CAAYC,CAAZ,CACXqB,EAAA,CAAU,GAAIlC,CAAQmC,CAAAA,QAAZ,EAAsBD,CAAtB,CACV,IAA6B,CAA7B,GAAKA,CAAQF,CAAAA,MAAb,CAAsB,CAAtB,EAAmD,EAAnD,CAAkCE,CAAQF,CAAAA,MAA1C,EAA0E,EAA1E,CAAyDE,CAAQF,CAAAA,MAAjE,CACI,KAAUC,MAAJ,CAAU,iBAAV,CAAN,CAIJ,IAFA,IAAIiB,EAAU,CAAC,CAAD,CAAd,CACIC,EAAgB,EADpB,CAESX,EAAI,CAAb,CAAgBA,CAAhB,CAAoBN,CAAQF,CAAAA,MAA5B,CAAoCQ,CAAA,EAApC,CAEwB,CAApB,CAAIW,CAAJ,EACID,CAAA,CAAQA,CAAQlB,CAAAA,MAAhB,CAAyB,CAAzB,CAEA,GAFgC,CAEhC,CADAkB,CAAA,CAAQA,CAAQlB,CAAAA,MAAhB,CAAyB,CAAzB,CACA,EAD+BE,CAAA,CAAQM,CAAR,CAC/B,CAAAW,CAAA,EAAiB,CAHrB,GAOID,CAAA,CAAQA,CAAQlB,CAAAA,MAAhB,CAAyB,CAAzB,CAIA,GAJgCmB,CAIhC,CAHAD,CAAA,CAAQA,CAAQlB,CAAAA,MAAhB,CAAyB,CAAzB,CAGA,EAH+BE,CAAA,CAAQM,CAAR,CAG/B,EAH8C,CAG9C,CAHkDW,CAGlD,CADAD,CAAQE,CAAAA,IAAR,CAAalB,CAAA,CAAQM,CAAR,CAAb,EA/RA,CA+RA,EAAuC,CAAvC,CAA2CW,CAA3C,EA/Ra,CA+Rb,CACA,CAAAA,CAAA,EAAiB,CAXrB,CAeAL,EAAAA,CAAeZ,CAAQF,CAAAA,MAAvBc,CAAgC,CAChCO,EAAAA,CAAW,GAAIrD,CAAQmC,CAAAA,QAAZ,EAAsB,GAAIzB,CAAOC,CAAAA,MAAX,EAAmBuB,CAAnB,CAAtB,CAAA,CAAmD,CAAnD,CAAXmB,EAzSK,CAySLA,EAAgFP,CAAhFO,EAzSkB,CAySlBA,EAzSyB,CAySzBA,CAAgFP,CAEpFI,EAAA,CAAQA,CAAQlB,CAAAA,MAAhB,CAAyB,CAAzB,CAAA,GAAgCc,CAChCI,EAAA,CAAQA,CAAQlB,CAAAA,MAAhB,CAAyB,CAAzB,CAAA,EAAgCqB,CAAhC,EAA6C,CAA7C,CAAiDP,CACjD,OAAOjC,EAASyC,CAAAA,IAAT,CAAcJ,CAAQK,CAAAA,GAAR,CAAY,QAAS,CAACd,CAAD,CAAQ,CAAE,MAAO5B,EAAS2C,CAAAA,OAAT,CAAiBf,CAAjB,CAAT,CAA7B,CAAd,CA9BmC;AApS9CgB,MAAOC,CAAAA,cAAP,CAAsB7D,CAAtB,CAA+B,YAA/B,CAA6C,CAAEE,MAAO,CAAA,CAAT,CAA7C,CACAF,EAAQ8D,CAAAA,cAAR,CAAyB9D,CAAQ+D,CAAAA,eAAjC,CAAmD/D,CAAQoD,CAAAA,iBAA3D,CAA+EpD,CAAQgC,CAAAA,iBAAvF,CAA2GhC,CAAQsB,CAAAA,cAAnH,CAAoItB,CAAQgE,CAAAA,MAA5I,CAAqJhE,CAAQiE,CAAAA,WAA7J,CAA2K,IAAK,EAChL,KAAIzD,EAAUV,CAAA,CAAQ,GAAR,CAAd,CACIK,EAAUL,CAAA,CAAQ,EAAR,CADd,CAEIoE,EAAcpE,CAAA,CAAQ,EAAR,CAFlB,CAGI4B,EAAY5B,CAAA,CAAQ,EAAR,CAHhB,CAIIgC,EAAWhC,CAAA,CAAQ,GAAR,CAJf,CAKIqE,EAAerE,CAAA,CAAQ,EAAR,CALnB,CAMIsE,EAAgBtE,CAAA,CAAQ,GAAR,CANpB,CAOIe,EAASf,CAAA,CAAQ,GAAR,CAPb,CAQIuE,EAAiBvE,CAAA,CAAQ,GAAR,CARrB,CASImB,EAAcnB,CAAA,CAAQ,GAAR,CACdwE,EAAAA,CAAWxE,CAAA,CAAQ,CAAR,CACXyE,EAAAA,CAAazE,CAAA,CAAQ,GAAR,CACjB,KAAIsB,EAAS,IAAIkD,CAASE,CAAAA,MAAb,CAAoBD,CAAWE,CAAAA,OAA/B,CAAb,CACIC,EAAIR,CAAYS,CAAAA,SAAUC,CAAAA,IAAtB,CAA2B,oEAA3B,CADR,CAGIC,EAAe,GAAInD,CAAUC,CAAAA,WAAd,EAA2B,cAA3B,CAHnB,CAgCImD,EAAoB,EACxB9E,EAAQiE,CAAAA,WAAR,CAAsB,kBAElBD,EAAAA,CAAwB,QAAS,EAAG,CAQpCA,QAASA,EAAM,CAACe,CAAD,CAAmBC,CAAnB,CAA+BC,CAA/B,CAA0CC,CAA1C;AAA6DC,CAA7D,CAAwEvC,CAAxE,CAA+EwC,CAA/E,CAAsFC,CAAtF,CAAsG,CAEjH,GAAIN,CAAJ,GAAyBD,CAAzB,CACI,KAAU1C,MAAJ,CAAU,8CAAV,CAAN,CAEA4C,CAAJ,EACQM,CAEJ,CAFiB,IAAIlB,CAAcmB,CAAAA,UAAlB,CAA6BP,CAA7B,CAEjB,CADA,GAAIb,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,YAAvC,CAAqDF,CAAWN,CAAAA,UAAhE,CACA,CAAA,GAAIb,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,WAAvC,CAAoDF,CAAWG,CAAAA,mBAA/D,CAHJ,GAMI,GAAItB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,YAAvC,CAAqD,IAArD,CACA,CAAA,GAAIrB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,WAAvC,CAAoD,GAAIrF,CAAQE,CAAAA,OAAZ,EAAqB4E,CAArB,CAApD,CAPJ,CASA,IAAId,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,mBAAvC,CAA4DN,CAA5D,CACA,IAAIf,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,aAAvC,CAAsD,GAAIrF,CAAQS,CAAAA,YAAZ,EAA0B,GAAIC,CAAO6E,CAAAA,SAAX,EAAsB,GAAI7E,CAAOC,CAAAA,MAAX,EAAmB,IAAKmE,CAAAA,SAAxB,CAAtB,CAA1B,CAAqF,CAArF,CAAwF,CAAxF,CAAtD,CACA,IAAId,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC;AAAuC,SAAvC,CAAkD,GAAInB,CAAesB,CAAAA,cAAnB,EAAmC,IAAKV,CAAAA,SAAxC,CAAlD,CACA,IAAId,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,WAAvC,CAAoDL,CAApD,CACA,IAAIhB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,OAAvC,CAAgD5C,CAAhD,CACA,IAAIuB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,OAAvC,CAAgDJ,CAAhD,CACsB,KAAtB,EAAIC,CAAJ,EAEI,GAAIlB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,UAAvC,CAAmD,IAAnD,CACA,CAAA,GAAIrB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,MAAvC,CAA+C,IAA/C,CAHJ,EAKqC,QAAhC,GAAI,MAAQH,EAAZ,EAED,GAAIlB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,UAAvC,CAAmD,IAAnD,CACA,CAAA,GAAIrB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,MAAvC,CAA+CH,CAA/C,CAHC,GAOD,GAAIlB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,UAAvC,CAAmDH,CAAnD,CACA,CAAA,GAAIlB,CAAaqB,CAAAA,cAAjB,EAAiC,IAAjC,CAAuC,MAAvC,CAA+CH,CAAeO,CAAAA,IAA9D,CARC,CAzB4G,CAoCrHhC,MAAOC,CAAAA,cAAP,CAAsBG,CAAO6B,CAAAA,SAA7B,CAAwC,aAAxC,CAAuD,CACnDC,IAAKA,QAAS,EAAG,CAMb,GAAkB,GAAlB;AAAI,IAAKV,CAAAA,KAAT,CACI,KAAUhD,MAAJ,CAAU,kBAAV,CAAN,CAEJ,MAAO9B,EAAA,CAAY,GAAIH,CAAQQ,CAAAA,MAAZ,EAAoB,CACd,IAApB,EAAC,IAAKqE,CAAAA,UAAN,CAA4B,YAA5B,CAA2C,YADT,CAEnC,GAAI7E,CAAQE,CAAAA,OAAZ,EAAqB,IAAK+E,CAAAA,KAA1B,CAFmC,CAGnC,IAAKF,CAAAA,iBAH8B,CAInC,GAAI/E,CAAQC,CAAAA,UAAZ,EAAwB,GAAID,CAAQE,CAAAA,OAAZ,EAAqB,IAAKuC,CAAAA,KAA1B,CAAxB,CAA0D,CAA1D,CAJmC,CAKnC,IAAKuC,CAAAA,SAL8B,CAMd,IAApB,EAAC,IAAKH,CAAAA,UAAN,CAA4B,GAAI7E,CAAQQ,CAAAA,MAAZ,EAAoB,CAAC,MAAD,CAAS,IAAKqE,CAAAA,UAAd,CAApB,CAA5B,CAA6E,IAAKC,CAAAA,SANhD,CAApB,CAAZ,CATM,CADkC,CAmBnDc,WAAY,CAAA,CAnBuC,CAoBnDC,aAAc,CAAA,CApBqC,CAAvD,CAsBAhC,EAAO6B,CAAAA,SAAUI,CAAAA,MAAjB,CAA0BC,QAAS,EAAG,CAClC,MAAO,KAAIlC,CAAJ,CAAWc,CAAX,CAA8B,IAA9B,CAAoC,IAAKG,CAAAA,SAAzC,CAAoD,IAAKC,CAAAA,iBAAzD,CAA4E,IAAKC,CAAAA,SAAjF,CAA4F,IAAKvC,CAAAA,KAAjG,CAAwG,IAAKwC,CAAAA,KAA7G,CAAoH,IAAKQ,CAAAA,IAAzH,CAD2B,CAGtC5B,EAAO6B,CAAAA,SAAUM,CAAAA,OAAjB,CAA2BC,QAAS,CAACxD,CAAD,CAAQ,CACxC,GAAY,UAAZ;AAAIA,CAAJ,CACI,KAAUR,MAAJ,CAAU,kBAAV,CAA+BiE,MAAA,CAAOzD,CAAP,CAA/B,CAAN,CAGJ,IAAIgD,EAAO,IAAKA,CAAAA,IACZA,EAAJ,GACIA,CADJ,EACY,GADZ,EACmBhD,CADnB,CA1GU0D,UA0GV,EAGA,KAAI/F,EAAO,IAAIgC,UAAJ,CAAe,EAAf,CACX,IAAIK,CAAJ,CA9GU0D,UA8GV,CAAyB,CACrB,GAAI,CAAC,IAAKtB,CAAAA,UAAV,CACI,KAAU5C,MAAJ,CAAU,sCAAV,CAAN,CAGJ7B,CAAKgG,CAAAA,GAAL,CAAS,GAAIpG,CAAQmC,CAAAA,QAAZ,EAAsB,IAAK0C,CAAAA,UAA3B,CAAT,CAAiD,CAAjD,CAEIY,EAAJ,GACIA,CADJ,EACY,GADZ,CAPqB,CAAzB,IAaIrF,EAAKgG,CAAAA,GAAL,CAAS,GAAIpG,CAAQmC,CAAAA,QAAZ,EAAsB,IAAK2C,CAAAA,SAA3B,CAAT,CAGJ,KAAK,IAAItC,EAAI,EAAb,CAAsB,CAAtB,EAAiBA,CAAjB,CAAyBA,CAAzB,EAA8B,CAA9B,CACIpC,CAAA,CAAK,EAAL,EAAWoC,CAAX,EAAgB,CAAhB,EAAA,CAAwBC,CAAxB,EAAkC,EAAlC,CAAuCD,CAAvC,CAA6C,GAE7C6D,EAAAA,CAAI,GAAIrG,CAAQmC,CAAAA,QAAZ,EAAsB,GAAIzB,CAAO4F,CAAAA,WAAX,EAAwB5F,CAAO6F,CAAAA,kBAAmBC,CAAAA,MAAlD,CAA0D,IAAKxB,CAAAA,SAA/D,CAA0E5E,CAA1E,CAAtB,CACR,KAAIqG,EAAKJ,CAAErD,CAAAA,KAAF,CAAQ,CAAR,CAAW,EAAX,CACL0D,EAAAA,CAAKL,CAAErD,CAAAA,KAAF,CAAQ,EAAR,CAIT,KAAI2D,EAFAC,CAEAD,CAFK,IAGL,KAAK9B,CAAAA,UAAT,CACI+B,CADJ,CACS9G,CAAA,CAAQiE,CAAYS,CAAAA,SAAUC,CAAAA,IAAtB,CAA2BgC,CAA3B,CAA+BI,CAAAA,GAA/B,CAAmC,IAAKhC,CAAAA,UAAxC,CAAoDiC,CAAAA,GAApD,CAAwDvC,CAAxD,CAAR,CADT;AAKIoC,CALJ,CAKYI,CADCC,IAAI/C,CAAcmB,CAAAA,UAAlB4B,CAA6B,GAAIhH,CAAQE,CAAAA,OAAZ,EAAqBuG,CAArB,CAA7BO,CACDD,EAAAA,SAAH,CAAa,IAAKjC,CAAAA,SAAlB,CAELI,EAAAA,CAAiBO,CACrB,KAAIwB,EAAc,IAAK7F,CAAAA,QACnB6F,EAAJ,GACI/B,CADJ,CACqBzB,MAAOyD,CAAAA,MAAP,CAAc,CAC3BC,OAAQF,CAAYE,CAAAA,MADO,CAE3B1B,KAAMA,CAFqB,CAG3B2B,OAASH,CAAYG,CAAAA,MAArBA,EAA+B,IAHJ,CAAd,CADrB,CAOA,OAAO,KAAIvD,CAAJ,CAAWc,CAAX,CAA8BiC,CAA9B,CAAkCD,CAAlC,CAAsC,IAAKU,CAAAA,WAA3C,CAAwDvH,CAAA,CAAQ4G,CAAR,CAAxD,CAAqEjE,CAArE,CAA4E,IAAKwC,CAAAA,KAAjF,CAAyF,CAAzF,CAA4FC,CAA5F,CApDiC,CAsD5CrB,EAAO6B,CAAAA,SAAU4B,CAAAA,UAAjB,CAA8BC,QAAS,CAAC9B,CAAD,CAAO,CAC1C,IAAI+B,EAAa/B,CAAK1D,CAAAA,KAAL,CAAW,GAAX,CACjB,IAA0B,CAA1B,GAAIyF,CAAWxF,CAAAA,MAAf,EAAkD,GAAlD,GAAgCwF,CAAA,CAAW,CAAX,CAAhC,EAAwE,CAAxE,GAAyD,IAAKvC,CAAAA,KAA9D,CACI,KAAUhD,MAAJ,CAAU,iBAAV,CAA8BwD,CAA9B,CAAN,CAEkB,GAAtB,GAAI+B,CAAA,CAAW,CAAX,CAAJ,EACIA,CAAWC,CAAAA,KAAX,EAEAC,EAAAA,CAAS,IACb,KAAK,IAAIlF,EAAI,CAAb,CAAgBA,CAAhB,CAAoBgF,CAAWxF,CAAAA,MAA/B,CAAuCQ,CAAA,EAAvC,CAA4C,CACxC,IAAImF,EAAYH,CAAA,CAAWhF,CAAX,CAChB,IAAImF,CAAUC,CAAAA,KAAV,CAAgB,WAAhB,CAAJ,CAAkC,CAC9B,IAAInF,EAAQoF,QAAA,CAASF,CAAUG,CAAAA,SAAV,CAAoB,CAApB,CAAuBH,CAAU3F,CAAAA,MAAjC,CAA0C,CAA1C,CAAT,CACZ,IAvKEmE,UAuKF,EAAI1D,CAAJ,CACI,KAAUR,MAAJ,CAAU,uBAAV;AAAoC0F,CAApC,CAAN,CAEJD,CAAA,CAASA,CAAO1B,CAAAA,OAAP,CA1KPG,UA0KO,CAA6B1D,CAA7B,CALqB,CAAlC,IAOK,IAAIkF,CAAUC,CAAAA,KAAV,CAAgB,UAAhB,CAAJ,CAAiC,CAC9BnF,CAAJ,CAAYoF,QAAA,CAASF,CAAT,CACZ,IA9KExB,UA8KF,EAAI1D,CAAJ,CACI,KAAUR,MAAJ,CAAU,uBAAV,CAAoC0F,CAApC,CAAN,CAEJD,CAAA,CAASA,CAAO1B,CAAAA,OAAP,CAAevD,CAAf,CALyB,CAAjC,IAQD,MAAUR,MAAJ,CAAU,2BAAV,CAAwC0F,CAAxC,CAAN,CAjBoC,CAoB5C,MAAOD,EA7BmC,CA+B9C7D,EAAOkE,CAAAA,SAAP,CAAmBC,QAAS,CAACC,CAAD,CAAO7G,CAAP,CAAiB,CACrC8G,CAAAA,CAAY,GAAIlI,CAAQmC,CAAAA,QAAZ,EAAsB8F,CAAtB,CAChB,IAAuB,EAAvB,CAAIC,CAAUlG,CAAAA,MAAd,EAAgD,EAAhD,CAA6BkG,CAAUlG,CAAAA,MAAvC,CACI,KAAUC,MAAJ,CAAU,cAAV,CAAN,CAEAoE,CAAAA,CAAI,GAAIrG,CAAQmC,CAAAA,QAAZ,EAAsB,GAAIzB,CAAO4F,CAAAA,WAAX,EAAwB5F,CAAO6F,CAAAA,kBAAmBC,CAAAA,MAAlD,CAA0D9B,CAA1D,CAAwEwD,CAAxE,CAAtB,CACR,OAAO,KAAIrE,CAAJ,CAAWc,CAAX,CAA8B7E,CAAA,CAAQuG,CAAErD,CAAAA,KAAF,CAAQ,CAAR,CAAW,EAAX,CAAR,CAA9B,CAAuD,IAAvD,CAA6D,YAA7D,CAA2ElD,CAAA,CAAQuG,CAAErD,CAAAA,KAAF,CAAQ,EAAR,CAAR,CAA3E,CAAiG,CAAjG,CAAoG,CAApG,CAAuG5B,CAAvG,CANkC,CAQ7CyC,EAAOsE,CAAAA,YAAP,CAAsBC,QAAS,CAAChH,CAAD,CAAWC,CAAX,CAAqBR,CAArB,CAA+B,CAE1DA,CAAA,CAAWD,CAAA,CAAYC,CAAZ,CAEXO,EAAA,CAAW6B,CAAA,CAAkBpB,CAAA,CAAkBT,CAAlB,CAA4BP,CAA5B,CAAlB,CAAyDA,CAAzD,CACX,OAAOgD,EAAOkE,CAAAA,SAAP,CAAiB5G,CAAA,CAAeC,CAAf;AAAyBC,CAAzB,CAAjB,CAAqD,CACxD8F,OAAQ/F,CADgD,CAExDqE,KAAM,GAFkD,CAGxD2B,OAAQvG,CAASuG,CAAAA,MAHuC,CAArD,CALmD,CAW9DvD,EAAOwE,CAAAA,QAAP,CAAkBC,QAAS,CAACL,CAAD,CAAO,CAC9B,MAAOpE,EAAOkE,CAAAA,SAAP,CAAiBE,CAAjB,CAAuB,IAAvB,CADuB,CAGlCpE,EAAO0E,CAAAA,eAAP,CAAyBC,QAAS,CAACC,CAAD,CAAc,CAC5C,IAAIC,EAAQrI,CAAQC,CAAAA,MAAOqI,CAAAA,MAAf,CAAsBF,CAAtB,CACS,GAArB,GAAIC,CAAM1G,CAAAA,MAAV,EAA2B7B,CAAA,CAAYuI,CAAM1F,CAAAA,KAAN,CAAY,CAAZ,CAAe,EAAf,CAAZ,CAA3B,GAA+DyF,CAA/D,EACIxH,CAAOC,CAAAA,kBAAP,CAA0B,sBAA1B,CAAkD,aAAlD,CAAiE,YAAjE,CAEA+D,EAAAA,CAAQyD,CAAA,CAAM,CAAN,CACZ,KAAI3D,EAAoB,GAAI/E,CAAQE,CAAAA,OAAZ,EAAqBwI,CAAM1F,CAAAA,KAAN,CAAY,CAAZ,CAAe,CAAf,CAArB,CAAxB,CACIP,EAAQoF,QAAA,CAAS,GAAI7H,CAAQE,CAAAA,OAAZ,EAAqBwI,CAAM1F,CAAAA,KAAN,CAAY,CAAZ,CAAe,EAAf,CAArB,CAAyC8E,CAAAA,SAAzC,CAAmD,CAAnD,CAAT,CAAgE,EAAhE,CADZ,CAEI9C,EAAY,GAAIhF,CAAQE,CAAAA,OAAZ,EAAqBwI,CAAM1F,CAAAA,KAAN,CAAY,EAAZ,CAAgB,EAAhB,CAArB,CAFhB,CAGI4F,EAAMF,CAAM1F,CAAAA,KAAN,CAAY,EAAZ,CAAgB,EAAhB,CACV,QAAQ,GAAIhD,CAAQE,CAAAA,OAAZ,EAAqBwI,CAAM1F,CAAAA,KAAN,CAAY,CAAZ,CAAe,CAAf,CAArB,CAAR,EAEI,KAAK,YAAL,CACA,KAAK,YAAL,CACI,MAAO,KAAIa,CAAJ,CAAWc,CAAX,CAA8B,IAA9B,CAAoC,GAAI3E,CAAQE,CAAAA,OAAZ,EAAqB0I,CAArB,CAApC;AAA+D7D,CAA/D,CAAkFC,CAAlF,CAA6FvC,CAA7F,CAAoGwC,CAApG,CAA2G,IAA3G,CAEX,MAAK,YAAL,CACA,KAAK,aAAL,CACI,GAAe,CAAf,GAAI2D,CAAA,CAAI,CAAJ,CAAJ,CAGA,MAAO,KAAI/E,CAAJ,CAAWc,CAAX,CAA8B,GAAI3E,CAAQE,CAAAA,OAAZ,EAAqB0I,CAAI5F,CAAAA,KAAJ,CAAU,CAAV,CAArB,CAA9B,CAAkE,IAAlE,CAAwE+B,CAAxE,CAA2FC,CAA3F,CAAsGvC,CAAtG,CAA6GwC,CAA7G,CAAoH,IAApH,CAXf,CAaA,MAAOhE,EAAOC,CAAAA,kBAAP,CAA0B,sBAA1B,CAAkD,aAAlD,CAAiE,YAAjE,CAvBqC,CAyBhD,OAAO2C,EAzM6B,CAAZ,EA2M5BhE,EAAQgE,CAAAA,MAAR,CAAiBA,CAQjBhE,EAAQsB,CAAAA,cAAR,CAAyBA,CA+BzBtB,EAAQgC,CAAAA,iBAAR,CAA4BA,CAiC5BhC,EAAQoD,CAAAA,iBAAR,CAA4BA,CAS5BpD,EAAQ+D,CAAAA,eAAR,CARAA,QAAwB,CAACxC,CAAD,CAAWP,CAAX,CAAqB,CACzC,GAAI,CAEA,MADAgB,EAAA,CAAkBT,CAAlB,CAA4BP,CAA5B,CACO,CAAA,CAAA,CAFP,CAIJ,MAAOgI,CAAP,CAAc,EACd,MAAO,CAAA,CANkC,CAe7ChJ,EAAQ8D,CAAAA,cAAR,CANAA,QAAuB,CAAClB,CAAD,CAAQ,CAC3B,CAAuB,QAAvB,GAAI,MAAQA,EAAZ,EAA2C,CAA3C,CAAmCA,CAAnC,EA7Tc0D,UA6Td,EAAgD1D,CAAhD,EAAwEA,CAAxE,CAAgF,CAAhF,GACIxB,CAAOC,CAAAA,kBAAP,CAA0B,uBAA1B,CAAmD,OAAnD,CAA4DuB,CAA5D,CAEJ,OAAO,YAAP;AAAsBA,CAAtB,CAA8B,OAJH,CAhV+B;\",\n\"sources\":[\"node_modules/@ethersproject/hdnode/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[281] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.getAccountPath = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.mnemonicToSeed = exports.HDNode = exports.defaultPath = void 0;\\nvar basex_1 = require(\\\"@ethersproject/basex\\\");\\nvar bytes_1 = require(\\\"@ethersproject/bytes\\\");\\nvar bignumber_1 = require(\\\"@ethersproject/bignumber\\\");\\nvar strings_1 = require(\\\"@ethersproject/strings\\\");\\nvar pbkdf2_1 = require(\\\"@ethersproject/pbkdf2\\\");\\nvar properties_1 = require(\\\"@ethersproject/properties\\\");\\nvar signing_key_1 = require(\\\"@ethersproject/signing-key\\\");\\nvar sha2_1 = require(\\\"@ethersproject/sha2\\\");\\nvar transactions_1 = require(\\\"@ethersproject/transactions\\\");\\nvar wordlists_1 = require(\\\"@ethersproject/wordlists\\\");\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"./_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\nvar N = bignumber_1.BigNumber.from(\\\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\\\");\\n// \\\"Bitcoin seed\\\"\\nvar MasterSecret = (0, strings_1.toUtf8Bytes)(\\\"Bitcoin seed\\\");\\nvar HardenedBit = 0x80000000;\\n// Returns a byte with the MSB bits set\\nfunction getUpperMask(bits) {\\n    return ((1 << bits) - 1) << (8 - bits);\\n}\\n// Returns a byte with the LSB bits set\\nfunction getLowerMask(bits) {\\n    return (1 << bits) - 1;\\n}\\nfunction bytes32(value) {\\n    return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);\\n}\\nfunction base58check(data) {\\n    return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));\\n}\\nfunction getWordlist(wordlist) {\\n    if (wordlist == null) {\\n        return wordlists_1.wordlists[\\\"en\\\"];\\n    }\\n    if (typeof (wordlist) === \\\"string\\\") {\\n        var words = wordlists_1.wordlists[wordlist];\\n        if (words == null) {\\n            logger.throwArgumentError(\\\"unknown locale\\\", \\\"wordlist\\\", wordlist);\\n        }\\n        return words;\\n    }\\n    return wordlist;\\n}\\nvar _constructorGuard = {};\\nexports.defaultPath = \\\"m/44'/60'/0'/0/0\\\";\\n;\\nvar HDNode = /** @class */ (function () {\\n    /**\\n     *  This constructor should not be called directly.\\n     *\\n     *  Please use:\\n     *   - fromMnemonic\\n     *   - fromSeed\\n     */\\n    function HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {\\n        /* istanbul ignore if */\\n        if (constructorGuard !== _constructorGuard) {\\n            throw new Error(\\\"HDNode constructor cannot be called directly\\\");\\n        }\\n        if (privateKey) {\\n            var signingKey = new signing_key_1.SigningKey(privateKey);\\n            (0, properties_1.defineReadOnly)(this, \\\"privateKey\\\", signingKey.privateKey);\\n            (0, properties_1.defineReadOnly)(this, \\\"publicKey\\\", signingKey.compressedPublicKey);\\n        }\\n        else {\\n            (0, properties_1.defineReadOnly)(this, \\\"privateKey\\\", null);\\n            (0, properties_1.defineReadOnly)(this, \\\"publicKey\\\", (0, bytes_1.hexlify)(publicKey));\\n        }\\n        (0, properties_1.defineReadOnly)(this, \\\"parentFingerprint\\\", parentFingerprint);\\n        (0, properties_1.defineReadOnly)(this, \\\"fingerprint\\\", (0, bytes_1.hexDataSlice)((0, sha2_1.ripemd160)((0, sha2_1.sha256)(this.publicKey)), 0, 4));\\n        (0, properties_1.defineReadOnly)(this, \\\"address\\\", (0, transactions_1.computeAddress)(this.publicKey));\\n        (0, properties_1.defineReadOnly)(this, \\\"chainCode\\\", chainCode);\\n        (0, properties_1.defineReadOnly)(this, \\\"index\\\", index);\\n        (0, properties_1.defineReadOnly)(this, \\\"depth\\\", depth);\\n        if (mnemonicOrPath == null) {\\n            // From a source that does not preserve the path (e.g. extended keys)\\n            (0, properties_1.defineReadOnly)(this, \\\"mnemonic\\\", null);\\n            (0, properties_1.defineReadOnly)(this, \\\"path\\\", null);\\n        }\\n        else if (typeof (mnemonicOrPath) === \\\"string\\\") {\\n            // From a source that does not preserve the mnemonic (e.g. neutered)\\n            (0, properties_1.defineReadOnly)(this, \\\"mnemonic\\\", null);\\n            (0, properties_1.defineReadOnly)(this, \\\"path\\\", mnemonicOrPath);\\n        }\\n        else {\\n            // From a fully qualified source\\n            (0, properties_1.defineReadOnly)(this, \\\"mnemonic\\\", mnemonicOrPath);\\n            (0, properties_1.defineReadOnly)(this, \\\"path\\\", mnemonicOrPath.path);\\n        }\\n    }\\n    Object.defineProperty(HDNode.prototype, \\\"extendedKey\\\", {\\n        get: function () {\\n            // We only support the mainnet values for now, but if anyone needs\\n            // testnet values, let me know. I believe current sentiment is that\\n            // we should always use mainnet, and use BIP-44 to derive the network\\n            //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\\n            //   - Testnet: public=0x043587CF, private=0x04358394\\n            if (this.depth >= 256) {\\n                throw new Error(\\\"Depth too large!\\\");\\n            }\\n            return base58check((0, bytes_1.concat)([\\n                ((this.privateKey != null) ? \\\"0x0488ADE4\\\" : \\\"0x0488B21E\\\"),\\n                (0, bytes_1.hexlify)(this.depth),\\n                this.parentFingerprint,\\n                (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(this.index), 4),\\n                this.chainCode,\\n                ((this.privateKey != null) ? (0, bytes_1.concat)([\\\"0x00\\\", this.privateKey]) : this.publicKey),\\n            ]));\\n        },\\n        enumerable: false,\\n        configurable: true\\n    });\\n    HDNode.prototype.neuter = function () {\\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\\n    };\\n    HDNode.prototype._derive = function (index) {\\n        if (index > 0xffffffff) {\\n            throw new Error(\\\"invalid index - \\\" + String(index));\\n        }\\n        // Base path\\n        var path = this.path;\\n        if (path) {\\n            path += \\\"/\\\" + (index & ~HardenedBit);\\n        }\\n        var data = new Uint8Array(37);\\n        if (index & HardenedBit) {\\n            if (!this.privateKey) {\\n                throw new Error(\\\"cannot derive child of neutered node\\\");\\n            }\\n            // Data = 0x00 || ser_256(k_par)\\n            data.set((0, bytes_1.arrayify)(this.privateKey), 1);\\n            // Hardened path\\n            if (path) {\\n                path += \\\"'\\\";\\n            }\\n        }\\n        else {\\n            // Data = ser_p(point(k_par))\\n            data.set((0, bytes_1.arrayify)(this.publicKey));\\n        }\\n        // Data += ser_32(i)\\n        for (var i = 24; i >= 0; i -= 8) {\\n            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\\n        }\\n        var I = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, this.chainCode, data));\\n        var IL = I.slice(0, 32);\\n        var IR = I.slice(32);\\n        // The private key\\n        var ki = null;\\n        // The public key\\n        var Ki = null;\\n        if (this.privateKey) {\\n            ki = bytes32(bignumber_1.BigNumber.from(IL).add(this.privateKey).mod(N));\\n        }\\n        else {\\n            var ek = new signing_key_1.SigningKey((0, bytes_1.hexlify)(IL));\\n            Ki = ek._addPoint(this.publicKey);\\n        }\\n        var mnemonicOrPath = path;\\n        var srcMnemonic = this.mnemonic;\\n        if (srcMnemonic) {\\n            mnemonicOrPath = Object.freeze({\\n                phrase: srcMnemonic.phrase,\\n                path: path,\\n                locale: (srcMnemonic.locale || \\\"en\\\")\\n            });\\n        }\\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\\n    };\\n    HDNode.prototype.derivePath = function (path) {\\n        var components = path.split(\\\"/\\\");\\n        if (components.length === 0 || (components[0] === \\\"m\\\" && this.depth !== 0)) {\\n            throw new Error(\\\"invalid path - \\\" + path);\\n        }\\n        if (components[0] === \\\"m\\\") {\\n            components.shift();\\n        }\\n        var result = this;\\n        for (var i = 0; i < components.length; i++) {\\n            var component = components[i];\\n            if (component.match(/^[0-9]+'$/)) {\\n                var index = parseInt(component.substring(0, component.length - 1));\\n                if (index >= HardenedBit) {\\n                    throw new Error(\\\"invalid path index - \\\" + component);\\n                }\\n                result = result._derive(HardenedBit + index);\\n            }\\n            else if (component.match(/^[0-9]+$/)) {\\n                var index = parseInt(component);\\n                if (index >= HardenedBit) {\\n                    throw new Error(\\\"invalid path index - \\\" + component);\\n                }\\n                result = result._derive(index);\\n            }\\n            else {\\n                throw new Error(\\\"invalid path component - \\\" + component);\\n            }\\n        }\\n        return result;\\n    };\\n    HDNode._fromSeed = function (seed, mnemonic) {\\n        var seedArray = (0, bytes_1.arrayify)(seed);\\n        if (seedArray.length < 16 || seedArray.length > 64) {\\n            throw new Error(\\\"invalid seed\\\");\\n        }\\n        var I = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, MasterSecret, seedArray));\\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \\\"0x00000000\\\", bytes32(I.slice(32)), 0, 0, mnemonic);\\n    };\\n    HDNode.fromMnemonic = function (mnemonic, password, wordlist) {\\n        // If a locale name was passed in, find the associated wordlist\\n        wordlist = getWordlist(wordlist);\\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\\n            phrase: mnemonic,\\n            path: \\\"m\\\",\\n            locale: wordlist.locale\\n        });\\n    };\\n    HDNode.fromSeed = function (seed) {\\n        return HDNode._fromSeed(seed, null);\\n    };\\n    HDNode.fromExtendedKey = function (extendedKey) {\\n        var bytes = basex_1.Base58.decode(extendedKey);\\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\\n            logger.throwArgumentError(\\\"invalid extended key\\\", \\\"extendedKey\\\", \\\"[REDACTED]\\\");\\n        }\\n        var depth = bytes[4];\\n        var parentFingerprint = (0, bytes_1.hexlify)(bytes.slice(5, 9));\\n        var index = parseInt((0, bytes_1.hexlify)(bytes.slice(9, 13)).substring(2), 16);\\n        var chainCode = (0, bytes_1.hexlify)(bytes.slice(13, 45));\\n        var key = bytes.slice(45, 78);\\n        switch ((0, bytes_1.hexlify)(bytes.slice(0, 4))) {\\n            // Public Key\\n            case \\\"0x0488b21e\\\":\\n            case \\\"0x043587cf\\\":\\n                return new HDNode(_constructorGuard, null, (0, bytes_1.hexlify)(key), parentFingerprint, chainCode, index, depth, null);\\n            // Private Key\\n            case \\\"0x0488ade4\\\":\\n            case \\\"0x04358394 \\\":\\n                if (key[0] !== 0) {\\n                    break;\\n                }\\n                return new HDNode(_constructorGuard, (0, bytes_1.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\\n        }\\n        return logger.throwArgumentError(\\\"invalid extended key\\\", \\\"extendedKey\\\", \\\"[REDACTED]\\\");\\n    };\\n    return HDNode;\\n}());\\nexports.HDNode = HDNode;\\nfunction mnemonicToSeed(mnemonic, password) {\\n    if (!password) {\\n        password = \\\"\\\";\\n    }\\n    var salt = (0, strings_1.toUtf8Bytes)(\\\"mnemonic\\\" + password, strings_1.UnicodeNormalizationForm.NFKD);\\n    return (0, pbkdf2_1.pbkdf2)((0, strings_1.toUtf8Bytes)(mnemonic, strings_1.UnicodeNormalizationForm.NFKD), salt, 2048, 64, \\\"sha512\\\");\\n}\\nexports.mnemonicToSeed = mnemonicToSeed;\\nfunction mnemonicToEntropy(mnemonic, wordlist) {\\n    wordlist = getWordlist(wordlist);\\n    logger.checkNormalize();\\n    var words = wordlist.split(mnemonic);\\n    if ((words.length % 3) !== 0) {\\n        throw new Error(\\\"invalid mnemonic\\\");\\n    }\\n    var entropy = (0, bytes_1.arrayify)(new Uint8Array(Math.ceil(11 * words.length / 8)));\\n    var offset = 0;\\n    for (var i = 0; i < words.length; i++) {\\n        var index = wordlist.getWordIndex(words[i].normalize(\\\"NFKD\\\"));\\n        if (index === -1) {\\n            throw new Error(\\\"invalid mnemonic\\\");\\n        }\\n        for (var bit = 0; bit < 11; bit++) {\\n            if (index & (1 << (10 - bit))) {\\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\\n            }\\n            offset++;\\n        }\\n    }\\n    var entropyBits = 32 * words.length / 3;\\n    var checksumBits = words.length / 3;\\n    var checksumMask = getUpperMask(checksumBits);\\n    var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\\n        throw new Error(\\\"invalid checksum\\\");\\n    }\\n    return (0, bytes_1.hexlify)(entropy.slice(0, entropyBits / 8));\\n}\\nexports.mnemonicToEntropy = mnemonicToEntropy;\\nfunction entropyToMnemonic(entropy, wordlist) {\\n    wordlist = getWordlist(wordlist);\\n    entropy = (0, bytes_1.arrayify)(entropy);\\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\\n        throw new Error(\\\"invalid entropy\\\");\\n    }\\n    var indices = [0];\\n    var remainingBits = 11;\\n    for (var i = 0; i < entropy.length; i++) {\\n        // Consume the whole byte (with still more to go)\\n        if (remainingBits > 8) {\\n            indices[indices.length - 1] <<= 8;\\n            indices[indices.length - 1] |= entropy[i];\\n            remainingBits -= 8;\\n            // This byte will complete an 11-bit index\\n        }\\n        else {\\n            indices[indices.length - 1] <<= remainingBits;\\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\\n            // Start the next word\\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\\n            remainingBits += 3;\\n        }\\n    }\\n    // Compute the checksum bits\\n    var checksumBits = entropy.length / 4;\\n    var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy))[0] & getUpperMask(checksumBits);\\n    // Shift the checksum into the word indices\\n    indices[indices.length - 1] <<= checksumBits;\\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\\n    return wordlist.join(indices.map(function (index) { return wordlist.getWord(index); }));\\n}\\nexports.entropyToMnemonic = entropyToMnemonic;\\nfunction isValidMnemonic(mnemonic, wordlist) {\\n    try {\\n        mnemonicToEntropy(mnemonic, wordlist);\\n        return true;\\n    }\\n    catch (error) { }\\n    return false;\\n}\\nexports.isValidMnemonic = isValidMnemonic;\\nfunction getAccountPath(index) {\\n    if (typeof (index) !== \\\"number\\\" || index < 0 || index >= HardenedBit || index % 1) {\\n        logger.throwArgumentError(\\\"invalid account index\\\", \\\"index\\\", index);\\n    }\\n    return \\\"m/44'/60'/\\\" + index + \\\"'/0/0\\\";\\n}\\nexports.getAccountPath = getAccountPath;\\n//# sourceMappingURL=index.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"bytes32\",\"value\",\"bytes_1\",\"hexZeroPad\",\"hexlify\",\"base58check\",\"data\",\"basex_1\",\"Base58\",\"encode\",\"concat\",\"hexDataSlice\",\"sha2_1\",\"sha256\",\"getWordlist\",\"wordlist\",\"wordlists_1\",\"wordlists\",\"words\",\"logger\",\"throwArgumentError\",\"mnemonicToSeed\",\"mnemonic\",\"password\",\"salt\",\"strings_1\",\"toUtf8Bytes\",\"UnicodeNormalizationForm\",\"NFKD\",\"pbkdf2_1\",\"pbkdf2\",\"mnemonicToEntropy\",\"checkNormalize\",\"split\",\"length\",\"Error\",\"entropy\",\"arrayify\",\"Uint8Array\",\"Math\",\"ceil\",\"offset\",\"i\",\"index\",\"getWordIndex\",\"normalize\",\"bit\",\"entropyBits\",\"checksumBits\",\"checksumMask\",\"slice\",\"entropyToMnemonic\",\"indices\",\"remainingBits\",\"push\",\"checksum\",\"join\",\"map\",\"getWord\",\"Object\",\"defineProperty\",\"getAccountPath\",\"isValidMnemonic\",\"HDNode\",\"defaultPath\",\"bignumber_1\",\"properties_1\",\"signing_key_1\",\"transactions_1\",\"logger_1\",\"_version_1\",\"Logger\",\"version\",\"N\",\"BigNumber\",\"from\",\"MasterSecret\",\"_constructorGuard\",\"constructorGuard\",\"privateKey\",\"publicKey\",\"parentFingerprint\",\"chainCode\",\"depth\",\"mnemonicOrPath\",\"signingKey\",\"SigningKey\",\"defineReadOnly\",\"compressedPublicKey\",\"ripemd160\",\"computeAddress\",\"path\",\"prototype\",\"get\",\"enumerable\",\"configurable\",\"neuter\",\"HDNode.prototype.neuter\",\"_derive\",\"HDNode.prototype._derive\",\"String\",\"HardenedBit\",\"set\",\"I\",\"computeHmac\",\"SupportedAlgorithm\",\"sha512\",\"IL\",\"IR\",\"Ki\",\"ki\",\"add\",\"mod\",\"_addPoint\",\"ek\",\"srcMnemonic\",\"freeze\",\"phrase\",\"locale\",\"fingerprint\",\"derivePath\",\"HDNode.prototype.derivePath\",\"components\",\"shift\",\"result\",\"component\",\"match\",\"parseInt\",\"substring\",\"_fromSeed\",\"HDNode._fromSeed\",\"seed\",\"seedArray\",\"fromMnemonic\",\"HDNode.fromMnemonic\",\"fromSeed\",\"HDNode.fromSeed\",\"fromExtendedKey\",\"HDNode.fromExtendedKey\",\"extendedKey\",\"bytes\",\"decode\",\"key\",\"error\"]\n}\n"]