["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/browserify-aes/modes/ctr.js"],"~:js","shadow$provide[190]=function(S,A,V,q){var F=A(183),G=A(111).Buffer,r=A(189);q.encrypt=function(y,e){var u=Math.ceil(e.length/16),p=y._cache.length;y._cache=G.concat([y._cache,G.allocUnsafe(16*u)]);for(var n=0;n<u;n++){var l=y;var h=l._cipher.encryptBlockRaw(l._prev);r(l._prev);l=h;h=p+16*n;y._cache.writeUInt32BE(l[0],h+0);y._cache.writeUInt32BE(l[1],h+4);y._cache.writeUInt32BE(l[2],h+8);y._cache.writeUInt32BE(l[3],h+12)}u=y._cache.slice(0,e.length);y._cache=y._cache.slice(e.length);return F(e,u)}}","~:source","shadow$provide[190] = function(global,require,module,exports) {\nvar xor = require('buffer-xor')\nvar Buffer = require('safe-buffer').Buffer\nvar incr32 = require('../incr32')\n\nfunction getBlock (self) {\n  var out = self._cipher.encryptBlockRaw(self._prev)\n  incr32(self._prev)\n  return out\n}\n\nvar blockSize = 16\nexports.encrypt = function (self, chunk) {\n  var chunkNum = Math.ceil(chunk.length / blockSize)\n  var start = self._cache.length\n  self._cache = Buffer.concat([\n    self._cache,\n    Buffer.allocUnsafe(chunkNum * blockSize)\n  ])\n  for (var i = 0; i < chunkNum; i++) {\n    var out = getBlock(self)\n    var offset = start + i * blockSize\n    self._cache.writeUInt32BE(out[0], offset + 0)\n    self._cache.writeUInt32BE(out[1], offset + 4)\n    self._cache.writeUInt32BE(out[2], offset + 8)\n    self._cache.writeUInt32BE(out[3], offset + 12)\n  }\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$browserify_aes$incr32","~$shadow.js","~$module$node_modules$buffer_xor$index","~$module$node_modules$safe_buffer$index"]],"~:properties",["^5",["encrypt","_cache"]],"~:compiled-at",1695041440824,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$browserify_aes$modes$ctr.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAC9D,IAAIC,EAAMH,CAAA,CAAQ,GAAR,CAAV,CACII,EAASJ,CAAA,CAAQ,GAAR,CAAuBI,CAAAA,MADpC,CAEIC,EAASL,CAAA,CAAQ,GAAR,CASbE,EAAQI,CAAAA,OAAR,CAAkBC,QAAS,CAACC,CAAD,CAAOC,CAAP,CAAc,CACvC,IAAIC,EAAWC,IAAKC,CAAAA,IAAL,CAAUH,CAAMI,CAAAA,MAAhB,CAFDC,EAEC,CAAf,CACIC,EAAQP,CAAKQ,CAAAA,MAAOH,CAAAA,MACxBL,EAAKQ,CAAAA,MAAL,CAAcZ,CAAOa,CAAAA,MAAP,CAAc,CAC1BT,CAAKQ,CAAAA,MADqB,CAE1BZ,CAAOc,CAAAA,WAAP,CANYJ,EAMZ,CAAmBJ,CAAnB,CAF0B,CAAd,CAId,KAAK,IAAIS,EAAI,CAAb,CAAgBA,CAAhB,CAAoBT,CAApB,CAA8BS,CAAA,EAA9B,CAAmC,CACdX,IAAAA,EAAAA,CAdrB,KAAIY,EAAMZ,CAAKa,CAAAA,OAAQC,CAAAA,eAAb,CAA6Bd,CAAKe,CAAAA,KAAlC,CACVlB,EAAA,CAAOG,CAAKe,CAAAA,KAAZ,CACA,EAAA,CAAOH,CAaDI,EAAAA,CAAST,CAATS,CAVQV,EAURU,CAAiBL,CACrBX,EAAKQ,CAAAA,MAAOS,CAAAA,aAAZ,CAA0BL,CAAA,CAAI,CAAJ,CAA1B,CAAkCI,CAAlC,CAA2C,CAA3C,CACAhB,EAAKQ,CAAAA,MAAOS,CAAAA,aAAZ,CAA0BL,CAAA,CAAI,CAAJ,CAA1B,CAAkCI,CAAlC,CAA2C,CAA3C,CACAhB,EAAKQ,CAAAA,MAAOS,CAAAA,aAAZ,CAA0BL,CAAA,CAAI,CAAJ,CAA1B,CAAkCI,CAAlC,CAA2C,CAA3C,CACAhB,EAAKQ,CAAAA,MAAOS,CAAAA,aAAZ,CAA0BL,CAAA,CAAI,CAAJ,CAA1B,CAAkCI,CAAlC,CAA2C,EAA3C,CANiC,CAQ/BE,CAAAA,CAAMlB,CAAKQ,CAAAA,MAAOW,CAAAA,KAAZ,CAAkB,CAAlB,CAAqBlB,CAAMI,CAAAA,MAA3B,CACVL,EAAKQ,CAAAA,MAAL,CAAcR,CAAKQ,CAAAA,MAAOW,CAAAA,KAAZ,CAAkBlB,CAAMI,CAAAA,MAAxB,CACd,OAAOV,EAAA,CAAIM,CAAJ,CAAWiB,CAAX,CAjBgC,CAZqB;\",\n\"sources\":[\"node_modules/browserify-aes/modes/ctr.js\"],\n\"sourcesContent\":[\"shadow$provide[190] = function(global,require,module,exports) {\\nvar xor = require('buffer-xor')\\nvar Buffer = require('safe-buffer').Buffer\\nvar incr32 = require('../incr32')\\n\\nfunction getBlock (self) {\\n  var out = self._cipher.encryptBlockRaw(self._prev)\\n  incr32(self._prev)\\n  return out\\n}\\n\\nvar blockSize = 16\\nexports.encrypt = function (self, chunk) {\\n  var chunkNum = Math.ceil(chunk.length / blockSize)\\n  var start = self._cache.length\\n  self._cache = Buffer.concat([\\n    self._cache,\\n    Buffer.allocUnsafe(chunkNum * blockSize)\\n  ])\\n  for (var i = 0; i < chunkNum; i++) {\\n    var out = getBlock(self)\\n    var offset = start + i * blockSize\\n    self._cache.writeUInt32BE(out[0], offset + 0)\\n    self._cache.writeUInt32BE(out[1], offset + 4)\\n    self._cache.writeUInt32BE(out[2], offset + 8)\\n    self._cache.writeUInt32BE(out[3], offset + 12)\\n  }\\n  var pad = self._cache.slice(0, chunk.length)\\n  self._cache = self._cache.slice(chunk.length)\\n  return xor(chunk, pad)\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"xor\",\"Buffer\",\"incr32\",\"encrypt\",\"exports.encrypt\",\"self\",\"chunk\",\"chunkNum\",\"Math\",\"ceil\",\"length\",\"blockSize\",\"start\",\"_cache\",\"concat\",\"allocUnsafe\",\"i\",\"out\",\"_cipher\",\"encryptBlockRaw\",\"_prev\",\"offset\",\"writeUInt32BE\",\"pad\",\"slice\"]\n}\n"]