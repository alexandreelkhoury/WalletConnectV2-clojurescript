shadow$provide.module$node_modules$viem$_cjs$utils$abi$encodePacked=function(global,require,module,exports){function encode(type,value,isArray=!1){if("address"===type){if(!(0,isAddress_js_1.isAddress)(value))throw new address_js_1.InvalidAddressError({address:value});return(0,pad_js_1.pad)(value.toLowerCase(),{size:isArray?32:null})}if("string"===type)return(0,toHex_js_1.stringToHex)(value);if("bytes"===type)return value;if("bool"===type)return(0,pad_js_1.pad)((0,toHex_js_1.boolToHex)(value),{size:isArray?
32:1});var intMatch=type.match(regex_js_1.integerRegex);if(intMatch){const [,baseType,bits="256"]=intMatch;type=parseInt(bits)/8;return(0,toHex_js_1.numberToHex)(value,{size:isArray?32:type,signed:"int"===baseType})}if(intMatch=type.match(regex_js_1.bytesRegex)){[,type]=intMatch;if(parseInt(type)!==(value.length-2)/2)throw new abi_js_1.BytesSizeMismatchError({expectedSize:parseInt(type),givenSize:(value.length-2)/2});return(0,pad_js_1.pad)(value,{dir:"right",size:isArray?32:null})}if((isArray=type.match(regex_js_1.arrayRegex))&&
Array.isArray(value)){[,isArray]=isArray;type=[];for(intMatch=0;intMatch<value.length;intMatch++)type.push(encode(isArray,value[intMatch],!0));return 0===type.length?"0x":(0,concat_js_1.concatHex)(type)}throw new abi_js_1.UnsupportedPackedAbiType(type);}Object.defineProperty(exports,"__esModule",{value:!0});exports.encodePacked=void 0;const abi_js_1=require("module$node_modules$viem$_cjs$errors$abi"),address_js_1=require("module$node_modules$viem$_cjs$errors$address"),isAddress_js_1=require("module$node_modules$viem$_cjs$utils$address$isAddress"),
concat_js_1=require("module$node_modules$viem$_cjs$utils$data$concat"),pad_js_1=require("module$node_modules$viem$_cjs$utils$data$pad"),toHex_js_1=require("module$node_modules$viem$_cjs$utils$encoding$toHex"),regex_js_1=require("module$node_modules$viem$_cjs$utils$regex");exports.encodePacked=function(types,values){if(types.length!==values.length)throw new abi_js_1.AbiEncodingLengthMismatchError({expectedLength:types.length,givenLength:values.length});const data=[];for(let i=0;i<types.length;i++)data.push(encode(types[i],
values[i]));return(0,concat_js_1.concatHex)(data)}}
//# sourceMappingURL=module$node_modules$viem$_cjs$utils$abi$encodePacked.js.map
