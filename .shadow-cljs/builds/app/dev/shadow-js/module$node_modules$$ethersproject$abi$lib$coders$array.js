["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/abi/lib/coders/array.js"],"~:js","shadow$provide.module$node_modules$$ethersproject$abi$lib$coders$array=function(global,require,module,exports){function pack(writer,coders,values){var arrayValues=null;if(Array.isArray(values))arrayValues=values;else if(values&&\"object\"===typeof values){var unique_1={};arrayValues=coders.map(function(coder){var name=coder.localName;name||logger.throwError(\"cannot encode object for signature with missing names\",logger_1.Logger.errors.INVALID_ARGUMENT,{argument:\"values\",coder,value:values});unique_1[name]&&\nlogger.throwError(\"cannot encode object for signature with duplicate names\",logger_1.Logger.errors.INVALID_ARGUMENT,{argument:\"values\",coder,value:values});unique_1[name]=!0;return values[name]})}else logger.throwArgumentError(\"invalid tuple value\",\"tuple\",values);coders.length!==arrayValues.length&&logger.throwArgumentError(\"types/value length mismatch\",\"tuple\",values);var staticWriter=new abstract_coder_1.Writer(writer.wordSize),dynamicWriter=new abstract_coder_1.Writer(writer.wordSize),updateFuncs=\n[];coders.forEach(function(coder,index){index=arrayValues[index];if(coder.dynamic){var dynamicOffset_1=dynamicWriter.length;coder.encode(dynamicWriter,index);var updateFunc_1=staticWriter.writeUpdatableValue();updateFuncs.push(function(baseOffset){updateFunc_1(baseOffset+dynamicOffset_1)})}else coder.encode(staticWriter,index)});updateFuncs.forEach(function(func){func(staticWriter.length)});coders=writer.appendWriter(staticWriter);return coders+=writer.appendWriter(dynamicWriter)}function unpack(reader,\ncoders){var values=[],baseReader=reader.subReader(0);coders.forEach(function(coder){var value=null;if(coder.dynamic){var offset=reader.readValue();offset=baseReader.subReader(offset.toNumber());try{value=coder.decode(offset)}catch(error){if(error.code===logger_1.Logger.errors.BUFFER_OVERRUN)throw error;value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}else try{value=coder.decode(reader)}catch(error){if(error.code===logger_1.Logger.errors.BUFFER_OVERRUN)throw error;\nvalue=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}void 0!=value&&values.push(value)});var uniqueNames=coders.reduce(function(accum,coder){if(coder=coder.localName)accum[coder]||(accum[coder]=0),accum[coder]++;return accum},{});coders.forEach(function(coder,index){if((coder=coder.localName)&&1===uniqueNames[coder]&&(\"length\"===coder&&(coder=\"_length\"),null==values[coder])){var value=values[index];value instanceof Error?Object.defineProperty(values,coder,{enumerable:!0,\nget:function(){throw value;}}):values[coder]=value}});coders=function(i){var value=values[i];value instanceof Error&&Object.defineProperty(values,i,{enumerable:!0,get:function(){throw value;}})};for(var i$jscomp$0=0;i$jscomp$0<values.length;i$jscomp$0++)coders(i$jscomp$0);return Object.freeze(values)}var __extends=this&&this.__extends||function(){var extendStatics=function(d$jscomp$0,b$jscomp$0){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,\nb){for(var p in b)Object.prototype.hasOwnProperty.call(b,p)&&(d[p]=b[p])};return extendStatics(d$jscomp$0,b$jscomp$0)};return function(d,b){function __(){this.constructor=d}if(\"function\"!==typeof b&&null!==b)throw new TypeError(\"Class extends value \"+String(b)+\" is not a constructor or null\");extendStatics(d,b);d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ArrayCoder=exports.unpack=exports.pack=void 0;var logger_1=\nrequire(\"module$node_modules$$ethersproject$logger$lib$index\");global=require(\"module$node_modules$$ethersproject$abi$lib$_version\");var logger=new logger_1.Logger(global.version),abstract_coder_1=require(\"module$node_modules$$ethersproject$abi$lib$coders$abstract_coder\"),anonymous_1=require(\"module$node_modules$$ethersproject$abi$lib$coders$anonymous\");exports.pack=pack;exports.unpack=unpack;require=function(_super){function ArrayCoder(coder,length,localName){localName=_super.call(this,\"array\",coder.type+\n\"[\"+(0<=length?length:\"\")+\"]\",localName,-1===length||coder.dynamic)||this;localName.coder=coder;localName.length=length;return localName}__extends(ArrayCoder,_super);ArrayCoder.prototype.defaultValue=function(){for(var defaultChild=this.coder.defaultValue(),result=[],i=0;i<this.length;i++)result.push(defaultChild);return result};ArrayCoder.prototype.encode=function(writer,value){Array.isArray(value)||this._throwError(\"expected array value\",value);var count=this.length;-1===count&&(count=value.length,\nwriter.writeValue(value.length));logger.checkArgumentCount(value.length,count,\"coder array\"+(this.localName?\" \"+this.localName:\"\"));count=[];for(var i=0;i<value.length;i++)count.push(this.coder);return pack(writer,count,value)};ArrayCoder.prototype.decode=function(reader){var count=this.length;-1===count&&(count=reader.readValue().toNumber(),32*count>reader._data.length&&logger.throwError(\"insufficient data length\",logger_1.Logger.errors.BUFFER_OVERRUN,{length:reader._data.length,count}));for(var coders=\n[],i=0;i<count;i++)coders.push(new anonymous_1.AnonymousCoder(this.coder));return reader.coerce(this.name,unpack(reader,coders))};return ArrayCoder}(abstract_coder_1.Coder);exports.ArrayCoder=require}","~:source","shadow$provide[\"module$node_modules$$ethersproject$abi$lib$coders$array\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayCoder = exports.unpack = exports.pack = void 0;\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"../_version\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar abstract_coder_1 = require(\"./abstract-coder\");\nvar anonymous_1 = require(\"./anonymous\");\nfunction pack(writer, coders, values) {\n    var arrayValues = null;\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        var unique_1 = {};\n        arrayValues = coders.map(function (coder) {\n            var name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            if (unique_1[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            unique_1[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n    var staticWriter = new abstract_coder_1.Writer(writer.wordSize);\n    var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);\n    var updateFuncs = [];\n    coders.forEach(function (coder, index) {\n        var value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            var dynamicOffset_1 = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            var updateFunc_1 = staticWriter.writeUpdatableValue();\n            updateFuncs.push(function (baseOffset) {\n                updateFunc_1(baseOffset + dynamicOffset_1);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach(function (func) { func(staticWriter.length); });\n    var length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\nexports.pack = pack;\nfunction unpack(reader, coders) {\n    var values = [];\n    // A reader anchored to this base\n    var baseReader = reader.subReader(0);\n    coders.forEach(function (coder) {\n        var value = null;\n        if (coder.dynamic) {\n            var offset = reader.readValue();\n            var offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n    // We only output named properties for uniquely named coders\n    var uniqueNames = coders.reduce(function (accum, coder) {\n        var name = coder.localName;\n        if (name) {\n            if (!accum[name]) {\n                accum[name] = 0;\n            }\n            accum[name]++;\n        }\n        return accum;\n    }, {});\n    // Add any named parameters (i.e. tuples)\n    coders.forEach(function (coder, index) {\n        var name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) {\n            return;\n        }\n        if (name === \"length\") {\n            name = \"_length\";\n        }\n        if (values[name] != null) {\n            return;\n        }\n        var value = values[index];\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: function () { throw value; }\n            });\n        }\n        else {\n            values[name] = value;\n        }\n    });\n    var _loop_1 = function (i) {\n        var value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: function () { throw value; }\n            });\n        }\n    };\n    for (var i = 0; i < values.length; i++) {\n        _loop_1(i);\n    }\n    return Object.freeze(values);\n}\nexports.unpack = unpack;\nvar ArrayCoder = /** @class */ (function (_super) {\n    __extends(ArrayCoder, _super);\n    function ArrayCoder(coder, length, localName) {\n        var _this = this;\n        var type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        var dynamic = (length === -1 || coder.dynamic);\n        _this = _super.call(this, \"array\", type, localName, dynamic) || this;\n        _this.coder = coder;\n        _this.length = length;\n        return _this;\n    }\n    ArrayCoder.prototype.defaultValue = function () {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        var defaultChild = this.coder.defaultValue();\n        var result = [];\n        for (var i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    };\n    ArrayCoder.prototype.encode = function (writer, value) {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        var count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        var coders = [];\n        for (var i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    };\n    ArrayCoder.prototype.decode = function (reader) {\n        var count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", logger_1.Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        var coders = [];\n        for (var i = 0; i < count; i++) {\n            coders.push(new anonymous_1.AnonymousCoder(this.coder));\n        }\n        return reader.coerce(this.name, unpack(reader, coders));\n    };\n    return ArrayCoder;\n}(abstract_coder_1.Coder));\nexports.ArrayCoder = ArrayCoder;\n//# sourceMappingURL=array.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$ethersproject$abi$lib$coders$anonymous","~$shadow.js","~$module$node_modules$$ethersproject$abi$lib$coders$abstract_coder","~$module$node_modules$$ethersproject$logger$lib$index","~$module$node_modules$$ethersproject$abi$lib$_version"]],"~:properties",["^5",["prototype","pack","ArrayCoder","baseType","decode","__esModule","count","name","value","enumerable","coder","length","type","__proto__","argument","defaultValue","unpack","get","encode","constructor"]],"~:compiled-at",1695040653413,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$abi$lib$coders$array.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@ethersproject/abi/lib/coders/array.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$ethersproject$abi$lib$coders$array\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        if (typeof b !== \\\"function\\\" && b !== null)\\n            throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.ArrayCoder = exports.unpack = exports.pack = void 0;\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"../_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\nvar abstract_coder_1 = require(\\\"./abstract-coder\\\");\\nvar anonymous_1 = require(\\\"./anonymous\\\");\\nfunction pack(writer, coders, values) {\\n    var arrayValues = null;\\n    if (Array.isArray(values)) {\\n        arrayValues = values;\\n    }\\n    else if (values && typeof (values) === \\\"object\\\") {\\n        var unique_1 = {};\\n        arrayValues = coders.map(function (coder) {\\n            var name = coder.localName;\\n            if (!name) {\\n                logger.throwError(\\\"cannot encode object for signature with missing names\\\", logger_1.Logger.errors.INVALID_ARGUMENT, {\\n                    argument: \\\"values\\\",\\n                    coder: coder,\\n                    value: values\\n                });\\n            }\\n            if (unique_1[name]) {\\n                logger.throwError(\\\"cannot encode object for signature with duplicate names\\\", logger_1.Logger.errors.INVALID_ARGUMENT, {\\n                    argument: \\\"values\\\",\\n                    coder: coder,\\n                    value: values\\n                });\\n            }\\n            unique_1[name] = true;\\n            return values[name];\\n        });\\n    }\\n    else {\\n        logger.throwArgumentError(\\\"invalid tuple value\\\", \\\"tuple\\\", values);\\n    }\\n    if (coders.length !== arrayValues.length) {\\n        logger.throwArgumentError(\\\"types/value length mismatch\\\", \\\"tuple\\\", values);\\n    }\\n    var staticWriter = new abstract_coder_1.Writer(writer.wordSize);\\n    var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);\\n    var updateFuncs = [];\\n    coders.forEach(function (coder, index) {\\n        var value = arrayValues[index];\\n        if (coder.dynamic) {\\n            // Get current dynamic offset (for the future pointer)\\n            var dynamicOffset_1 = dynamicWriter.length;\\n            // Encode the dynamic value into the dynamicWriter\\n            coder.encode(dynamicWriter, value);\\n            // Prepare to populate the correct offset once we are done\\n            var updateFunc_1 = staticWriter.writeUpdatableValue();\\n            updateFuncs.push(function (baseOffset) {\\n                updateFunc_1(baseOffset + dynamicOffset_1);\\n            });\\n        }\\n        else {\\n            coder.encode(staticWriter, value);\\n        }\\n    });\\n    // Backfill all the dynamic offsets, now that we know the static length\\n    updateFuncs.forEach(function (func) { func(staticWriter.length); });\\n    var length = writer.appendWriter(staticWriter);\\n    length += writer.appendWriter(dynamicWriter);\\n    return length;\\n}\\nexports.pack = pack;\\nfunction unpack(reader, coders) {\\n    var values = [];\\n    // A reader anchored to this base\\n    var baseReader = reader.subReader(0);\\n    coders.forEach(function (coder) {\\n        var value = null;\\n        if (coder.dynamic) {\\n            var offset = reader.readValue();\\n            var offsetReader = baseReader.subReader(offset.toNumber());\\n            try {\\n                value = coder.decode(offsetReader);\\n            }\\n            catch (error) {\\n                // Cannot recover from this\\n                if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {\\n                    throw error;\\n                }\\n                value = error;\\n                value.baseType = coder.name;\\n                value.name = coder.localName;\\n                value.type = coder.type;\\n            }\\n        }\\n        else {\\n            try {\\n                value = coder.decode(reader);\\n            }\\n            catch (error) {\\n                // Cannot recover from this\\n                if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {\\n                    throw error;\\n                }\\n                value = error;\\n                value.baseType = coder.name;\\n                value.name = coder.localName;\\n                value.type = coder.type;\\n            }\\n        }\\n        if (value != undefined) {\\n            values.push(value);\\n        }\\n    });\\n    // We only output named properties for uniquely named coders\\n    var uniqueNames = coders.reduce(function (accum, coder) {\\n        var name = coder.localName;\\n        if (name) {\\n            if (!accum[name]) {\\n                accum[name] = 0;\\n            }\\n            accum[name]++;\\n        }\\n        return accum;\\n    }, {});\\n    // Add any named parameters (i.e. tuples)\\n    coders.forEach(function (coder, index) {\\n        var name = coder.localName;\\n        if (!name || uniqueNames[name] !== 1) {\\n            return;\\n        }\\n        if (name === \\\"length\\\") {\\n            name = \\\"_length\\\";\\n        }\\n        if (values[name] != null) {\\n            return;\\n        }\\n        var value = values[index];\\n        if (value instanceof Error) {\\n            Object.defineProperty(values, name, {\\n                enumerable: true,\\n                get: function () { throw value; }\\n            });\\n        }\\n        else {\\n            values[name] = value;\\n        }\\n    });\\n    var _loop_1 = function (i) {\\n        var value = values[i];\\n        if (value instanceof Error) {\\n            Object.defineProperty(values, i, {\\n                enumerable: true,\\n                get: function () { throw value; }\\n            });\\n        }\\n    };\\n    for (var i = 0; i < values.length; i++) {\\n        _loop_1(i);\\n    }\\n    return Object.freeze(values);\\n}\\nexports.unpack = unpack;\\nvar ArrayCoder = /** @class */ (function (_super) {\\n    __extends(ArrayCoder, _super);\\n    function ArrayCoder(coder, length, localName) {\\n        var _this = this;\\n        var type = (coder.type + \\\"[\\\" + (length >= 0 ? length : \\\"\\\") + \\\"]\\\");\\n        var dynamic = (length === -1 || coder.dynamic);\\n        _this = _super.call(this, \\\"array\\\", type, localName, dynamic) || this;\\n        _this.coder = coder;\\n        _this.length = length;\\n        return _this;\\n    }\\n    ArrayCoder.prototype.defaultValue = function () {\\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\\n        var defaultChild = this.coder.defaultValue();\\n        var result = [];\\n        for (var i = 0; i < this.length; i++) {\\n            result.push(defaultChild);\\n        }\\n        return result;\\n    };\\n    ArrayCoder.prototype.encode = function (writer, value) {\\n        if (!Array.isArray(value)) {\\n            this._throwError(\\\"expected array value\\\", value);\\n        }\\n        var count = this.length;\\n        if (count === -1) {\\n            count = value.length;\\n            writer.writeValue(value.length);\\n        }\\n        logger.checkArgumentCount(value.length, count, \\\"coder array\\\" + (this.localName ? (\\\" \\\" + this.localName) : \\\"\\\"));\\n        var coders = [];\\n        for (var i = 0; i < value.length; i++) {\\n            coders.push(this.coder);\\n        }\\n        return pack(writer, coders, value);\\n    };\\n    ArrayCoder.prototype.decode = function (reader) {\\n        var count = this.length;\\n        if (count === -1) {\\n            count = reader.readValue().toNumber();\\n            // Check that there is *roughly* enough data to ensure\\n            // stray random data is not being read as a length. Each\\n            // slot requires at least 32 bytes for their value (or 32\\n            // bytes as a link to the data). This could use a much\\n            // tighter bound, but we are erroring on the side of safety.\\n            if (count * 32 > reader._data.length) {\\n                logger.throwError(\\\"insufficient data length\\\", logger_1.Logger.errors.BUFFER_OVERRUN, {\\n                    length: reader._data.length,\\n                    count: count\\n                });\\n            }\\n        }\\n        var coders = [];\\n        for (var i = 0; i < count; i++) {\\n            coders.push(new anonymous_1.AnonymousCoder(this.coder));\\n        }\\n        return reader.coerce(this.name, unpack(reader, coders));\\n    };\\n    return ArrayCoder;\\n}(abstract_coder_1.Coder));\\nexports.ArrayCoder = ArrayCoder;\\n//# sourceMappingURL=array.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"pack\",\"writer\",\"coders\",\"values\",\"arrayValues\",\"Array\",\"isArray\",\"unique_1\",\"map\",\"coder\",\"name\",\"localName\",\"logger\",\"throwError\",\"logger_1\",\"Logger\",\"errors\",\"INVALID_ARGUMENT\",\"argument\",\"value\",\"throwArgumentError\",\"length\",\"staticWriter\",\"abstract_coder_1\",\"Writer\",\"wordSize\",\"dynamicWriter\",\"updateFuncs\",\"forEach\",\"index\",\"dynamic\",\"dynamicOffset_1\",\"encode\",\"updateFunc_1\",\"writeUpdatableValue\",\"push\",\"baseOffset\",\"func\",\"appendWriter\",\"unpack\",\"reader\",\"baseReader\",\"subReader\",\"offset\",\"readValue\",\"offsetReader\",\"toNumber\",\"decode\",\"error\",\"code\",\"BUFFER_OVERRUN\",\"baseType\",\"type\",\"undefined\",\"uniqueNames\",\"reduce\",\"accum\",\"Error\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"_loop_1\",\"i\",\"freeze\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"setPrototypeOf\",\"__proto__\",\"p\",\"prototype\",\"hasOwnProperty\",\"call\",\"__\",\"constructor\",\"TypeError\",\"String\",\"create\",\"ArrayCoder\",\"_version_1\",\"version\",\"anonymous_1\",\"_super\",\"_this\",\"defaultValue\",\"ArrayCoder.prototype.defaultValue\",\"defaultChild\",\"result\",\"ArrayCoder.prototype.encode\",\"_throwError\",\"count\",\"writeValue\",\"checkArgumentCount\",\"ArrayCoder.prototype.decode\",\"_data\",\"AnonymousCoder\",\"coerce\",\"Coder\"]\n}\n"]