["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/stream-http/lib/response.js"],"~:js","shadow$provide[299]=function(S,A,V,q){var F=A(1),G=A(53).Buffer,r=A(298);V=A(76);var y=A(156),e=q.readyStates={UNSENT:0,OPENED:1,HEADERS_RECEIVED:2,LOADING:3,DONE:4};A=q.IncomingMessage=function(u,p,n,l){var h=this;y.Readable.call(h);h._mode=n;h.headers={};h.rawHeaders=[];h.trailers={};h.rawTrailers=[];h.on(\"end\",function(){F.nextTick(function(){h.emit(\"close\")})});if(\"fetch\"===n){h._fetchResponse=p;h.url=p.url;h.statusCode=p.status;h.statusMessage=p.statusText;p.headers.forEach(function(B,E){h.headers[E.toLowerCase()]=\nB;h.rawHeaders.push(E,B)});if(r.writableStream){u=new WritableStream({write:function(B){return new Promise(function(E,H){h._destroyed?H():h.push(new G(B))?E():h._resumeFetch=E})},close:function(){S.clearTimeout(l);h._destroyed||h.push(null)},abort:function(B){h._destroyed||h.emit(\"error\",B)}});try{p.body.pipeTo(u).catch(function(B){S.clearTimeout(l);h._destroyed||h.emit(\"error\",B)});return}catch(B){}}var k=p.body.getReader();function t(){k.read().then(function(B){h._destroyed||(B.done?(S.clearTimeout(l),\nh.push(null)):(h.push(new G(B.value)),t()))}).catch(function(B){S.clearTimeout(l);h._destroyed||h.emit(\"error\",B)})}t()}else if(h._xhr=u,h._pos=0,h.url=u.responseURL,h.statusCode=u.status,h.statusMessage=u.statusText,u.getAllResponseHeaders().split(/\\r?\\n/).forEach(function(t){if(t=t.match(/^([^:]+):\\s*(.*)/)){var B=t[1].toLowerCase();\"set-cookie\"===B?(void 0===h.headers[B]&&(h.headers[B]=[]),h.headers[B].push(t[2])):h.headers[B]=void 0!==h.headers[B]?h.headers[B]+(\", \"+t[2]):t[2];h.rawHeaders.push(t[1],\nt[2])}}),h._charset=\"x-user-defined\",!r.overrideMimeType){if(p=h.rawHeaders[\"mime-type\"])if(p=p.match(/;\\s*charset=([^;])(;|$)/))h._charset=p[1].toLowerCase();h._charset||(h._charset=\"utf-8\")}};V(A,y.Readable);A.prototype._read=function(){var u=this._resumeFetch;u&&(this._resumeFetch=null,u())};A.prototype._onXHRProgress=function(){var u=this,p=u._xhr,n=null;switch(u._mode){case \"text:vbarray\":if(p.readyState!==e.DONE)break;try{n=(new S.VBArray(p.responseBody)).toArray()}catch(t){}if(null!==n){u.push(new G(n));\nbreak}case \"text\":try{n=p.responseText}catch(t){u._mode=\"text:vbarray\";break}if(n.length>u._pos){p=n.substr(u._pos);if(\"x-user-defined\"===u._charset){for(var l=new G(p.length),h=0;h<p.length;h++)l[h]=p.charCodeAt(h)&255;u.push(l)}else u.push(p,u._charset);u._pos=n.length}break;case \"arraybuffer\":if(p.readyState!==e.DONE||!p.response)break;n=p.response;u.push(new G(new Uint8Array(n)));break;case \"moz-chunked-arraybuffer\":n=p.response;if(p.readyState!==e.LOADING||!n)break;u.push(new G(new Uint8Array(n)));\nbreak;case \"ms-stream\":if(n=p.response,p.readyState===e.LOADING){var k=new S.MSStreamReader;k.onprogress=function(){k.result.byteLength>u._pos&&(u.push(new G(new Uint8Array(k.result.slice(u._pos)))),u._pos=k.result.byteLength)};k.onload=function(){u.push(null)};k.readAsArrayBuffer(n)}}u._xhr.readyState===e.DONE&&\"ms-stream\"!==u._mode&&u.push(null)}}","~:source","shadow$provide[299] = function(global,require,module,exports) {\nvar process = require('process');\nvar Buffer = require('buffer').Buffer;\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function (header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\t\tif (capability.writableStream) {\n\t\t\tvar writable = new WritableStream({\n\t\t\t\twrite: function (chunk) {\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tif (self._destroyed) {\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else if(self.push(new Buffer(chunk))) {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself._resumeFetch = resolve\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tglobal.clearTimeout(fetchTimer)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.push(null)\n\t\t\t\t},\n\t\t\t\tabort: function (err) {\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\n\t\t\t\t\tglobal.clearTimeout(fetchTimer)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t\t}\n\t\t// fallback for when writableStream or pipeTo aren't available\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tif (result.done) {\n\t\t\t\t\tglobal.clearTimeout(fetchTimer)\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(new Buffer(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function (err) {\n\t\t\t\tglobal.clearTimeout(fetchTimer)\n\t\t\t\tif (!self._destroyed)\n\t\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar self = this\n\n\tvar resolve = self._resumeFetch\n\tif (resolve) {\n\t\tself._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nIncomingMessage.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text:vbarray': // For IE9\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\ttry {\n\t\t\t\t// This fails in IE8\n\t\t\t\tresponse = new global.VBArray(xhr.responseBody).toArray()\n\t\t\t} catch (e) {}\n\t\t\tif (response !== null) {\n\t\t\t\tself.push(new Buffer(response))\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Falls through in IE8\t\n\t\tcase 'text':\n\t\t\ttry { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n\t\t\t\tresponse = xhr.responseText\n\t\t\t} catch (e) {\n\t\t\t\tself._mode = 'text:vbarray'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = new Buffer(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tself.push(null)\n\t}\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$process$browser","~$module$node_modules$stream_http$lib$capability","~$shadow.js","~$module$node_modules$inherits$inherits_browser","~$module$node_modules$buffer$index","~$module$node_modules$readable_stream$readable_browser"]],"~:properties",["^5",["url","HEADERS_RECEIVED","_xhr","_resumeFetch","DONE","readyStates","_fetchResponse","LOADING","rawHeaders","_read","_onXHRProgress","statusCode","IncomingMessage","_charset","statusMessage","_pos","onload","rawTrailers","close","OPENED","abort","write","onprogress","trailers","UNSENT","_mode","headers"]],"~:compiled-at",1695041440891,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$stream_http$lib$response.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/stream-http/lib/response.js\"],\n\"sourcesContent\":[\"shadow$provide[299] = function(global,require,module,exports) {\\nvar process = require('process');\\nvar Buffer = require('buffer').Buffer;\\nvar capability = require('./capability')\\nvar inherits = require('inherits')\\nvar stream = require('readable-stream')\\n\\nvar rStates = exports.readyStates = {\\n\\tUNSENT: 0,\\n\\tOPENED: 1,\\n\\tHEADERS_RECEIVED: 2,\\n\\tLOADING: 3,\\n\\tDONE: 4\\n}\\n\\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {\\n\\tvar self = this\\n\\tstream.Readable.call(self)\\n\\n\\tself._mode = mode\\n\\tself.headers = {}\\n\\tself.rawHeaders = []\\n\\tself.trailers = {}\\n\\tself.rawTrailers = []\\n\\n\\t// Fake the 'close' event, but only once 'end' fires\\n\\tself.on('end', function () {\\n\\t\\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\\n\\t\\tprocess.nextTick(function () {\\n\\t\\t\\tself.emit('close')\\n\\t\\t})\\n\\t})\\n\\n\\tif (mode === 'fetch') {\\n\\t\\tself._fetchResponse = response\\n\\n\\t\\tself.url = response.url\\n\\t\\tself.statusCode = response.status\\n\\t\\tself.statusMessage = response.statusText\\n\\t\\t\\n\\t\\tresponse.headers.forEach(function (header, key){\\n\\t\\t\\tself.headers[key.toLowerCase()] = header\\n\\t\\t\\tself.rawHeaders.push(key, header)\\n\\t\\t})\\n\\n\\t\\tif (capability.writableStream) {\\n\\t\\t\\tvar writable = new WritableStream({\\n\\t\\t\\t\\twrite: function (chunk) {\\n\\t\\t\\t\\t\\treturn new Promise(function (resolve, reject) {\\n\\t\\t\\t\\t\\t\\tif (self._destroyed) {\\n\\t\\t\\t\\t\\t\\t\\treject()\\n\\t\\t\\t\\t\\t\\t} else if(self.push(new Buffer(chunk))) {\\n\\t\\t\\t\\t\\t\\t\\tresolve()\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tself._resumeFetch = resolve\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tclose: function () {\\n\\t\\t\\t\\t\\tglobal.clearTimeout(fetchTimer)\\n\\t\\t\\t\\t\\tif (!self._destroyed)\\n\\t\\t\\t\\t\\t\\tself.push(null)\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tabort: function (err) {\\n\\t\\t\\t\\t\\tif (!self._destroyed)\\n\\t\\t\\t\\t\\t\\tself.emit('error', err)\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tresponse.body.pipeTo(writable).catch(function (err) {\\n\\t\\t\\t\\t\\tglobal.clearTimeout(fetchTimer)\\n\\t\\t\\t\\t\\tif (!self._destroyed)\\n\\t\\t\\t\\t\\t\\tself.emit('error', err)\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\treturn\\n\\t\\t\\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\\n\\t\\t}\\n\\t\\t// fallback for when writableStream or pipeTo aren't available\\n\\t\\tvar reader = response.body.getReader()\\n\\t\\tfunction read () {\\n\\t\\t\\treader.read().then(function (result) {\\n\\t\\t\\t\\tif (self._destroyed)\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif (result.done) {\\n\\t\\t\\t\\t\\tglobal.clearTimeout(fetchTimer)\\n\\t\\t\\t\\t\\tself.push(null)\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tself.push(new Buffer(result.value))\\n\\t\\t\\t\\tread()\\n\\t\\t\\t}).catch(function (err) {\\n\\t\\t\\t\\tglobal.clearTimeout(fetchTimer)\\n\\t\\t\\t\\tif (!self._destroyed)\\n\\t\\t\\t\\t\\tself.emit('error', err)\\n\\t\\t\\t})\\n\\t\\t}\\n\\t\\tread()\\n\\t} else {\\n\\t\\tself._xhr = xhr\\n\\t\\tself._pos = 0\\n\\n\\t\\tself.url = xhr.responseURL\\n\\t\\tself.statusCode = xhr.status\\n\\t\\tself.statusMessage = xhr.statusText\\n\\t\\tvar headers = xhr.getAllResponseHeaders().split(/\\\\r?\\\\n/)\\n\\t\\theaders.forEach(function (header) {\\n\\t\\t\\tvar matches = header.match(/^([^:]+):\\\\s*(.*)/)\\n\\t\\t\\tif (matches) {\\n\\t\\t\\t\\tvar key = matches[1].toLowerCase()\\n\\t\\t\\t\\tif (key === 'set-cookie') {\\n\\t\\t\\t\\t\\tif (self.headers[key] === undefined) {\\n\\t\\t\\t\\t\\t\\tself.headers[key] = []\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tself.headers[key].push(matches[2])\\n\\t\\t\\t\\t} else if (self.headers[key] !== undefined) {\\n\\t\\t\\t\\t\\tself.headers[key] += ', ' + matches[2]\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tself.headers[key] = matches[2]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tself.rawHeaders.push(matches[1], matches[2])\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tself._charset = 'x-user-defined'\\n\\t\\tif (!capability.overrideMimeType) {\\n\\t\\t\\tvar mimeType = self.rawHeaders['mime-type']\\n\\t\\t\\tif (mimeType) {\\n\\t\\t\\t\\tvar charsetMatch = mimeType.match(/;\\\\s*charset=([^;])(;|$)/)\\n\\t\\t\\t\\tif (charsetMatch) {\\n\\t\\t\\t\\t\\tself._charset = charsetMatch[1].toLowerCase()\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!self._charset)\\n\\t\\t\\t\\tself._charset = 'utf-8' // best guess\\n\\t\\t}\\n\\t}\\n}\\n\\ninherits(IncomingMessage, stream.Readable)\\n\\nIncomingMessage.prototype._read = function () {\\n\\tvar self = this\\n\\n\\tvar resolve = self._resumeFetch\\n\\tif (resolve) {\\n\\t\\tself._resumeFetch = null\\n\\t\\tresolve()\\n\\t}\\n}\\n\\nIncomingMessage.prototype._onXHRProgress = function () {\\n\\tvar self = this\\n\\n\\tvar xhr = self._xhr\\n\\n\\tvar response = null\\n\\tswitch (self._mode) {\\n\\t\\tcase 'text:vbarray': // For IE9\\n\\t\\t\\tif (xhr.readyState !== rStates.DONE)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\ttry {\\n\\t\\t\\t\\t// This fails in IE8\\n\\t\\t\\t\\tresponse = new global.VBArray(xhr.responseBody).toArray()\\n\\t\\t\\t} catch (e) {}\\n\\t\\t\\tif (response !== null) {\\n\\t\\t\\t\\tself.push(new Buffer(response))\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\t// Falls through in IE8\\t\\n\\t\\tcase 'text':\\n\\t\\t\\ttry { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\\n\\t\\t\\t\\tresponse = xhr.responseText\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\tself._mode = 'text:vbarray'\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tif (response.length > self._pos) {\\n\\t\\t\\t\\tvar newData = response.substr(self._pos)\\n\\t\\t\\t\\tif (self._charset === 'x-user-defined') {\\n\\t\\t\\t\\t\\tvar buffer = new Buffer(newData.length)\\n\\t\\t\\t\\t\\tfor (var i = 0; i < newData.length; i++)\\n\\t\\t\\t\\t\\t\\tbuffer[i] = newData.charCodeAt(i) & 0xff\\n\\n\\t\\t\\t\\t\\tself.push(buffer)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tself.push(newData, self._charset)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tself._pos = response.length\\n\\t\\t\\t}\\n\\t\\t\\tbreak\\n\\t\\tcase 'arraybuffer':\\n\\t\\t\\tif (xhr.readyState !== rStates.DONE || !xhr.response)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tresponse = xhr.response\\n\\t\\t\\tself.push(new Buffer(new Uint8Array(response)))\\n\\t\\t\\tbreak\\n\\t\\tcase 'moz-chunked-arraybuffer': // take whole\\n\\t\\t\\tresponse = xhr.response\\n\\t\\t\\tif (xhr.readyState !== rStates.LOADING || !response)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tself.push(new Buffer(new Uint8Array(response)))\\n\\t\\t\\tbreak\\n\\t\\tcase 'ms-stream':\\n\\t\\t\\tresponse = xhr.response\\n\\t\\t\\tif (xhr.readyState !== rStates.LOADING)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tvar reader = new global.MSStreamReader()\\n\\t\\t\\treader.onprogress = function () {\\n\\t\\t\\t\\tif (reader.result.byteLength > self._pos) {\\n\\t\\t\\t\\t\\tself.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))\\n\\t\\t\\t\\t\\tself._pos = reader.result.byteLength\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treader.onload = function () {\\n\\t\\t\\t\\tself.push(null)\\n\\t\\t\\t}\\n\\t\\t\\t// reader.onerror = ??? // TODO: this\\n\\t\\t\\treader.readAsArrayBuffer(response)\\n\\t\\t\\tbreak\\n\\t}\\n\\n\\t// The ms-stream case handles end separately in reader.onload()\\n\\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\\n\\t\\tself.push(null)\\n\\t}\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"process\",\"Buffer\",\"capability\",\"inherits\",\"stream\",\"rStates\",\"readyStates\",\"UNSENT\",\"OPENED\",\"HEADERS_RECEIVED\",\"LOADING\",\"DONE\",\"IncomingMessage\",\"exports.IncomingMessage\",\"xhr\",\"response\",\"mode\",\"fetchTimer\",\"self\",\"Readable\",\"call\",\"_mode\",\"headers\",\"rawHeaders\",\"trailers\",\"rawTrailers\",\"on\",\"nextTick\",\"emit\",\"_fetchResponse\",\"url\",\"statusCode\",\"status\",\"statusMessage\",\"statusText\",\"forEach\",\"header\",\"key\",\"toLowerCase\",\"push\",\"writableStream\",\"writable\",\"WritableStream\",\"write\",\"chunk\",\"Promise\",\"resolve\",\"reject\",\"_destroyed\",\"_resumeFetch\",\"close\",\"clearTimeout\",\"abort\",\"err\",\"body\",\"pipeTo\",\"catch\",\"e\",\"reader\",\"getReader\",\"read\",\"then\",\"result\",\"done\",\"value\",\"_xhr\",\"_pos\",\"responseURL\",\"getAllResponseHeaders\",\"split\",\"matches\",\"match\",\"undefined\",\"_charset\",\"overrideMimeType\",\"mimeType\",\"charsetMatch\",\"prototype\",\"_read\",\"IncomingMessage.prototype._read\",\"_onXHRProgress\",\"IncomingMessage.prototype._onXHRProgress\",\"readyState\",\"toArray\",\"VBArray\",\"responseBody\",\"responseText\",\"length\",\"newData\",\"substr\",\"buffer\",\"i\",\"charCodeAt\",\"Uint8Array\",\"MSStreamReader\",\"onprogress\",\"reader.onprogress\",\"byteLength\",\"slice\",\"onload\",\"reader.onload\",\"readAsArrayBuffer\"]\n}\n"]