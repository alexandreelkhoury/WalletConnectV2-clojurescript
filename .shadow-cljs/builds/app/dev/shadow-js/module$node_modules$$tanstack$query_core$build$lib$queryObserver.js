["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@tanstack/query-core/build/lib/queryObserver.js"],"~:js","shadow$provide.module$node_modules$$tanstack$query_core$build$lib$queryObserver=function(global,require,module,exports){function shouldFetchOnMount(query,options){return!1!==options.enabled&&!query.state.dataUpdatedAt&&!(\"error\"===query.state.status&&!1===options.retryOnMount)||0<query.state.dataUpdatedAt&&shouldFetchOn(query,options,options.refetchOnMount)}function shouldFetchOn(query,options,field){return!1!==options.enabled?(field=\"function\"===typeof field?field(query):field,\"always\"===field||\n!1!==field&&query.isStaleByTime(options.staleTime)):!1}function shouldFetchOptionally(query,prevQuery,options,prevOptions){return!1!==options.enabled&&(query!==prevQuery||!1===prevOptions.enabled)&&(!options.suspense||\"error\"!==query.state.status)&&query.isStaleByTime(options.staleTime)}Object.defineProperty(exports,\"__esModule\",{value:!0});var utils=require(\"module$node_modules$$tanstack$query_core$build$lib$utils\"),notifyManager=require(\"module$node_modules$$tanstack$query_core$build$lib$notifyManager\"),\nfocusManager=require(\"module$node_modules$$tanstack$query_core$build$lib$focusManager\");global=require(\"module$node_modules$$tanstack$query_core$build$lib$subscribable\");var retryer=require(\"module$node_modules$$tanstack$query_core$build$lib$retryer\");class QueryObserver extends global.Subscribable{constructor(client,options){super();this.client=client;this.options=options;this.trackedProps=new Set;this.selectError=null;this.bindMethods();this.setOptions(options)}bindMethods(){this.remove=this.remove.bind(this);\nthis.refetch=this.refetch.bind(this)}onSubscribe(){1===this.listeners.size&&(this.currentQuery.addObserver(this),shouldFetchOnMount(this.currentQuery,this.options)&&this.executeFetch(),this.updateTimers())}onUnsubscribe(){this.hasListeners()||this.destroy()}shouldFetchOnReconnect(){return shouldFetchOn(this.currentQuery,this.options,this.options.refetchOnReconnect)}shouldFetchOnWindowFocus(){return shouldFetchOn(this.currentQuery,this.options,this.options.refetchOnWindowFocus)}destroy(){this.listeners=\nnew Set;this.clearStaleTimeout();this.clearRefetchInterval();this.currentQuery.removeObserver(this)}setOptions(options,notifyOptions){const prevOptions=this.options,prevQuery=this.currentQuery;this.options=this.client.defaultQueryOptions(options);\"undefined\"!==typeof(null==options?void 0:options.isDataEqual)&&this.client.getLogger().error(\"The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option\");\nutils.shallowEqualObjects(prevOptions,this.options)||this.client.getQueryCache().notify({type:\"observerOptionsUpdated\",query:this.currentQuery,observer:this});if(\"undefined\"!==typeof this.options.enabled&&\"boolean\"!==typeof this.options.enabled)throw Error(\"Expected enabled to be a boolean\");this.options.queryKey||(this.options.queryKey=prevOptions.queryKey);this.updateQuery();(options=this.hasListeners())&&shouldFetchOptionally(this.currentQuery,prevQuery,this.options,prevOptions)&&this.executeFetch();\nthis.updateResult(notifyOptions);!options||this.currentQuery===prevQuery&&this.options.enabled===prevOptions.enabled&&this.options.staleTime===prevOptions.staleTime||this.updateStaleTimeout();notifyOptions=this.computeRefetchInterval();!options||this.currentQuery===prevQuery&&this.options.enabled===prevOptions.enabled&&notifyOptions===this.currentRefetchInterval||this.updateRefetchInterval(notifyOptions)}getOptimisticResult(options){var query=this.client.getQueryCache().build(this.client,options);\nquery=this.createResult(query,options);options=options.keepPreviousData?!1:void 0!==options.placeholderData?query.isPlaceholderData:utils.shallowEqualObjects(this.getCurrentResult(),query)?!1:!0;options&&(this.currentResult=query,this.currentResultOptions=this.options,this.currentResultState=this.currentQuery.state);return query}getCurrentResult(){return this.currentResult}trackResult(result){const trackedResult={};Object.keys(result).forEach(key=>{Object.defineProperty(trackedResult,key,{configurable:!1,\nenumerable:!0,get:()=>{this.trackedProps.add(key);return result[key]}})});return trackedResult}getCurrentQuery(){return this.currentQuery}remove(){this.client.getQueryCache().remove(this.currentQuery)}refetch({refetchPage,...options}={}){return this.fetch({...options,meta:{refetchPage}})}fetchOptimistic(options){const defaultedOptions=this.client.defaultQueryOptions(options),query=this.client.getQueryCache().build(this.client,defaultedOptions);query.isFetchingOptimistic=!0;return query.fetch().then(()=>\nthis.createResult(query,defaultedOptions))}fetch(fetchOptions){var _fetchOptions$cancelR;return this.executeFetch({...fetchOptions,cancelRefetch:null!=(_fetchOptions$cancelR=fetchOptions.cancelRefetch)?_fetchOptions$cancelR:!0}).then(()=>{this.updateResult();return this.currentResult})}executeFetch(fetchOptions){this.updateQuery();let promise=this.currentQuery.fetch(this.options,fetchOptions);null!=fetchOptions&&fetchOptions.throwOnError||(promise=promise.catch(utils.noop));return promise}updateStaleTimeout(){this.clearStaleTimeout();\nif(!utils.isServer&&!this.currentResult.isStale&&utils.isValidTimeout(this.options.staleTime)){var time=utils.timeUntilStale(this.currentResult.dataUpdatedAt,this.options.staleTime);this.staleTimeoutId=setTimeout(()=>{this.currentResult.isStale||this.updateResult()},time+1)}}computeRefetchInterval(){var _this$options$refetch;return\"function\"===typeof this.options.refetchInterval?this.options.refetchInterval(this.currentResult.data,this.currentQuery):null!=(_this$options$refetch=this.options.refetchInterval)?\n_this$options$refetch:!1}updateRefetchInterval(nextInterval){this.clearRefetchInterval();this.currentRefetchInterval=nextInterval;!utils.isServer&&!1!==this.options.enabled&&utils.isValidTimeout(this.currentRefetchInterval)&&0!==this.currentRefetchInterval&&(this.refetchIntervalId=setInterval(()=>{(this.options.refetchIntervalInBackground||focusManager.focusManager.isFocused())&&this.executeFetch()},this.currentRefetchInterval))}updateTimers(){this.updateStaleTimeout();this.updateRefetchInterval(this.computeRefetchInterval())}clearStaleTimeout(){this.staleTimeoutId&&\n(clearTimeout(this.staleTimeoutId),this.staleTimeoutId=void 0)}clearRefetchInterval(){this.refetchIntervalId&&(clearInterval(this.refetchIntervalId),this.refetchIntervalId=void 0)}createResult(query,options){var prevQuery=this.currentQuery;const prevOptions=this.options;var prevResult=this.currentResult,prevResultState=this.currentResultState,prevResultOptions=this.currentResultOptions,queryChange=query!==prevQuery;const queryInitialState=queryChange?query.state:this.currentQueryInitialState,prevQueryResult=\nqueryChange?this.currentResult:this.previousQueryResult;({state:queryChange}=query);let {dataUpdatedAt,error,errorUpdatedAt,fetchStatus,status}=queryChange,isPreviousData=!1,isPlaceholderData=!1,data;if(options._optimisticResults){const mounted=this.hasListeners(),fetchOnMount=!mounted&&shouldFetchOnMount(query,options);prevQuery=mounted&&shouldFetchOptionally(query,prevQuery,options,prevOptions);if(fetchOnMount||prevQuery)fetchStatus=retryer.canFetch(query.options.networkMode)?\"fetching\":\"paused\",\ndataUpdatedAt||(status=\"loading\");\"isRestoring\"===options._optimisticResults&&(fetchStatus=\"idle\")}if(options.keepPreviousData&&!queryChange.dataUpdatedAt&&null!=prevQueryResult&&prevQueryResult.isSuccess&&\"error\"!==status)data=prevQueryResult.data,dataUpdatedAt=prevQueryResult.dataUpdatedAt,status=prevQueryResult.status,isPreviousData=!0;else if(options.select&&\"undefined\"!==typeof queryChange.data)if(prevResult&&queryChange.data===(null==prevResultState?void 0:prevResultState.data)&&options.select===\nthis.selectFn)data=this.selectResult;else try{this.selectFn=options.select,data=options.select(queryChange.data),this.selectResult=data=utils.replaceData(null==prevResult?void 0:prevResult.data,data,options),this.selectError=null}catch(selectError){this.client.getLogger().error(selectError),this.selectError=selectError}else data=queryChange.data;if(\"undefined\"!==typeof options.placeholderData&&\"undefined\"===typeof data&&\"loading\"===status){if(null!=prevResult&&prevResult.isPlaceholderData&&options.placeholderData===\n(null==prevResultOptions?void 0:prevResultOptions.placeholderData))prevResultState=prevResult.data;else if(prevResultState=\"function\"===typeof options.placeholderData?options.placeholderData():options.placeholderData,options.select&&\"undefined\"!==typeof prevResultState)try{prevResultState=options.select(prevResultState),this.selectError=null}catch(selectError){this.client.getLogger().error(selectError),this.selectError=selectError}\"undefined\"!==typeof prevResultState&&(status=\"success\",data=utils.replaceData(null==\nprevResult?void 0:prevResult.data,prevResultState,options),isPlaceholderData=!0)}this.selectError&&(error=this.selectError,data=this.selectResult,errorUpdatedAt=Date.now(),status=\"error\");prevResult=\"fetching\"===fetchStatus;prevResultState=\"loading\"===status;prevResultOptions=\"error\"===status;return{status,fetchStatus,isLoading:prevResultState,isSuccess:\"success\"===status,isError:prevResultOptions,isInitialLoading:prevResultState&&prevResult,data,dataUpdatedAt,error,errorUpdatedAt,failureCount:queryChange.fetchFailureCount,\nfailureReason:queryChange.fetchFailureReason,errorUpdateCount:queryChange.errorUpdateCount,isFetched:0<queryChange.dataUpdateCount||0<queryChange.errorUpdateCount,isFetchedAfterMount:queryChange.dataUpdateCount>queryInitialState.dataUpdateCount||queryChange.errorUpdateCount>queryInitialState.errorUpdateCount,isFetching:prevResult,isRefetching:prevResult&&!prevResultState,isLoadingError:prevResultOptions&&0===queryChange.dataUpdatedAt,isPaused:\"paused\"===fetchStatus,isPlaceholderData,isPreviousData,\nisRefetchError:prevResultOptions&&0!==queryChange.dataUpdatedAt,isStale:query.isStaleByTime(options.staleTime),refetch:this.refetch,remove:this.remove}}updateResult(notifyOptions){const prevResult=this.currentResult;var nextResult=this.createResult(this.currentQuery,this.options);this.currentResultState=this.currentQuery.state;this.currentResultOptions=this.options;if(!utils.shallowEqualObjects(nextResult,prevResult)){this.currentResult=nextResult;nextResult={cache:!0};var shouldNotifyListeners=()=>\n{if(!prevResult)return!0;var {notifyOnChangeProps}=this.options;notifyOnChangeProps=\"function\"===typeof notifyOnChangeProps?notifyOnChangeProps():notifyOnChangeProps;if(\"all\"===notifyOnChangeProps||!notifyOnChangeProps&&!this.trackedProps.size)return!0;const includedProps=new Set(null!=notifyOnChangeProps?notifyOnChangeProps:this.trackedProps);this.options.useErrorBoundary&&includedProps.add(\"error\");return Object.keys(this.currentResult).some(key=>this.currentResult[key]!==prevResult[key]&&includedProps.has(key))};\n!1!==(null==notifyOptions?void 0:notifyOptions.listeners)&&shouldNotifyListeners()&&(nextResult.listeners=!0);this.notify({...nextResult,...notifyOptions})}}updateQuery(){const query=this.client.getQueryCache().build(this.client,this.options);if(query!==this.currentQuery){var prevQuery=this.currentQuery;this.currentQuery=query;this.currentQueryInitialState=query.state;this.previousQueryResult=this.currentResult;this.hasListeners()&&(null==prevQuery?void 0:prevQuery.removeObserver(this),query.addObserver(this))}}onQueryUpdate(action){const notifyOptions=\n{};\"success\"===action.type?notifyOptions.onSuccess=!action.manual:\"error\"!==action.type||retryer.isCancelledError(action.error)||(notifyOptions.onError=!0);this.updateResult(notifyOptions);this.hasListeners()&&this.updateTimers()}notify(notifyOptions){notifyManager.notifyManager.batch(()=>{if(notifyOptions.onSuccess){var _this$options$onSucce,_this$options,_this$options$onSettl,_this$options2;null==(_this$options$onSucce=(_this$options=this.options).onSuccess)?void 0:_this$options$onSucce.call(_this$options,\nthis.currentResult.data);null==(_this$options$onSettl=(_this$options2=this.options).onSettled)?void 0:_this$options$onSettl.call(_this$options2,this.currentResult.data,null)}else if(notifyOptions.onError){var _this$options$onError,_this$options3,_this$options$onSettl2,_this$options4;null==(_this$options$onError=(_this$options3=this.options).onError)?void 0:_this$options$onError.call(_this$options3,this.currentResult.error);null==(_this$options$onSettl2=(_this$options4=this.options).onSettled)?void 0:\n_this$options$onSettl2.call(_this$options4,void 0,this.currentResult.error)}notifyOptions.listeners&&this.listeners.forEach(({listener})=>{listener(this.currentResult)});notifyOptions.cache&&this.client.getQueryCache().notify({query:this.currentQuery,type:\"observerResultsUpdated\"})})}}exports.QueryObserver=QueryObserver}","~:source","shadow$provide[\"module$node_modules$$tanstack$query_core$build$lib$queryObserver\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('./utils.js');\nvar notifyManager = require('./notifyManager.js');\nvar focusManager = require('./focusManager.js');\nvar subscribable = require('./subscribable.js');\nvar retryer = require('./retryer.js');\n\nclass QueryObserver extends subscribable.Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (process.env.NODE_ENV !== 'production' && typeof (options == null ? void 0 : options.isDataEqual) !== 'undefined') {\n      this.client.getLogger().error(\"The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option\");\n    }\n\n    if (!utils.shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    const result = this.createResult(query, options);\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result;\n      this.currentResultOptions = this.options;\n      this.currentResultState = this.currentQuery.state;\n    }\n\n    return result;\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(utils.noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (utils.isServer || this.currentResult.isStale || !utils.isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = utils.timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (utils.isServer || this.options.enabled === false || !utils.isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = retryer.canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = utils.replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = utils.replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const isLoading = status === 'loading';\n    const isError = status === 'error';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (utils.shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === 'function' ? notifyOnChangeProps() : notifyOnChangeProps;\n\n      if (notifyOnChangePropsValue === 'all' || !notifyOnChangePropsValue && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !retryer.isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n} // this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\n\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false;\n  } // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n\n\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData;\n  } // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n\n\n  if (!utils.shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  } // basically, just keep previous properties if nothing changed\n\n\n  return false;\n}\n\nexports.QueryObserver = QueryObserver;\n//# sourceMappingURL=queryObserver.js.map\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$tanstack$query_core$build$lib$focusManager","~$shadow.js","~$module$node_modules$$tanstack$query_core$build$lib$subscribable","~$module$node_modules$$tanstack$query_core$build$lib$utils","~$module$node_modules$$tanstack$query_core$build$lib$retryer","~$module$node_modules$$tanstack$query_core$build$lib$notifyManager"]],"~:properties",["^5",["isRefetching","queryKey","fetchStatus","dataUpdatedAt","isFetched","observer","errorUpdatedAt","errorUpdateCount","selectError","currentResultState","isRefetchError","cancelRefetch","selectResult","currentResultOptions","query","__esModule","currentQueryInitialState","error","onError","refetchIntervalId","isFetching","isInitialLoading","cache","refetchPage","configurable","value","enumerable","trackedProps","status","refetch","isLoading","remove","isPreviousData","failureCount","currentQuery","isFetchedAfterMount","onSuccess","type","QueryObserver","isPaused","isPlaceholderData","meta","isError","currentResult","failureReason","previousQueryResult","staleTimeoutId","client","options","isSuccess","selectFn","listeners","data","get","isStale","isLoadingError","currentRefetchInterval","isFetchingOptimistic"]],"~:compiled-at",1695111489943,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$tanstack$query_core$build$lib$queryObserver.js\",\n\"lineCount\":25,\n\"mappings\":\"AAAAA,cAAA,CAAA,gEAAA,CAAqF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAkhB7HC,QAASA,mBAAkB,CAACC,KAAD,CAAQC,OAAR,CAAiB,CAC1C,MAJ2B,CAAA,CAI3B,GAAgCA,OAJjBC,CAAAA,OAIf,EAJoC,CAIXF,KAJkBG,CAAAA,KAAMC,CAAAA,aAIjD,EAJkE,EAAyB,OAAzB,GAIzCJ,KAJiDG,CAAAA,KAAME,CAAAA,MAAd,EAA6D,CAAA,CAA7D,GAIlCJ,OAJ8EK,CAAAA,YAA5C,CAIlE,EAAwE,CAAxE,CAA4CN,KAAMG,CAAAA,KAAMC,CAAAA,aAAxD,EAA6EG,aAAA,CAAcP,KAAd,CAAqBC,OAArB,CAA8BA,OAAQO,CAAAA,cAAtC,CADnC,CAI5CD,QAASA,cAAa,CAACP,KAAD,CAAQC,OAAR,CAAiBQ,KAAjB,CAAwB,CAC5C,MAAwB,CAAA,CAAxB,GAAIR,OAAQC,CAAAA,OAAZ,EACQQ,KACC,CADwB,UAAjB,GAAA,MAAOD,MAAP,CAA8BA,KAAA,CAAMT,KAAN,CAA9B,CAA6CS,KACpD,CAAU,QAAV,GAAAC,KAAA;AAAgC,CAAA,CAAhC,GAAsBA,KAAtB,EAAiDV,KAW7CW,CAAAA,aAAN,CAX0DV,OAW9BW,CAAAA,SAA5B,CAbP,EAKO,CAAA,CANqC,CAS9CC,QAASA,sBAAqB,CAACb,KAAD,CAAQc,SAAR,CAAmBb,OAAnB,CAA4Bc,WAA5B,CAAyC,CACrE,MAA2B,CAAA,CAA3B,GAAOd,OAAQC,CAAAA,OAAf,GAAqCF,KAArC,GAA+Cc,SAA/C,EAAoF,CAAA,CAApF,GAA4DC,WAAYb,CAAAA,OAAxE,IAA+F,CAACD,OAAQe,CAAAA,QAAxG,EAA2I,OAA3I,GAAoHhB,KAAMG,CAAAA,KAAME,CAAAA,MAAhI,GAA+JL,KAIlJW,CAAAA,aAAN,CAJ+JV,OAInIW,CAAAA,SAA5B,CAL8D,CA5hBvEK,MAAOC,CAAAA,cAAP,CAAsBpB,OAAtB,CAA+B,YAA/B,CAA6C,CAAEY,MAAO,CAAA,CAAT,CAA7C,CAEA,KAAIS,MAAQvB,OAAA,CAAQ,0DAAR,CAAZ,CACIwB,cAAgBxB,OAAA,CAAQ,kEAAR,CADpB;AAEIyB,aAAezB,OAAA,CAAQ,iEAAR,CACf0B,OAAAA,CAAe1B,OAAA,CAAQ,iEAAR,CACnB,KAAI2B,QAAU3B,OAAA,CAAQ,4DAAR,CAEd,MAAM4B,cAAN,QAA4BF,OAAaG,CAAAA,YAAzC,CACEC,WAAW,CAACC,MAAD,CAAS1B,OAAT,CAAkB,CAC3B,KAAA,EACA,KAAK0B,CAAAA,MAAL,CAAcA,MACd,KAAK1B,CAAAA,OAAL,CAAeA,OACf,KAAK2B,CAAAA,YAAL,CAAoB,IAAIC,GACxB,KAAKC,CAAAA,WAAL,CAAmB,IACnB,KAAKC,CAAAA,WAAL,EACA,KAAKC,CAAAA,UAAL,CAAgB/B,OAAhB,CAP2B,CAU7B8B,WAAW,EAAG,CACZ,IAAKE,CAAAA,MAAL,CAAc,IAAKA,CAAAA,MAAOC,CAAAA,IAAZ,CAAiB,IAAjB,CACd;IAAKC,CAAAA,OAAL,CAAe,IAAKA,CAAAA,OAAQD,CAAAA,IAAb,CAAkB,IAAlB,CAFH,CAKdE,WAAW,EAAG,CACgB,CAA5B,GAAI,IAAKC,CAAAA,SAAUC,CAAAA,IAAnB,GACE,IAAKC,CAAAA,YAAaC,CAAAA,WAAlB,CAA8B,IAA9B,CAMA,CAJIzC,kBAAA,CAAmB,IAAKwC,CAAAA,YAAxB,CAAsC,IAAKtC,CAAAA,OAA3C,CAIJ,EAHE,IAAKwC,CAAAA,YAAL,EAGF,CAAA,IAAKC,CAAAA,YAAL,EAPF,CADY,CAYdC,aAAa,EAAG,CACT,IAAKC,CAAAA,YAAL,EAAL,EACE,IAAKC,CAAAA,OAAL,EAFY,CAMhBC,sBAAsB,EAAG,CACvB,MAAOvC,cAAA,CAAc,IAAKgC,CAAAA,YAAnB,CAAiC,IAAKtC,CAAAA,OAAtC,CAA+C,IAAKA,CAAAA,OAAQ8C,CAAAA,kBAA5D,CADgB,CAIzBC,wBAAwB,EAAG,CACzB,MAAOzC,cAAA,CAAc,IAAKgC,CAAAA,YAAnB,CAAiC,IAAKtC,CAAAA,OAAtC,CAA+C,IAAKA,CAAAA,OAAQgD,CAAAA,oBAA5D,CADkB,CAI3BJ,OAAO,EAAG,CACR,IAAKR,CAAAA,SAAL;AAAiB,IAAIR,GACrB,KAAKqB,CAAAA,iBAAL,EACA,KAAKC,CAAAA,oBAAL,EACA,KAAKZ,CAAAA,YAAaa,CAAAA,cAAlB,CAAiC,IAAjC,CAJQ,CAOVpB,UAAU,CAAC/B,OAAD,CAAUoD,aAAV,CAAyB,CACjC,MAAMtC,YAAc,IAAKd,CAAAA,OAAzB,CACMa,UAAY,IAAKyB,CAAAA,YACvB,KAAKtC,CAAAA,OAAL,CAAe,IAAK0B,CAAAA,MAAO2B,CAAAA,mBAAZ,CAAgCrD,OAAhC,CAE0F,YAAzG,GAA6C,OAAmB,IAAX,EAAAA,OAAA,CAAkB,IAAK,EAAvB,CAA2BA,OAAQsD,CAAAA,WAA3C,CAA7C,EACE,IAAK5B,CAAAA,MAAO6B,CAAAA,SAAZ,EAAwBC,CAAAA,KAAxB,CAA8B,wLAA9B,CAGGtC;KAAMuC,CAAAA,mBAAN,CAA0B3C,WAA1B,CAAuC,IAAKd,CAAAA,OAA5C,CAAL,EACE,IAAK0B,CAAAA,MAAOgC,CAAAA,aAAZ,EAA4BC,CAAAA,MAA5B,CAAmC,CACjCC,KAAM,wBAD2B,CAEjC7D,MAAO,IAAKuC,CAAAA,YAFqB,CAGjCuB,SAAU,IAHuB,CAAnC,CAOF,IAAoC,WAApC,GAAI,MAAO,KAAK7D,CAAAA,OAAQC,CAAAA,OAAxB,EAAmF,SAAnF,GAAmD,MAAO,KAAKD,CAAAA,OAAQC,CAAAA,OAAvE,CACE,KAAU6D,MAAJ,CAAU,kCAAV,CAAN,CAIG,IAAK9D,CAAAA,OAAQ+D,CAAAA,QAAlB,GACE,IAAK/D,CAAAA,OAAQ+D,CAAAA,QADf,CAC0BjD,WAAYiD,CAAAA,QADtC,CAIA,KAAKC,CAAAA,WAAL,EAGA,EAFMC,OAEN,CAFgB,IAAKtB,CAAAA,YAAL,EAEhB,GAAe/B,qBAAA,CAAsB,IAAK0B,CAAAA,YAA3B,CAAyCzB,SAAzC,CAAoD,IAAKb,CAAAA,OAAzD,CAAkEc,WAAlE,CAAf,EACE,IAAK0B,CAAAA,YAAL,EAIF;IAAK0B,CAAAA,YAAL,CAAkBd,aAAlB,CAEIa,EAAAA,OAAJ,EAAgB,IAAK3B,CAAAA,YAArB,GAAsCzB,SAAtC,EAAmD,IAAKb,CAAAA,OAAQC,CAAAA,OAAhE,GAA4Ea,WAAYb,CAAAA,OAAxF,EAAmG,IAAKD,CAAAA,OAAQW,CAAAA,SAAhH,GAA8HG,WAAYH,CAAAA,SAA1I,EACE,IAAKwD,CAAAA,kBAAL,EAGIC,cAAAA,CAAsB,IAAKC,CAAAA,sBAAL,EAExBJ,EAAAA,OAAJ,EAAgB,IAAK3B,CAAAA,YAArB,GAAsCzB,SAAtC,EAAmD,IAAKb,CAAAA,OAAQC,CAAAA,OAAhE,GAA4Ea,WAAYb,CAAAA,OAAxF,EAAmGmE,aAAnG,GAA2H,IAAKE,CAAAA,sBAAhI,EACE,IAAKC,CAAAA,qBAAL,CAA2BH,aAA3B,CA3C+B,CA+CnCI,mBAAmB,CAACxE,OAAD,CAAU,CAC3B,IAAMD,MAAQ,IAAK2B,CAAAA,MAAOgC,CAAAA,aAAZ,EAA4Be,CAAAA,KAA5B,CAAkC,IAAK/C,CAAAA,MAAvC,CAA+C1B,OAA/C,CACR0E;KAAAA,CAAS,IAAKC,CAAAA,YAAL,CAAkB5E,KAAlB,CAAyBC,OAAzB,CAocf,QAAA,CAlcwDA,OAic9C4E,CAAAA,gBAAZ,CACS,CAAA,CADT,CAMgCC,IAAAA,EAAhC,GAvc0D7E,OAuc9C8E,CAAAA,eAAZ,CAvckDJ,KA2cxBK,CAAAA,iBAJ1B,CASK7D,KAAMuC,CAAAA,mBAAN,CAhduCI,IAgdJmB,CAAAA,gBAAT,EAA1B,CAhd6CN,KAgd7C,CAAL,CAKO,CAAA,CALP,CACS,CAAA,CAjdH,QAAJ,GAgBE,IAAKO,CAAAA,aAEL,CAFqBP,KAErB,CADA,IAAKQ,CAAAA,oBACL,CAD4B,IAAKlF,CAAAA,OACjC,CAAA,IAAKmF,CAAAA,kBAAL,CAA0B,IAAK7C,CAAAA,YAAapC,CAAAA,KAlB9C,CAqBA,OAAOwE,MAzBoB,CA4B7BM,gBAAgB,EAAG,CACjB,MAAO,KAAKC,CAAAA,aADK,CAInBG,WAAW,CAACV,MAAD,CAAS,CAClB,MAAMW,cAAgB,EACtBrE,OAAOsE,CAAAA,IAAP,CAAYZ,MAAZ,CAAoBa,CAAAA,OAApB,CAA4BC,GAAA,EAAO,CACjCxE,MAAOC,CAAAA,cAAP,CAAsBoE,aAAtB,CAAqCG,GAArC,CAA0C,CACxCC,aAAc,CAAA,CAD0B;AAExCC,WAAY,CAAA,CAF4B,CAGxCC,IAAK,EAAAA,EAAM,CACT,IAAKhE,CAAAA,YAAaiE,CAAAA,GAAlB,CAAsBJ,GAAtB,CACA,OAAOd,OAAA,CAAOc,GAAP,CAFE,CAH6B,CAA1C,CADiC,CAAnC,CAUA,OAAOH,cAZW,CAepBQ,eAAe,EAAG,CAChB,MAAO,KAAKvD,CAAAA,YADI,CAIlBN,MAAM,EAAG,CACP,IAAKN,CAAAA,MAAOgC,CAAAA,aAAZ,EAA4B1B,CAAAA,MAA5B,CAAmC,IAAKM,CAAAA,YAAxC,CADO,CAITJ,OAAO,CAAC,CACN4D,WADM,CAEN,GAAG9F,OAFG,CAAA,CAGJ,EAHG,CAGC,CACN,MAAO,KAAK+F,CAAAA,KAAL,CAAW,CAAE,GAAG/F,OAAL,CAChBgG,KAAM,CACJF,WADI,CADU,CAAX,CADD,CAQRG,eAAe,CAACjG,OAAD,CAAU,CACvB,MAAMkG,iBAAmB,IAAKxE,CAAAA,MAAO2B,CAAAA,mBAAZ,CAAgCrD,OAAhC,CAAzB,CACMD,MAAQ,IAAK2B,CAAAA,MAAOgC,CAAAA,aAAZ,EAA4Be,CAAAA,KAA5B,CAAkC,IAAK/C,CAAAA,MAAvC,CAA+CwE,gBAA/C,CACdnG,MAAMoG,CAAAA,oBAAN,CAA6B,CAAA,CAC7B,OAAOpG,MAAMgG,CAAAA,KAAN,EAAcK,CAAAA,IAAd,CAAmB,EAAA;AAAM,IAAKzB,CAAAA,YAAL,CAAkB5E,KAAlB,CAAyBmG,gBAAzB,CAAzB,CAJgB,CAOzBH,KAAK,CAACM,YAAD,CAAe,CAClB,IAAIC,qBAEJ,OAAO,KAAK9D,CAAAA,YAAL,CAAkB,CAAE,GAAG6D,YAAL,CACvBE,cAAuE,IAAxD,GAACD,qBAAD,CAAyBD,YAAaE,CAAAA,aAAtC,EAA+DD,qBAA/D,CAAuF,CAAA,CAD/E,CAAlB,CAEJF,CAAAA,IAFI,CAEC,EAAA,EAAM,CACZ,IAAKlC,CAAAA,YAAL,EACA,OAAO,KAAKe,CAAAA,aAFA,CAFP,CAHW,CAWpBzC,YAAY,CAAC6D,YAAD,CAAe,CAEzB,IAAKrC,CAAAA,WAAL,EAEA,KAAIwC,QAAU,IAAKlE,CAAAA,YAAayD,CAAAA,KAAlB,CAAwB,IAAK/F,CAAAA,OAA7B,CAAsCqG,YAAtC,CAEQ,KAAtB,EAAMA,YAAN,EAA8BA,YAAaI,CAAAA,YAA3C,GACED,OADF,CACYA,OAAQE,CAAAA,KAAR,CAAcxF,KAAMyF,CAAAA,IAApB,CADZ,CAIA,OAAOH,QAVkB,CAa3BrC,kBAAkB,EAAG,CACnB,IAAKlB,CAAAA,iBAAL,EAEA;GAAU2D,CAAN1F,KAAM0F,CAAAA,QAAV,EAAyCC,CAAnB,IAAK5B,CAAAA,aAAc4B,CAAAA,OAAzC,EAAqD3F,KAAM4F,CAAAA,cAAN,CAAqB,IAAK9G,CAAAA,OAAQW,CAAAA,SAAlC,CAArD,CAAA,CAIA,IAAMoG,KAAO7F,KAAM8F,CAAAA,cAAN,CAAqB,IAAK/B,CAAAA,aAAc9E,CAAAA,aAAxC,CAAuD,IAAKH,CAAAA,OAAQW,CAAAA,SAApE,CAIb,KAAKsG,CAAAA,cAAL,CAAsBC,UAAA,CAAW,EAAA,EAAM,CAChC,IAAKjC,CAAAA,aAAc4B,CAAAA,OAAxB,EACE,IAAK3C,CAAAA,YAAL,EAFmC,CAAjB,CADN6C,IACM,CADC,CACD,CARtB,CAHmB,CAkBrB1C,sBAAsB,EAAG,CACvB,IAAI8C,qBAEJ,OAA+C,UAAxC,GAAA,MAAO,KAAKnH,CAAAA,OAAQoH,CAAAA,eAApB,CAAqD,IAAKpH,CAAAA,OAAQoH,CAAAA,eAAb,CAA6B,IAAKnC,CAAAA,aAAcoC,CAAAA,IAAhD,CAAsD,IAAK/E,CAAAA,YAA3D,CAArD,CAA0L,IAA1D,GAAC6E,qBAAD,CAAyB,IAAKnH,CAAAA,OAAQoH,CAAAA,eAAtC;AAAiED,qBAAjE,CAAyF,CAAA,CAHzM,CAMzB5C,qBAAqB,CAAC+C,YAAD,CAAe,CAClC,IAAKpE,CAAAA,oBAAL,EACA,KAAKoB,CAAAA,sBAAL,CAA8BgD,YAEpBV,EAAN1F,KAAM0F,CAAAA,QAAV,EAA+C,CAAA,CAA/C,GAAsB,IAAK5G,CAAAA,OAAQC,CAAAA,OAAnC,EAAyDiB,KAAM4F,CAAAA,cAAN,CAAqB,IAAKxC,CAAAA,sBAA1B,CAAzD,EAA8I,CAA9I,GAA8G,IAAKA,CAAAA,sBAAnH,GAIA,IAAKiD,CAAAA,iBAJL,CAIyBC,WAAA,CAAY,EAAA,EAAM,CACzC,CAAI,IAAKxH,CAAAA,OAAQyH,CAAAA,2BAAjB,EAAgDrG,YAAaA,CAAAA,YAAasG,CAAAA,SAA1B,EAAhD,GACE,IAAKlF,CAAAA,YAAL,EAFuC,CAAlB,CAItB,IAAK8B,CAAAA,sBAJiB,CAJzB,CAJkC,CAepC7B,YAAY,EAAG,CACb,IAAK0B,CAAAA,kBAAL,EACA,KAAKI,CAAAA,qBAAL,CAA2B,IAAKF,CAAAA,sBAAL,EAA3B,CAFa,CAKfpB,iBAAiB,EAAG,CACd,IAAKgE,CAAAA,cAAT;CACEU,YAAA,CAAa,IAAKV,CAAAA,cAAlB,CACA,CAAA,IAAKA,CAAAA,cAAL,CAAsBpC,IAAAA,EAFxB,CADkB,CAOpB3B,oBAAoB,EAAG,CACjB,IAAKqE,CAAAA,iBAAT,GACEK,aAAA,CAAc,IAAKL,CAAAA,iBAAnB,CACA,CAAA,IAAKA,CAAAA,iBAAL,CAAyB1C,IAAAA,EAF3B,CADqB,CAOvBF,YAAY,CAAC5E,KAAD,CAAQC,OAAR,CAAiB,CAC3B,IAAMa,UAAY,IAAKyB,CAAAA,YACvB,OAAMxB,YAAc,IAAKd,CAAAA,OACzB,KAAM6H,WAAa,IAAK5C,CAAAA,aAAxB,CACM6C,gBAAkB,IAAK3C,CAAAA,kBAD7B,CAEM4C,kBAAoB,IAAK7C,CAAAA,oBAF/B,CAGM8C,YAAcjI,KAAdiI,GAAwBnH,SAC9B,OAAMoH,kBAAoBD,WAAA,CAAcjI,KAAMG,CAAAA,KAApB,CAA4B,IAAKgI,CAAAA,wBAA3D,CACMC;AAAkBH,WAAA,CAAc,IAAK/C,CAAAA,aAAnB,CAAmC,IAAKmD,CAAAA,mBAChE,EAAM,CACJ,MAAAlI,WADI,CAAN,CAEIH,KAFJ,CAGA,KAAI,CACFI,aADE,CAEFqD,KAFE,CAGF6E,cAHE,CAIFC,WAJE,CAKFlI,MALE,CAAA,CAMAF,WANJ,CAOIqI,eAAiB,CAAA,CAPrB,CAQIxD,kBAAoB,CAAA,CARxB,CASIsC,IAEJ,IAAIrH,OAAQwI,CAAAA,kBAAZ,CAAgC,CAC9B,MAAMvE,QAAU,IAAKtB,CAAAA,YAAL,EAAhB,CACM8F,aAAe,CAACxE,OAAhBwE,EAA2B3I,kBAAA,CAAmBC,KAAnB,CAA0BC,OAA1B,CAC3B0I,UAAAA,CAAkBzE,OAAlByE,EAA6B9H,qBAAA,CAAsBb,KAAtB,CAA6Bc,SAA7B,CAAwCb,OAAxC,CAAiDc,WAAjD,CAEnC,IAAI2H,YAAJ,EAAoBC,SAApB,CACEJ,WAEA,CAFchH,OAAQqH,CAAAA,QAAR,CAAiB5I,KAAMC,CAAAA,OAAQ4I,CAAAA,WAA/B,CAAA,CAA8C,UAA9C,CAA2D,QAEzE;AAAKzI,aAAL,GACEC,MADF,CACW,SADX,CAKiC,cAAnC,GAAIJ,OAAQwI,CAAAA,kBAAZ,GACEF,WADF,CACgB,MADhB,CAb8B,CAmBhC,GAAItI,OAAQ4E,CAAAA,gBAAZ,EAAgC,CAAC1E,WAAMC,CAAAA,aAAvC,EAA2E,IAA3E,EAAwDgI,eAAxD,EAAmFA,eAAgBU,CAAAA,SAAnG,EAA2H,OAA3H,GAAgHzI,MAAhH,CACEiH,IAGA,CAHOc,eAAgBd,CAAAA,IAGvB,CAFAlH,aAEA,CAFgBgI,eAAgBhI,CAAAA,aAEhC,CADAC,MACA,CADS+H,eAAgB/H,CAAAA,MACzB,CAAAmI,cAAA,CAAiB,CAAA,CAJnB,KAMK,IAAIvI,OAAQ8I,CAAAA,MAAZ,EAA4C,WAA5C,GAAsB,MAAO5I,YAAMmH,CAAAA,IAAnC,CAEH,GAAIQ,UAAJ,EAAkB3H,WAAMmH,CAAAA,IAAxB,IAAqD,IAAnB,EAAAS,eAAA,CAA0B,IAAK,EAA/B,CAAmCA,eAAgBT,CAAAA,IAArF,GAA8FrH,OAAQ8I,CAAAA,MAAtG;AAAiH,IAAKC,CAAAA,QAAtH,CACE1B,IAAA,CAAO,IAAK2B,CAAAA,YADd,KAGE,IAAI,CACF,IAAKD,CAAAA,QAIL,CAJgB/I,OAAQ8I,CAAAA,MAIxB,CAHAzB,IAGA,CAHOrH,OAAQ8I,CAAAA,MAAR,CAAe5I,WAAMmH,CAAAA,IAArB,CAGP,CADA,IAAK2B,CAAAA,YACL,CAFA3B,IAEA,CAFOnG,KAAM+H,CAAAA,WAAN,CAAgC,IAAd,EAAApB,UAAA,CAAqB,IAAK,EAA1B,CAA8BA,UAAWR,CAAAA,IAA3D,CAAiEA,IAAjE,CAAuErH,OAAvE,CAEP,CAAA,IAAK6B,CAAAA,WAAL,CAAmB,IALjB,CAMF,MAAOA,WAAP,CAAoB,CAElB,IAAKH,CAAAA,MAAO6B,CAAAA,SAAZ,EAAwBC,CAAAA,KAAxB,CAA8B3B,WAA9B,CAGF,CAAA,IAAKA,CAAAA,WAAL,CAAmBA,WALC,CAXrB,IAqBHwF,KAAA,CAAOnH,WAAMmH,CAAAA,IAIf,IAAuC,WAAvC,GAAI,MAAOrH,QAAQ8E,CAAAA,eAAnB,EAAsE,WAAtE,GAAsD,MAAOuC,KAA7D,EAAgG,SAAhG,GAAqFjH,MAArF,CAA2G,CAGzG,GAAkB,IAAlB,EAAIyH,UAAJ,EAA0BA,UAAW9C,CAAAA,iBAArC,EAA0D/E,OAAQ8E,CAAAA,eAAlE;CAA4G,IAArB,EAAAiD,iBAAA,CAA4B,IAAK,EAAjC,CAAqCA,iBAAkBjD,CAAAA,eAA9I,EACEA,eAAA,CAAkB+C,UAAWR,CAAAA,IAD/B,KAKE,IAFAvC,eAEI,CAFiD,UAAnC,GAAA,MAAO9E,QAAQ8E,CAAAA,eAAf,CAAgD9E,OAAQ8E,CAAAA,eAAR,EAAhD,CAA4E9E,OAAQ8E,CAAAA,eAElG,CAAA9E,OAAQ8I,CAAAA,MAAR,EAA6C,WAA7C,GAAkB,MAAOhE,gBAA7B,CACE,GAAI,CACFA,eACA,CADkB9E,OAAQ8I,CAAAA,MAAR,CAAehE,eAAf,CAClB,CAAA,IAAKjD,CAAAA,WAAL,CAAmB,IAFjB,CAGF,MAAOA,WAAP,CAAoB,CAElB,IAAKH,CAAAA,MAAO6B,CAAAA,SAAZ,EAAwBC,CAAAA,KAAxB,CAA8B3B,WAA9B,CAGF,CAAA,IAAKA,CAAAA,WAAL,CAAmBA,WALC,CAUK,WAA/B,GAAI,MAAOiD,gBAAX,GACE1E,MAEA,CAFS,SAET,CADAiH,IACA,CADOnG,KAAM+H,CAAAA,WAAN,CAAgC,IAAd;AAAApB,UAAA,CAAqB,IAAK,EAA1B,CAA8BA,UAAWR,CAAAA,IAA3D,CAAiEvC,eAAjE,CAAkF9E,OAAlF,CACP,CAAA+E,iBAAA,CAAoB,CAAA,CAHtB,CAtByG,CA6BvG,IAAKlD,CAAAA,WAAT,GACE2B,KAGA,CAHQ,IAAK3B,CAAAA,WAGb,CAFAwF,IAEA,CAFO,IAAK2B,CAAAA,YAEZ,CADAX,cACA,CADiBa,IAAKC,CAAAA,GAAL,EACjB,CAAA/I,MAAA,CAAS,OAJX,CAOMgJ,WAAAA,CAA6B,UAA7BA,GAAad,WACbe,gBAAAA,CAAuB,SAAvBA,GAAYjJ,MACZkJ,kBAAAA,CAAqB,OAArBA,GAAUlJ,MA4BhB,OA3BesE,CACbtE,MADasE,CAEb4D,WAFa5D,CAGb2E,UAAAA,eAHa3E,CAIbmE,UAAsB,SAAtBA,GAAWzI,MAJEsE,CAKb4E,QAAAA,iBALa5E,CAMb6E,iBAAkBF,eAAlBE,EAA+BH,UANlB1E,CAOb2C,IAPa3C,CAQbvE,aARauE,CASblB,KATakB,CAUb2D,cAVa3D,CAWb8E,aAActJ,WAAMuJ,CAAAA,iBAXP/E;AAYbgF,cAAexJ,WAAMyJ,CAAAA,kBAZRjF,CAabkF,iBAAkB1J,WAAM0J,CAAAA,gBAbXlF,CAcbmF,UAAmC,CAAnCA,CAAW3J,WAAM4J,CAAAA,eAAjBD,EAAiE,CAAjEA,CAAwC3J,WAAM0J,CAAAA,gBAdjClF,CAebqF,oBAAqB7J,WAAM4J,CAAAA,eAA3BC,CAA6C9B,iBAAkB6B,CAAAA,eAA/DC,EAAkF7J,WAAM0J,CAAAA,gBAAxFG,CAA2G9B,iBAAkB2B,CAAAA,gBAfhHlF,CAgBb0E,WAAAA,UAhBa1E,CAiBbsF,aAAcZ,UAAdY,EAA4B,CAACX,eAjBhB3E,CAkBbuF,eAAgBX,iBAAhBW,EAAmD,CAAnDA,GAA2B/J,WAAMC,CAAAA,aAlBpBuE,CAmBbwF,SAA0B,QAA1BA,GAAU5B,WAnBG5D,CAoBbK,iBApBaL,CAqBb6D,cArBa7D;AAsBbyF,eAAgBb,iBAAhBa,EAAmD,CAAnDA,GAA2BjK,WAAMC,CAAAA,aAtBpBuE,CAuBbmC,QAAiB9G,KAuJRW,CAAAA,aAAN,CAvJqBV,OAuJOW,CAAAA,SAA5B,CA9KU+D,CAwBbxC,QAAS,IAAKA,CAAAA,OAxBDwC,CAyBb1C,OAAQ,IAAKA,CAAAA,MAzBA0C,CAhHY,CA8I7BR,YAAY,CAACd,aAAD,CAAgB,CAC1B,MAAMyE,WAAa,IAAK5C,CAAAA,aACxB,KAAMmF,WAAa,IAAKzF,CAAAA,YAAL,CAAkB,IAAKrC,CAAAA,YAAvB,CAAqC,IAAKtC,CAAAA,OAA1C,CACnB,KAAKmF,CAAAA,kBAAL,CAA0B,IAAK7C,CAAAA,YAAapC,CAAAA,KAC5C,KAAKgF,CAAAA,oBAAL,CAA4B,IAAKlF,CAAAA,OAEjC,IAAI,CAAAkB,KAAMuC,CAAAA,mBAAN,CAA0B2G,UAA1B,CAAsCvC,UAAtC,CAAJ,CAAA,CAIA,IAAK5C,CAAAA,aAAL,CAAqBmF,UAEfC,WAAAA,CAAuB,CAC3BC,MAAO,CAAA,CADoB,CAI7B,KAAMC,sBAAwB,EAAAA;AAAM,CAClC,GAAI,CAAC1C,UAAL,CACE,MAAO,CAAA,CAGT,KAAM,CACJ2C,mBADI,CAAA,CAEF,IAAKxK,CAAAA,OACHyK,oBAAAA,CAA0D,UAA/B,GAAA,MAAOD,oBAAP,CAA4CA,mBAAA,EAA5C,CAAoEA,mBAErG,IAAiC,KAAjC,GAAIC,mBAAJ,EAA0C,CAACA,mBAA3C,EAAuE,CAAC,IAAK9I,CAAAA,YAAaU,CAAAA,IAA1F,CACE,MAAO,CAAA,CAGT,OAAMqI,cAAgB,IAAI9I,GAAJ,CAAoC,IAA5B,EAAA6I,mBAAA,CAAmCA,mBAAnC,CAA8D,IAAK9I,CAAAA,YAA3E,CAElB,KAAK3B,CAAAA,OAAQ2K,CAAAA,gBAAjB,EACED,aAAc9E,CAAAA,GAAd,CAAkB,OAAlB,CAGF,OAAO5E,OAAOsE,CAAAA,IAAP,CAAY,IAAKL,CAAAA,aAAjB,CAAgC2F,CAAAA,IAAhC,CAAqCpF,GAAA,EAE1B,IAAKP,CAAAA,aAAL,CADCO,GACD,CAF0B,GAEOqC,UAAA,CADhCrC,GACgC,CAFP,EAGxBkF,aAAcG,CAAAA,GAAd,CAFDrF,GAEC,CAHb,CApB2B,CA2B+B;CAAA,CAAnE,IAAsB,IAAjB,EAAApC,aAAA,CAAwB,IAAK,EAA7B,CAAiCA,aAAchB,CAAAA,SAApD,GAA4EmI,qBAAA,EAA5E,GACEF,UAAqBjI,CAAAA,SADvB,CACmC,CAAA,CADnC,CAIA,KAAKuB,CAAAA,MAAL,CAAY,CAAE,GAAG0G,UAAL,CACV,GAAGjH,aADO,CAAZ,CAzCA,CAN0B,CAoD5BY,WAAW,EAAG,CACZ,MAAMjE,MAAQ,IAAK2B,CAAAA,MAAOgC,CAAAA,aAAZ,EAA4Be,CAAAA,KAA5B,CAAkC,IAAK/C,CAAAA,MAAvC,CAA+C,IAAK1B,CAAAA,OAApD,CAEd,IAAID,KAAJ,GAAc,IAAKuC,CAAAA,YAAnB,CAAA,CAIA,IAAMzB,UAAY,IAAKyB,CAAAA,YACvB,KAAKA,CAAAA,YAAL,CAAoBvC,KACpB,KAAKmI,CAAAA,wBAAL,CAAgCnI,KAAMG,CAAAA,KACtC,KAAKkI,CAAAA,mBAAL,CAA2B,IAAKnD,CAAAA,aAE5B,KAAKtC,CAAAA,YAAL,EAAJ,GACe,IAAb,EAAA9B,SAAA,CAAoB,IAAK,EAAzB,CAA6BA,SAAUsC,CAAAA,cAAV,CAAyB,IAAzB,CAC7B,CAAApD,KAAMwC,CAAAA,WAAN,CAAkB,IAAlB,CAFF,CATA,CAHY,CAkBduI,aAAa,CAACC,MAAD,CAAS,CACpB,MAAM3H;AAAgB,EAEF,UAApB,GAAI2H,MAAOnH,CAAAA,IAAX,CACER,aAAc4H,CAAAA,SADhB,CAC4B,CAACD,MAAOE,CAAAA,MADpC,CAE2B,OAF3B,GAEWF,MAAOnH,CAAAA,IAFlB,EAEuCtC,OAAQ4J,CAAAA,gBAAR,CAAyBH,MAAOvH,CAAAA,KAAhC,CAFvC,GAGEJ,aAAc+H,CAAAA,OAHhB,CAG0B,CAAA,CAH1B,CAMA,KAAKjH,CAAAA,YAAL,CAAkBd,aAAlB,CAEI,KAAKT,CAAAA,YAAL,EAAJ,EACE,IAAKF,CAAAA,YAAL,EAZkB,CAgBtBkB,MAAM,CAACP,aAAD,CAAgB,CACpBjC,aAAcA,CAAAA,aAAciK,CAAAA,KAA5B,CAAkC,EAAA,EAAM,CAEtC,GAAIhI,aAAc4H,CAAAA,SAAlB,CAA6B,CAAA,IACvBK,qBADuB,CACAC,aADA,CACeC,qBADf,CACsCC,cAEK,KAAtE,GAACH,qBAAD,CAAwDL,CAA9BM,aAA8BN,CAAd,IAAKhL,CAAAA,OAASgL,EAAAA,SAAxD,EAA6E,IAAK,EAAlF,CAAsFK,qBAAsBI,CAAAA,IAAtB,CAA2BH,aAA3B;AAA0C,IAAKrG,CAAAA,aAAcoC,CAAAA,IAA7D,CACf,KAAvE,GAACkE,qBAAD,CAAyDG,CAA/BF,cAA+BE,CAAd,IAAK1L,CAAAA,OAAS0L,EAAAA,SAAzD,EAA8E,IAAK,EAAnF,CAAuFH,qBAAsBE,CAAAA,IAAtB,CAA2BD,cAA3B,CAA2C,IAAKvG,CAAAA,aAAcoC,CAAAA,IAA9D,CAAoE,IAApE,CAJ5D,CAA7B,IAKO,IAAIjE,aAAc+H,CAAAA,OAAlB,CAA2B,CAAA,IAC5BQ,qBAD4B,CACLC,cADK,CACWC,sBADX,CACmCC,cAEE,KAArE,GAACH,qBAAD,CAAyDR,CAA/BS,cAA+BT,CAAd,IAAKnL,CAAAA,OAASmL,EAAAA,OAAzD,EAA4E,IAAK,EAAjF,CAAqFQ,qBAAsBF,CAAAA,IAAtB,CAA2BG,cAA3B,CAA2C,IAAK3G,CAAAA,aAAczB,CAAAA,KAA9D,CACb,KAAxE,GAACqI,sBAAD,CAA0DH,CAA/BI,cAA+BJ,CAAd,IAAK1L,CAAAA,OAAS0L,EAAAA,SAA1D,EAA+E,IAAK,EAApF;AAAwFG,sBAAuBJ,CAAAA,IAAvB,CAA4BK,cAA5B,CAA4CjH,IAAAA,EAA5C,CAAuD,IAAKI,CAAAA,aAAczB,CAAAA,KAA1E,CAJxD,CAQ9BJ,aAAchB,CAAAA,SAAlB,EACE,IAAKA,CAAAA,SAAUmD,CAAAA,OAAf,CAAuB,CAAC,CACtBwG,QADsB,CAAD,CAAA,EAEjB,CACJA,QAAA,CAAS,IAAK9G,CAAAA,aAAd,CADI,CAFN,CAQE7B,cAAckH,CAAAA,KAAlB,EACE,IAAK5I,CAAAA,MAAOgC,CAAAA,aAAZ,EAA4BC,CAAAA,MAA5B,CAAmC,CACjC5D,MAAO,IAAKuC,CAAAA,YADqB,CAEjCsB,KAAM,wBAF2B,CAAnC,CAzBoC,CAAxC,CADoB,CA/dxB,CA4jBA/D,OAAQ0B,CAAAA,aAAR,CAAwBA,aAvkBqG;\",\n\"sources\":[\"node_modules/@tanstack/query-core/build/lib/queryObserver.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$tanstack$query_core$build$lib$queryObserver\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nvar utils = require('./utils.js');\\nvar notifyManager = require('./notifyManager.js');\\nvar focusManager = require('./focusManager.js');\\nvar subscribable = require('./subscribable.js');\\nvar retryer = require('./retryer.js');\\n\\nclass QueryObserver extends subscribable.Subscribable {\\n  constructor(client, options) {\\n    super();\\n    this.client = client;\\n    this.options = options;\\n    this.trackedProps = new Set();\\n    this.selectError = null;\\n    this.bindMethods();\\n    this.setOptions(options);\\n  }\\n\\n  bindMethods() {\\n    this.remove = this.remove.bind(this);\\n    this.refetch = this.refetch.bind(this);\\n  }\\n\\n  onSubscribe() {\\n    if (this.listeners.size === 1) {\\n      this.currentQuery.addObserver(this);\\n\\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\\n        this.executeFetch();\\n      }\\n\\n      this.updateTimers();\\n    }\\n  }\\n\\n  onUnsubscribe() {\\n    if (!this.hasListeners()) {\\n      this.destroy();\\n    }\\n  }\\n\\n  shouldFetchOnReconnect() {\\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\\n  }\\n\\n  shouldFetchOnWindowFocus() {\\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\\n  }\\n\\n  destroy() {\\n    this.listeners = new Set();\\n    this.clearStaleTimeout();\\n    this.clearRefetchInterval();\\n    this.currentQuery.removeObserver(this);\\n  }\\n\\n  setOptions(options, notifyOptions) {\\n    const prevOptions = this.options;\\n    const prevQuery = this.currentQuery;\\n    this.options = this.client.defaultQueryOptions(options);\\n\\n    if (process.env.NODE_ENV !== 'production' && typeof (options == null ? void 0 : options.isDataEqual) !== 'undefined') {\\n      this.client.getLogger().error(\\\"The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option\\\");\\n    }\\n\\n    if (!utils.shallowEqualObjects(prevOptions, this.options)) {\\n      this.client.getQueryCache().notify({\\n        type: 'observerOptionsUpdated',\\n        query: this.currentQuery,\\n        observer: this\\n      });\\n    }\\n\\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\\n      throw new Error('Expected enabled to be a boolean');\\n    } // Keep previous query key if the user does not supply one\\n\\n\\n    if (!this.options.queryKey) {\\n      this.options.queryKey = prevOptions.queryKey;\\n    }\\n\\n    this.updateQuery();\\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\\n\\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\\n      this.executeFetch();\\n    } // Update result\\n\\n\\n    this.updateResult(notifyOptions); // Update stale interval if needed\\n\\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\\n      this.updateStaleTimeout();\\n    }\\n\\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\\n\\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\\n      this.updateRefetchInterval(nextRefetchInterval);\\n    }\\n  }\\n\\n  getOptimisticResult(options) {\\n    const query = this.client.getQueryCache().build(this.client, options);\\n    const result = this.createResult(query, options);\\n\\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\\n      // this assigns the optimistic result to the current Observer\\n      // because if the query function changes, useQuery will be performing\\n      // an effect where it would fetch again.\\n      // When the fetch finishes, we perform a deep data cloning in order\\n      // to reuse objects references. This deep data clone is performed against\\n      // the `observer.currentResult.data` property\\n      // When QueryKey changes, we refresh the query and get new `optimistic`\\n      // result, while we leave the `observer.currentResult`, so when new data\\n      // arrives, it finds the old `observer.currentResult` which is related\\n      // to the old QueryKey. Which means that currentResult and selectData are\\n      // out of sync already.\\n      // To solve this, we move the cursor of the currentResult everytime\\n      // an observer reads an optimistic value.\\n      // When keeping the previous data, the result doesn't change until new\\n      // data arrives.\\n      this.currentResult = result;\\n      this.currentResultOptions = this.options;\\n      this.currentResultState = this.currentQuery.state;\\n    }\\n\\n    return result;\\n  }\\n\\n  getCurrentResult() {\\n    return this.currentResult;\\n  }\\n\\n  trackResult(result) {\\n    const trackedResult = {};\\n    Object.keys(result).forEach(key => {\\n      Object.defineProperty(trackedResult, key, {\\n        configurable: false,\\n        enumerable: true,\\n        get: () => {\\n          this.trackedProps.add(key);\\n          return result[key];\\n        }\\n      });\\n    });\\n    return trackedResult;\\n  }\\n\\n  getCurrentQuery() {\\n    return this.currentQuery;\\n  }\\n\\n  remove() {\\n    this.client.getQueryCache().remove(this.currentQuery);\\n  }\\n\\n  refetch({\\n    refetchPage,\\n    ...options\\n  } = {}) {\\n    return this.fetch({ ...options,\\n      meta: {\\n        refetchPage\\n      }\\n    });\\n  }\\n\\n  fetchOptimistic(options) {\\n    const defaultedOptions = this.client.defaultQueryOptions(options);\\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\\n    query.isFetchingOptimistic = true;\\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\\n  }\\n\\n  fetch(fetchOptions) {\\n    var _fetchOptions$cancelR;\\n\\n    return this.executeFetch({ ...fetchOptions,\\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\\n    }).then(() => {\\n      this.updateResult();\\n      return this.currentResult;\\n    });\\n  }\\n\\n  executeFetch(fetchOptions) {\\n    // Make sure we reference the latest query as the current one might have been removed\\n    this.updateQuery(); // Fetch\\n\\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\\n\\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\\n      promise = promise.catch(utils.noop);\\n    }\\n\\n    return promise;\\n  }\\n\\n  updateStaleTimeout() {\\n    this.clearStaleTimeout();\\n\\n    if (utils.isServer || this.currentResult.isStale || !utils.isValidTimeout(this.options.staleTime)) {\\n      return;\\n    }\\n\\n    const time = utils.timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\\n    // To mitigate this issue we always add 1 ms to the timeout.\\n\\n    const timeout = time + 1;\\n    this.staleTimeoutId = setTimeout(() => {\\n      if (!this.currentResult.isStale) {\\n        this.updateResult();\\n      }\\n    }, timeout);\\n  }\\n\\n  computeRefetchInterval() {\\n    var _this$options$refetch;\\n\\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\\n  }\\n\\n  updateRefetchInterval(nextInterval) {\\n    this.clearRefetchInterval();\\n    this.currentRefetchInterval = nextInterval;\\n\\n    if (utils.isServer || this.options.enabled === false || !utils.isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\\n      return;\\n    }\\n\\n    this.refetchIntervalId = setInterval(() => {\\n      if (this.options.refetchIntervalInBackground || focusManager.focusManager.isFocused()) {\\n        this.executeFetch();\\n      }\\n    }, this.currentRefetchInterval);\\n  }\\n\\n  updateTimers() {\\n    this.updateStaleTimeout();\\n    this.updateRefetchInterval(this.computeRefetchInterval());\\n  }\\n\\n  clearStaleTimeout() {\\n    if (this.staleTimeoutId) {\\n      clearTimeout(this.staleTimeoutId);\\n      this.staleTimeoutId = undefined;\\n    }\\n  }\\n\\n  clearRefetchInterval() {\\n    if (this.refetchIntervalId) {\\n      clearInterval(this.refetchIntervalId);\\n      this.refetchIntervalId = undefined;\\n    }\\n  }\\n\\n  createResult(query, options) {\\n    const prevQuery = this.currentQuery;\\n    const prevOptions = this.options;\\n    const prevResult = this.currentResult;\\n    const prevResultState = this.currentResultState;\\n    const prevResultOptions = this.currentResultOptions;\\n    const queryChange = query !== prevQuery;\\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\\n    const {\\n      state\\n    } = query;\\n    let {\\n      dataUpdatedAt,\\n      error,\\n      errorUpdatedAt,\\n      fetchStatus,\\n      status\\n    } = state;\\n    let isPreviousData = false;\\n    let isPlaceholderData = false;\\n    let data; // Optimistically set result in fetching state if needed\\n\\n    if (options._optimisticResults) {\\n      const mounted = this.hasListeners();\\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\\n\\n      if (fetchOnMount || fetchOptionally) {\\n        fetchStatus = retryer.canFetch(query.options.networkMode) ? 'fetching' : 'paused';\\n\\n        if (!dataUpdatedAt) {\\n          status = 'loading';\\n        }\\n      }\\n\\n      if (options._optimisticResults === 'isRestoring') {\\n        fetchStatus = 'idle';\\n      }\\n    } // Keep previous data if needed\\n\\n\\n    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\\n      data = prevQueryResult.data;\\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\\n      status = prevQueryResult.status;\\n      isPreviousData = true;\\n    } // Select data if needed\\n    else if (options.select && typeof state.data !== 'undefined') {\\n      // Memoize select result\\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\\n        data = this.selectResult;\\n      } else {\\n        try {\\n          this.selectFn = options.select;\\n          data = options.select(state.data);\\n          data = utils.replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\\n          this.selectResult = data;\\n          this.selectError = null;\\n        } catch (selectError) {\\n          if (process.env.NODE_ENV !== 'production') {\\n            this.client.getLogger().error(selectError);\\n          }\\n\\n          this.selectError = selectError;\\n        }\\n      }\\n    } // Use query data\\n    else {\\n      data = state.data;\\n    } // Show placeholder data if needed\\n\\n\\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\\n      let placeholderData; // Memoize placeholder data\\n\\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\\n        placeholderData = prevResult.data;\\n      } else {\\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\\n\\n        if (options.select && typeof placeholderData !== 'undefined') {\\n          try {\\n            placeholderData = options.select(placeholderData);\\n            this.selectError = null;\\n          } catch (selectError) {\\n            if (process.env.NODE_ENV !== 'production') {\\n              this.client.getLogger().error(selectError);\\n            }\\n\\n            this.selectError = selectError;\\n          }\\n        }\\n      }\\n\\n      if (typeof placeholderData !== 'undefined') {\\n        status = 'success';\\n        data = utils.replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\\n        isPlaceholderData = true;\\n      }\\n    }\\n\\n    if (this.selectError) {\\n      error = this.selectError;\\n      data = this.selectResult;\\n      errorUpdatedAt = Date.now();\\n      status = 'error';\\n    }\\n\\n    const isFetching = fetchStatus === 'fetching';\\n    const isLoading = status === 'loading';\\n    const isError = status === 'error';\\n    const result = {\\n      status,\\n      fetchStatus,\\n      isLoading,\\n      isSuccess: status === 'success',\\n      isError,\\n      isInitialLoading: isLoading && isFetching,\\n      data,\\n      dataUpdatedAt,\\n      error,\\n      errorUpdatedAt,\\n      failureCount: state.fetchFailureCount,\\n      failureReason: state.fetchFailureReason,\\n      errorUpdateCount: state.errorUpdateCount,\\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\\n      isFetching,\\n      isRefetching: isFetching && !isLoading,\\n      isLoadingError: isError && state.dataUpdatedAt === 0,\\n      isPaused: fetchStatus === 'paused',\\n      isPlaceholderData,\\n      isPreviousData,\\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\\n      isStale: isStale(query, options),\\n      refetch: this.refetch,\\n      remove: this.remove\\n    };\\n    return result;\\n  }\\n\\n  updateResult(notifyOptions) {\\n    const prevResult = this.currentResult;\\n    const nextResult = this.createResult(this.currentQuery, this.options);\\n    this.currentResultState = this.currentQuery.state;\\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\\n\\n    if (utils.shallowEqualObjects(nextResult, prevResult)) {\\n      return;\\n    }\\n\\n    this.currentResult = nextResult; // Determine which callbacks to trigger\\n\\n    const defaultNotifyOptions = {\\n      cache: true\\n    };\\n\\n    const shouldNotifyListeners = () => {\\n      if (!prevResult) {\\n        return true;\\n      }\\n\\n      const {\\n        notifyOnChangeProps\\n      } = this.options;\\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === 'function' ? notifyOnChangeProps() : notifyOnChangeProps;\\n\\n      if (notifyOnChangePropsValue === 'all' || !notifyOnChangePropsValue && !this.trackedProps.size) {\\n        return true;\\n      }\\n\\n      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);\\n\\n      if (this.options.useErrorBoundary) {\\n        includedProps.add('error');\\n      }\\n\\n      return Object.keys(this.currentResult).some(key => {\\n        const typedKey = key;\\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\\n        return changed && includedProps.has(typedKey);\\n      });\\n    };\\n\\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\\n      defaultNotifyOptions.listeners = true;\\n    }\\n\\n    this.notify({ ...defaultNotifyOptions,\\n      ...notifyOptions\\n    });\\n  }\\n\\n  updateQuery() {\\n    const query = this.client.getQueryCache().build(this.client, this.options);\\n\\n    if (query === this.currentQuery) {\\n      return;\\n    }\\n\\n    const prevQuery = this.currentQuery;\\n    this.currentQuery = query;\\n    this.currentQueryInitialState = query.state;\\n    this.previousQueryResult = this.currentResult;\\n\\n    if (this.hasListeners()) {\\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\\n      query.addObserver(this);\\n    }\\n  }\\n\\n  onQueryUpdate(action) {\\n    const notifyOptions = {};\\n\\n    if (action.type === 'success') {\\n      notifyOptions.onSuccess = !action.manual;\\n    } else if (action.type === 'error' && !retryer.isCancelledError(action.error)) {\\n      notifyOptions.onError = true;\\n    }\\n\\n    this.updateResult(notifyOptions);\\n\\n    if (this.hasListeners()) {\\n      this.updateTimers();\\n    }\\n  }\\n\\n  notify(notifyOptions) {\\n    notifyManager.notifyManager.batch(() => {\\n      // First trigger the configuration callbacks\\n      if (notifyOptions.onSuccess) {\\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\\n\\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\\n      } else if (notifyOptions.onError) {\\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\\n\\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\\n      } // Then trigger the listeners\\n\\n\\n      if (notifyOptions.listeners) {\\n        this.listeners.forEach(({\\n          listener\\n        }) => {\\n          listener(this.currentResult);\\n        });\\n      } // Then the cache listeners\\n\\n\\n      if (notifyOptions.cache) {\\n        this.client.getQueryCache().notify({\\n          query: this.currentQuery,\\n          type: 'observerResultsUpdated'\\n        });\\n      }\\n    });\\n  }\\n\\n}\\n\\nfunction shouldLoadOnMount(query, options) {\\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\\n}\\n\\nfunction shouldFetchOnMount(query, options) {\\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\\n}\\n\\nfunction shouldFetchOn(query, options, field) {\\n  if (options.enabled !== false) {\\n    const value = typeof field === 'function' ? field(query) : field;\\n    return value === 'always' || value !== false && isStale(query, options);\\n  }\\n\\n  return false;\\n}\\n\\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\\n}\\n\\nfunction isStale(query, options) {\\n  return query.isStaleByTime(options.staleTime);\\n} // this function would decide if we will update the observer's 'current'\\n// properties after an optimistic reading via getOptimisticResult\\n\\n\\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {\\n  // it is important to keep this condition like this for three reasons:\\n  // 1. It will get removed in the v5\\n  // 2. it reads: don't update the properties if we want to keep the previous\\n  // data.\\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\\n  // and will result in a bad decision\\n  if (options.keepPreviousData) {\\n    return false;\\n  } // this means we want to put some placeholder data when pending and queryKey\\n  // changed.\\n\\n\\n  if (options.placeholderData !== undefined) {\\n    // re-assign properties only if current data is placeholder data\\n    // which means that data did not arrive yet, so, if there is some cached data\\n    // we need to \\\"prepare\\\" to receive it\\n    return optimisticResult.isPlaceholderData;\\n  } // if the newly created result isn't what the observer is holding as current,\\n  // then we'll need to update the properties as well\\n\\n\\n  if (!utils.shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\\n    return true;\\n  } // basically, just keep previous properties if nothing changed\\n\\n\\n  return false;\\n}\\n\\nexports.QueryObserver = QueryObserver;\\n//# sourceMappingURL=queryObserver.js.map\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"shouldFetchOnMount\",\"query\",\"options\",\"enabled\",\"state\",\"dataUpdatedAt\",\"status\",\"retryOnMount\",\"shouldFetchOn\",\"refetchOnMount\",\"field\",\"value\",\"isStaleByTime\",\"staleTime\",\"shouldFetchOptionally\",\"prevQuery\",\"prevOptions\",\"suspense\",\"Object\",\"defineProperty\",\"utils\",\"notifyManager\",\"focusManager\",\"subscribable\",\"retryer\",\"QueryObserver\",\"Subscribable\",\"constructor\",\"client\",\"trackedProps\",\"Set\",\"selectError\",\"bindMethods\",\"setOptions\",\"remove\",\"bind\",\"refetch\",\"onSubscribe\",\"listeners\",\"size\",\"currentQuery\",\"addObserver\",\"executeFetch\",\"updateTimers\",\"onUnsubscribe\",\"hasListeners\",\"destroy\",\"shouldFetchOnReconnect\",\"refetchOnReconnect\",\"shouldFetchOnWindowFocus\",\"refetchOnWindowFocus\",\"clearStaleTimeout\",\"clearRefetchInterval\",\"removeObserver\",\"notifyOptions\",\"defaultQueryOptions\",\"isDataEqual\",\"getLogger\",\"error\",\"shallowEqualObjects\",\"getQueryCache\",\"notify\",\"type\",\"observer\",\"Error\",\"queryKey\",\"updateQuery\",\"mounted\",\"updateResult\",\"updateStaleTimeout\",\"nextRefetchInterval\",\"computeRefetchInterval\",\"currentRefetchInterval\",\"updateRefetchInterval\",\"getOptimisticResult\",\"build\",\"result\",\"createResult\",\"keepPreviousData\",\"undefined\",\"placeholderData\",\"isPlaceholderData\",\"getCurrentResult\",\"currentResult\",\"currentResultOptions\",\"currentResultState\",\"trackResult\",\"trackedResult\",\"keys\",\"forEach\",\"key\",\"configurable\",\"enumerable\",\"get\",\"add\",\"getCurrentQuery\",\"refetchPage\",\"fetch\",\"meta\",\"fetchOptimistic\",\"defaultedOptions\",\"isFetchingOptimistic\",\"then\",\"fetchOptions\",\"_fetchOptions$cancelR\",\"cancelRefetch\",\"promise\",\"throwOnError\",\"catch\",\"noop\",\"isServer\",\"isStale\",\"isValidTimeout\",\"time\",\"timeUntilStale\",\"staleTimeoutId\",\"setTimeout\",\"_this$options$refetch\",\"refetchInterval\",\"data\",\"nextInterval\",\"refetchIntervalId\",\"setInterval\",\"refetchIntervalInBackground\",\"isFocused\",\"clearTimeout\",\"clearInterval\",\"prevResult\",\"prevResultState\",\"prevResultOptions\",\"queryChange\",\"queryInitialState\",\"currentQueryInitialState\",\"prevQueryResult\",\"previousQueryResult\",\"errorUpdatedAt\",\"fetchStatus\",\"isPreviousData\",\"_optimisticResults\",\"fetchOnMount\",\"fetchOptionally\",\"canFetch\",\"networkMode\",\"isSuccess\",\"select\",\"selectFn\",\"selectResult\",\"replaceData\",\"Date\",\"now\",\"isFetching\",\"isLoading\",\"isError\",\"isInitialLoading\",\"failureCount\",\"fetchFailureCount\",\"failureReason\",\"fetchFailureReason\",\"errorUpdateCount\",\"isFetched\",\"dataUpdateCount\",\"isFetchedAfterMount\",\"isRefetching\",\"isLoadingError\",\"isPaused\",\"isRefetchError\",\"nextResult\",\"defaultNotifyOptions\",\"cache\",\"shouldNotifyListeners\",\"notifyOnChangeProps\",\"notifyOnChangePropsValue\",\"includedProps\",\"useErrorBoundary\",\"some\",\"has\",\"onQueryUpdate\",\"action\",\"onSuccess\",\"manual\",\"isCancelledError\",\"onError\",\"batch\",\"_this$options$onSucce\",\"_this$options\",\"_this$options$onSettl\",\"_this$options2\",\"call\",\"onSettled\",\"_this$options$onError\",\"_this$options3\",\"_this$options$onSettl2\",\"_this$options4\",\"listener\"]\n}\n"]