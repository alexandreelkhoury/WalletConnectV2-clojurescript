["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/signing-key/lib/index.js"],"~:js","shadow$provide[105]=function(S,A,V,q){function F(){p||(p=new r.EC(\"secp256k1\"));return p}function G(l,h){l=(0,y.arrayify)(l);if(32===l.length){var k=new n(l);return h?\"0x\"+F().keyFromPrivate(l).getPublic(!0,\"hex\"):k.publicKey}return 33===l.length?h?(0,y.hexlify)(l):\"0x\"+F().keyFromPublic(l).getPublic(!1,\"hex\"):65===l.length?h?\"0x\"+F().keyFromPublic(l).getPublic(!0,\"hex\"):(0,y.hexlify)(l):u.throwArgumentError(\"invalid public or private key\",\"key\",\"[REDACTED]\")}Object.defineProperty(q,\"__esModule\",\n{value:!0});q.computePublicKey=q.recoverPublicKey=q.SigningKey=void 0;var r=A(103),y=A(11),e=A(17);S=A(9);A=A(104);var u=new S.Logger(A.version),p=null,n=function(){function l(h){(0,e.defineReadOnly)(this,\"curve\",\"secp256k1\");(0,e.defineReadOnly)(this,\"privateKey\",(0,y.hexlify)(h));32!==(0,y.hexDataLength)(this.privateKey)&&u.throwArgumentError(\"invalid private key\",\"privateKey\",\"[[ REDACTED ]]\");h=F().keyFromPrivate((0,y.arrayify)(this.privateKey));(0,e.defineReadOnly)(this,\"publicKey\",\"0x\"+h.getPublic(!1,\n\"hex\"));(0,e.defineReadOnly)(this,\"compressedPublicKey\",\"0x\"+h.getPublic(!0,\"hex\"));(0,e.defineReadOnly)(this,\"_isSigningKey\",!0)}l.prototype._addPoint=function(h){var k=F().keyFromPublic((0,y.arrayify)(this.publicKey));h=F().keyFromPublic((0,y.arrayify)(h));return\"0x\"+k.pub.add(h.pub).encodeCompressed(\"hex\")};l.prototype.signDigest=function(h){var k=F().keyFromPrivate((0,y.arrayify)(this.privateKey)),t=(0,y.arrayify)(h);32!==t.length&&u.throwArgumentError(\"bad digest length\",\"digest\",h);h=k.sign(t,\n{canonical:!0});return(0,y.splitSignature)({recoveryParam:h.recoveryParam,r:(0,y.hexZeroPad)(\"0x\"+h.r.toString(16),32),s:(0,y.hexZeroPad)(\"0x\"+h.s.toString(16),32)})};l.prototype.computeSharedSecret=function(h){var k=F().keyFromPrivate((0,y.arrayify)(this.privateKey));h=F().keyFromPublic((0,y.arrayify)(G(h)));return(0,y.hexZeroPad)(\"0x\"+k.derive(h.getPublic()).toString(16),32)};l.isSigningKey=function(h){return!(!h||!h._isSigningKey)};return l}();q.SigningKey=n;q.recoverPublicKey=function(l,h){h=\n(0,y.splitSignature)(h);var k={r:(0,y.arrayify)(h.r),s:(0,y.arrayify)(h.s)};return\"0x\"+F().recoverPubKey((0,y.arrayify)(l),k,h.recoveryParam).encode(\"hex\",!1)};q.computePublicKey=G}","~:source","shadow$provide[105] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computePublicKey = exports.recoverPublicKey = exports.SigningKey = void 0;\nvar elliptic_1 = require(\"./elliptic\");\nvar bytes_1 = require(\"@ethersproject/bytes\");\nvar properties_1 = require(\"@ethersproject/properties\");\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new elliptic_1.EC(\"secp256k1\");\n    }\n    return _curve;\n}\nvar SigningKey = /** @class */ (function () {\n    function SigningKey(privateKey) {\n        (0, properties_1.defineReadOnly)(this, \"curve\", \"secp256k1\");\n        (0, properties_1.defineReadOnly)(this, \"privateKey\", (0, bytes_1.hexlify)(privateKey));\n        if ((0, bytes_1.hexDataLength)(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));\n        (0, properties_1.defineReadOnly)(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        (0, properties_1.defineReadOnly)(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        (0, properties_1.defineReadOnly)(this, \"_isSigningKey\", true);\n    }\n    SigningKey.prototype._addPoint = function (other) {\n        var p0 = getCurve().keyFromPublic((0, bytes_1.arrayify)(this.publicKey));\n        var p1 = getCurve().keyFromPublic((0, bytes_1.arrayify)(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    };\n    SigningKey.prototype.signDigest = function (digest) {\n        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));\n        var digestBytes = (0, bytes_1.arrayify)(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        var signature = keyPair.sign(digestBytes, { canonical: true });\n        return (0, bytes_1.splitSignature)({\n            recoveryParam: signature.recoveryParam,\n            r: (0, bytes_1.hexZeroPad)(\"0x\" + signature.r.toString(16), 32),\n            s: (0, bytes_1.hexZeroPad)(\"0x\" + signature.s.toString(16), 32),\n        });\n    };\n    SigningKey.prototype.computeSharedSecret = function (otherKey) {\n        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));\n        var otherKeyPair = getCurve().keyFromPublic((0, bytes_1.arrayify)(computePublicKey(otherKey)));\n        return (0, bytes_1.hexZeroPad)(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    };\n    SigningKey.isSigningKey = function (value) {\n        return !!(value && value._isSigningKey);\n    };\n    return SigningKey;\n}());\nexports.SigningKey = SigningKey;\nfunction recoverPublicKey(digest, signature) {\n    var sig = (0, bytes_1.splitSignature)(signature);\n    var rs = { r: (0, bytes_1.arrayify)(sig.r), s: (0, bytes_1.arrayify)(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey((0, bytes_1.arrayify)(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction computePublicKey(key, compressed) {\n    var bytes = (0, bytes_1.arrayify)(key);\n    if (bytes.length === 32) {\n        var signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    }\n    else if (bytes.length === 33) {\n        if (compressed) {\n            return (0, bytes_1.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    }\n    else if (bytes.length === 65) {\n        if (!compressed) {\n            return (0, bytes_1.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\nexports.computePublicKey = computePublicKey;\n//# sourceMappingURL=index.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$ethersproject$bytes$lib$index","~$module$node_modules$$ethersproject$signing_key$lib$_version","~$module$node_modules$$ethersproject$logger$lib$index","~$module$node_modules$$ethersproject$properties$lib$index","~$module$node_modules$$ethersproject$signing_key$lib$elliptic"]],"~:properties",["^5",["s","recoveryParam","recoverPublicKey","computePublicKey","__esModule","signDigest","value","canonical","isSigningKey","r","computeSharedSecret","_addPoint","SigningKey"]],"~:compiled-at",1695041440757,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$signing_key$lib$index.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@ethersproject/signing-key/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[105] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.computePublicKey = exports.recoverPublicKey = exports.SigningKey = void 0;\\nvar elliptic_1 = require(\\\"./elliptic\\\");\\nvar bytes_1 = require(\\\"@ethersproject/bytes\\\");\\nvar properties_1 = require(\\\"@ethersproject/properties\\\");\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"./_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\nvar _curve = null;\\nfunction getCurve() {\\n    if (!_curve) {\\n        _curve = new elliptic_1.EC(\\\"secp256k1\\\");\\n    }\\n    return _curve;\\n}\\nvar SigningKey = /** @class */ (function () {\\n    function SigningKey(privateKey) {\\n        (0, properties_1.defineReadOnly)(this, \\\"curve\\\", \\\"secp256k1\\\");\\n        (0, properties_1.defineReadOnly)(this, \\\"privateKey\\\", (0, bytes_1.hexlify)(privateKey));\\n        if ((0, bytes_1.hexDataLength)(this.privateKey) !== 32) {\\n            logger.throwArgumentError(\\\"invalid private key\\\", \\\"privateKey\\\", \\\"[[ REDACTED ]]\\\");\\n        }\\n        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));\\n        (0, properties_1.defineReadOnly)(this, \\\"publicKey\\\", \\\"0x\\\" + keyPair.getPublic(false, \\\"hex\\\"));\\n        (0, properties_1.defineReadOnly)(this, \\\"compressedPublicKey\\\", \\\"0x\\\" + keyPair.getPublic(true, \\\"hex\\\"));\\n        (0, properties_1.defineReadOnly)(this, \\\"_isSigningKey\\\", true);\\n    }\\n    SigningKey.prototype._addPoint = function (other) {\\n        var p0 = getCurve().keyFromPublic((0, bytes_1.arrayify)(this.publicKey));\\n        var p1 = getCurve().keyFromPublic((0, bytes_1.arrayify)(other));\\n        return \\\"0x\\\" + p0.pub.add(p1.pub).encodeCompressed(\\\"hex\\\");\\n    };\\n    SigningKey.prototype.signDigest = function (digest) {\\n        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));\\n        var digestBytes = (0, bytes_1.arrayify)(digest);\\n        if (digestBytes.length !== 32) {\\n            logger.throwArgumentError(\\\"bad digest length\\\", \\\"digest\\\", digest);\\n        }\\n        var signature = keyPair.sign(digestBytes, { canonical: true });\\n        return (0, bytes_1.splitSignature)({\\n            recoveryParam: signature.recoveryParam,\\n            r: (0, bytes_1.hexZeroPad)(\\\"0x\\\" + signature.r.toString(16), 32),\\n            s: (0, bytes_1.hexZeroPad)(\\\"0x\\\" + signature.s.toString(16), 32),\\n        });\\n    };\\n    SigningKey.prototype.computeSharedSecret = function (otherKey) {\\n        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));\\n        var otherKeyPair = getCurve().keyFromPublic((0, bytes_1.arrayify)(computePublicKey(otherKey)));\\n        return (0, bytes_1.hexZeroPad)(\\\"0x\\\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\\n    };\\n    SigningKey.isSigningKey = function (value) {\\n        return !!(value && value._isSigningKey);\\n    };\\n    return SigningKey;\\n}());\\nexports.SigningKey = SigningKey;\\nfunction recoverPublicKey(digest, signature) {\\n    var sig = (0, bytes_1.splitSignature)(signature);\\n    var rs = { r: (0, bytes_1.arrayify)(sig.r), s: (0, bytes_1.arrayify)(sig.s) };\\n    return \\\"0x\\\" + getCurve().recoverPubKey((0, bytes_1.arrayify)(digest), rs, sig.recoveryParam).encode(\\\"hex\\\", false);\\n}\\nexports.recoverPublicKey = recoverPublicKey;\\nfunction computePublicKey(key, compressed) {\\n    var bytes = (0, bytes_1.arrayify)(key);\\n    if (bytes.length === 32) {\\n        var signingKey = new SigningKey(bytes);\\n        if (compressed) {\\n            return \\\"0x\\\" + getCurve().keyFromPrivate(bytes).getPublic(true, \\\"hex\\\");\\n        }\\n        return signingKey.publicKey;\\n    }\\n    else if (bytes.length === 33) {\\n        if (compressed) {\\n            return (0, bytes_1.hexlify)(bytes);\\n        }\\n        return \\\"0x\\\" + getCurve().keyFromPublic(bytes).getPublic(false, \\\"hex\\\");\\n    }\\n    else if (bytes.length === 65) {\\n        if (!compressed) {\\n            return (0, bytes_1.hexlify)(bytes);\\n        }\\n        return \\\"0x\\\" + getCurve().keyFromPublic(bytes).getPublic(true, \\\"hex\\\");\\n    }\\n    return logger.throwArgumentError(\\\"invalid public or private key\\\", \\\"key\\\", \\\"[REDACTED]\\\");\\n}\\nexports.computePublicKey = computePublicKey;\\n//# sourceMappingURL=index.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getCurve\",\"_curve\",\"elliptic_1\",\"EC\",\"computePublicKey\",\"key\",\"compressed\",\"bytes\",\"bytes_1\",\"arrayify\",\"length\",\"signingKey\",\"SigningKey\",\"keyFromPrivate\",\"getPublic\",\"publicKey\",\"hexlify\",\"keyFromPublic\",\"logger\",\"throwArgumentError\",\"Object\",\"defineProperty\",\"value\",\"recoverPublicKey\",\"properties_1\",\"logger_1\",\"_version_1\",\"Logger\",\"version\",\"privateKey\",\"defineReadOnly\",\"hexDataLength\",\"keyPair\",\"prototype\",\"_addPoint\",\"SigningKey.prototype._addPoint\",\"other\",\"p0\",\"p1\",\"pub\",\"add\",\"encodeCompressed\",\"signDigest\",\"SigningKey.prototype.signDigest\",\"digest\",\"digestBytes\",\"signature\",\"sign\",\"canonical\",\"splitSignature\",\"recoveryParam\",\"r\",\"hexZeroPad\",\"toString\",\"s\",\"computeSharedSecret\",\"SigningKey.prototype.computeSharedSecret\",\"otherKey\",\"otherKeyPair\",\"derive\",\"isSigningKey\",\"SigningKey.isSigningKey\",\"_isSigningKey\",\"sig\",\"rs\",\"recoverPubKey\",\"encode\"]\n}\n"]