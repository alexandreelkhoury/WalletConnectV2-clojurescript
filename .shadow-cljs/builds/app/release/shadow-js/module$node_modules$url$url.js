["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/url/url.js"],"~:js","shadow$provide[309]=function(S,A,V,q){function F(){this.href=this.path=this.pathname=this.query=this.search=this.hash=this.hostname=this.port=this.host=this.auth=this.slashes=this.protocol=null}function G(C,I,M){if(C&&y.isObject(C)&&C instanceof F)return C;var P=new F;P.parse(C,I,M);return P}var r=A(304),y=A(305);q.parse=G;q.resolve=function(C,I){return G(C,!1,!0).resolve(I)};q.resolveObject=function(C,I){return C?G(C,!1,!0).resolveObject(I):I};q.format=function(C){y.isString(C)&&(C=G(C));return C instanceof\nF?C.format():F.prototype.format.call(C)};q.Url=F;var e=/^([a-z0-9.+-]+:)/i,u=/:[0-9]*$/,p=/^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/;S=\"{}|\\\\^`\".split(\"\").concat('\\x3c\\x3e\"` \\r\\n\\t'.split(\"\"));var n=[\"'\"].concat(S),l=[\"%\",\"/\",\"?\",\";\",\"#\"].concat(n),h=[\"/\",\"?\",\"#\"],k=/^[+a-z0-9A-Z_-]{0,63}$/,t=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,B={javascript:!0,\"javascript:\":!0},E={javascript:!0,\"javascript:\":!0},H={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,\"http:\":!0,\"https:\":!0,\"ftp:\":!0,\"gopher:\":!0,\"file:\":!0},D=A(308);\nF.prototype.parse=function(C,I,M){if(!y.isString(C))throw new TypeError(\"Parameter 'url' must be a string, not \"+typeof C);var P=C.indexOf(\"?\");P=-1!==P&&P<C.indexOf(\"#\")?\"?\":\"#\";C=C.split(P);C[0]=C[0].replace(/\\\\/g,\"/\");C=C.join(P);P=C.trim();if(!M&&1===C.split(\"#\").length&&(C=p.exec(P)))return this.href=this.path=P,this.pathname=C[1],C[2]?(this.search=C[2],this.query=I?D.parse(this.search.substr(1)):this.search.substr(1)):I&&(this.search=\"\",this.query={}),this;if(C=e.exec(P)){C=C[0];var J=C.toLowerCase();\nthis.protocol=J;P=P.substr(C.length)}if(M||C||P.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)){var T=\"//\"===P.substr(0,2);!T||C&&E[C]||(P=P.substr(2),this.slashes=!0)}if(!E[C]&&(T||C&&!H[C])){T=-1;for(M=0;M<h.length;M++)C=P.indexOf(h[M]),-1!==C&&(-1===T||C<T)&&(T=C);T=-1===T?P.lastIndexOf(\"@\"):P.lastIndexOf(\"@\",T);-1!==T&&(M=P.slice(0,T),P=P.slice(T+1),this.auth=decodeURIComponent(M));T=-1;for(M=0;M<l.length;M++)C=P.indexOf(l[M]),-1!==C&&(-1===T||C<T)&&(T=C);-1===T&&(T=P.length);this.host=P.slice(0,T);P=P.slice(T);\nthis.parseHost();this.hostname=this.hostname||\"\";T=\"[\"===this.hostname[0]&&\"]\"===this.hostname[this.hostname.length-1];if(!T){var N=this.hostname.split(/\\./);M=0;for(C=N.length;M<C;M++){var a=N[M];if(a&&!a.match(k)){for(var b=\"\",c=0,d=a.length;c<d;c++)b=127<a.charCodeAt(c)?b+\"x\":b+a[c];if(!b.match(k)){C=N.slice(0,M);M=N.slice(M+1);if(a=a.match(t))C.push(a[1]),M.unshift(a[2]);M.length&&(P=\"/\"+M.join(\".\")+P);this.hostname=C.join(\".\");break}}}}this.hostname=255<this.hostname.length?\"\":this.hostname.toLowerCase();\nT||(this.hostname=r.toASCII(this.hostname));M=this.port?\":\"+this.port:\"\";this.host=(this.hostname||\"\")+M;this.href+=this.host;T&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),\"/\"!==P[0]&&(P=\"/\"+P))}if(!B[J])for(M=0,C=n.length;M<C;M++)T=n[M],-1!==P.indexOf(T)&&(a=encodeURIComponent(T),a===T&&(a=escape(T)),P=P.split(T).join(a));M=P.indexOf(\"#\");-1!==M&&(this.hash=P.substr(M),P=P.slice(0,M));M=P.indexOf(\"?\");-1!==M?(this.search=P.substr(M),this.query=P.substr(M+1),I&&(this.query=D.parse(this.query)),\nP=P.slice(0,M)):I&&(this.search=\"\",this.query={});P&&(this.pathname=P);H[J]&&this.hostname&&!this.pathname&&(this.pathname=\"/\");if(this.pathname||this.search)M=this.pathname||\"\",this.path=M+(this.search||\"\");this.href=this.format();return this};F.prototype.format=function(){var C=this.auth||\"\";C&&(C=encodeURIComponent(C),C=C.replace(/%3A/i,\":\"),C+=\"@\");var I=this.protocol||\"\",M=this.pathname||\"\",P=this.hash||\"\",J=!1,T=\"\";this.host?J=C+this.host:this.hostname&&(J=C+(-1===this.hostname.indexOf(\":\")?\nthis.hostname:\"[\"+this.hostname+\"]\"),this.port&&(J+=\":\"+this.port));this.query&&y.isObject(this.query)&&Object.keys(this.query).length&&(T=D.stringify(this.query));C=this.search||T&&\"?\"+T||\"\";I&&\":\"!==I.substr(-1)&&(I+=\":\");this.slashes||(!I||H[I])&&!1!==J?(J=\"//\"+(J||\"\"),M&&\"/\"!==M.charAt(0)&&(M=\"/\"+M)):J||(J=\"\");P&&\"#\"!==P.charAt(0)&&(P=\"#\"+P);C&&\"?\"!==C.charAt(0)&&(C=\"?\"+C);M=M.replace(/[?#]/g,function(N){return encodeURIComponent(N)});C=C.replace(\"#\",\"%23\");return I+J+M+C+P};F.prototype.resolve=\nfunction(C){return this.resolveObject(G(C,!1,!0)).format()};F.prototype.resolveObject=function(C){if(y.isString(C)){var I=new F;I.parse(C,!1,!0);C=I}I=new F;for(var M=Object.keys(this),P=0;P<M.length;P++){var J=M[P];I[J]=this[J]}I.hash=C.hash;if(\"\"===C.href)return I.href=I.format(),I;if(C.slashes&&!C.protocol){M=Object.keys(C);for(P=0;P<M.length;P++)J=M[P],\"protocol\"!==J&&(I[J]=C[J]);H[I.protocol]&&I.hostname&&!I.pathname&&(I.path=I.pathname=\"/\");I.href=I.format();return I}if(C.protocol&&C.protocol!==\nI.protocol){if(!H[C.protocol]){M=Object.keys(C);for(P=0;P<M.length;P++)J=M[P],I[J]=C[J];I.href=I.format();return I}I.protocol=C.protocol;if(C.host||E[C.protocol])I.pathname=C.pathname;else{for(var T=(C.pathname||\"\").split(\"/\");T.length&&!(C.host=T.shift()););C.host||(C.host=\"\");C.hostname||(C.hostname=\"\");\"\"!==T[0]&&T.unshift(\"\");2>T.length&&T.unshift(\"\");I.pathname=T.join(\"/\")}I.search=C.search;I.query=C.query;I.host=C.host||\"\";I.auth=C.auth;I.hostname=C.hostname||C.host;I.port=C.port;if(I.pathname||\nI.search)I.path=(I.pathname||\"\")+(I.search||\"\");I.slashes=I.slashes||C.slashes;I.href=I.format();return I}M=I.pathname&&\"/\"===I.pathname.charAt(0);var N=C.host||C.pathname&&\"/\"===C.pathname.charAt(0),a=M=N||M||I.host&&C.pathname;P=I.pathname&&I.pathname.split(\"/\")||[];T=C.pathname&&C.pathname.split(\"/\")||[];if(J=I.protocol&&!H[I.protocol])I.hostname=\"\",I.port=null,I.host&&(\"\"===P[0]?P[0]=I.host:P.unshift(I.host)),I.host=\"\",C.protocol&&(C.hostname=null,C.port=null,C.host&&(\"\"===T[0]?T[0]=C.host:T.unshift(C.host)),\nC.host=null),M=M&&(\"\"===T[0]||\"\"===P[0]);if(N)I.host=C.host||\"\"===C.host?C.host:I.host,I.hostname=C.hostname||\"\"===C.hostname?C.hostname:I.hostname,I.search=C.search,I.query=C.query,P=T;else if(T.length)P||(P=[]),P.pop(),P=P.concat(T),I.search=C.search,I.query=C.query;else if(!y.isNullOrUndefined(C.search))return J&&(I.hostname=I.host=P.shift(),J=I.host&&0<I.host.indexOf(\"@\")?I.host.split(\"@\"):!1)&&(I.auth=J.shift(),I.host=I.hostname=J.shift()),I.search=C.search,I.query=C.query,y.isNull(I.pathname)&&\ny.isNull(I.search)||(I.path=(I.pathname?I.pathname:\"\")+(I.search?I.search:\"\")),I.href=I.format(),I;if(!P.length)return I.pathname=null,I.path=I.search?\"/\"+I.search:null,I.href=I.format(),I;N=P.slice(-1)[0];T=(I.host||C.host||1<P.length)&&(\".\"===N||\"..\"===N)||\"\"===N;for(var b=0,c=P.length;0<=c;c--)N=P[c],\".\"===N?P.splice(c,1):\"..\"===N?(P.splice(c,1),b++):b&&(P.splice(c,1),b--);if(!M&&!a)for(;b--;b)P.unshift(\"..\");!M||\"\"===P[0]||P[0]&&\"/\"===P[0].charAt(0)||P.unshift(\"\");T&&\"/\"!==P.join(\"/\").substr(-1)&&\nP.push(\"\");a=\"\"===P[0]||P[0]&&\"/\"===P[0].charAt(0);J&&(I.hostname=I.host=a?\"\":P.length?P.shift():\"\",J=I.host&&0<I.host.indexOf(\"@\")?I.host.split(\"@\"):!1)&&(I.auth=J.shift(),I.host=I.hostname=J.shift());(M=M||I.host&&P.length)&&!a&&P.unshift(\"\");P.length?I.pathname=P.join(\"/\"):(I.pathname=null,I.path=null);y.isNull(I.pathname)&&y.isNull(I.search)||(I.path=(I.pathname?I.pathname:\"\")+(I.search?I.search:\"\"));I.auth=C.auth||I.auth;I.slashes=I.slashes||C.slashes;I.href=I.format();return I};F.prototype.parseHost=\nfunction(){var C=this.host,I=u.exec(C);I&&(I=I[0],\":\"!==I&&(this.port=I.substr(1)),C=C.substr(0,C.length-I.length));C&&(this.hostname=C)}}","~:source","shadow$provide[309] = function(global,require,module,exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$url$node_modules$punycode$punycode","~$shadow.js","~$module$node_modules$url$util","~$module$node_modules$querystring_es3$index"]],"~:properties",["^5",["hostname","protocol","resolve","slashes","host","hash","pathname","query","auth","path","href","Url","port","resolveObject","parse","parseHost","search","format"]],"~:compiled-at",1695041440894,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$url$url.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/url/url.js\"],\n\"sourcesContent\":[\"shadow$provide[309] = function(global,require,module,exports) {\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n'use strict';\\n\\nvar punycode = require('punycode');\\nvar util = require('./util');\\n\\nexports.parse = urlParse;\\nexports.resolve = urlResolve;\\nexports.resolveObject = urlResolveObject;\\nexports.format = urlFormat;\\n\\nexports.Url = Url;\\n\\nfunction Url() {\\n  this.protocol = null;\\n  this.slashes = null;\\n  this.auth = null;\\n  this.host = null;\\n  this.port = null;\\n  this.hostname = null;\\n  this.hash = null;\\n  this.search = null;\\n  this.query = null;\\n  this.pathname = null;\\n  this.path = null;\\n  this.href = null;\\n}\\n\\n// Reference: RFC 3986, RFC 1808, RFC 2396\\n\\n// define these here so at least they only have to be\\n// compiled once on the first module load.\\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\\n    portPattern = /:[0-9]*$/,\\n\\n    // Special case for a simple path URL\\n    simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,\\n\\n    // RFC 2396: characters reserved for delimiting URLs.\\n    // We actually just auto-escape these.\\n    delims = ['<', '>', '\\\"', '`', ' ', '\\\\r', '\\\\n', '\\\\t'],\\n\\n    // RFC 2396: characters not allowed for various reasons.\\n    unwise = ['{', '}', '|', '\\\\\\\\', '^', '`'].concat(delims),\\n\\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\\n    autoEscape = ['\\\\''].concat(unwise),\\n    // Characters that are never ever allowed in a hostname.\\n    // Note that any invalid chars are also handled, but these\\n    // are the ones that are *expected* to be seen, so we fast-path\\n    // them.\\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\\n    hostEndingChars = ['/', '?', '#'],\\n    hostnameMaxLen = 255,\\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\\n    // protocols that can allow \\\"unsafe\\\" and \\\"unwise\\\" chars.\\n    unsafeProtocol = {\\n      'javascript': true,\\n      'javascript:': true\\n    },\\n    // protocols that never have a hostname.\\n    hostlessProtocol = {\\n      'javascript': true,\\n      'javascript:': true\\n    },\\n    // protocols that always contain a // bit.\\n    slashedProtocol = {\\n      'http': true,\\n      'https': true,\\n      'ftp': true,\\n      'gopher': true,\\n      'file': true,\\n      'http:': true,\\n      'https:': true,\\n      'ftp:': true,\\n      'gopher:': true,\\n      'file:': true\\n    },\\n    querystring = require('querystring');\\n\\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\\n  if (url && util.isObject(url) && url instanceof Url) return url;\\n\\n  var u = new Url;\\n  u.parse(url, parseQueryString, slashesDenoteHost);\\n  return u;\\n}\\n\\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\\n  if (!util.isString(url)) {\\n    throw new TypeError(\\\"Parameter 'url' must be a string, not \\\" + typeof url);\\n  }\\n\\n  // Copy chrome, IE, opera backslash-handling behavior.\\n  // Back slashes before the query string get converted to forward slashes\\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\\n  var queryIndex = url.indexOf('?'),\\n      splitter =\\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\\n      uSplit = url.split(splitter),\\n      slashRegex = /\\\\\\\\/g;\\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\\n  url = uSplit.join(splitter);\\n\\n  var rest = url;\\n\\n  // trim before proceeding.\\n  // This is to support parse stuff like \\\"  http://foo.com  \\\\n\\\"\\n  rest = rest.trim();\\n\\n  if (!slashesDenoteHost && url.split('#').length === 1) {\\n    // Try fast path regexp\\n    var simplePath = simplePathPattern.exec(rest);\\n    if (simplePath) {\\n      this.path = rest;\\n      this.href = rest;\\n      this.pathname = simplePath[1];\\n      if (simplePath[2]) {\\n        this.search = simplePath[2];\\n        if (parseQueryString) {\\n          this.query = querystring.parse(this.search.substr(1));\\n        } else {\\n          this.query = this.search.substr(1);\\n        }\\n      } else if (parseQueryString) {\\n        this.search = '';\\n        this.query = {};\\n      }\\n      return this;\\n    }\\n  }\\n\\n  var proto = protocolPattern.exec(rest);\\n  if (proto) {\\n    proto = proto[0];\\n    var lowerProto = proto.toLowerCase();\\n    this.protocol = lowerProto;\\n    rest = rest.substr(proto.length);\\n  }\\n\\n  // figure out if it's got a host\\n  // user@server is *always* interpreted as a hostname, and url\\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\\n  // how the browser resolves relative URLs.\\n  if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {\\n    var slashes = rest.substr(0, 2) === '//';\\n    if (slashes && !(proto && hostlessProtocol[proto])) {\\n      rest = rest.substr(2);\\n      this.slashes = true;\\n    }\\n  }\\n\\n  if (!hostlessProtocol[proto] &&\\n      (slashes || (proto && !slashedProtocol[proto]))) {\\n\\n    // there's a hostname.\\n    // the first instance of /, ?, ;, or # ends the host.\\n    //\\n    // If there is an @ in the hostname, then non-host chars *are* allowed\\n    // to the left of the last @ sign, unless some host-ending character\\n    // comes *before* the @-sign.\\n    // URLs are obnoxious.\\n    //\\n    // ex:\\n    // http://a@b@c/ => user:a@b host:c\\n    // http://a@b?@c => user:a host:c path:/?@c\\n\\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\\n    // Review our test case against browsers more comprehensively.\\n\\n    // find the first instance of any hostEndingChars\\n    var hostEnd = -1;\\n    for (var i = 0; i < hostEndingChars.length; i++) {\\n      var hec = rest.indexOf(hostEndingChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\n        hostEnd = hec;\\n    }\\n\\n    // at this point, either we have an explicit point where the\\n    // auth portion cannot go past, or the last @ char is the decider.\\n    var auth, atSign;\\n    if (hostEnd === -1) {\\n      // atSign can be anywhere.\\n      atSign = rest.lastIndexOf('@');\\n    } else {\\n      // atSign must be in auth portion.\\n      // http://a@b/c@d => host:b auth:a path:/c@d\\n      atSign = rest.lastIndexOf('@', hostEnd);\\n    }\\n\\n    // Now we have a portion which is definitely the auth.\\n    // Pull that off.\\n    if (atSign !== -1) {\\n      auth = rest.slice(0, atSign);\\n      rest = rest.slice(atSign + 1);\\n      this.auth = decodeURIComponent(auth);\\n    }\\n\\n    // the host is the remaining to the left of the first non-host char\\n    hostEnd = -1;\\n    for (var i = 0; i < nonHostChars.length; i++) {\\n      var hec = rest.indexOf(nonHostChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\\n        hostEnd = hec;\\n    }\\n    // if we still have not hit it, then the entire thing is a host.\\n    if (hostEnd === -1)\\n      hostEnd = rest.length;\\n\\n    this.host = rest.slice(0, hostEnd);\\n    rest = rest.slice(hostEnd);\\n\\n    // pull out port.\\n    this.parseHost();\\n\\n    // we've indicated that there is a hostname,\\n    // so even if it's empty, it has to be present.\\n    this.hostname = this.hostname || '';\\n\\n    // if hostname begins with [ and ends with ]\\n    // assume that it's an IPv6 address.\\n    var ipv6Hostname = this.hostname[0] === '[' &&\\n        this.hostname[this.hostname.length - 1] === ']';\\n\\n    // validate a little.\\n    if (!ipv6Hostname) {\\n      var hostparts = this.hostname.split(/\\\\./);\\n      for (var i = 0, l = hostparts.length; i < l; i++) {\\n        var part = hostparts[i];\\n        if (!part) continue;\\n        if (!part.match(hostnamePartPattern)) {\\n          var newpart = '';\\n          for (var j = 0, k = part.length; j < k; j++) {\\n            if (part.charCodeAt(j) > 127) {\\n              // we replace non-ASCII char with a temporary placeholder\\n              // we need this to make sure size of hostname is not\\n              // broken by replacing non-ASCII by nothing\\n              newpart += 'x';\\n            } else {\\n              newpart += part[j];\\n            }\\n          }\\n          // we test again with ASCII char only\\n          if (!newpart.match(hostnamePartPattern)) {\\n            var validParts = hostparts.slice(0, i);\\n            var notHost = hostparts.slice(i + 1);\\n            var bit = part.match(hostnamePartStart);\\n            if (bit) {\\n              validParts.push(bit[1]);\\n              notHost.unshift(bit[2]);\\n            }\\n            if (notHost.length) {\\n              rest = '/' + notHost.join('.') + rest;\\n            }\\n            this.hostname = validParts.join('.');\\n            break;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (this.hostname.length > hostnameMaxLen) {\\n      this.hostname = '';\\n    } else {\\n      // hostnames are always lower case.\\n      this.hostname = this.hostname.toLowerCase();\\n    }\\n\\n    if (!ipv6Hostname) {\\n      // IDNA Support: Returns a punycoded representation of \\\"domain\\\".\\n      // It only converts parts of the domain name that\\n      // have non-ASCII characters, i.e. it doesn't matter if\\n      // you call it with a domain that already is ASCII-only.\\n      this.hostname = punycode.toASCII(this.hostname);\\n    }\\n\\n    var p = this.port ? ':' + this.port : '';\\n    var h = this.hostname || '';\\n    this.host = h + p;\\n    this.href += this.host;\\n\\n    // strip [ and ] from the hostname\\n    // the host field still retains them, though\\n    if (ipv6Hostname) {\\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\\n      if (rest[0] !== '/') {\\n        rest = '/' + rest;\\n      }\\n    }\\n  }\\n\\n  // now rest is set to the post-host stuff.\\n  // chop off any delim chars.\\n  if (!unsafeProtocol[lowerProto]) {\\n\\n    // First, make 100% sure that any \\\"autoEscape\\\" chars get\\n    // escaped, even if encodeURIComponent doesn't think they\\n    // need to be.\\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\\n      var ae = autoEscape[i];\\n      if (rest.indexOf(ae) === -1)\\n        continue;\\n      var esc = encodeURIComponent(ae);\\n      if (esc === ae) {\\n        esc = escape(ae);\\n      }\\n      rest = rest.split(ae).join(esc);\\n    }\\n  }\\n\\n\\n  // chop off from the tail first.\\n  var hash = rest.indexOf('#');\\n  if (hash !== -1) {\\n    // got a fragment string.\\n    this.hash = rest.substr(hash);\\n    rest = rest.slice(0, hash);\\n  }\\n  var qm = rest.indexOf('?');\\n  if (qm !== -1) {\\n    this.search = rest.substr(qm);\\n    this.query = rest.substr(qm + 1);\\n    if (parseQueryString) {\\n      this.query = querystring.parse(this.query);\\n    }\\n    rest = rest.slice(0, qm);\\n  } else if (parseQueryString) {\\n    // no query string, but parseQueryString still requested\\n    this.search = '';\\n    this.query = {};\\n  }\\n  if (rest) this.pathname = rest;\\n  if (slashedProtocol[lowerProto] &&\\n      this.hostname && !this.pathname) {\\n    this.pathname = '/';\\n  }\\n\\n  //to support http.request\\n  if (this.pathname || this.search) {\\n    var p = this.pathname || '';\\n    var s = this.search || '';\\n    this.path = p + s;\\n  }\\n\\n  // finally, reconstruct the href based on what has been validated.\\n  this.href = this.format();\\n  return this;\\n};\\n\\n// format a parsed object into a url string\\nfunction urlFormat(obj) {\\n  // ensure it's an object, and not a string url.\\n  // If it's an obj, this is a no-op.\\n  // this way, you can call url_format() on strings\\n  // to clean up potentially wonky urls.\\n  if (util.isString(obj)) obj = urlParse(obj);\\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\\n  return obj.format();\\n}\\n\\nUrl.prototype.format = function() {\\n  var auth = this.auth || '';\\n  if (auth) {\\n    auth = encodeURIComponent(auth);\\n    auth = auth.replace(/%3A/i, ':');\\n    auth += '@';\\n  }\\n\\n  var protocol = this.protocol || '',\\n      pathname = this.pathname || '',\\n      hash = this.hash || '',\\n      host = false,\\n      query = '';\\n\\n  if (this.host) {\\n    host = auth + this.host;\\n  } else if (this.hostname) {\\n    host = auth + (this.hostname.indexOf(':') === -1 ?\\n        this.hostname :\\n        '[' + this.hostname + ']');\\n    if (this.port) {\\n      host += ':' + this.port;\\n    }\\n  }\\n\\n  if (this.query &&\\n      util.isObject(this.query) &&\\n      Object.keys(this.query).length) {\\n    query = querystring.stringify(this.query);\\n  }\\n\\n  var search = this.search || (query && ('?' + query)) || '';\\n\\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\\n\\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\\n  // unless they had them to begin with.\\n  if (this.slashes ||\\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\\n    host = '//' + (host || '');\\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\\n  } else if (!host) {\\n    host = '';\\n  }\\n\\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\\n  if (search && search.charAt(0) !== '?') search = '?' + search;\\n\\n  pathname = pathname.replace(/[?#]/g, function(match) {\\n    return encodeURIComponent(match);\\n  });\\n  search = search.replace('#', '%23');\\n\\n  return protocol + host + pathname + search + hash;\\n};\\n\\nfunction urlResolve(source, relative) {\\n  return urlParse(source, false, true).resolve(relative);\\n}\\n\\nUrl.prototype.resolve = function(relative) {\\n  return this.resolveObject(urlParse(relative, false, true)).format();\\n};\\n\\nfunction urlResolveObject(source, relative) {\\n  if (!source) return relative;\\n  return urlParse(source, false, true).resolveObject(relative);\\n}\\n\\nUrl.prototype.resolveObject = function(relative) {\\n  if (util.isString(relative)) {\\n    var rel = new Url();\\n    rel.parse(relative, false, true);\\n    relative = rel;\\n  }\\n\\n  var result = new Url();\\n  var tkeys = Object.keys(this);\\n  for (var tk = 0; tk < tkeys.length; tk++) {\\n    var tkey = tkeys[tk];\\n    result[tkey] = this[tkey];\\n  }\\n\\n  // hash is always overridden, no matter what.\\n  // even href=\\\"\\\" will remove it.\\n  result.hash = relative.hash;\\n\\n  // if the relative url is empty, then there's nothing left to do here.\\n  if (relative.href === '') {\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // hrefs like //foo/bar always cut to the protocol.\\n  if (relative.slashes && !relative.protocol) {\\n    // take everything except the protocol from relative\\n    var rkeys = Object.keys(relative);\\n    for (var rk = 0; rk < rkeys.length; rk++) {\\n      var rkey = rkeys[rk];\\n      if (rkey !== 'protocol')\\n        result[rkey] = relative[rkey];\\n    }\\n\\n    //urlParse appends trailing / to urls like http://www.example.com\\n    if (slashedProtocol[result.protocol] &&\\n        result.hostname && !result.pathname) {\\n      result.path = result.pathname = '/';\\n    }\\n\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (relative.protocol && relative.protocol !== result.protocol) {\\n    // if it's a known url protocol, then changing\\n    // the protocol does weird things\\n    // first, if it's not file:, then we MUST have a host,\\n    // and if there was a path\\n    // to begin with, then we MUST have a path.\\n    // if it is file:, then the host is dropped,\\n    // because that's known to be hostless.\\n    // anything else is assumed to be absolute.\\n    if (!slashedProtocol[relative.protocol]) {\\n      var keys = Object.keys(relative);\\n      for (var v = 0; v < keys.length; v++) {\\n        var k = keys[v];\\n        result[k] = relative[k];\\n      }\\n      result.href = result.format();\\n      return result;\\n    }\\n\\n    result.protocol = relative.protocol;\\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\\n      var relPath = (relative.pathname || '').split('/');\\n      while (relPath.length && !(relative.host = relPath.shift()));\\n      if (!relative.host) relative.host = '';\\n      if (!relative.hostname) relative.hostname = '';\\n      if (relPath[0] !== '') relPath.unshift('');\\n      if (relPath.length < 2) relPath.unshift('');\\n      result.pathname = relPath.join('/');\\n    } else {\\n      result.pathname = relative.pathname;\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    result.host = relative.host || '';\\n    result.auth = relative.auth;\\n    result.hostname = relative.hostname || relative.host;\\n    result.port = relative.port;\\n    // to support http.request\\n    if (result.pathname || result.search) {\\n      var p = result.pathname || '';\\n      var s = result.search || '';\\n      result.path = p + s;\\n    }\\n    result.slashes = result.slashes || relative.slashes;\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\\n      isRelAbs = (\\n          relative.host ||\\n          relative.pathname && relative.pathname.charAt(0) === '/'\\n      ),\\n      mustEndAbs = (isRelAbs || isSourceAbs ||\\n                    (result.host && relative.pathname)),\\n      removeAllDots = mustEndAbs,\\n      srcPath = result.pathname && result.pathname.split('/') || [],\\n      relPath = relative.pathname && relative.pathname.split('/') || [],\\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\\n\\n  // if the url is a non-slashed url, then relative\\n  // links like ../.. should be able\\n  // to crawl up to the hostname, as well.  This is strange.\\n  // result.protocol has already been set by now.\\n  // Later on, put the first path part into the host field.\\n  if (psychotic) {\\n    result.hostname = '';\\n    result.port = null;\\n    if (result.host) {\\n      if (srcPath[0] === '') srcPath[0] = result.host;\\n      else srcPath.unshift(result.host);\\n    }\\n    result.host = '';\\n    if (relative.protocol) {\\n      relative.hostname = null;\\n      relative.port = null;\\n      if (relative.host) {\\n        if (relPath[0] === '') relPath[0] = relative.host;\\n        else relPath.unshift(relative.host);\\n      }\\n      relative.host = null;\\n    }\\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\\n  }\\n\\n  if (isRelAbs) {\\n    // it's absolute.\\n    result.host = (relative.host || relative.host === '') ?\\n                  relative.host : result.host;\\n    result.hostname = (relative.hostname || relative.hostname === '') ?\\n                      relative.hostname : result.hostname;\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    srcPath = relPath;\\n    // fall through to the dot-handling below.\\n  } else if (relPath.length) {\\n    // it's relative\\n    // throw away the existing file, and take the new path instead.\\n    if (!srcPath) srcPath = [];\\n    srcPath.pop();\\n    srcPath = srcPath.concat(relPath);\\n    result.search = relative.search;\\n    result.query = relative.query;\\n  } else if (!util.isNullOrUndefined(relative.search)) {\\n    // just pull out the search.\\n    // like href='?foo'.\\n    // Put this after the other two cases because it simplifies the booleans\\n    if (psychotic) {\\n      result.hostname = result.host = srcPath.shift();\\n      //occationaly the auth can get stuck only in host\\n      //this especially happens in cases like\\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\\n                       result.host.split('@') : false;\\n      if (authInHost) {\\n        result.auth = authInHost.shift();\\n        result.host = result.hostname = authInHost.shift();\\n      }\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    //to support http.request\\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\n      result.path = (result.pathname ? result.pathname : '') +\\n                    (result.search ? result.search : '');\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (!srcPath.length) {\\n    // no path at all.  easy.\\n    // we've already handled the other stuff above.\\n    result.pathname = null;\\n    //to support http.request\\n    if (result.search) {\\n      result.path = '/' + result.search;\\n    } else {\\n      result.path = null;\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // if a url ENDs in . or .., then it must get a trailing slash.\\n  // however, if it ends in anything else non-slashy,\\n  // then it must NOT get a trailing slash.\\n  var last = srcPath.slice(-1)[0];\\n  var hasTrailingSlash = (\\n      (result.host || relative.host || srcPath.length > 1) &&\\n      (last === '.' || last === '..') || last === '');\\n\\n  // strip single dots, resolve double dots to parent dir\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = srcPath.length; i >= 0; i--) {\\n    last = srcPath[i];\\n    if (last === '.') {\\n      srcPath.splice(i, 1);\\n    } else if (last === '..') {\\n      srcPath.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      srcPath.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (!mustEndAbs && !removeAllDots) {\\n    for (; up--; up) {\\n      srcPath.unshift('..');\\n    }\\n  }\\n\\n  if (mustEndAbs && srcPath[0] !== '' &&\\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\\n    srcPath.push('');\\n  }\\n\\n  var isAbsolute = srcPath[0] === '' ||\\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\\n\\n  // put the host back\\n  if (psychotic) {\\n    result.hostname = result.host = isAbsolute ? '' :\\n                                    srcPath.length ? srcPath.shift() : '';\\n    //occationaly the auth can get stuck only in host\\n    //this especially happens in cases like\\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\\n                     result.host.split('@') : false;\\n    if (authInHost) {\\n      result.auth = authInHost.shift();\\n      result.host = result.hostname = authInHost.shift();\\n    }\\n  }\\n\\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\\n\\n  if (mustEndAbs && !isAbsolute) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (!srcPath.length) {\\n    result.pathname = null;\\n    result.path = null;\\n  } else {\\n    result.pathname = srcPath.join('/');\\n  }\\n\\n  //to support request.http\\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\n    result.path = (result.pathname ? result.pathname : '') +\\n                  (result.search ? result.search : '');\\n  }\\n  result.auth = relative.auth || result.auth;\\n  result.slashes = result.slashes || relative.slashes;\\n  result.href = result.format();\\n  return result;\\n};\\n\\nUrl.prototype.parseHost = function() {\\n  var host = this.host;\\n  var port = portPattern.exec(host);\\n  if (port) {\\n    port = port[0];\\n    if (port !== ':') {\\n      this.port = port.substr(1);\\n    }\\n    host = host.substr(0, host.length - port.length);\\n  }\\n  if (host) this.hostname = host;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Url\",\"href\",\"path\",\"pathname\",\"query\",\"search\",\"hash\",\"hostname\",\"port\",\"host\",\"auth\",\"slashes\",\"protocol\",\"urlParse\",\"url\",\"parseQueryString\",\"slashesDenoteHost\",\"util\",\"isObject\",\"u\",\"parse\",\"punycode\",\"resolve\",\"urlResolve\",\"source\",\"relative\",\"resolveObject\",\"urlResolveObject\",\"format\",\"urlFormat\",\"obj\",\"isString\",\"prototype\",\"call\",\"protocolPattern\",\"portPattern\",\"simplePathPattern\",\"unwise\",\"concat\",\"delims\",\"autoEscape\",\"nonHostChars\",\"hostEndingChars\",\"hostnamePartPattern\",\"hostnamePartStart\",\"unsafeProtocol\",\"hostlessProtocol\",\"slashedProtocol\",\"querystring\",\"Url.prototype.parse\",\"TypeError\",\"queryIndex\",\"indexOf\",\"splitter\",\"uSplit\",\"split\",\"replace\",\"slashRegex\",\"join\",\"rest\",\"trim\",\"length\",\"simplePath\",\"exec\",\"substr\",\"proto\",\"lowerProto\",\"toLowerCase\",\"match\",\"hostEnd\",\"i\",\"hec\",\"atSign\",\"lastIndexOf\",\"slice\",\"decodeURIComponent\",\"parseHost\",\"ipv6Hostname\",\"hostparts\",\"l\",\"part\",\"newpart\",\"j\",\"k\",\"charCodeAt\",\"validParts\",\"notHost\",\"bit\",\"push\",\"unshift\",\"hostnameMaxLen\",\"toASCII\",\"p\",\"ae\",\"esc\",\"encodeURIComponent\",\"escape\",\"qm\",\"Url.prototype.format\",\"Object\",\"keys\",\"stringify\",\"charAt\",\"Url.prototype.resolve\",\"Url.prototype.resolveObject\",\"rel\",\"result\",\"tkeys\",\"tk\",\"tkey\",\"rkeys\",\"rk\",\"rkey\",\"v\",\"relPath\",\"shift\",\"isSourceAbs\",\"isRelAbs\",\"removeAllDots\",\"mustEndAbs\",\"srcPath\",\"psychotic\",\"pop\",\"isNullOrUndefined\",\"authInHost\",\"isNull\",\"last\",\"hasTrailingSlash\",\"up\",\"splice\",\"isAbsolute\",\"Url.prototype.parseHost\"]\n}\n"]