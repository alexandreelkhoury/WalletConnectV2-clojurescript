["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/elliptic/lib/elliptic/curve/base.js"],"~:js","shadow$provide[75]=function(S,A,V,q){function F(n,l){this.type=n;this.p=new r(l.p,16);this.red=l.prime?r.red(l.prime):r.mont(this.p);this.zero=(new r(0)).toRed(this.red);this.one=(new r(1)).toRed(this.red);this.two=(new r(2)).toRed(this.red);this.n=l.n&&new r(l.n,16);this.g=l.g&&this.pointFromJSON(l.g,l.gRed);this._wnafT1=Array(4);this._wnafT2=Array(4);this._wnafT3=Array(4);this._wnafT4=Array(4);this._bitLength=this.n?this.n.bitLength():0;n=this.n&&this.p.div(this.n);!n||0<n.cmpn(100)?this.redN=null:\n(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function G(n,l){this.curve=n;this.type=l;this.precomputed=null}var r=A(70),y=A(73),e=y.getNAF,u=y.getJSF,p=y.assert;V.exports=F;F.prototype.point=function(){throw Error(\"Not implemented\");};F.prototype.validate=function(){throw Error(\"Not implemented\");};F.prototype._fixedNafMul=function(n,l){p(n.precomputed);n=n._getDoubles();var h=e(l,1,this._bitLength),k=(1<<n.step+1)-(0===n.step%2?2:1);k/=3;l=[];var t;for(t=0;t<h.length;t+=n.step){var B=\n0;for(var E=t+n.step-1;E>=t;E--)B=(B<<1)+h[E];l.push(B)}h=this.jpoint(null,null,null);for(E=this.jpoint(null,null,null);0<k;k--){for(t=0;t<l.length;t++)B=l[t],B===k?E=E.mixedAdd(n.points[t]):B===-k&&(E=E.mixedAdd(n.points[t].neg()));h=h.add(E)}return h.toP()};F.prototype._wnafMul=function(n,l){var h=n._getNAFPoints(4),k=h.points;l=e(l,h.wnd,this._bitLength);h=this.jpoint(null,null,null);for(var t=l.length-1;0<=t;t--){for(var B=0;0<=t&&0===l[t];t--)B++;0<=t&&B++;h=h.dblp(B);if(0>t)break;B=l[t];p(0!==\nB);h=\"affine\"===n.type?0<B?h.mixedAdd(k[B-1>>1]):h.mixedAdd(k[-B-1>>1].neg()):0<B?h.add(k[B-1>>1]):h.add(k[-B-1>>1].neg())}return\"affine\"===n.type?h.toP():h};F.prototype._wnafMulAdd=function(n,l,h,k,t){var B=this._wnafT1,E=this._wnafT2,H=this._wnafT3,D=0,C;for(C=0;C<k;C++){var I=l[C];var M=I._getNAFPoints(n);B[C]=M.wnd;E[C]=M.points}for(C=k-1;1<=C;C-=2){M=C-1;var P=C;if(1!==B[M]||1!==B[P])H[M]=e(h[M],B[M],this._bitLength),H[P]=e(h[P],B[P],this._bitLength),D=Math.max(H[M].length,D),D=Math.max(H[P].length,\nD);else{var J=[l[M],null,null,l[P]];0===l[M].y.cmp(l[P].y)?(J[1]=l[M].add(l[P]),J[2]=l[M].toJ().mixedAdd(l[P].neg())):0===l[M].y.cmp(l[P].y.redNeg())?(J[1]=l[M].toJ().mixedAdd(l[P]),J[2]=l[M].add(l[P].neg())):(J[1]=l[M].toJ().mixedAdd(l[P]),J[2]=l[M].toJ().mixedAdd(l[P].neg()));var T=[-3,-1,-5,-7,0,7,5,1,3],N=u(h[M],h[P]);D=Math.max(N[0].length,D);H[M]=Array(D);H[P]=Array(D);for(n=0;n<D;n++)H[M][n]=T[3*((N[0][n]|0)+1)+((N[1][n]|0)+1)],H[P][n]=0,E[M]=J}}l=this.jpoint(null,null,null);h=this._wnafT4;\nfor(C=D;0<=C;C--){for(D=0;0<=C;){B=!0;for(n=0;n<k;n++)h[n]=H[n][C]|0,0!==h[n]&&(B=!1);if(!B)break;D++;C--}0<=C&&D++;l=l.dblp(D);if(0>C)break;for(n=0;n<k;n++)D=h[n],I,0!==D&&(0<D?I=E[n][D-1>>1]:0>D&&(I=E[n][-D-1>>1].neg()),l=\"affine\"===I.type?l.mixedAdd(I):l.add(I))}for(C=0;C<k;C++)E[C]=null;return t?l:l.toP()};F.BasePoint=G;G.prototype.eq=function(){throw Error(\"Not implemented\");};G.prototype.validate=function(){return this.curve.validate(this)};F.prototype.decodePoint=function(n,l){n=y.toArray(n,\nl);l=this.p.byteLength();if((4===n[0]||6===n[0]||7===n[0])&&n.length-1===2*l)return 6===n[0]?p(0===n[n.length-1]%2):7===n[0]&&p(1===n[n.length-1]%2),this.point(n.slice(1,1+l),n.slice(1+l,1+2*l));if((2===n[0]||3===n[0])&&n.length-1===l)return this.pointFromX(n.slice(1,1+l),3===n[0]);throw Error(\"Unknown point format\");};G.prototype.encodeCompressed=function(n){return this.encode(n,!0)};G.prototype._encode=function(n){var l=this.curve.p.byteLength(),h=this.getX().toArray(\"be\",l);return n?[this.getY().isEven()?\n2:3].concat(h):[4].concat(h,this.getY().toArray(\"be\",l))};G.prototype.encode=function(n,l){return y.encode(this._encode(l),n)};G.prototype.precompute=function(n){if(this.precomputed)return this;var l={doubles:null,naf:null,beta:null};l.naf=this._getNAFPoints(8);l.doubles=this._getDoubles(4,n);l.beta=this._getBeta();this.precomputed=l;return this};G.prototype._hasDoubles=function(n){if(!this.precomputed)return!1;var l=this.precomputed.doubles;return l?l.points.length>=Math.ceil((n.bitLength()+1)/l.step):\n!1};G.prototype._getDoubles=function(n,l){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var h=[this],k=this,t=0;t<l;t+=n){for(var B=0;B<n;B++)k=k.dbl();h.push(k)}return{step:n,points:h}};G.prototype._getNAFPoints=function(n){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var l=[this],h=(1<<n)-1,k=1===h?null:this.dbl(),t=1;t<h;t++)l[t]=l[t-1].add(k);return{wnd:n,points:l}};G.prototype._getBeta=function(){return null};G.prototype.dblp=function(n){for(var l=\nthis,h=0;h<n;h++)l=l.dbl();return l}}","~:source","shadow$provide[75] = function(global,require,module,exports) {\n'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$elliptic$node_modules$bn_js$lib$bn","~$module$node_modules$elliptic$lib$elliptic$utils"]],"~:properties",["^5",["n","dblp","_getBeta","_getNAFPoints","BasePoint","curve","redN","_getDoubles","encodeCompressed","_bitLength","two","eq","p","validate","_wnafT3","points","zero","_wnafMulAdd","doubles","decodePoint","_fixedNafMul","red","_wnafT4","precompute","_wnafMul","type","wnd","one","naf","g","_encode","_wnafT1","beta","precomputed","_wnafT2","encode","point","_maxwellTrick","_hasDoubles","step"]],"~:compiled-at",1695041440737,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$elliptic$lib$elliptic$curve$base.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/elliptic/lib/elliptic/curve/base.js\"],\n\"sourcesContent\":[\"shadow$provide[75] = function(global,require,module,exports) {\\n'use strict';\\n\\nvar BN = require('bn.js');\\nvar utils = require('../utils');\\nvar getNAF = utils.getNAF;\\nvar getJSF = utils.getJSF;\\nvar assert = utils.assert;\\n\\nfunction BaseCurve(type, conf) {\\n  this.type = type;\\n  this.p = new BN(conf.p, 16);\\n\\n  // Use Montgomery, when there is no fast reduction for the prime\\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\\n\\n  // Useful for many curves\\n  this.zero = new BN(0).toRed(this.red);\\n  this.one = new BN(1).toRed(this.red);\\n  this.two = new BN(2).toRed(this.red);\\n\\n  // Curve configuration, optional\\n  this.n = conf.n && new BN(conf.n, 16);\\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\\n\\n  // Temporary arrays\\n  this._wnafT1 = new Array(4);\\n  this._wnafT2 = new Array(4);\\n  this._wnafT3 = new Array(4);\\n  this._wnafT4 = new Array(4);\\n\\n  this._bitLength = this.n ? this.n.bitLength() : 0;\\n\\n  // Generalized Greg Maxwell's trick\\n  var adjustCount = this.n && this.p.div(this.n);\\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\\n    this.redN = null;\\n  } else {\\n    this._maxwellTrick = true;\\n    this.redN = this.n.toRed(this.red);\\n  }\\n}\\nmodule.exports = BaseCurve;\\n\\nBaseCurve.prototype.point = function point() {\\n  throw new Error('Not implemented');\\n};\\n\\nBaseCurve.prototype.validate = function validate() {\\n  throw new Error('Not implemented');\\n};\\n\\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\\n  assert(p.precomputed);\\n  var doubles = p._getDoubles();\\n\\n  var naf = getNAF(k, 1, this._bitLength);\\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\\n  I /= 3;\\n\\n  // Translate into more windowed form\\n  var repr = [];\\n  var j;\\n  var nafW;\\n  for (j = 0; j < naf.length; j += doubles.step) {\\n    nafW = 0;\\n    for (var l = j + doubles.step - 1; l >= j; l--)\\n      nafW = (nafW << 1) + naf[l];\\n    repr.push(nafW);\\n  }\\n\\n  var a = this.jpoint(null, null, null);\\n  var b = this.jpoint(null, null, null);\\n  for (var i = I; i > 0; i--) {\\n    for (j = 0; j < repr.length; j++) {\\n      nafW = repr[j];\\n      if (nafW === i)\\n        b = b.mixedAdd(doubles.points[j]);\\n      else if (nafW === -i)\\n        b = b.mixedAdd(doubles.points[j].neg());\\n    }\\n    a = a.add(b);\\n  }\\n  return a.toP();\\n};\\n\\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\\n  var w = 4;\\n\\n  // Precompute window\\n  var nafPoints = p._getNAFPoints(w);\\n  w = nafPoints.wnd;\\n  var wnd = nafPoints.points;\\n\\n  // Get NAF form\\n  var naf = getNAF(k, w, this._bitLength);\\n\\n  // Add `this`*(N+1) for every w-NAF index\\n  var acc = this.jpoint(null, null, null);\\n  for (var i = naf.length - 1; i >= 0; i--) {\\n    // Count zeroes\\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\\n      l++;\\n    if (i >= 0)\\n      l++;\\n    acc = acc.dblp(l);\\n\\n    if (i < 0)\\n      break;\\n    var z = naf[i];\\n    assert(z !== 0);\\n    if (p.type === 'affine') {\\n      // J +- P\\n      if (z > 0)\\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\\n      else\\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\\n    } else {\\n      // J +- J\\n      if (z > 0)\\n        acc = acc.add(wnd[(z - 1) >> 1]);\\n      else\\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\\n    }\\n  }\\n  return p.type === 'affine' ? acc.toP() : acc;\\n};\\n\\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\\n  points,\\n  coeffs,\\n  len,\\n  jacobianResult) {\\n  var wndWidth = this._wnafT1;\\n  var wnd = this._wnafT2;\\n  var naf = this._wnafT3;\\n\\n  // Fill all arrays\\n  var max = 0;\\n  var i;\\n  var j;\\n  var p;\\n  for (i = 0; i < len; i++) {\\n    p = points[i];\\n    var nafPoints = p._getNAFPoints(defW);\\n    wndWidth[i] = nafPoints.wnd;\\n    wnd[i] = nafPoints.points;\\n  }\\n\\n  // Comb small window NAFs\\n  for (i = len - 1; i >= 1; i -= 2) {\\n    var a = i - 1;\\n    var b = i;\\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\\n      max = Math.max(naf[a].length, max);\\n      max = Math.max(naf[b].length, max);\\n      continue;\\n    }\\n\\n    var comb = [\\n      points[a], /* 1 */\\n      null, /* 3 */\\n      null, /* 5 */\\n      points[b], /* 7 */\\n    ];\\n\\n    // Try to avoid Projective points, if possible\\n    if (points[a].y.cmp(points[b].y) === 0) {\\n      comb[1] = points[a].add(points[b]);\\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\\n      comb[2] = points[a].add(points[b].neg());\\n    } else {\\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\\n    }\\n\\n    var index = [\\n      -3, /* -1 -1 */\\n      -1, /* -1 0 */\\n      -5, /* -1 1 */\\n      -7, /* 0 -1 */\\n      0, /* 0 0 */\\n      7, /* 0 1 */\\n      5, /* 1 -1 */\\n      1, /* 1 0 */\\n      3,  /* 1 1 */\\n    ];\\n\\n    var jsf = getJSF(coeffs[a], coeffs[b]);\\n    max = Math.max(jsf[0].length, max);\\n    naf[a] = new Array(max);\\n    naf[b] = new Array(max);\\n    for (j = 0; j < max; j++) {\\n      var ja = jsf[0][j] | 0;\\n      var jb = jsf[1][j] | 0;\\n\\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\\n      naf[b][j] = 0;\\n      wnd[a] = comb;\\n    }\\n  }\\n\\n  var acc = this.jpoint(null, null, null);\\n  var tmp = this._wnafT4;\\n  for (i = max; i >= 0; i--) {\\n    var k = 0;\\n\\n    while (i >= 0) {\\n      var zero = true;\\n      for (j = 0; j < len; j++) {\\n        tmp[j] = naf[j][i] | 0;\\n        if (tmp[j] !== 0)\\n          zero = false;\\n      }\\n      if (!zero)\\n        break;\\n      k++;\\n      i--;\\n    }\\n    if (i >= 0)\\n      k++;\\n    acc = acc.dblp(k);\\n    if (i < 0)\\n      break;\\n\\n    for (j = 0; j < len; j++) {\\n      var z = tmp[j];\\n      p;\\n      if (z === 0)\\n        continue;\\n      else if (z > 0)\\n        p = wnd[j][(z - 1) >> 1];\\n      else if (z < 0)\\n        p = wnd[j][(-z - 1) >> 1].neg();\\n\\n      if (p.type === 'affine')\\n        acc = acc.mixedAdd(p);\\n      else\\n        acc = acc.add(p);\\n    }\\n  }\\n  // Zeroify references\\n  for (i = 0; i < len; i++)\\n    wnd[i] = null;\\n\\n  if (jacobianResult)\\n    return acc;\\n  else\\n    return acc.toP();\\n};\\n\\nfunction BasePoint(curve, type) {\\n  this.curve = curve;\\n  this.type = type;\\n  this.precomputed = null;\\n}\\nBaseCurve.BasePoint = BasePoint;\\n\\nBasePoint.prototype.eq = function eq(/*other*/) {\\n  throw new Error('Not implemented');\\n};\\n\\nBasePoint.prototype.validate = function validate() {\\n  return this.curve.validate(this);\\n};\\n\\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\\n  bytes = utils.toArray(bytes, enc);\\n\\n  var len = this.p.byteLength();\\n\\n  // uncompressed, hybrid-odd, hybrid-even\\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\\n      bytes.length - 1 === 2 * len) {\\n    if (bytes[0] === 0x06)\\n      assert(bytes[bytes.length - 1] % 2 === 0);\\n    else if (bytes[0] === 0x07)\\n      assert(bytes[bytes.length - 1] % 2 === 1);\\n\\n    var res =  this.point(bytes.slice(1, 1 + len),\\n      bytes.slice(1 + len, 1 + 2 * len));\\n\\n    return res;\\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\\n              bytes.length - 1 === len) {\\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\\n  }\\n  throw new Error('Unknown point format');\\n};\\n\\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\\n  return this.encode(enc, true);\\n};\\n\\nBasePoint.prototype._encode = function _encode(compact) {\\n  var len = this.curve.p.byteLength();\\n  var x = this.getX().toArray('be', len);\\n\\n  if (compact)\\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\\n\\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\\n};\\n\\nBasePoint.prototype.encode = function encode(enc, compact) {\\n  return utils.encode(this._encode(compact), enc);\\n};\\n\\nBasePoint.prototype.precompute = function precompute(power) {\\n  if (this.precomputed)\\n    return this;\\n\\n  var precomputed = {\\n    doubles: null,\\n    naf: null,\\n    beta: null,\\n  };\\n  precomputed.naf = this._getNAFPoints(8);\\n  precomputed.doubles = this._getDoubles(4, power);\\n  precomputed.beta = this._getBeta();\\n  this.precomputed = precomputed;\\n\\n  return this;\\n};\\n\\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\\n  if (!this.precomputed)\\n    return false;\\n\\n  var doubles = this.precomputed.doubles;\\n  if (!doubles)\\n    return false;\\n\\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\\n};\\n\\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\\n  if (this.precomputed && this.precomputed.doubles)\\n    return this.precomputed.doubles;\\n\\n  var doubles = [ this ];\\n  var acc = this;\\n  for (var i = 0; i < power; i += step) {\\n    for (var j = 0; j < step; j++)\\n      acc = acc.dbl();\\n    doubles.push(acc);\\n  }\\n  return {\\n    step: step,\\n    points: doubles,\\n  };\\n};\\n\\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\\n  if (this.precomputed && this.precomputed.naf)\\n    return this.precomputed.naf;\\n\\n  var res = [ this ];\\n  var max = (1 << wnd) - 1;\\n  var dbl = max === 1 ? null : this.dbl();\\n  for (var i = 1; i < max; i++)\\n    res[i] = res[i - 1].add(dbl);\\n  return {\\n    wnd: wnd,\\n    points: res,\\n  };\\n};\\n\\nBasePoint.prototype._getBeta = function _getBeta() {\\n  return null;\\n};\\n\\nBasePoint.prototype.dblp = function dblp(k) {\\n  var r = this;\\n  for (var i = 0; i < k; i++)\\n    r = r.dbl();\\n  return r;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"BaseCurve\",\"type\",\"conf\",\"p\",\"BN\",\"red\",\"prime\",\"mont\",\"zero\",\"toRed\",\"one\",\"two\",\"n\",\"g\",\"pointFromJSON\",\"gRed\",\"_wnafT1\",\"Array\",\"_wnafT2\",\"_wnafT3\",\"_wnafT4\",\"_bitLength\",\"bitLength\",\"adjustCount\",\"div\",\"cmpn\",\"redN\",\"_maxwellTrick\",\"BasePoint\",\"curve\",\"precomputed\",\"utils\",\"getNAF\",\"getJSF\",\"assert\",\"prototype\",\"point\",\"BaseCurve.prototype.point\",\"Error\",\"validate\",\"BaseCurve.prototype.validate\",\"_fixedNafMul\",\"BaseCurve.prototype._fixedNafMul\",\"k\",\"doubles\",\"_getDoubles\",\"naf\",\"I\",\"step\",\"repr\",\"j\",\"length\",\"nafW\",\"l\",\"push\",\"a\",\"jpoint\",\"b\",\"i\",\"mixedAdd\",\"points\",\"neg\",\"add\",\"toP\",\"_wnafMul\",\"BaseCurve.prototype._wnafMul\",\"nafPoints\",\"_getNAFPoints\",\"w\",\"wnd\",\"acc\",\"dblp\",\"z\",\"_wnafMulAdd\",\"BaseCurve.prototype._wnafMulAdd\",\"defW\",\"coeffs\",\"len\",\"jacobianResult\",\"wndWidth\",\"max\",\"Math\",\"comb\",\"y\",\"cmp\",\"toJ\",\"redNeg\",\"index\",\"jsf\",\"tmp\",\"eq\",\"BasePoint.prototype.eq\",\"BasePoint.prototype.validate\",\"decodePoint\",\"BaseCurve.prototype.decodePoint\",\"bytes\",\"enc\",\"toArray\",\"byteLength\",\"res\",\"slice\",\"pointFromX\",\"encodeCompressed\",\"BasePoint.prototype.encodeCompressed\",\"encode\",\"_encode\",\"BasePoint.prototype._encode\",\"compact\",\"x\",\"getX\",\"getY\",\"isEven\",\"concat\",\"BasePoint.prototype.encode\",\"precompute\",\"BasePoint.prototype.precompute\",\"power\",\"beta\",\"_getBeta\",\"_hasDoubles\",\"BasePoint.prototype._hasDoubles\",\"ceil\",\"BasePoint.prototype._getDoubles\",\"dbl\",\"BasePoint.prototype._getNAFPoints\",\"BasePoint.prototype._getBeta\",\"BasePoint.prototype.dblp\",\"r\"]\n}\n"]