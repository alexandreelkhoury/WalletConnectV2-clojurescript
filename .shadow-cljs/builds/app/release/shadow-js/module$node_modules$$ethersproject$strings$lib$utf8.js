["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/strings/lib/utf8.js"],"~:js","shadow$provide[41]=function(S,A,V,q){function F(h,k,t,B,E){if(h===l.BAD_PREFIX||h===l.UNEXPECTED_CONTINUE){h=0;for(k+=1;k<t.length&&2===t[k]>>6;k++)h++;return h}return h===l.OVERRUN?t.length-k-1:0}function G(h,k){null==k&&(k=q.Utf8ErrorFuncs.error);h=(0,u.arrayify)(h);for(var t=[],B=0;B<h.length;){var E=h[B++];if(0===E>>7)t.push(E);else{if(192===(E&224)){var H=1;var D=127}else if(224===(E&240))H=2,D=2047;else if(240===(E&248))H=3,D=65535;else{B=128===(E&192)?B+k(l.UNEXPECTED_CONTINUE,B-1,h,t):B+k(l.BAD_PREFIX,\nB-1,h,t);continue}if(B-1+H>=h.length)B+=k(l.OVERRUN,B-1,h,t);else{E&=(1<<8-H-1)-1;for(var C=0;C<H;C++){var I=h[B];if(128!=(I&192)){B+=k(l.MISSING_CONTINUE,B,h,t);E=null;break}E=E<<6|I&63;B++}null!==E&&(1114111<E?B+=k(l.OUT_OF_RANGE,B-1-H,h,t,E):55296<=E&&57343>=E?B+=k(l.UTF16_SURROGATE,B-1-H,h,t,E):E<=D?B+=k(l.OVERLONG,B-1-H,h,t,E):t.push(E))}}}return t}function r(h,k){void 0===k&&(k=n.current);k!=n.current&&(p.checkNormalize(),h=h.normalize(k));k=[];for(var t=0;t<h.length;t++){var B=h.charCodeAt(t);\nif(128>B)k.push(B);else if(2048>B)k.push(B>>6|192),k.push(B&63|128);else if(55296==(B&64512)){t++;var E=h.charCodeAt(t);if(t>=h.length||56320!==(E&64512))throw Error(\"invalid utf-8 string\");B=65536+((B&1023)<<10)+(E&1023);k.push(B>>18|240);k.push(B>>12&63|128);k.push(B>>6&63|128);k.push(B&63|128)}else k.push(B>>12|224),k.push(B>>6&63|128),k.push(B&63|128)}return(0,u.arrayify)(k)}function y(h){h=\"0000\"+h.toString(16);return\"\\\\u\"+h.substring(h.length-4)}function e(h){return h.map(function(k){if(65535>=\nk)return String.fromCharCode(k);k-=65536;return String.fromCharCode((k>>10&1023)+55296,(k&1023)+56320)}).join(\"\")}Object.defineProperty(q,\"__esModule\",{value:!0});q.toUtf8CodePoints=q.toUtf8String=q._toUtf8String=q._toEscapedUtf8String=q.toUtf8Bytes=q.Utf8ErrorFuncs=q.Utf8ErrorReason=q.UnicodeNormalizationForm=void 0;var u=A(11);S=A(9);A=A(40);var p=new S.Logger(A.version),n;(function(h){h.current=\"\";h.NFC=\"NFC\";h.NFD=\"NFD\";h.NFKC=\"NFKC\";h.NFKD=\"NFKD\"})(n=q.UnicodeNormalizationForm||(q.UnicodeNormalizationForm=\n{}));var l;(function(h){h.UNEXPECTED_CONTINUE=\"unexpected continuation byte\";h.BAD_PREFIX=\"bad codepoint prefix\";h.OVERRUN=\"string overrun\";h.MISSING_CONTINUE=\"missing continuation byte\";h.OUT_OF_RANGE=\"out of UTF-8 range\";h.UTF16_SURROGATE=\"UTF-16 surrogate\";h.OVERLONG=\"overlong representation\"})(l=q.Utf8ErrorReason||(q.Utf8ErrorReason={}));q.Utf8ErrorFuncs=Object.freeze({error:function(h,k,t,B,E){return p.throwArgumentError(\"invalid codepoint at offset \"+k+\"; \"+h,\"bytes\",t)},ignore:F,replace:function(h,\nk,t,B,E){if(h===l.OVERLONG)return B.push(E),0;B.push(65533);return F(h,k,t,B,E)}});q.toUtf8Bytes=r;q._toEscapedUtf8String=function(h,k){return'\"'+G(h,k).map(function(t){if(256>t){switch(t){case 8:return\"\\\\b\";case 9:return\"\\\\t\";case 10:return\"\\\\n\";case 13:return\"\\\\r\";case 34:return'\\\\\"';case 92:return\"\\\\\\\\\"}if(32<=t&&127>t)return String.fromCharCode(t)}if(65535>=t)return y(t);t-=65536;return y((t>>10&1023)+55296)+y((t&1023)+56320)}).join(\"\")+'\"'};q._toUtf8String=e;q.toUtf8String=function(h,k){return e(G(h,\nk))};q.toUtf8CodePoints=function(h,k){void 0===k&&(k=n.current);return G(r(h,k))}}","~:source","shadow$provide[41] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;\nvar bytes_1 = require(\"@ethersproject/bytes\");\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n;\nvar Utf8ErrorReason;\n(function (Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(\"invalid codepoint at offset \" + offset + \"; \" + reason, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        var i = 0;\n        for (var o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nexports.Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = exports.Utf8ErrorFuncs.error;\n    }\n    bytes = (0, bytes_1.arrayify)(bytes);\n    var result = [];\n    var i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        var c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        var extraLength = null;\n        var overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            }\n            else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        var res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (var j = 0; j < extraLength; j++) {\n            var nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form) {\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            var c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return (0, bytes_1.arrayify)(result);\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n;\nfunction escapeChar(value) {\n    var hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nfunction _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map(function (codePoint) {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8: return \"\\\\b\";\n                case 9: return \"\\\\t\";\n                case 10: return \"\\\\n\";\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nexports._toEscapedUtf8String = _toEscapedUtf8String;\nfunction _toUtf8String(codePoints) {\n    return codePoints.map(function (codePoint) {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\nexports._toUtf8String = _toUtf8String;\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nexports.toUtf8String = toUtf8String;\nfunction toUtf8CodePoints(str, form) {\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\nexports.toUtf8CodePoints = toUtf8CodePoints;\n//# sourceMappingURL=utf8.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$ethersproject$bytes$lib$index","~$module$node_modules$$ethersproject$logger$lib$index","~$module$node_modules$$ethersproject$strings$lib$_version"]],"~:properties",["^5",["ignore","_toEscapedUtf8String","_toUtf8String","__esModule","UnicodeNormalizationForm","error","toUtf8CodePoints","replace","value","Utf8ErrorReason","toUtf8Bytes","toUtf8String","Utf8ErrorFuncs"]],"~:compiled-at",1695041440695,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$strings$lib$utf8.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@ethersproject/strings/lib/utf8.js\"],\n\"sourcesContent\":[\"shadow$provide[41] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;\\nvar bytes_1 = require(\\\"@ethersproject/bytes\\\");\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"./_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\n///////////////////////////////\\nvar UnicodeNormalizationForm;\\n(function (UnicodeNormalizationForm) {\\n    UnicodeNormalizationForm[\\\"current\\\"] = \\\"\\\";\\n    UnicodeNormalizationForm[\\\"NFC\\\"] = \\\"NFC\\\";\\n    UnicodeNormalizationForm[\\\"NFD\\\"] = \\\"NFD\\\";\\n    UnicodeNormalizationForm[\\\"NFKC\\\"] = \\\"NFKC\\\";\\n    UnicodeNormalizationForm[\\\"NFKD\\\"] = \\\"NFKD\\\";\\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\\n;\\nvar Utf8ErrorReason;\\n(function (Utf8ErrorReason) {\\n    // A continuation byte was present where there was nothing to continue\\n    // - offset = the index the codepoint began in\\n    Utf8ErrorReason[\\\"UNEXPECTED_CONTINUE\\\"] = \\\"unexpected continuation byte\\\";\\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\\n    // - offset = the index the codepoint began in\\n    Utf8ErrorReason[\\\"BAD_PREFIX\\\"] = \\\"bad codepoint prefix\\\";\\n    // The string is too short to process the expected codepoint\\n    // - offset = the index the codepoint began in\\n    Utf8ErrorReason[\\\"OVERRUN\\\"] = \\\"string overrun\\\";\\n    // A missing continuation byte was expected but not found\\n    // - offset = the index the continuation byte was expected at\\n    Utf8ErrorReason[\\\"MISSING_CONTINUE\\\"] = \\\"missing continuation byte\\\";\\n    // The computed code point is outside the range for UTF-8\\n    // - offset       = start of this codepoint\\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\\n    Utf8ErrorReason[\\\"OUT_OF_RANGE\\\"] = \\\"out of UTF-8 range\\\";\\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\\n    // - offset       = start of this codepoint\\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\\n    Utf8ErrorReason[\\\"UTF16_SURROGATE\\\"] = \\\"UTF-16 surrogate\\\";\\n    // The string is an overlong representation\\n    // - offset       = start of this codepoint\\n    // - badCodepoint = the computed codepoint; already bounds checked\\n    Utf8ErrorReason[\\\"OVERLONG\\\"] = \\\"overlong representation\\\";\\n})(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));\\n;\\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\\n    return logger.throwArgumentError(\\\"invalid codepoint at offset \\\" + offset + \\\"; \\\" + reason, \\\"bytes\\\", bytes);\\n}\\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\\n        var i = 0;\\n        for (var o = offset + 1; o < bytes.length; o++) {\\n            if (bytes[o] >> 6 !== 0x02) {\\n                break;\\n            }\\n            i++;\\n        }\\n        return i;\\n    }\\n    // This byte runs us past the end of the string, so just jump to the end\\n    // (but the first byte was read already read and therefore skipped)\\n    if (reason === Utf8ErrorReason.OVERRUN) {\\n        return bytes.length - offset - 1;\\n    }\\n    // Nothing to skip\\n    return 0;\\n}\\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\\n    // Overlong representations are otherwise \\\"valid\\\" code points; just non-deistingtished\\n    if (reason === Utf8ErrorReason.OVERLONG) {\\n        output.push(badCodepoint);\\n        return 0;\\n    }\\n    // Put the replacement character into the output\\n    output.push(0xfffd);\\n    // Otherwise, process as if ignoring errors\\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\\n}\\n// Common error handing strategies\\nexports.Utf8ErrorFuncs = Object.freeze({\\n    error: errorFunc,\\n    ignore: ignoreFunc,\\n    replace: replaceFunc\\n});\\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\\nfunction getUtf8CodePoints(bytes, onError) {\\n    if (onError == null) {\\n        onError = exports.Utf8ErrorFuncs.error;\\n    }\\n    bytes = (0, bytes_1.arrayify)(bytes);\\n    var result = [];\\n    var i = 0;\\n    // Invalid bytes are ignored\\n    while (i < bytes.length) {\\n        var c = bytes[i++];\\n        // 0xxx xxxx\\n        if (c >> 7 === 0) {\\n            result.push(c);\\n            continue;\\n        }\\n        // Multibyte; how many bytes left for this character?\\n        var extraLength = null;\\n        var overlongMask = null;\\n        // 110x xxxx 10xx xxxx\\n        if ((c & 0xe0) === 0xc0) {\\n            extraLength = 1;\\n            overlongMask = 0x7f;\\n            // 1110 xxxx 10xx xxxx 10xx xxxx\\n        }\\n        else if ((c & 0xf0) === 0xe0) {\\n            extraLength = 2;\\n            overlongMask = 0x7ff;\\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\\n        }\\n        else if ((c & 0xf8) === 0xf0) {\\n            extraLength = 3;\\n            overlongMask = 0xffff;\\n        }\\n        else {\\n            if ((c & 0xc0) === 0x80) {\\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\\n            }\\n            else {\\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\\n            }\\n            continue;\\n        }\\n        // Do we have enough bytes in our data?\\n        if (i - 1 + extraLength >= bytes.length) {\\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\\n            continue;\\n        }\\n        // Remove the length prefix from the char\\n        var res = c & ((1 << (8 - extraLength - 1)) - 1);\\n        for (var j = 0; j < extraLength; j++) {\\n            var nextChar = bytes[i];\\n            // Invalid continuation byte\\n            if ((nextChar & 0xc0) != 0x80) {\\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\\n                res = null;\\n                break;\\n            }\\n            ;\\n            res = (res << 6) | (nextChar & 0x3f);\\n            i++;\\n        }\\n        // See above loop for invalid continuation byte\\n        if (res === null) {\\n            continue;\\n        }\\n        // Maximum code point\\n        if (res > 0x10ffff) {\\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\\n            continue;\\n        }\\n        // Reserved for UTF-16 surrogate halves\\n        if (res >= 0xd800 && res <= 0xdfff) {\\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\\n            continue;\\n        }\\n        // Check for overlong sequences (more bytes than needed)\\n        if (res <= overlongMask) {\\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\\n            continue;\\n        }\\n        result.push(res);\\n    }\\n    return result;\\n}\\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\\nfunction toUtf8Bytes(str, form) {\\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\\n    if (form != UnicodeNormalizationForm.current) {\\n        logger.checkNormalize();\\n        str = str.normalize(form);\\n    }\\n    var result = [];\\n    for (var i = 0; i < str.length; i++) {\\n        var c = str.charCodeAt(i);\\n        if (c < 0x80) {\\n            result.push(c);\\n        }\\n        else if (c < 0x800) {\\n            result.push((c >> 6) | 0xc0);\\n            result.push((c & 0x3f) | 0x80);\\n        }\\n        else if ((c & 0xfc00) == 0xd800) {\\n            i++;\\n            var c2 = str.charCodeAt(i);\\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\\n                throw new Error(\\\"invalid utf-8 string\\\");\\n            }\\n            // Surrogate Pair\\n            var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\\n            result.push((pair >> 18) | 0xf0);\\n            result.push(((pair >> 12) & 0x3f) | 0x80);\\n            result.push(((pair >> 6) & 0x3f) | 0x80);\\n            result.push((pair & 0x3f) | 0x80);\\n        }\\n        else {\\n            result.push((c >> 12) | 0xe0);\\n            result.push(((c >> 6) & 0x3f) | 0x80);\\n            result.push((c & 0x3f) | 0x80);\\n        }\\n    }\\n    return (0, bytes_1.arrayify)(result);\\n}\\nexports.toUtf8Bytes = toUtf8Bytes;\\n;\\nfunction escapeChar(value) {\\n    var hex = (\\\"0000\\\" + value.toString(16));\\n    return \\\"\\\\\\\\u\\\" + hex.substring(hex.length - 4);\\n}\\nfunction _toEscapedUtf8String(bytes, onError) {\\n    return '\\\"' + getUtf8CodePoints(bytes, onError).map(function (codePoint) {\\n        if (codePoint < 256) {\\n            switch (codePoint) {\\n                case 8: return \\\"\\\\\\\\b\\\";\\n                case 9: return \\\"\\\\\\\\t\\\";\\n                case 10: return \\\"\\\\\\\\n\\\";\\n                case 13: return \\\"\\\\\\\\r\\\";\\n                case 34: return \\\"\\\\\\\\\\\\\\\"\\\";\\n                case 92: return \\\"\\\\\\\\\\\\\\\\\\\";\\n            }\\n            if (codePoint >= 32 && codePoint < 127) {\\n                return String.fromCharCode(codePoint);\\n            }\\n        }\\n        if (codePoint <= 0xffff) {\\n            return escapeChar(codePoint);\\n        }\\n        codePoint -= 0x10000;\\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\\n    }).join(\\\"\\\") + '\\\"';\\n}\\nexports._toEscapedUtf8String = _toEscapedUtf8String;\\nfunction _toUtf8String(codePoints) {\\n    return codePoints.map(function (codePoint) {\\n        if (codePoint <= 0xffff) {\\n            return String.fromCharCode(codePoint);\\n        }\\n        codePoint -= 0x10000;\\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\\n    }).join(\\\"\\\");\\n}\\nexports._toUtf8String = _toUtf8String;\\nfunction toUtf8String(bytes, onError) {\\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\\n}\\nexports.toUtf8String = toUtf8String;\\nfunction toUtf8CodePoints(str, form) {\\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\\n}\\nexports.toUtf8CodePoints = toUtf8CodePoints;\\n//# sourceMappingURL=utf8.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"ignoreFunc\",\"reason\",\"offset\",\"bytes\",\"output\",\"badCodepoint\",\"Utf8ErrorReason\",\"BAD_PREFIX\",\"UNEXPECTED_CONTINUE\",\"i\",\"o\",\"length\",\"OVERRUN\",\"getUtf8CodePoints\",\"onError\",\"Utf8ErrorFuncs\",\"error\",\"bytes_1\",\"arrayify\",\"result\",\"c\",\"push\",\"extraLength\",\"overlongMask\",\"res\",\"j\",\"nextChar\",\"MISSING_CONTINUE\",\"OUT_OF_RANGE\",\"UTF16_SURROGATE\",\"OVERLONG\",\"toUtf8Bytes\",\"str\",\"form\",\"UnicodeNormalizationForm\",\"current\",\"logger\",\"checkNormalize\",\"normalize\",\"charCodeAt\",\"c2\",\"Error\",\"pair\",\"escapeChar\",\"value\",\"hex\",\"toString\",\"substring\",\"_toUtf8String\",\"codePoints\",\"map\",\"codePoint\",\"String\",\"fromCharCode\",\"join\",\"Object\",\"defineProperty\",\"toUtf8CodePoints\",\"toUtf8String\",\"_toEscapedUtf8String\",\"logger_1\",\"_version_1\",\"Logger\",\"version\",\"freeze\",\"errorFunc\",\"throwArgumentError\",\"ignore\",\"replace\",\"replaceFunc\"]\n}\n"]