["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/abi/lib/coders/array.js"],"~:js","shadow$provide[29]=function(S,A,V,q){function F(n,l,h){var k=null;if(Array.isArray(h))k=h;else if(h&&\"object\"===typeof h){var t={};k=l.map(function(D){var C=D.localName;C||e.throwError(\"cannot encode object for signature with missing names\",y.Logger.errors.INVALID_ARGUMENT,{argument:\"values\",coder:D,value:h});t[C]&&e.throwError(\"cannot encode object for signature with duplicate names\",y.Logger.errors.INVALID_ARGUMENT,{argument:\"values\",coder:D,value:h});t[C]=!0;return h[C]})}else e.throwArgumentError(\"invalid tuple value\",\n\"tuple\",h);l.length!==k.length&&e.throwArgumentError(\"types/value length mismatch\",\"tuple\",h);var B=new u.Writer(n.wordSize),E=new u.Writer(n.wordSize),H=[];l.forEach(function(D,C){C=k[C];if(D.dynamic){var I=E.length;D.encode(E,C);var M=B.writeUpdatableValue();H.push(function(P){M(P+I)})}else D.encode(B,C)});H.forEach(function(D){D(B.length)});l=n.appendWriter(B);return l+=n.appendWriter(E)}function G(n,l){var h=[],k=n.subReader(0);l.forEach(function(E){var H=null;if(E.dynamic){var D=n.readValue();\nD=k.subReader(D.toNumber());try{H=E.decode(D)}catch(C){if(C.code===y.Logger.errors.BUFFER_OVERRUN)throw C;H=C;H.baseType=E.name;H.name=E.localName;H.type=E.type}}else try{H=E.decode(n)}catch(C){if(C.code===y.Logger.errors.BUFFER_OVERRUN)throw C;H=C;H.baseType=E.name;H.name=E.localName;H.type=E.type}void 0!=H&&h.push(H)});var t=l.reduce(function(E,H){if(H=H.localName)E[H]||(E[H]=0),E[H]++;return E},{});l.forEach(function(E,H){if((E=E.localName)&&1===t[E]&&(\"length\"===E&&(E=\"_length\"),null==h[E])){var D=\nh[H];D instanceof Error?Object.defineProperty(h,E,{enumerable:!0,get:function(){throw D;}}):h[E]=D}});l=function(E){var H=h[E];H instanceof Error&&Object.defineProperty(h,E,{enumerable:!0,get:function(){throw H;}})};for(var B=0;B<h.length;B++)l(B);return Object.freeze(h)}var r=this&&this.__extends||function(){var n=function(l,h){n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(k,t){k.__proto__=t}||function(k,t){for(var B in t)Object.prototype.hasOwnProperty.call(t,B)&&(k[B]=t[B])};\nreturn n(l,h)};return function(l,h){function k(){this.constructor=l}if(\"function\"!==typeof h&&null!==h)throw new TypeError(\"Class extends value \"+String(h)+\" is not a constructor or null\");n(l,h);l.prototype=null===h?Object.create(h):(k.prototype=h.prototype,new k)}}();Object.defineProperty(q,\"__esModule\",{value:!0});q.ArrayCoder=q.unpack=q.pack=void 0;var y=A(9);S=A(18);var e=new y.Logger(S.version),u=A(20),p=A(28);q.pack=F;q.unpack=G;A=function(n){function l(h,k,t){t=n.call(this,\"array\",h.type+\n\"[\"+(0<=k?k:\"\")+\"]\",t,-1===k||h.dynamic)||this;t.coder=h;t.length=k;return t}r(l,n);l.prototype.defaultValue=function(){for(var h=this.coder.defaultValue(),k=[],t=0;t<this.length;t++)k.push(h);return k};l.prototype.encode=function(h,k){Array.isArray(k)||this._throwError(\"expected array value\",k);var t=this.length;-1===t&&(t=k.length,h.writeValue(k.length));e.checkArgumentCount(k.length,t,\"coder array\"+(this.localName?\" \"+this.localName:\"\"));t=[];for(var B=0;B<k.length;B++)t.push(this.coder);return F(h,\nt,k)};l.prototype.decode=function(h){var k=this.length;-1===k&&(k=h.readValue().toNumber(),32*k>h._data.length&&e.throwError(\"insufficient data length\",y.Logger.errors.BUFFER_OVERRUN,{length:h._data.length,count:k}));for(var t=[],B=0;B<k;B++)t.push(new p.AnonymousCoder(this.coder));return h.coerce(this.name,G(h,t))};return l}(u.Coder);q.ArrayCoder=A}","~:source","shadow$provide[29] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayCoder = exports.unpack = exports.pack = void 0;\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"../_version\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar abstract_coder_1 = require(\"./abstract-coder\");\nvar anonymous_1 = require(\"./anonymous\");\nfunction pack(writer, coders, values) {\n    var arrayValues = null;\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        var unique_1 = {};\n        arrayValues = coders.map(function (coder) {\n            var name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            if (unique_1[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            unique_1[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n    var staticWriter = new abstract_coder_1.Writer(writer.wordSize);\n    var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);\n    var updateFuncs = [];\n    coders.forEach(function (coder, index) {\n        var value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            var dynamicOffset_1 = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            var updateFunc_1 = staticWriter.writeUpdatableValue();\n            updateFuncs.push(function (baseOffset) {\n                updateFunc_1(baseOffset + dynamicOffset_1);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach(function (func) { func(staticWriter.length); });\n    var length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\nexports.pack = pack;\nfunction unpack(reader, coders) {\n    var values = [];\n    // A reader anchored to this base\n    var baseReader = reader.subReader(0);\n    coders.forEach(function (coder) {\n        var value = null;\n        if (coder.dynamic) {\n            var offset = reader.readValue();\n            var offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n    // We only output named properties for uniquely named coders\n    var uniqueNames = coders.reduce(function (accum, coder) {\n        var name = coder.localName;\n        if (name) {\n            if (!accum[name]) {\n                accum[name] = 0;\n            }\n            accum[name]++;\n        }\n        return accum;\n    }, {});\n    // Add any named parameters (i.e. tuples)\n    coders.forEach(function (coder, index) {\n        var name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) {\n            return;\n        }\n        if (name === \"length\") {\n            name = \"_length\";\n        }\n        if (values[name] != null) {\n            return;\n        }\n        var value = values[index];\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: function () { throw value; }\n            });\n        }\n        else {\n            values[name] = value;\n        }\n    });\n    var _loop_1 = function (i) {\n        var value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: function () { throw value; }\n            });\n        }\n    };\n    for (var i = 0; i < values.length; i++) {\n        _loop_1(i);\n    }\n    return Object.freeze(values);\n}\nexports.unpack = unpack;\nvar ArrayCoder = /** @class */ (function (_super) {\n    __extends(ArrayCoder, _super);\n    function ArrayCoder(coder, length, localName) {\n        var _this = this;\n        var type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        var dynamic = (length === -1 || coder.dynamic);\n        _this = _super.call(this, \"array\", type, localName, dynamic) || this;\n        _this.coder = coder;\n        _this.length = length;\n        return _this;\n    }\n    ArrayCoder.prototype.defaultValue = function () {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        var defaultChild = this.coder.defaultValue();\n        var result = [];\n        for (var i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    };\n    ArrayCoder.prototype.encode = function (writer, value) {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        var count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        var coders = [];\n        for (var i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    };\n    ArrayCoder.prototype.decode = function (reader) {\n        var count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", logger_1.Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        var coders = [];\n        for (var i = 0; i < count; i++) {\n            coders.push(new anonymous_1.AnonymousCoder(this.coder));\n        }\n        return reader.coerce(this.name, unpack(reader, coders));\n    };\n    return ArrayCoder;\n}(abstract_coder_1.Coder));\nexports.ArrayCoder = ArrayCoder;\n//# sourceMappingURL=array.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$ethersproject$abi$lib$coders$anonymous","~$shadow.js","~$module$node_modules$$ethersproject$abi$lib$coders$abstract_coder","~$module$node_modules$$ethersproject$logger$lib$index","~$module$node_modules$$ethersproject$abi$lib$_version"]],"~:properties",["^5",["prototype","pack","ArrayCoder","baseType","decode","__esModule","count","name","value","enumerable","coder","length","type","__proto__","argument","defaultValue","unpack","get","encode","constructor"]],"~:compiled-at",1695041440691,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$abi$lib$coders$array.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@ethersproject/abi/lib/coders/array.js\"],\n\"sourcesContent\":[\"shadow$provide[29] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        if (typeof b !== \\\"function\\\" && b !== null)\\n            throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.ArrayCoder = exports.unpack = exports.pack = void 0;\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"../_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\nvar abstract_coder_1 = require(\\\"./abstract-coder\\\");\\nvar anonymous_1 = require(\\\"./anonymous\\\");\\nfunction pack(writer, coders, values) {\\n    var arrayValues = null;\\n    if (Array.isArray(values)) {\\n        arrayValues = values;\\n    }\\n    else if (values && typeof (values) === \\\"object\\\") {\\n        var unique_1 = {};\\n        arrayValues = coders.map(function (coder) {\\n            var name = coder.localName;\\n            if (!name) {\\n                logger.throwError(\\\"cannot encode object for signature with missing names\\\", logger_1.Logger.errors.INVALID_ARGUMENT, {\\n                    argument: \\\"values\\\",\\n                    coder: coder,\\n                    value: values\\n                });\\n            }\\n            if (unique_1[name]) {\\n                logger.throwError(\\\"cannot encode object for signature with duplicate names\\\", logger_1.Logger.errors.INVALID_ARGUMENT, {\\n                    argument: \\\"values\\\",\\n                    coder: coder,\\n                    value: values\\n                });\\n            }\\n            unique_1[name] = true;\\n            return values[name];\\n        });\\n    }\\n    else {\\n        logger.throwArgumentError(\\\"invalid tuple value\\\", \\\"tuple\\\", values);\\n    }\\n    if (coders.length !== arrayValues.length) {\\n        logger.throwArgumentError(\\\"types/value length mismatch\\\", \\\"tuple\\\", values);\\n    }\\n    var staticWriter = new abstract_coder_1.Writer(writer.wordSize);\\n    var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);\\n    var updateFuncs = [];\\n    coders.forEach(function (coder, index) {\\n        var value = arrayValues[index];\\n        if (coder.dynamic) {\\n            // Get current dynamic offset (for the future pointer)\\n            var dynamicOffset_1 = dynamicWriter.length;\\n            // Encode the dynamic value into the dynamicWriter\\n            coder.encode(dynamicWriter, value);\\n            // Prepare to populate the correct offset once we are done\\n            var updateFunc_1 = staticWriter.writeUpdatableValue();\\n            updateFuncs.push(function (baseOffset) {\\n                updateFunc_1(baseOffset + dynamicOffset_1);\\n            });\\n        }\\n        else {\\n            coder.encode(staticWriter, value);\\n        }\\n    });\\n    // Backfill all the dynamic offsets, now that we know the static length\\n    updateFuncs.forEach(function (func) { func(staticWriter.length); });\\n    var length = writer.appendWriter(staticWriter);\\n    length += writer.appendWriter(dynamicWriter);\\n    return length;\\n}\\nexports.pack = pack;\\nfunction unpack(reader, coders) {\\n    var values = [];\\n    // A reader anchored to this base\\n    var baseReader = reader.subReader(0);\\n    coders.forEach(function (coder) {\\n        var value = null;\\n        if (coder.dynamic) {\\n            var offset = reader.readValue();\\n            var offsetReader = baseReader.subReader(offset.toNumber());\\n            try {\\n                value = coder.decode(offsetReader);\\n            }\\n            catch (error) {\\n                // Cannot recover from this\\n                if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {\\n                    throw error;\\n                }\\n                value = error;\\n                value.baseType = coder.name;\\n                value.name = coder.localName;\\n                value.type = coder.type;\\n            }\\n        }\\n        else {\\n            try {\\n                value = coder.decode(reader);\\n            }\\n            catch (error) {\\n                // Cannot recover from this\\n                if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {\\n                    throw error;\\n                }\\n                value = error;\\n                value.baseType = coder.name;\\n                value.name = coder.localName;\\n                value.type = coder.type;\\n            }\\n        }\\n        if (value != undefined) {\\n            values.push(value);\\n        }\\n    });\\n    // We only output named properties for uniquely named coders\\n    var uniqueNames = coders.reduce(function (accum, coder) {\\n        var name = coder.localName;\\n        if (name) {\\n            if (!accum[name]) {\\n                accum[name] = 0;\\n            }\\n            accum[name]++;\\n        }\\n        return accum;\\n    }, {});\\n    // Add any named parameters (i.e. tuples)\\n    coders.forEach(function (coder, index) {\\n        var name = coder.localName;\\n        if (!name || uniqueNames[name] !== 1) {\\n            return;\\n        }\\n        if (name === \\\"length\\\") {\\n            name = \\\"_length\\\";\\n        }\\n        if (values[name] != null) {\\n            return;\\n        }\\n        var value = values[index];\\n        if (value instanceof Error) {\\n            Object.defineProperty(values, name, {\\n                enumerable: true,\\n                get: function () { throw value; }\\n            });\\n        }\\n        else {\\n            values[name] = value;\\n        }\\n    });\\n    var _loop_1 = function (i) {\\n        var value = values[i];\\n        if (value instanceof Error) {\\n            Object.defineProperty(values, i, {\\n                enumerable: true,\\n                get: function () { throw value; }\\n            });\\n        }\\n    };\\n    for (var i = 0; i < values.length; i++) {\\n        _loop_1(i);\\n    }\\n    return Object.freeze(values);\\n}\\nexports.unpack = unpack;\\nvar ArrayCoder = /** @class */ (function (_super) {\\n    __extends(ArrayCoder, _super);\\n    function ArrayCoder(coder, length, localName) {\\n        var _this = this;\\n        var type = (coder.type + \\\"[\\\" + (length >= 0 ? length : \\\"\\\") + \\\"]\\\");\\n        var dynamic = (length === -1 || coder.dynamic);\\n        _this = _super.call(this, \\\"array\\\", type, localName, dynamic) || this;\\n        _this.coder = coder;\\n        _this.length = length;\\n        return _this;\\n    }\\n    ArrayCoder.prototype.defaultValue = function () {\\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\\n        var defaultChild = this.coder.defaultValue();\\n        var result = [];\\n        for (var i = 0; i < this.length; i++) {\\n            result.push(defaultChild);\\n        }\\n        return result;\\n    };\\n    ArrayCoder.prototype.encode = function (writer, value) {\\n        if (!Array.isArray(value)) {\\n            this._throwError(\\\"expected array value\\\", value);\\n        }\\n        var count = this.length;\\n        if (count === -1) {\\n            count = value.length;\\n            writer.writeValue(value.length);\\n        }\\n        logger.checkArgumentCount(value.length, count, \\\"coder array\\\" + (this.localName ? (\\\" \\\" + this.localName) : \\\"\\\"));\\n        var coders = [];\\n        for (var i = 0; i < value.length; i++) {\\n            coders.push(this.coder);\\n        }\\n        return pack(writer, coders, value);\\n    };\\n    ArrayCoder.prototype.decode = function (reader) {\\n        var count = this.length;\\n        if (count === -1) {\\n            count = reader.readValue().toNumber();\\n            // Check that there is *roughly* enough data to ensure\\n            // stray random data is not being read as a length. Each\\n            // slot requires at least 32 bytes for their value (or 32\\n            // bytes as a link to the data). This could use a much\\n            // tighter bound, but we are erroring on the side of safety.\\n            if (count * 32 > reader._data.length) {\\n                logger.throwError(\\\"insufficient data length\\\", logger_1.Logger.errors.BUFFER_OVERRUN, {\\n                    length: reader._data.length,\\n                    count: count\\n                });\\n            }\\n        }\\n        var coders = [];\\n        for (var i = 0; i < count; i++) {\\n            coders.push(new anonymous_1.AnonymousCoder(this.coder));\\n        }\\n        return reader.coerce(this.name, unpack(reader, coders));\\n    };\\n    return ArrayCoder;\\n}(abstract_coder_1.Coder));\\nexports.ArrayCoder = ArrayCoder;\\n//# sourceMappingURL=array.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"pack\",\"writer\",\"coders\",\"values\",\"arrayValues\",\"Array\",\"isArray\",\"unique_1\",\"map\",\"coder\",\"name\",\"localName\",\"logger\",\"throwError\",\"logger_1\",\"Logger\",\"errors\",\"INVALID_ARGUMENT\",\"argument\",\"value\",\"throwArgumentError\",\"length\",\"staticWriter\",\"abstract_coder_1\",\"Writer\",\"wordSize\",\"dynamicWriter\",\"updateFuncs\",\"forEach\",\"index\",\"dynamic\",\"dynamicOffset_1\",\"encode\",\"updateFunc_1\",\"writeUpdatableValue\",\"push\",\"baseOffset\",\"func\",\"appendWriter\",\"unpack\",\"reader\",\"baseReader\",\"subReader\",\"offset\",\"readValue\",\"offsetReader\",\"toNumber\",\"decode\",\"error\",\"code\",\"BUFFER_OVERRUN\",\"baseType\",\"type\",\"undefined\",\"uniqueNames\",\"reduce\",\"accum\",\"Error\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"_loop_1\",\"i\",\"freeze\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"setPrototypeOf\",\"__proto__\",\"p\",\"prototype\",\"hasOwnProperty\",\"call\",\"__\",\"constructor\",\"TypeError\",\"String\",\"create\",\"ArrayCoder\",\"_version_1\",\"version\",\"anonymous_1\",\"_super\",\"_this\",\"defaultValue\",\"ArrayCoder.prototype.defaultValue\",\"defaultChild\",\"result\",\"ArrayCoder.prototype.encode\",\"_throwError\",\"count\",\"writeValue\",\"checkArgumentCount\",\"ArrayCoder.prototype.decode\",\"_data\",\"AnonymousCoder\",\"coerce\",\"Coder\"]\n}\n"]