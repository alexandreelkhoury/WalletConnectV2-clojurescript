["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/browserify-zlib/lib/binding.js"],"~:js","shadow$provide[328]=function(S,A,V,q){function F(l){if(\"number\"!==typeof l||l<q.DEFLATE||l>q.UNZIP)throw new TypeError(\"Bad argument\");this.dictionary=null;this.flush=this.err=0;this.init_done=!1;this.memLevel=this.level=0;this.mode=l;this.windowBits=this.strategy=0;this.pending_close=this.write_in_progress=!1;this.gzip_id_bytes_read=0}var G=A(1),r=A(53).Buffer;\"use strict\";var y=A(316),e=A(317),u=A(323),p=A(326);S=A(327);for(var n in S)q[n]=S[n];q.NONE=0;q.DEFLATE=1;q.INFLATE=2;q.GZIP=3;q.GUNZIP=\n4;q.DEFLATERAW=5;q.INFLATERAW=6;q.UNZIP=7;F.prototype.close=function(){this.write_in_progress?this.pending_close=!0:(this.pending_close=!1,y(this.init_done,\"close before init\"),y(this.mode<=q.UNZIP),this.mode===q.DEFLATE||this.mode===q.GZIP||this.mode===q.DEFLATERAW?u.deflateEnd(this.strm):(this.mode===q.INFLATE||this.mode===q.GUNZIP||this.mode===q.INFLATERAW||this.mode===q.UNZIP)&&p.inflateEnd(this.strm),this.mode=q.NONE,this.dictionary=null)};F.prototype.write=function(l,h,k,t,B,E,H){return this._write(!0,\nl,h,k,t,B,E,H)};F.prototype.writeSync=function(l,h,k,t,B,E,H){return this._write(!1,l,h,k,t,B,E,H)};F.prototype._write=function(l,h,k,t,B,E,H,D){y.equal(arguments.length,8);y(this.init_done,\"write before init\");y(this.mode!==q.NONE,\"already finalized\");y.equal(!1,this.write_in_progress,\"write already in progress\");y.equal(!1,this.pending_close,\"close is pending\");this.write_in_progress=!0;y.equal(!1,void 0===h,\"must provide flush value\");this.write_in_progress=!0;if(h!==q.Z_NO_FLUSH&&h!==q.Z_PARTIAL_FLUSH&&\nh!==q.Z_SYNC_FLUSH&&h!==q.Z_FULL_FLUSH&&h!==q.Z_FINISH&&h!==q.Z_BLOCK)throw Error(\"Invalid flush value\");null==k&&(k=r.alloc(0),t=B=0);this.strm.avail_in=B;this.strm.input=k;this.strm.next_in=t;this.strm.avail_out=D;this.strm.output=E;this.strm.next_out=H;this.flush=h;if(l){var C=this;G.nextTick(function(){C._process();C._after()});return this}this._process();if(this._checkError())return this._afterSync()};F.prototype._afterSync=function(){var l=this.strm.avail_out,h=this.strm.avail_in;this.write_in_progress=\n!1;return[h,l]};F.prototype._process=function(){var l=null;switch(this.mode){case q.DEFLATE:case q.GZIP:case q.DEFLATERAW:this.err=u.deflate(this.strm,this.flush);break;case q.UNZIP:switch(0<this.strm.avail_in&&(l=this.strm.next_in),this.gzip_id_bytes_read){case 0:if(null===l)break;if(31===this.strm.input[l]){if(this.gzip_id_bytes_read=1,l++,1===this.strm.avail_in)break}else{this.mode=q.INFLATE;break}case 1:if(null===l)break;139===this.strm.input[l]?(this.gzip_id_bytes_read=2,this.mode=q.GUNZIP):\nthis.mode=q.INFLATE;break;default:throw Error(\"invalid number of gzip magic number bytes read\");}case q.INFLATE:case q.GUNZIP:case q.INFLATERAW:this.err=p.inflate(this.strm,this.flush);this.err===q.Z_NEED_DICT&&this.dictionary&&(this.err=p.inflateSetDictionary(this.strm,this.dictionary),this.err===q.Z_OK?this.err=p.inflate(this.strm,this.flush):this.err===q.Z_DATA_ERROR&&(this.err=q.Z_NEED_DICT));for(;0<this.strm.avail_in&&this.mode===q.GUNZIP&&this.err===q.Z_STREAM_END&&0!==this.strm.next_in[0];)this.reset(),\nthis.err=p.inflate(this.strm,this.flush);break;default:throw Error(\"Unknown mode \"+this.mode);}};F.prototype._checkError=function(){switch(this.err){case q.Z_OK:case q.Z_BUF_ERROR:if(0!==this.strm.avail_out&&this.flush===q.Z_FINISH)return this._error(\"unexpected end of file\"),!1;break;case q.Z_STREAM_END:break;case q.Z_NEED_DICT:return null==this.dictionary?this._error(\"Missing dictionary\"):this._error(\"Bad dictionary\"),!1;default:return this._error(\"Zlib error\"),!1}return!0};F.prototype._after=function(){if(this._checkError()){var l=\nthis.strm.avail_out,h=this.strm.avail_in;this.write_in_progress=!1;this.callback(h,l);this.pending_close&&this.close()}};F.prototype._error=function(l){this.strm.msg&&(l=this.strm.msg);this.onerror(l,this.err);this.write_in_progress=!1;this.pending_close&&this.close()};F.prototype.init=function(l,h,k,t,B){y(4===arguments.length||5===arguments.length,\"init(windowBits, level, memLevel, strategy, [dictionary])\");y(8<=l&&15>=l,\"invalid windowBits\");y(-1<=h&&9>=h,\"invalid compression level\");y(1<=k&&9>=\nk,\"invalid memlevel\");y(t===q.Z_FILTERED||t===q.Z_HUFFMAN_ONLY||t===q.Z_RLE||t===q.Z_FIXED||t===q.Z_DEFAULT_STRATEGY,\"invalid strategy\");this._init(h,l,k,t,B);this._setDictionary()};F.prototype.params=function(){throw Error(\"deflateParams Not supported\");};F.prototype.reset=function(){this._reset();this._setDictionary()};F.prototype._init=function(l,h,k,t,B){this.level=l;this.windowBits=h;this.memLevel=k;this.strategy=t;this.flush=q.Z_NO_FLUSH;this.err=q.Z_OK;if(this.mode===q.GZIP||this.mode===q.GUNZIP)this.windowBits+=\n16;this.mode===q.UNZIP&&(this.windowBits+=32);if(this.mode===q.DEFLATERAW||this.mode===q.INFLATERAW)this.windowBits*=-1;this.strm=new e;switch(this.mode){case q.DEFLATE:case q.GZIP:case q.DEFLATERAW:this.err=u.deflateInit2(this.strm,this.level,q.Z_DEFLATED,this.windowBits,this.memLevel,this.strategy);break;case q.INFLATE:case q.GUNZIP:case q.INFLATERAW:case q.UNZIP:this.err=p.inflateInit2(this.strm,this.windowBits);break;default:throw Error(\"Unknown mode \"+this.mode);}this.err!==q.Z_OK&&this._error(\"Init error\");\nthis.dictionary=B;this.write_in_progress=!1;this.init_done=!0};F.prototype._setDictionary=function(){if(null!=this.dictionary){this.err=q.Z_OK;switch(this.mode){case q.DEFLATE:case q.DEFLATERAW:this.err=u.deflateSetDictionary(this.strm,this.dictionary)}this.err!==q.Z_OK&&this._error(\"Failed to set dictionary\")}};F.prototype._reset=function(){this.err=q.Z_OK;switch(this.mode){case q.DEFLATE:case q.DEFLATERAW:case q.GZIP:this.err=u.deflateReset(this.strm);break;case q.INFLATE:case q.INFLATERAW:case q.GUNZIP:this.err=\np.inflateReset(this.strm)}this.err!==q.Z_OK&&this._error(\"Failed to reset stream\")};q.Zlib=F}","~:source","shadow$provide[328] = function(global,require,module,exports) {\nvar process = require('process');\nvar Buffer = require('buffer').Buffer;\n'use strict';\n/* eslint camelcase: \"off\" */\n\nvar assert = require('assert');\n\nvar Zstream = require('pako/lib/zlib/zstream');\nvar zlib_deflate = require('pako/lib/zlib/deflate.js');\nvar zlib_inflate = require('pako/lib/zlib/inflate.js');\nvar constants = require('pako/lib/zlib/constants');\n\nfor (var key in constants) {\n  exports[key] = constants[key];\n}\n\n// zlib modes\nexports.NONE = 0;\nexports.DEFLATE = 1;\nexports.INFLATE = 2;\nexports.GZIP = 3;\nexports.GUNZIP = 4;\nexports.DEFLATERAW = 5;\nexports.INFLATERAW = 6;\nexports.UNZIP = 7;\n\nvar GZIP_HEADER_ID1 = 0x1f;\nvar GZIP_HEADER_ID2 = 0x8b;\n\n/**\n * Emulate Node's zlib C++ layer for use by the JS layer in index.js\n */\nfunction Zlib(mode) {\n  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {\n    throw new TypeError('Bad argument');\n  }\n\n  this.dictionary = null;\n  this.err = 0;\n  this.flush = 0;\n  this.init_done = false;\n  this.level = 0;\n  this.memLevel = 0;\n  this.mode = mode;\n  this.strategy = 0;\n  this.windowBits = 0;\n  this.write_in_progress = false;\n  this.pending_close = false;\n  this.gzip_id_bytes_read = 0;\n}\n\nZlib.prototype.close = function () {\n  if (this.write_in_progress) {\n    this.pending_close = true;\n    return;\n  }\n\n  this.pending_close = false;\n\n  assert(this.init_done, 'close before init');\n  assert(this.mode <= exports.UNZIP);\n\n  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n    zlib_deflate.deflateEnd(this.strm);\n  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {\n    zlib_inflate.inflateEnd(this.strm);\n  }\n\n  this.mode = exports.NONE;\n\n  this.dictionary = null;\n};\n\nZlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {\n  assert.equal(arguments.length, 8);\n\n  assert(this.init_done, 'write before init');\n  assert(this.mode !== exports.NONE, 'already finalized');\n  assert.equal(false, this.write_in_progress, 'write already in progress');\n  assert.equal(false, this.pending_close, 'close is pending');\n\n  this.write_in_progress = true;\n\n  assert.equal(false, flush === undefined, 'must provide flush value');\n\n  this.write_in_progress = true;\n\n  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {\n    throw new Error('Invalid flush value');\n  }\n\n  if (input == null) {\n    input = Buffer.alloc(0);\n    in_len = 0;\n    in_off = 0;\n  }\n\n  this.strm.avail_in = in_len;\n  this.strm.input = input;\n  this.strm.next_in = in_off;\n  this.strm.avail_out = out_len;\n  this.strm.output = out;\n  this.strm.next_out = out_off;\n  this.flush = flush;\n\n  if (!async) {\n    // sync version\n    this._process();\n\n    if (this._checkError()) {\n      return this._afterSync();\n    }\n    return;\n  }\n\n  // async version\n  var self = this;\n  process.nextTick(function () {\n    self._process();\n    self._after();\n  });\n\n  return this;\n};\n\nZlib.prototype._afterSync = function () {\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n\n  this.write_in_progress = false;\n\n  return [avail_in, avail_out];\n};\n\nZlib.prototype._process = function () {\n  var next_expected_header_byte = null;\n\n  // If the avail_out is left at 0, then it means that it ran out\n  // of room.  If there was avail_out left over, then it means\n  // that all of the input was consumed.\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflate(this.strm, this.flush);\n      break;\n    case exports.UNZIP:\n      if (this.strm.avail_in > 0) {\n        next_expected_header_byte = this.strm.next_in;\n      }\n\n      switch (this.gzip_id_bytes_read) {\n        case 0:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n            this.gzip_id_bytes_read = 1;\n            next_expected_header_byte++;\n\n            if (this.strm.avail_in === 1) {\n              // The only available byte was already read.\n              break;\n            }\n          } else {\n            this.mode = exports.INFLATE;\n            break;\n          }\n\n        // fallthrough\n        case 1:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {\n            this.gzip_id_bytes_read = 2;\n            this.mode = exports.GUNZIP;\n          } else {\n            // There is no actual difference between INFLATE and INFLATERAW\n            // (after initialization).\n            this.mode = exports.INFLATE;\n          }\n\n          break;\n        default:\n          throw new Error('invalid number of gzip magic number bytes read');\n      }\n\n    // fallthrough\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n      this.err = zlib_inflate.inflate(this.strm, this.flush\n\n      // If data was encoded with dictionary\n      );if (this.err === exports.Z_NEED_DICT && this.dictionary) {\n        // Load it\n        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);\n        if (this.err === exports.Z_OK) {\n          // And try to decode again\n          this.err = zlib_inflate.inflate(this.strm, this.flush);\n        } else if (this.err === exports.Z_DATA_ERROR) {\n          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.\n          // Make it possible for After() to tell a bad dictionary from bad\n          // input.\n          this.err = exports.Z_NEED_DICT;\n        }\n      }\n      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {\n        // Bytes remain in input buffer. Perhaps this is another compressed\n        // member in the same archive, or just trailing garbage.\n        // Trailing zero bytes are okay, though, since they are frequently\n        // used for padding.\n\n        this.reset();\n        this.err = zlib_inflate.inflate(this.strm, this.flush);\n      }\n      break;\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n};\n\nZlib.prototype._checkError = function () {\n  // Acceptable error states depend on the type of zlib stream.\n  switch (this.err) {\n    case exports.Z_OK:\n    case exports.Z_BUF_ERROR:\n      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {\n        this._error('unexpected end of file');\n        return false;\n      }\n      break;\n    case exports.Z_STREAM_END:\n      // normal statuses, not fatal\n      break;\n    case exports.Z_NEED_DICT:\n      if (this.dictionary == null) {\n        this._error('Missing dictionary');\n      } else {\n        this._error('Bad dictionary');\n      }\n      return false;\n    default:\n      // something else.\n      this._error('Zlib error');\n      return false;\n  }\n\n  return true;\n};\n\nZlib.prototype._after = function () {\n  if (!this._checkError()) {\n    return;\n  }\n\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n\n  this.write_in_progress = false;\n\n  // call the write() cb\n  this.callback(avail_in, avail_out);\n\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\nZlib.prototype._error = function (message) {\n  if (this.strm.msg) {\n    message = this.strm.msg;\n  }\n  this.onerror(message, this.err\n\n  // no hope of rescue.\n  );this.write_in_progress = false;\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\nZlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\n  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');\n\n  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');\n  assert(level >= -1 && level <= 9, 'invalid compression level');\n\n  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');\n\n  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');\n\n  this._init(level, windowBits, memLevel, strategy, dictionary);\n  this._setDictionary();\n};\n\nZlib.prototype.params = function () {\n  throw new Error('deflateParams Not supported');\n};\n\nZlib.prototype.reset = function () {\n  this._reset();\n  this._setDictionary();\n};\n\nZlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {\n  this.level = level;\n  this.windowBits = windowBits;\n  this.memLevel = memLevel;\n  this.strategy = strategy;\n\n  this.flush = exports.Z_NO_FLUSH;\n\n  this.err = exports.Z_OK;\n\n  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {\n    this.windowBits += 16;\n  }\n\n  if (this.mode === exports.UNZIP) {\n    this.windowBits += 32;\n  }\n\n  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {\n    this.windowBits = -1 * this.windowBits;\n  }\n\n  this.strm = new Zstream();\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\n      break;\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n    case exports.UNZIP:\n      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n      break;\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Init error');\n  }\n\n  this.dictionary = dictionary;\n\n  this.write_in_progress = false;\n  this.init_done = true;\n};\n\nZlib.prototype._setDictionary = function () {\n  if (this.dictionary == null) {\n    return;\n  }\n\n  this.err = exports.Z_OK;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n      break;\n    default:\n      break;\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Failed to set dictionary');\n  }\n};\n\nZlib.prototype._reset = function () {\n  this.err = exports.Z_OK;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n    case exports.GZIP:\n      this.err = zlib_deflate.deflateReset(this.strm);\n      break;\n    case exports.INFLATE:\n    case exports.INFLATERAW:\n    case exports.GUNZIP:\n      this.err = zlib_inflate.inflateReset(this.strm);\n      break;\n    default:\n      break;\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Failed to reset stream');\n  }\n};\n\nexports.Zlib = Zlib;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$process$browser","~$shadow.js","~$module$node_modules$pako$lib$zlib$inflate","~$module$node_modules$assert$assert","~$module$node_modules$pako$lib$zlib$deflate","~$module$node_modules$pako$lib$zlib$zstream","~$module$node_modules$buffer$index","~$module$node_modules$pako$lib$zlib$constants"]],"~:properties",["^5",["INFLATERAW","Zlib","_after","gzip_id_bytes_read","output","pending_close","next_out","strategy","GUNZIP","params","memLevel","err","DEFLATE","avail_out","GZIP","UNZIP","avail_in","flush","strm","write_in_progress","reset","writeSync","init_done","_setDictionary","mode","level","_process","NONE","_checkError","_init","_write","_reset","_afterSync","input","close","init","DEFLATERAW","next_in","write","_error","dictionary","INFLATE","windowBits"]],"~:compiled-at",1695041440905,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$browserify_zlib$lib$binding.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/browserify-zlib/lib/binding.js\"],\n\"sourcesContent\":[\"shadow$provide[328] = function(global,require,module,exports) {\\nvar process = require('process');\\nvar Buffer = require('buffer').Buffer;\\n'use strict';\\n/* eslint camelcase: \\\"off\\\" */\\n\\nvar assert = require('assert');\\n\\nvar Zstream = require('pako/lib/zlib/zstream');\\nvar zlib_deflate = require('pako/lib/zlib/deflate.js');\\nvar zlib_inflate = require('pako/lib/zlib/inflate.js');\\nvar constants = require('pako/lib/zlib/constants');\\n\\nfor (var key in constants) {\\n  exports[key] = constants[key];\\n}\\n\\n// zlib modes\\nexports.NONE = 0;\\nexports.DEFLATE = 1;\\nexports.INFLATE = 2;\\nexports.GZIP = 3;\\nexports.GUNZIP = 4;\\nexports.DEFLATERAW = 5;\\nexports.INFLATERAW = 6;\\nexports.UNZIP = 7;\\n\\nvar GZIP_HEADER_ID1 = 0x1f;\\nvar GZIP_HEADER_ID2 = 0x8b;\\n\\n/**\\n * Emulate Node's zlib C++ layer for use by the JS layer in index.js\\n */\\nfunction Zlib(mode) {\\n  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {\\n    throw new TypeError('Bad argument');\\n  }\\n\\n  this.dictionary = null;\\n  this.err = 0;\\n  this.flush = 0;\\n  this.init_done = false;\\n  this.level = 0;\\n  this.memLevel = 0;\\n  this.mode = mode;\\n  this.strategy = 0;\\n  this.windowBits = 0;\\n  this.write_in_progress = false;\\n  this.pending_close = false;\\n  this.gzip_id_bytes_read = 0;\\n}\\n\\nZlib.prototype.close = function () {\\n  if (this.write_in_progress) {\\n    this.pending_close = true;\\n    return;\\n  }\\n\\n  this.pending_close = false;\\n\\n  assert(this.init_done, 'close before init');\\n  assert(this.mode <= exports.UNZIP);\\n\\n  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\\n    zlib_deflate.deflateEnd(this.strm);\\n  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {\\n    zlib_inflate.inflateEnd(this.strm);\\n  }\\n\\n  this.mode = exports.NONE;\\n\\n  this.dictionary = null;\\n};\\n\\nZlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\\n  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);\\n};\\n\\nZlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\\n  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);\\n};\\n\\nZlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {\\n  assert.equal(arguments.length, 8);\\n\\n  assert(this.init_done, 'write before init');\\n  assert(this.mode !== exports.NONE, 'already finalized');\\n  assert.equal(false, this.write_in_progress, 'write already in progress');\\n  assert.equal(false, this.pending_close, 'close is pending');\\n\\n  this.write_in_progress = true;\\n\\n  assert.equal(false, flush === undefined, 'must provide flush value');\\n\\n  this.write_in_progress = true;\\n\\n  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {\\n    throw new Error('Invalid flush value');\\n  }\\n\\n  if (input == null) {\\n    input = Buffer.alloc(0);\\n    in_len = 0;\\n    in_off = 0;\\n  }\\n\\n  this.strm.avail_in = in_len;\\n  this.strm.input = input;\\n  this.strm.next_in = in_off;\\n  this.strm.avail_out = out_len;\\n  this.strm.output = out;\\n  this.strm.next_out = out_off;\\n  this.flush = flush;\\n\\n  if (!async) {\\n    // sync version\\n    this._process();\\n\\n    if (this._checkError()) {\\n      return this._afterSync();\\n    }\\n    return;\\n  }\\n\\n  // async version\\n  var self = this;\\n  process.nextTick(function () {\\n    self._process();\\n    self._after();\\n  });\\n\\n  return this;\\n};\\n\\nZlib.prototype._afterSync = function () {\\n  var avail_out = this.strm.avail_out;\\n  var avail_in = this.strm.avail_in;\\n\\n  this.write_in_progress = false;\\n\\n  return [avail_in, avail_out];\\n};\\n\\nZlib.prototype._process = function () {\\n  var next_expected_header_byte = null;\\n\\n  // If the avail_out is left at 0, then it means that it ran out\\n  // of room.  If there was avail_out left over, then it means\\n  // that all of the input was consumed.\\n  switch (this.mode) {\\n    case exports.DEFLATE:\\n    case exports.GZIP:\\n    case exports.DEFLATERAW:\\n      this.err = zlib_deflate.deflate(this.strm, this.flush);\\n      break;\\n    case exports.UNZIP:\\n      if (this.strm.avail_in > 0) {\\n        next_expected_header_byte = this.strm.next_in;\\n      }\\n\\n      switch (this.gzip_id_bytes_read) {\\n        case 0:\\n          if (next_expected_header_byte === null) {\\n            break;\\n          }\\n\\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\\n            this.gzip_id_bytes_read = 1;\\n            next_expected_header_byte++;\\n\\n            if (this.strm.avail_in === 1) {\\n              // The only available byte was already read.\\n              break;\\n            }\\n          } else {\\n            this.mode = exports.INFLATE;\\n            break;\\n          }\\n\\n        // fallthrough\\n        case 1:\\n          if (next_expected_header_byte === null) {\\n            break;\\n          }\\n\\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {\\n            this.gzip_id_bytes_read = 2;\\n            this.mode = exports.GUNZIP;\\n          } else {\\n            // There is no actual difference between INFLATE and INFLATERAW\\n            // (after initialization).\\n            this.mode = exports.INFLATE;\\n          }\\n\\n          break;\\n        default:\\n          throw new Error('invalid number of gzip magic number bytes read');\\n      }\\n\\n    // fallthrough\\n    case exports.INFLATE:\\n    case exports.GUNZIP:\\n    case exports.INFLATERAW:\\n      this.err = zlib_inflate.inflate(this.strm, this.flush\\n\\n      // If data was encoded with dictionary\\n      );if (this.err === exports.Z_NEED_DICT && this.dictionary) {\\n        // Load it\\n        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);\\n        if (this.err === exports.Z_OK) {\\n          // And try to decode again\\n          this.err = zlib_inflate.inflate(this.strm, this.flush);\\n        } else if (this.err === exports.Z_DATA_ERROR) {\\n          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.\\n          // Make it possible for After() to tell a bad dictionary from bad\\n          // input.\\n          this.err = exports.Z_NEED_DICT;\\n        }\\n      }\\n      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {\\n        // Bytes remain in input buffer. Perhaps this is another compressed\\n        // member in the same archive, or just trailing garbage.\\n        // Trailing zero bytes are okay, though, since they are frequently\\n        // used for padding.\\n\\n        this.reset();\\n        this.err = zlib_inflate.inflate(this.strm, this.flush);\\n      }\\n      break;\\n    default:\\n      throw new Error('Unknown mode ' + this.mode);\\n  }\\n};\\n\\nZlib.prototype._checkError = function () {\\n  // Acceptable error states depend on the type of zlib stream.\\n  switch (this.err) {\\n    case exports.Z_OK:\\n    case exports.Z_BUF_ERROR:\\n      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {\\n        this._error('unexpected end of file');\\n        return false;\\n      }\\n      break;\\n    case exports.Z_STREAM_END:\\n      // normal statuses, not fatal\\n      break;\\n    case exports.Z_NEED_DICT:\\n      if (this.dictionary == null) {\\n        this._error('Missing dictionary');\\n      } else {\\n        this._error('Bad dictionary');\\n      }\\n      return false;\\n    default:\\n      // something else.\\n      this._error('Zlib error');\\n      return false;\\n  }\\n\\n  return true;\\n};\\n\\nZlib.prototype._after = function () {\\n  if (!this._checkError()) {\\n    return;\\n  }\\n\\n  var avail_out = this.strm.avail_out;\\n  var avail_in = this.strm.avail_in;\\n\\n  this.write_in_progress = false;\\n\\n  // call the write() cb\\n  this.callback(avail_in, avail_out);\\n\\n  if (this.pending_close) {\\n    this.close();\\n  }\\n};\\n\\nZlib.prototype._error = function (message) {\\n  if (this.strm.msg) {\\n    message = this.strm.msg;\\n  }\\n  this.onerror(message, this.err\\n\\n  // no hope of rescue.\\n  );this.write_in_progress = false;\\n  if (this.pending_close) {\\n    this.close();\\n  }\\n};\\n\\nZlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\\n  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');\\n\\n  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');\\n  assert(level >= -1 && level <= 9, 'invalid compression level');\\n\\n  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');\\n\\n  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');\\n\\n  this._init(level, windowBits, memLevel, strategy, dictionary);\\n  this._setDictionary();\\n};\\n\\nZlib.prototype.params = function () {\\n  throw new Error('deflateParams Not supported');\\n};\\n\\nZlib.prototype.reset = function () {\\n  this._reset();\\n  this._setDictionary();\\n};\\n\\nZlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {\\n  this.level = level;\\n  this.windowBits = windowBits;\\n  this.memLevel = memLevel;\\n  this.strategy = strategy;\\n\\n  this.flush = exports.Z_NO_FLUSH;\\n\\n  this.err = exports.Z_OK;\\n\\n  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {\\n    this.windowBits += 16;\\n  }\\n\\n  if (this.mode === exports.UNZIP) {\\n    this.windowBits += 32;\\n  }\\n\\n  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {\\n    this.windowBits = -1 * this.windowBits;\\n  }\\n\\n  this.strm = new Zstream();\\n\\n  switch (this.mode) {\\n    case exports.DEFLATE:\\n    case exports.GZIP:\\n    case exports.DEFLATERAW:\\n      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\\n      break;\\n    case exports.INFLATE:\\n    case exports.GUNZIP:\\n    case exports.INFLATERAW:\\n    case exports.UNZIP:\\n      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\\n      break;\\n    default:\\n      throw new Error('Unknown mode ' + this.mode);\\n  }\\n\\n  if (this.err !== exports.Z_OK) {\\n    this._error('Init error');\\n  }\\n\\n  this.dictionary = dictionary;\\n\\n  this.write_in_progress = false;\\n  this.init_done = true;\\n};\\n\\nZlib.prototype._setDictionary = function () {\\n  if (this.dictionary == null) {\\n    return;\\n  }\\n\\n  this.err = exports.Z_OK;\\n\\n  switch (this.mode) {\\n    case exports.DEFLATE:\\n    case exports.DEFLATERAW:\\n      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\\n      break;\\n    default:\\n      break;\\n  }\\n\\n  if (this.err !== exports.Z_OK) {\\n    this._error('Failed to set dictionary');\\n  }\\n};\\n\\nZlib.prototype._reset = function () {\\n  this.err = exports.Z_OK;\\n\\n  switch (this.mode) {\\n    case exports.DEFLATE:\\n    case exports.DEFLATERAW:\\n    case exports.GZIP:\\n      this.err = zlib_deflate.deflateReset(this.strm);\\n      break;\\n    case exports.INFLATE:\\n    case exports.INFLATERAW:\\n    case exports.GUNZIP:\\n      this.err = zlib_inflate.inflateReset(this.strm);\\n      break;\\n    default:\\n      break;\\n  }\\n\\n  if (this.err !== exports.Z_OK) {\\n    this._error('Failed to reset stream');\\n  }\\n};\\n\\nexports.Zlib = Zlib;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Zlib\",\"mode\",\"DEFLATE\",\"UNZIP\",\"TypeError\",\"dictionary\",\"flush\",\"err\",\"init_done\",\"memLevel\",\"level\",\"windowBits\",\"strategy\",\"pending_close\",\"write_in_progress\",\"gzip_id_bytes_read\",\"process\",\"Buffer\",\"assert\",\"Zstream\",\"zlib_deflate\",\"zlib_inflate\",\"constants\",\"key\",\"NONE\",\"INFLATE\",\"GZIP\",\"GUNZIP\",\"DEFLATERAW\",\"INFLATERAW\",\"prototype\",\"close\",\"Zlib.prototype.close\",\"deflateEnd\",\"strm\",\"inflateEnd\",\"write\",\"Zlib.prototype.write\",\"input\",\"in_off\",\"in_len\",\"out\",\"out_off\",\"out_len\",\"_write\",\"writeSync\",\"Zlib.prototype.writeSync\",\"Zlib.prototype._write\",\"async\",\"equal\",\"arguments\",\"length\",\"undefined\",\"Z_NO_FLUSH\",\"Z_PARTIAL_FLUSH\",\"Z_SYNC_FLUSH\",\"Z_FULL_FLUSH\",\"Z_FINISH\",\"Z_BLOCK\",\"Error\",\"alloc\",\"avail_in\",\"next_in\",\"avail_out\",\"output\",\"next_out\",\"self\",\"nextTick\",\"_process\",\"_after\",\"_checkError\",\"_afterSync\",\"Zlib.prototype._afterSync\",\"Zlib.prototype._process\",\"next_expected_header_byte\",\"deflate\",\"GZIP_HEADER_ID1\",\"GZIP_HEADER_ID2\",\"inflate\",\"Z_NEED_DICT\",\"inflateSetDictionary\",\"Z_OK\",\"Z_DATA_ERROR\",\"Z_STREAM_END\",\"reset\",\"Zlib.prototype._checkError\",\"Z_BUF_ERROR\",\"_error\",\"Zlib.prototype._after\",\"callback\",\"Zlib.prototype._error\",\"message\",\"msg\",\"onerror\",\"init\",\"Zlib.prototype.init\",\"Z_FILTERED\",\"Z_HUFFMAN_ONLY\",\"Z_RLE\",\"Z_FIXED\",\"Z_DEFAULT_STRATEGY\",\"_init\",\"_setDictionary\",\"params\",\"Zlib.prototype.params\",\"Zlib.prototype.reset\",\"_reset\",\"Zlib.prototype._init\",\"deflateInit2\",\"Z_DEFLATED\",\"inflateInit2\",\"Zlib.prototype._setDictionary\",\"deflateSetDictionary\",\"Zlib.prototype._reset\",\"deflateReset\",\"inflateReset\"]\n}\n"]