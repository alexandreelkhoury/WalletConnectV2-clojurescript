["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@noble/curves/abstract/modular.js"],"~:js","shadow$provide.module$node_modules$$noble$curves$abstract$modular=function(global,require,module,exports){function mod(a,b){a%=b;return a>=_0n?a:b+a}function pow(num,power,modulo){if(modulo<=_0n||power<_0n)throw Error(\"Expected power/modulo \\x3e 0\");if(modulo===_1n)return _0n;let res=_1n;for(;power>_0n;)power&_1n&&(res=res*num%modulo),num=num*num%modulo,power>>=_1n;return res}function invert(number,modulo){if(number===_0n||modulo<=_0n)throw Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\nnumber=mod(number,modulo);let b=modulo,x=_0n,u=_1n;for(;number!==_0n;){const r=b%number,m=x-b/number*u;b=number;number=r;x=u;u=m}if(b!==_1n)throw Error(\"invert: does not exist\");return mod(x,modulo)}function tonelliShanks(P){const legendreC=(P-_1n)/_2n;let Q,S,Z;Q=P-_1n;for(S=0;Q%_2n===_0n;Q/=_2n,S++);for(Z=_2n;Z<P&&pow(Z,legendreC,P)!==P-_1n;Z++);if(1===S){const p1div4=(P+_1n)/_4n;return function(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw Error(\"Cannot find square root\");\nreturn root}}const Q1div2=(Q+_1n)/_2n;return function(Fp,n){if(Fp.pow(n,legendreC)===Fp.neg(Fp.ONE))throw Error(\"Cannot find square root\");var r=S;let g=Fp.pow(Fp.mul(Fp.ONE,Z),Q),x=Fp.pow(n,Q1div2);for(n=Fp.pow(n,Q);!Fp.eql(n,Fp.ONE);){if(Fp.eql(n,Fp.ZERO))return Fp.ZERO;let m=1;for(let t2=Fp.sqr(n);m<r&&!Fp.eql(t2,Fp.ONE);m++)t2=Fp.sqr(t2);r=Fp.pow(g,_1n<<BigInt(r-m-1));g=Fp.sqr(r);x=Fp.mul(x,r);n=Fp.mul(n,g);r=m}return x}}function FpSqrt(P){if(P%_4n===_3n){const p1div4=(P+_1n)/_4n;return function(Fp,\nn){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw Error(\"Cannot find square root\");return root}}if(P%_8n===_5n){const c1=(P-_5n)/_8n;return function(Fp,n){var n2=Fp.mul(n,_2n),v=Fp.pow(n2,c1);n2=Fp.mul(n,v);v=Fp.mul(Fp.mul(n2,_2n),v);n2=Fp.mul(n2,Fp.sub(v,Fp.ONE));if(!Fp.eql(Fp.sqr(n2),n))throw Error(\"Cannot find square root\");return n2}}return tonelliShanks(P)}function FpPow(f,num,power){if(power<_0n)throw Error(\"Expected power \\x3e 0\");if(power===_0n)return f.ONE;if(power===_1n)return num;\nlet p=f.ONE;for(;power>_0n;)power&_1n&&(p=f.mul(p,num)),num=f.sqr(num),power>>=_1n;return p}function FpInvertBatch(f,nums){const tmp=Array(nums.length);var lastMultiplied=nums.reduce((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=acc;return f.mul(acc,num)},f.ONE);lastMultiplied=f.inv(lastMultiplied);nums.reduceRight((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=f.mul(acc,tmp[i]);return f.mul(acc,num)},lastMultiplied);return tmp}function nLength(n,nBitLength){n=void 0!==nBitLength?nBitLength:n.toString(2).length;\nreturn{nBitLength:n,nByteLength:Math.ceil(n/8)}}function getFieldBytesLength(fieldOrder){if(\"bigint\"!==typeof fieldOrder)throw Error(\"field order must be bigint\");fieldOrder=fieldOrder.toString(2).length;return Math.ceil(fieldOrder/8)}function getMinHashLength(fieldOrder){fieldOrder=getFieldBytesLength(fieldOrder);return fieldOrder+Math.ceil(fieldOrder/2)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.mapHashToField=exports.getMinHashLength=exports.getFieldBytesLength=exports.hashToPrivateScalar=\nexports.FpSqrtEven=exports.FpSqrtOdd=exports.Field=exports.nLength=exports.FpIsSquare=exports.FpDiv=exports.FpInvertBatch=exports.FpPow=exports.validateField=exports.isNegativeLE=exports.FpSqrt=exports.tonelliShanks=exports.invert=exports.pow2=exports.pow=exports.mod=void 0;const utils_js_1=require(\"module$node_modules$$noble$curves$abstract$utils\"),_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);exports.mod=mod;exports.pow=pow;exports.pow2=function(x,\npower,modulo){for(;power-- >_0n;)x*=x,x%=modulo;return x};exports.invert=invert;exports.tonelliShanks=tonelliShanks;exports.FpSqrt=FpSqrt;exports.isNegativeLE=(num,modulo)=>(mod(num,modulo)&_1n)===_1n;const FIELD_FIELDS=\"create isValid is0 neg inv sqrt sqr eql add sub mul pow div addN subN mulN sqrN\".split(\" \");exports.validateField=function(field){const opts=FIELD_FIELDS.reduce((map,val)=>{map[val]=\"function\";return map},{ORDER:\"bigint\",MASK:\"bigint\",BYTES:\"isSafeInteger\",BITS:\"isSafeInteger\"});\nreturn(0,utils_js_1.validateObject)(field,opts)};exports.FpPow=FpPow;exports.FpInvertBatch=FpInvertBatch;exports.FpDiv=function(f,lhs,rhs){return f.mul(lhs,\"bigint\"===typeof rhs?invert(rhs,f.ORDER):f.inv(rhs))};exports.FpIsSquare=function(f){const legendreConst=(f.ORDER-_1n)/_2n;return x=>{x=f.pow(x,legendreConst);return f.eql(x,f.ZERO)||f.eql(x,f.ONE)}};exports.nLength=nLength;exports.Field=function(ORDER,bitLen,isLE=!1,redef={}){if(ORDER<=_0n)throw Error(`Expected Field ORDER > 0, got ${ORDER}`);\nconst {nBitLength:BITS,nByteLength:BYTES}=nLength(ORDER,bitLen);if(2048<BYTES)throw Error(\"Field lengths over 2048 bytes are not supported\");const sqrtP=FpSqrt(ORDER),f=Object.freeze({ORDER,BITS,BYTES,MASK:(0,utils_js_1.bitMask)(BITS),ZERO:_0n,ONE:_1n,create:num=>mod(num,ORDER),isValid:num=>{if(\"bigint\"!==typeof num)throw Error(`Invalid field element: expected bigint, got ${typeof num}`);return _0n<=num&&num<ORDER},is0:num=>num===_0n,isOdd:num=>(num&_1n)===_1n,neg:num=>mod(-num,ORDER),eql:(lhs,rhs)=>\nlhs===rhs,sqr:num=>mod(num*num,ORDER),add:(lhs,rhs)=>mod(lhs+rhs,ORDER),sub:(lhs,rhs)=>mod(lhs-rhs,ORDER),mul:(lhs,rhs)=>mod(lhs*rhs,ORDER),pow:(num,power)=>FpPow(f,num,power),div:(lhs,rhs)=>mod(lhs*invert(rhs,ORDER),ORDER),sqrN:num=>num*num,addN:(lhs,rhs)=>lhs+rhs,subN:(lhs,rhs)=>lhs-rhs,mulN:(lhs,rhs)=>lhs*rhs,inv:num=>invert(num,ORDER),sqrt:redef.sqrt||(n=>sqrtP(f,n)),invertBatch:lst=>FpInvertBatch(f,lst),cmov:(a,b,c)=>c?b:a,toBytes:num=>isLE?(0,utils_js_1.numberToBytesLE)(num,BYTES):(0,utils_js_1.numberToBytesBE)(num,\nBYTES),fromBytes:bytes=>{if(bytes.length!==BYTES)throw Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);return isLE?(0,utils_js_1.bytesToNumberLE)(bytes):(0,utils_js_1.bytesToNumberBE)(bytes)}});return Object.freeze(f)};exports.FpSqrtOdd=function(Fp,elm){if(!Fp.isOdd)throw Error(\"Field doesn't have isOdd\");elm=Fp.sqrt(elm);return Fp.isOdd(elm)?elm:Fp.neg(elm)};exports.FpSqrtEven=function(Fp,elm){if(!Fp.isOdd)throw Error(\"Field doesn't have isOdd\");elm=Fp.sqrt(elm);return Fp.isOdd(elm)?\nFp.neg(elm):elm};exports.hashToPrivateScalar=function(hash,groupOrder,isLE=!1){hash=(0,utils_js_1.ensureBytes)(\"privateHash\",hash);const hashLen=hash.length,minLen=nLength(groupOrder).nByteLength+8;if(24>minLen||hashLen<minLen||1024<hashLen)throw Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);hash=isLE?(0,utils_js_1.bytesToNumberLE)(hash):(0,utils_js_1.bytesToNumberBE)(hash);return mod(hash,groupOrder-_1n)+_1n};exports.getFieldBytesLength=getFieldBytesLength;\nexports.getMinHashLength=getMinHashLength;exports.mapHashToField=function(key,fieldOrder,isLE=!1){const len=key.length,fieldLen=getFieldBytesLength(fieldOrder),minLen=getMinHashLength(fieldOrder);if(16>len||len<minLen||1024<len)throw Error(`expected ${minLen}-1024 bytes of input, got ${len}`);key=isLE?(0,utils_js_1.bytesToNumberBE)(key):(0,utils_js_1.bytesToNumberLE)(key);fieldOrder=mod(key,fieldOrder-_1n)+_1n;return isLE?(0,utils_js_1.numberToBytesLE)(fieldOrder,fieldLen):(0,utils_js_1.numberToBytesBE)(fieldOrder,\nfieldLen)}}","~:source","shadow$provide[\"module$node_modules$$noble$curves$abstract$modular\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nconst utils_js_1 = require(\"./utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nexports.mod = mod;\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\nexports.pow = pow;\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\nexports.pow2 = pow2;\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nexports.invert = invert;\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexports.tonelliShanks = tonelliShanks;\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\nexports.FpSqrt = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, utils_js_1.validateObject)(field, opts);\n}\nexports.validateField = validateField;\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\nexports.FpPow = FpPow;\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexports.FpInvertBatch = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nexports.FpDiv = FpDiv;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\nexports.FpIsSquare = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\nexports.nLength = nLength;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0, utils_js_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexports.Field = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexports.FpSqrtOdd = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\nexports.FpSqrtEven = FpSqrtEven;\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\nexports.hashToPrivateScalar = hashToPrivateScalar;\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\nexports.getFieldBytesLength = getFieldBytesLength;\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\nexports.getMinHashLength = getMinHashLength;\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\n}\nexports.mapHashToField = mapHashToField;\n//# sourceMappingURL=modular.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$noble$curves$abstract$utils"]],"~:properties",["^5",["fromBytes","mapHashToField","BITS","cmov","invert","sub","nLength","FpDiv","FpSqrt","mulN","__esModule","nBitLength","is0","pow","isOdd","pow2","value","isNegativeLE","inv","sqr","neg","FpPow","subN","sqrN","sqrt","FpInvertBatch","FpSqrtEven","eql","isValid","mod","mul","getMinHashLength","div","invertBatch","create","toBytes","add","ORDER","BYTES","validateField","Field","FpIsSquare","hashToPrivateScalar","tonelliShanks","FpSqrtOdd","getFieldBytesLength","addN","ZERO","ONE","nByteLength","MASK"]],"~:compiled-at",1695111490321,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$noble$curves$abstract$modular.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@noble/curves/abstract/modular.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$noble$curves$abstract$modular\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;\\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\\n// Utilities for modular arithmetics and finite fields\\nconst utils_js_1 = require(\\\"./utils.js\\\");\\n// prettier-ignore\\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\\n// prettier-ignore\\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\\n// prettier-ignore\\nconst _9n = BigInt(9), _16n = BigInt(16);\\n// Calculates a modulo b\\nfunction mod(a, b) {\\n    const result = a % b;\\n    return result >= _0n ? result : b + result;\\n}\\nexports.mod = mod;\\n/**\\n * Efficiently raise num to power and do modular division.\\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\\n * @example\\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\\n */\\n// TODO: use field version && remove\\nfunction pow(num, power, modulo) {\\n    if (modulo <= _0n || power < _0n)\\n        throw new Error('Expected power/modulo > 0');\\n    if (modulo === _1n)\\n        return _0n;\\n    let res = _1n;\\n    while (power > _0n) {\\n        if (power & _1n)\\n            res = (res * num) % modulo;\\n        num = (num * num) % modulo;\\n        power >>= _1n;\\n    }\\n    return res;\\n}\\nexports.pow = pow;\\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\\nfunction pow2(x, power, modulo) {\\n    let res = x;\\n    while (power-- > _0n) {\\n        res *= res;\\n        res %= modulo;\\n    }\\n    return res;\\n}\\nexports.pow2 = pow2;\\n// Inverses number over modulo\\nfunction invert(number, modulo) {\\n    if (number === _0n || modulo <= _0n) {\\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\\n    }\\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\\n    // Fermat's little theorem \\\"CT-like\\\" version inv(n) = n^(m-2) mod m is 30x slower.\\n    let a = mod(number, modulo);\\n    let b = modulo;\\n    // prettier-ignore\\n    let x = _0n, y = _1n, u = _1n, v = _0n;\\n    while (a !== _0n) {\\n        // JIT applies optimization if those two lines follow each other\\n        const q = b / a;\\n        const r = b % a;\\n        const m = x - u * q;\\n        const n = y - v * q;\\n        // prettier-ignore\\n        b = a, a = r, x = u, y = v, u = m, v = n;\\n    }\\n    const gcd = b;\\n    if (gcd !== _1n)\\n        throw new Error('invert: does not exist');\\n    return mod(x, modulo);\\n}\\nexports.invert = invert;\\n/**\\n * Tonelli-Shanks square root search algorithm.\\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\\n * Will start an infinite loop if field order P is not prime.\\n * @param P field order\\n * @returns function that takes field Fp (created from P) and number n\\n */\\nfunction tonelliShanks(P) {\\n    // Legendre constant: used to calculate Legendre symbol (a | p),\\n    // which denotes the value of a^((p-1)/2) (mod p).\\n    // (a | p) \\u2261 1    if a is a square (mod p)\\n    // (a | p) \\u2261 -1   if a is not a square (mod p)\\n    // (a | p) \\u2261 0    if a \\u2261 0 (mod p)\\n    const legendreC = (P - _1n) / _2n;\\n    let Q, S, Z;\\n    // Step 1: By factoring out powers of 2 from p - 1,\\n    // find q and s such that p - 1 = q*(2^s) with q odd\\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\\n        ;\\n    // Step 2: Select a non-square z such that (z | p) \\u2261 -1 and set c \\u2261 zq\\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\\n        ;\\n    // Fast-path\\n    if (S === 1) {\\n        const p1div4 = (P + _1n) / _4n;\\n        return function tonelliFast(Fp, n) {\\n            const root = Fp.pow(n, p1div4);\\n            if (!Fp.eql(Fp.sqr(root), n))\\n                throw new Error('Cannot find square root');\\n            return root;\\n        };\\n    }\\n    // Slow-path\\n    const Q1div2 = (Q + _1n) / _2n;\\n    return function tonelliSlow(Fp, n) {\\n        // Step 0: Check that n is indeed a square: (n | p) should not be \\u2261 -1\\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\\n            throw new Error('Cannot find square root');\\n        let r = S;\\n        // TODO: will fail at Fp2/etc\\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\\n        while (!Fp.eql(b, Fp.ONE)) {\\n            if (Fp.eql(b, Fp.ZERO))\\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\\n            // Find m such b^(2^m)==1\\n            let m = 1;\\n            for (let t2 = Fp.sqr(b); m < r; m++) {\\n                if (Fp.eql(t2, Fp.ONE))\\n                    break;\\n                t2 = Fp.sqr(t2); // t2 *= t2\\n            }\\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\\n            g = Fp.sqr(ge); // g = ge * ge\\n            x = Fp.mul(x, ge); // x *= ge\\n            b = Fp.mul(b, g); // b *= g\\n            r = m;\\n        }\\n        return x;\\n    };\\n}\\nexports.tonelliShanks = tonelliShanks;\\nfunction FpSqrt(P) {\\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\\n    // P \\u2261 3 (mod 4)\\n    // \\u221an = n^((P+1)/4)\\n    if (P % _4n === _3n) {\\n        // Not all roots possible!\\n        // const ORDER =\\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\\n        // const NUM = 72057594037927816n;\\n        const p1div4 = (P + _1n) / _4n;\\n        return function sqrt3mod4(Fp, n) {\\n            const root = Fp.pow(n, p1div4);\\n            // Throw if root**2 != n\\n            if (!Fp.eql(Fp.sqr(root), n))\\n                throw new Error('Cannot find square root');\\n            return root;\\n        };\\n    }\\n    // Atkin algorithm for q \\u2261 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\\n    if (P % _8n === _5n) {\\n        const c1 = (P - _5n) / _8n;\\n        return function sqrt5mod8(Fp, n) {\\n            const n2 = Fp.mul(n, _2n);\\n            const v = Fp.pow(n2, c1);\\n            const nv = Fp.mul(n, v);\\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\\n            if (!Fp.eql(Fp.sqr(root), n))\\n                throw new Error('Cannot find square root');\\n            return root;\\n        };\\n    }\\n    // P \\u2261 9 (mod 16)\\n    if (P % _16n === _9n) {\\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\\n        // Means we cannot use sqrt for constants at all!\\n        //\\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\\n        // sqrt = (x) => {\\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\\n        // }\\n    }\\n    // Other cases: Tonelli-Shanks algorithm\\n    return tonelliShanks(P);\\n}\\nexports.FpSqrt = FpSqrt;\\n// Little-endian check for first LE bit (last BE bit);\\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\\nexports.isNegativeLE = isNegativeLE;\\n// prettier-ignore\\nconst FIELD_FIELDS = [\\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\\n    'addN', 'subN', 'mulN', 'sqrN'\\n];\\nfunction validateField(field) {\\n    const initial = {\\n        ORDER: 'bigint',\\n        MASK: 'bigint',\\n        BYTES: 'isSafeInteger',\\n        BITS: 'isSafeInteger',\\n    };\\n    const opts = FIELD_FIELDS.reduce((map, val) => {\\n        map[val] = 'function';\\n        return map;\\n    }, initial);\\n    return (0, utils_js_1.validateObject)(field, opts);\\n}\\nexports.validateField = validateField;\\n// Generic field functions\\n/**\\n * Same as `pow` but for Fp: non-constant-time.\\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\\n */\\nfunction FpPow(f, num, power) {\\n    // Should have same speed as pow for bigints\\n    // TODO: benchmark!\\n    if (power < _0n)\\n        throw new Error('Expected power > 0');\\n    if (power === _0n)\\n        return f.ONE;\\n    if (power === _1n)\\n        return num;\\n    let p = f.ONE;\\n    let d = num;\\n    while (power > _0n) {\\n        if (power & _1n)\\n            p = f.mul(p, d);\\n        d = f.sqr(d);\\n        power >>= _1n;\\n    }\\n    return p;\\n}\\nexports.FpPow = FpPow;\\n/**\\n * Efficiently invert an array of Field elements.\\n * `inv(0)` will return `undefined` here: make sure to throw an error.\\n */\\nfunction FpInvertBatch(f, nums) {\\n    const tmp = new Array(nums.length);\\n    // Walk from first to last, multiply them by each other MOD p\\n    const lastMultiplied = nums.reduce((acc, num, i) => {\\n        if (f.is0(num))\\n            return acc;\\n        tmp[i] = acc;\\n        return f.mul(acc, num);\\n    }, f.ONE);\\n    // Invert last element\\n    const inverted = f.inv(lastMultiplied);\\n    // Walk from last to first, multiply them by inverted each other MOD p\\n    nums.reduceRight((acc, num, i) => {\\n        if (f.is0(num))\\n            return acc;\\n        tmp[i] = f.mul(acc, tmp[i]);\\n        return f.mul(acc, num);\\n    }, inverted);\\n    return tmp;\\n}\\nexports.FpInvertBatch = FpInvertBatch;\\nfunction FpDiv(f, lhs, rhs) {\\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\\n}\\nexports.FpDiv = FpDiv;\\n// This function returns True whenever the value x is a square in the field F.\\nfunction FpIsSquare(f) {\\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\\n    return (x) => {\\n        const p = f.pow(x, legendreConst);\\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\\n    };\\n}\\nexports.FpIsSquare = FpIsSquare;\\n// CURVE.n lengths\\nfunction nLength(n, nBitLength) {\\n    // Bit size, byte size of CURVE.n\\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\\n    const nByteLength = Math.ceil(_nBitLength / 8);\\n    return { nBitLength: _nBitLength, nByteLength };\\n}\\nexports.nLength = nLength;\\n/**\\n * Initializes a finite field over prime. **Non-primes are not supported.**\\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\\n * Major performance optimizations:\\n * * a) denormalized operations like mulN instead of mul\\n * * b) same object shape: never add or remove keys\\n * * c) Object.freeze\\n * @param ORDER prime positive bigint\\n * @param bitLen how many bits the field consumes\\n * @param isLE (def: false) if encoding / decoding should be in little-endian\\n * @param redef optional faster redefinitions of sqrt and other methods\\n */\\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\\n    if (ORDER <= _0n)\\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\\n    if (BYTES > 2048)\\n        throw new Error('Field lengths over 2048 bytes are not supported');\\n    const sqrtP = FpSqrt(ORDER);\\n    const f = Object.freeze({\\n        ORDER,\\n        BITS,\\n        BYTES,\\n        MASK: (0, utils_js_1.bitMask)(BITS),\\n        ZERO: _0n,\\n        ONE: _1n,\\n        create: (num) => mod(num, ORDER),\\n        isValid: (num) => {\\n            if (typeof num !== 'bigint')\\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\\n        },\\n        is0: (num) => num === _0n,\\n        isOdd: (num) => (num & _1n) === _1n,\\n        neg: (num) => mod(-num, ORDER),\\n        eql: (lhs, rhs) => lhs === rhs,\\n        sqr: (num) => mod(num * num, ORDER),\\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\\n        pow: (num, power) => FpPow(f, num, power),\\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\\n        // Same as above, but doesn't normalize\\n        sqrN: (num) => num * num,\\n        addN: (lhs, rhs) => lhs + rhs,\\n        subN: (lhs, rhs) => lhs - rhs,\\n        mulN: (lhs, rhs) => lhs * rhs,\\n        inv: (num) => invert(num, ORDER),\\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\\n        invertBatch: (lst) => FpInvertBatch(f, lst),\\n        // TODO: do we really need constant cmov?\\n        // We don't have const-time bigints anyway, so probably will be not very useful\\n        cmov: (a, b, c) => (c ? b : a),\\n        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),\\n        fromBytes: (bytes) => {\\n            if (bytes.length !== BYTES)\\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\\n        },\\n    });\\n    return Object.freeze(f);\\n}\\nexports.Field = Field;\\nfunction FpSqrtOdd(Fp, elm) {\\n    if (!Fp.isOdd)\\n        throw new Error(`Field doesn't have isOdd`);\\n    const root = Fp.sqrt(elm);\\n    return Fp.isOdd(root) ? root : Fp.neg(root);\\n}\\nexports.FpSqrtOdd = FpSqrtOdd;\\nfunction FpSqrtEven(Fp, elm) {\\n    if (!Fp.isOdd)\\n        throw new Error(`Field doesn't have isOdd`);\\n    const root = Fp.sqrt(elm);\\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\\n}\\nexports.FpSqrtEven = FpSqrtEven;\\n/**\\n * \\\"Constant-time\\\" private key generation utility.\\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\\n * Which makes it slightly more biased, less secure.\\n * @deprecated use mapKeyToField instead\\n */\\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\\n    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);\\n    const hashLen = hash.length;\\n    const minLen = nLength(groupOrder).nByteLength + 8;\\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\\n    return mod(num, groupOrder - _1n) + _1n;\\n}\\nexports.hashToPrivateScalar = hashToPrivateScalar;\\n/**\\n * Returns total number of bytes consumed by the field element.\\n * For example, 32 bytes for usual 256-bit weierstrass curve.\\n * @param fieldOrder number of field elements, usually CURVE.n\\n * @returns byte length of field\\n */\\nfunction getFieldBytesLength(fieldOrder) {\\n    if (typeof fieldOrder !== 'bigint')\\n        throw new Error('field order must be bigint');\\n    const bitLength = fieldOrder.toString(2).length;\\n    return Math.ceil(bitLength / 8);\\n}\\nexports.getFieldBytesLength = getFieldBytesLength;\\n/**\\n * Returns minimal amount of bytes that can be safely reduced\\n * by field order.\\n * Should be 2^-128 for 128-bit curve such as P256.\\n * @param fieldOrder number of field elements, usually CURVE.n\\n * @returns byte length of target hash\\n */\\nfunction getMinHashLength(fieldOrder) {\\n    const length = getFieldBytesLength(fieldOrder);\\n    return length + Math.ceil(length / 2);\\n}\\nexports.getMinHashLength = getMinHashLength;\\n/**\\n * \\\"Constant-time\\\" private key generation utility.\\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\\n * and convert them into private scalar, with the modulo bias being negligible.\\n * Needs at least 48 bytes of input for 32-byte private key.\\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\\n * @param hash hash output from SHA3 or a similar function\\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\\n * @param isLE interpret hash bytes as LE num\\n * @returns valid private scalar\\n */\\nfunction mapHashToField(key, fieldOrder, isLE = false) {\\n    const len = key.length;\\n    const fieldLen = getFieldBytesLength(fieldOrder);\\n    const minLen = getMinHashLength(fieldOrder);\\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\\n    if (len < 16 || len < minLen || len > 1024)\\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\\n    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);\\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\\n    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\\n}\\nexports.mapHashToField = mapHashToField;\\n//# sourceMappingURL=modular.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"mod\",\"a\",\"b\",\"result\",\"_0n\",\"pow\",\"num\",\"power\",\"modulo\",\"Error\",\"_1n\",\"res\",\"invert\",\"number\",\"x\",\"u\",\"r\",\"m\",\"tonelliShanks\",\"P\",\"legendreC\",\"_2n\",\"Q\",\"S\",\"Z\",\"p1div4\",\"_4n\",\"tonelliFast\",\"Fp\",\"n\",\"root\",\"eql\",\"sqr\",\"Q1div2\",\"tonelliSlow\",\"neg\",\"ONE\",\"g\",\"mul\",\"ZERO\",\"t2\",\"ge\",\"BigInt\",\"FpSqrt\",\"_3n\",\"sqrt3mod4\",\"_8n\",\"_5n\",\"c1\",\"sqrt5mod8\",\"n2\",\"v\",\"nv\",\"i\",\"sub\",\"FpPow\",\"f\",\"p\",\"d\",\"FpInvertBatch\",\"nums\",\"tmp\",\"Array\",\"length\",\"lastMultiplied\",\"reduce\",\"acc\",\"is0\",\"inverted\",\"inv\",\"reduceRight\",\"nLength\",\"nBitLength\",\"_nBitLength\",\"undefined\",\"toString\",\"nByteLength\",\"Math\",\"ceil\",\"getFieldBytesLength\",\"fieldOrder\",\"bitLength\",\"getMinHashLength\",\"Object\",\"defineProperty\",\"value\",\"mapHashToField\",\"hashToPrivateScalar\",\"FpSqrtEven\",\"FpSqrtOdd\",\"Field\",\"FpIsSquare\",\"FpDiv\",\"validateField\",\"isNegativeLE\",\"pow2\",\"utils_js_1\",\"FIELD_FIELDS\",\"field\",\"opts\",\"map\",\"val\",\"initial\",\"ORDER\",\"MASK\",\"BYTES\",\"BITS\",\"validateObject\",\"lhs\",\"rhs\",\"legendreConst\",\"bitLen\",\"isLE\",\"redef\",\"sqrtP\",\"freeze\",\"bitMask\",\"create\",\"isValid\",\"isOdd\",\"add\",\"div\",\"sqrN\",\"addN\",\"subN\",\"mulN\",\"sqrt\",\"invertBatch\",\"lst\",\"cmov\",\"c\",\"toBytes\",\"numberToBytesLE\",\"numberToBytesBE\",\"fromBytes\",\"bytes\",\"bytesToNumberLE\",\"bytesToNumberBE\",\"elm\",\"hash\",\"groupOrder\",\"ensureBytes\",\"hashLen\",\"minLen\",\"key\",\"len\",\"fieldLen\",\"reduced\"]\n}\n"]