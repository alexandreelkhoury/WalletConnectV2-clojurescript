["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@noble/hashes/utils.js"],"~:js","shadow$provide.module$node_modules$$noble$hashes$utils=function(global,require,module,exports){function utf8ToBytes(str){if(\"string\"!==typeof str)throw Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){\"string\"===typeof data&&(data=utf8ToBytes(data));if(!(data instanceof Uint8Array))throw Error(`expected Uint8Array, got ${typeof data}`);return data}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.randomBytes=\nexports.wrapXOFConstructorWithOpts=exports.wrapConstructorWithOpts=exports.wrapConstructor=exports.checkOpts=exports.Hash=exports.concatBytes=exports.toBytes=exports.utf8ToBytes=exports.asyncLoop=exports.nextTick=exports.hexToBytes=exports.bytesToHex=exports.isLE=exports.rotr=exports.createView=exports.u32=exports.u8=void 0;const crypto_1=require(\"module$node_modules$$noble$hashes$crypto\");exports.u8=arr=>new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength);exports.u32=arr=>new Uint32Array(arr.buffer,\narr.byteOffset,Math.floor(arr.byteLength/4));exports.createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);exports.rotr=(word,shift)=>word<<32-shift|word>>>shift;exports.isLE=68===(new Uint8Array((new Uint32Array([287454020])).buffer))[0];if(!exports.isLE)throw Error(\"Non little-endian hardware is not supported\");const hexes=Array.from({length:256},(_,i)=>i.toString(16).padStart(2,\"0\"));exports.bytesToHex=function(bytes){if(!(bytes instanceof Uint8Array))throw Error(\"Uint8Array expected\");\nlet hex=\"\";for(let i=0;i<bytes.length;i++)hex+=hexes[bytes[i]];return hex};exports.hexToBytes=function(hex){if(\"string\"!==typeof hex)throw Error(\"hex string expected, got \"+typeof hex);var len=hex.length;if(len%2)throw Error(\"padded hex string expected, got unpadded hex of length \"+len);len=new Uint8Array(len/2);for(let i=0;i<len.length;i++){var j=2*i;j=hex.slice(j,j+2);j=Number.parseInt(j,16);if(Number.isNaN(j)||0>j)throw Error(\"Invalid byte sequence\");len[i]=j}return len};exports.nextTick=async()=>\n{};exports.asyncLoop=async function(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;0<=diff&&diff<tick||(await (0,exports.nextTick)(),ts+=diff)}};exports.utf8ToBytes=utf8ToBytes;exports.toBytes=toBytes;exports.concatBytes=function(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!(a instanceof Uint8Array))throw Error(\"Uint8Array expected\");r.set(a,pad);pad+=a.length});return r};class Hash{clone(){return this._cloneInto()}}\nexports.Hash=Hash;const toStr={}.toString;exports.checkOpts=function(defaults,opts){if(void 0!==opts&&\"[object Object]\"!==toStr.call(opts))throw Error(\"Options should be object or undefined\");return Object.assign(defaults,opts)};exports.wrapConstructor=function(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=()=>hashCons();return hashC};exports.wrapConstructorWithOpts=function(hashCons){const hashC=\n(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=opts=>hashCons(opts);return hashC};exports.wrapXOFConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=opts=>hashCons(opts);return hashC};exports.randomBytes=function(bytesLength=32){if(crypto_1.crypto&&\"function\"===\ntypeof crypto_1.crypto.getRandomValues)return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));throw Error(\"crypto.getRandomValues must be defined\");}}","~:source","shadow$provide[\"module$node_modules$$noble$hashes$utils\"] = function(global,require,module,exports) {\n\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$noble$hashes$crypto"]],"~:properties",["^5",["createView","outputLen","__esModule","bytesToHex","hexToBytes","Hash","u32","u8","asyncLoop","wrapConstructorWithOpts","value","length","rotr","wrapXOFConstructorWithOpts","concatBytes","nextTick","create","toBytes","checkOpts","blockLen","wrapConstructor","randomBytes","utf8ToBytes","isLE"]],"~:compiled-at",1695111490228,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$noble$hashes$utils.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@noble/hashes/utils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$noble$hashes$utils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\\n// node.js versions earlier than v19 don't declare it in global scope.\\n// For node.js, package.json#exports field mapping rewrites import\\n// from `crypto` to `cryptoNode`, which imports native module.\\n// Makes the utils un-importable in browsers without a bundler.\\n// Once node.js 18 is deprecated, we can just drop the import.\\nconst crypto_1 = require(\\\"@noble/hashes/crypto\\\");\\nconst u8a = (a) => a instanceof Uint8Array;\\n// Cast array to different type\\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\\nexports.u8 = u8;\\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\\nexports.u32 = u32;\\n// Cast array to view\\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\\nexports.createView = createView;\\n// The rotate right (circular right shift) operation for uint32\\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\\nexports.rotr = rotr;\\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\\n// early-throw an error because we don't support BE yet.\\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\\nif (!exports.isLE)\\n    throw new Error('Non little-endian hardware is not supported');\\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\\n/**\\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\\n */\\nfunction bytesToHex(bytes) {\\n    if (!u8a(bytes))\\n        throw new Error('Uint8Array expected');\\n    // pre-caching improves the speed 6x\\n    let hex = '';\\n    for (let i = 0; i < bytes.length; i++) {\\n        hex += hexes[bytes[i]];\\n    }\\n    return hex;\\n}\\nexports.bytesToHex = bytesToHex;\\n/**\\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\\n */\\nfunction hexToBytes(hex) {\\n    if (typeof hex !== 'string')\\n        throw new Error('hex string expected, got ' + typeof hex);\\n    const len = hex.length;\\n    if (len % 2)\\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\\n    const array = new Uint8Array(len / 2);\\n    for (let i = 0; i < array.length; i++) {\\n        const j = i * 2;\\n        const hexByte = hex.slice(j, j + 2);\\n        const byte = Number.parseInt(hexByte, 16);\\n        if (Number.isNaN(byte) || byte < 0)\\n            throw new Error('Invalid byte sequence');\\n        array[i] = byte;\\n    }\\n    return array;\\n}\\nexports.hexToBytes = hexToBytes;\\n// There is no setImmediate in browser and setTimeout is slow.\\n// call of async fn will return Promise, which will be fullfiled only on\\n// next scheduler queue processing step and this is exactly what we need.\\nconst nextTick = async () => { };\\nexports.nextTick = nextTick;\\n// Returns control to thread each 'tick' ms to avoid blocking\\nasync function asyncLoop(iters, tick, cb) {\\n    let ts = Date.now();\\n    for (let i = 0; i < iters; i++) {\\n        cb(i);\\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\\n        const diff = Date.now() - ts;\\n        if (diff >= 0 && diff < tick)\\n            continue;\\n        await (0, exports.nextTick)();\\n        ts += diff;\\n    }\\n}\\nexports.asyncLoop = asyncLoop;\\n/**\\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\\n */\\nfunction utf8ToBytes(str) {\\n    if (typeof str !== 'string')\\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\\n}\\nexports.utf8ToBytes = utf8ToBytes;\\n/**\\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\\n * Warning: when Uint8Array is passed, it would NOT get copied.\\n * Keep in mind for future mutable operations.\\n */\\nfunction toBytes(data) {\\n    if (typeof data === 'string')\\n        data = utf8ToBytes(data);\\n    if (!u8a(data))\\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\\n    return data;\\n}\\nexports.toBytes = toBytes;\\n/**\\n * Copies several Uint8Arrays into one.\\n */\\nfunction concatBytes(...arrays) {\\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\\n    let pad = 0; // walk through each item, ensure they have proper type\\n    arrays.forEach((a) => {\\n        if (!u8a(a))\\n            throw new Error('Uint8Array expected');\\n        r.set(a, pad);\\n        pad += a.length;\\n    });\\n    return r;\\n}\\nexports.concatBytes = concatBytes;\\n// For runtime check if class implements interface\\nclass Hash {\\n    // Safe version that clones internal state\\n    clone() {\\n        return this._cloneInto();\\n    }\\n}\\nexports.Hash = Hash;\\nconst toStr = {}.toString;\\nfunction checkOpts(defaults, opts) {\\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\\n        throw new Error('Options should be object or undefined');\\n    const merged = Object.assign(defaults, opts);\\n    return merged;\\n}\\nexports.checkOpts = checkOpts;\\nfunction wrapConstructor(hashCons) {\\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\\n    const tmp = hashCons();\\n    hashC.outputLen = tmp.outputLen;\\n    hashC.blockLen = tmp.blockLen;\\n    hashC.create = () => hashCons();\\n    return hashC;\\n}\\nexports.wrapConstructor = wrapConstructor;\\nfunction wrapConstructorWithOpts(hashCons) {\\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\\n    const tmp = hashCons({});\\n    hashC.outputLen = tmp.outputLen;\\n    hashC.blockLen = tmp.blockLen;\\n    hashC.create = (opts) => hashCons(opts);\\n    return hashC;\\n}\\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\\nfunction wrapXOFConstructorWithOpts(hashCons) {\\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\\n    const tmp = hashCons({});\\n    hashC.outputLen = tmp.outputLen;\\n    hashC.blockLen = tmp.blockLen;\\n    hashC.create = (opts) => hashCons(opts);\\n    return hashC;\\n}\\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\\n/**\\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\\n */\\nfunction randomBytes(bytesLength = 32) {\\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\\n    }\\n    throw new Error('crypto.getRandomValues must be defined');\\n}\\nexports.randomBytes = randomBytes;\\n//# sourceMappingURL=utils.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"utf8ToBytes\",\"str\",\"Error\",\"Uint8Array\",\"encode\",\"TextEncoder\",\"toBytes\",\"data\",\"Object\",\"defineProperty\",\"value\",\"randomBytes\",\"wrapXOFConstructorWithOpts\",\"wrapConstructorWithOpts\",\"wrapConstructor\",\"checkOpts\",\"Hash\",\"concatBytes\",\"asyncLoop\",\"nextTick\",\"hexToBytes\",\"bytesToHex\",\"isLE\",\"rotr\",\"createView\",\"u32\",\"u8\",\"crypto_1\",\"arr\",\"buffer\",\"byteOffset\",\"byteLength\",\"Uint32Array\",\"Math\",\"floor\",\"DataView\",\"word\",\"shift\",\"hexes\",\"Array\",\"from\",\"length\",\"_\",\"i\",\"toString\",\"padStart\",\"bytes\",\"hex\",\"len\",\"array\",\"j\",\"hexByte\",\"slice\",\"byte\",\"Number\",\"parseInt\",\"isNaN\",\"iters\",\"tick\",\"cb\",\"ts\",\"Date\",\"now\",\"diff\",\"arrays\",\"r\",\"reduce\",\"sum\",\"a\",\"pad\",\"forEach\",\"set\",\"clone\",\"_cloneInto\",\"toStr\",\"defaults\",\"opts\",\"undefined\",\"call\",\"assign\",\"merged\",\"hashCons\",\"hashC\",\"msg\",\"update\",\"digest\",\"tmp\",\"outputLen\",\"blockLen\",\"create\",\"hashC.create\",\"bytesLength\",\"crypto\",\"getRandomValues\"]\n}\n"]