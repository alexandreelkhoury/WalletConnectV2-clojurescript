shadow$provide.module$node_modules$viem$_cjs$actions$public$multicall=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.multicall=void 0;const abis_js_1=require("module$node_modules$viem$_cjs$constants$abis"),abi_js_1=require("module$node_modules$viem$_cjs$errors$abi"),base_js_1=require("module$node_modules$viem$_cjs$errors$base"),contract_js_1=require("module$node_modules$viem$_cjs$errors$contract"),decodeFunctionResult_js_1=require("module$node_modules$viem$_cjs$utils$abi$decodeFunctionResult"),
encodeFunctionData_js_1=require("module$node_modules$viem$_cjs$utils$abi$encodeFunctionData"),chain_js_1=require("module$node_modules$viem$_cjs$utils$chain"),getContractError_js_1=require("module$node_modules$viem$_cjs$utils$errors$getContractError"),readContract_js_1=require("module$node_modules$viem$_cjs$actions$public$readContract");exports.multicall=async function(client,args$jscomp$0){const {allowFailure=!0,batchSize:batchSize_,blockNumber,blockTag,contracts,multicallAddress:multicallAddress_}=
args$jscomp$0;var batchSize=batchSize_??("object"===typeof client.batch?.multicall&&client.batch.multicall.batchSize||1024);let multicallAddress=multicallAddress_;if(!multicallAddress){if(!client.chain)throw Error("client chain not configured. multicallAddress is required.");multicallAddress=(0,chain_js_1.getChainContractAddress)({blockNumber,chain:client.chain,contract:"multicall3"})}args$jscomp$0=[[]];var currentChunk=0,currentChunkSize=0;for(var i=0;i<contracts.length;i++){const {abi,address,args,
functionName}=contracts[i];try{var callData=(0,encodeFunctionData_js_1.encodeFunctionData)({abi,args,functionName});currentChunkSize+=(callData.length-2)/2;0<batchSize&&currentChunkSize>batchSize&&0<args$jscomp$0[currentChunk].length&&(currentChunk++,currentChunkSize=(callData.length-2)/2,args$jscomp$0[currentChunk]=[]);args$jscomp$0[currentChunk]=[...args$jscomp$0[currentChunk],{allowFailure:!0,callData,target:address}]}catch(err){var error=(0,getContractError_js_1.getContractError)(err,{abi,address,
args,docsPath:"/docs/contract/multicall",functionName});if(!allowFailure)throw error;args$jscomp$0[currentChunk]=[...args$jscomp$0[currentChunk],{allowFailure:!0,callData:"0x",target:address}]}}callData=await Promise.allSettled(args$jscomp$0.map(calls=>(0,readContract_js_1.readContract)(client,{abi:abis_js_1.multicall3Abi,address:multicallAddress,args:[calls],blockNumber,blockTag,functionName:"aggregate3"})));batchSize=[];for(currentChunk=0;currentChunk<callData.length;currentChunk++)if(currentChunkSize=
callData[currentChunk],"rejected"===currentChunkSize.status){if(!allowFailure)throw currentChunkSize.reason;for(i=0;i<args$jscomp$0[currentChunk].length;i++)batchSize.push({status:"failure",error:currentChunkSize.reason,result:void 0})}else for(currentChunkSize=currentChunkSize.value,i=0;i<currentChunkSize.length;i++){const {returnData,success}=currentChunkSize[i];({callData:error}=args$jscomp$0[currentChunk][i]);const {abi,address,functionName,args}=contracts[batchSize.length];try{if("0x"===error)throw new abi_js_1.AbiDecodingZeroDataError;
if(!success)throw new contract_js_1.RawContractError({data:returnData});const result=(0,decodeFunctionResult_js_1.decodeFunctionResult)({abi,args,data:returnData,functionName});batchSize.push(allowFailure?{result,status:"success"}:result)}catch(err){error=(0,getContractError_js_1.getContractError)(err,{abi,address,args,docsPath:"/docs/contract/multicall",functionName});if(!allowFailure)throw error;batchSize.push({error,result:void 0,status:"failure"})}}if(batchSize.length!==contracts.length)throw new base_js_1.BaseError("multicall results mismatch");
return batchSize}}
//# sourceMappingURL=module$node_modules$viem$_cjs$actions$public$multicall.js.map
