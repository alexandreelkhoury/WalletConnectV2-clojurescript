shadow$provide.module$node_modules$viem$_cjs$clients$transports$fallback=function(global,require,module,exports){function rankTransports({chain,interval=4E3,onTransports,sampleCount=10,timeout=1E3,transports,weights={}}){const {stability:stabilityWeight=.7,latency:latencyWeight=.3}=weights,samples=[],rankTransports_=async()=>{var sample$jscomp$0=await Promise.all(transports.map(async transport=>{var transport_=transport({chain,retryCount:0,timeout});transport=Date.now();let success;try{await transport_.request({method:"net_listening"}),
success=1}catch{success=0}finally{transport_=Date.now()}return{latency:transport_-transport,success}}));samples.push(sample$jscomp$0);samples.length>sampleCount&&samples.shift();const maxLatency=Math.max(...samples.map(sample=>Math.max(...sample.map(({latency})=>latency))));sample$jscomp$0=transports.map((_,i)=>{_=samples.map(sample=>sample[i].latency);_=1-_.reduce((acc,latency)=>acc+latency,0)/_.length/maxLatency;var successes=samples.map(sample=>sample[i].success);successes=successes.reduce((acc,
success)=>acc+success,0)/successes.length;return 0===successes?[0,i]:[latencyWeight*_+stabilityWeight*successes,i]}).sort((a,b)=>b[0]-a[0]);onTransports(sample$jscomp$0.map(([,i])=>transports[i]));await (0,wait_js_1.wait)(interval);rankTransports_()};rankTransports_()}Object.defineProperty(exports,"__esModule",{value:!0});exports.rankTransports=exports.fallback=void 0;const buildRequest_js_1=require("module$node_modules$viem$_cjs$utils$buildRequest"),wait_js_1=require("module$node_modules$viem$_cjs$utils$wait"),
createTransport_js_1=require("module$node_modules$viem$_cjs$clients$transports$createTransport");exports.fallback=function(transports_,config={}){const {key="fallback",name="Fallback",rank=!1,retryCount,retryDelay}=config;return({chain,pollingInterval=4E3,timeout})=>{let transports=transports_,onResponse=()=>{};const transport$jscomp$0=(0,createTransport_js_1.createTransport)({key,name,async request({method,params}){const fetch=async(i=0)=>{const transport=transports[i]({chain,retryCount:0,timeout});
try{const response=await transport.request({method,params});onResponse({method,params,response,transport,status:"success"});return response}catch(err){onResponse({error:err,method,params,transport,status:"error"});if((0,buildRequest_js_1.isDeterministicError)(err))throw err;if(i===transports.length-1)throw err;return fetch(i+1)}};return fetch()},retryCount,retryDelay,type:"fallback"},{onResponse:fn=>onResponse=fn,transports:transports.map(fn=>fn({chain,retryCount:0}))});if(rank){const rankOptions=
"object"===typeof rank?rank:{};rankTransports({chain,interval:rankOptions.interval??pollingInterval,onTransports:transports_=>transports=transports_,sampleCount:rankOptions.sampleCount,timeout:rankOptions.timeout,transports,weights:rankOptions.weights})}return transport$jscomp$0}};exports.rankTransports=rankTransports}
//# sourceMappingURL=module$node_modules$viem$_cjs$clients$transports$fallback.js.map
