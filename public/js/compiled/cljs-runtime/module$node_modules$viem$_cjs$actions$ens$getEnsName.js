shadow$provide.module$node_modules$viem$_cjs$actions$ens$getEnsName=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.getEnsName=void 0;const abis_js_1=require("module$node_modules$viem$_cjs$constants$abis"),chain_js_1=require("module$node_modules$viem$_cjs$utils$chain"),toHex_js_1=require("module$node_modules$viem$_cjs$utils$encoding$toHex"),errors_js_1=require("module$node_modules$viem$_cjs$utils$ens$errors"),packetToBytes_js_1=require("module$node_modules$viem$_cjs$utils$ens$packetToBytes"),
readContract_js_1=require("module$node_modules$viem$_cjs$actions$public$readContract");exports.getEnsName=async function(client,{address,blockNumber,blockTag,universalResolverAddress:universalResolverAddress_}){if(!universalResolverAddress_){if(!client.chain)throw Error("client chain not configured. universalResolverAddress is required.");universalResolverAddress_=(0,chain_js_1.getChainContractAddress)({blockNumber,chain:client.chain,contract:"ensUniversalResolver"})}address=`${address.toLowerCase().substring(2)}.addr.reverse`;
try{return(await (0,readContract_js_1.readContract)(client,{address:universalResolverAddress_,abi:abis_js_1.universalResolverReverseAbi,functionName:"reverse",args:[(0,toHex_js_1.toHex)((0,packetToBytes_js_1.packetToBytes)(address))],blockNumber,blockTag}))[0]}catch(err){if((0,errors_js_1.isNullUniversalResolverError)(err,"reverse"))return null;throw err;}}}
//# sourceMappingURL=module$node_modules$viem$_cjs$actions$ens$getEnsName.js.map
