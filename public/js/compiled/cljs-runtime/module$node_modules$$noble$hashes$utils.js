shadow$provide.module$node_modules$$noble$hashes$utils=function(global,require,module,exports){function utf8ToBytes(str){if("string"!==typeof str)throw Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){"string"===typeof data&&(data=utf8ToBytes(data));if(!(data instanceof Uint8Array))throw Error(`expected Uint8Array, got ${typeof data}`);return data}Object.defineProperty(exports,"__esModule",{value:!0});exports.randomBytes=
exports.wrapXOFConstructorWithOpts=exports.wrapConstructorWithOpts=exports.wrapConstructor=exports.checkOpts=exports.Hash=exports.concatBytes=exports.toBytes=exports.utf8ToBytes=exports.asyncLoop=exports.nextTick=exports.hexToBytes=exports.bytesToHex=exports.isLE=exports.rotr=exports.createView=exports.u32=exports.u8=void 0;const crypto_1=require("module$node_modules$$noble$hashes$crypto");exports.u8=arr=>new Uint8Array(arr.buffer,arr.byteOffset,arr.byteLength);exports.u32=arr=>new Uint32Array(arr.buffer,
arr.byteOffset,Math.floor(arr.byteLength/4));exports.createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);exports.rotr=(word,shift)=>word<<32-shift|word>>>shift;exports.isLE=68===(new Uint8Array((new Uint32Array([287454020])).buffer))[0];if(!exports.isLE)throw Error("Non little-endian hardware is not supported");const hexes=Array.from({length:256},(_,i)=>i.toString(16).padStart(2,"0"));exports.bytesToHex=function(bytes){if(!(bytes instanceof Uint8Array))throw Error("Uint8Array expected");
let hex="";for(let i=0;i<bytes.length;i++)hex+=hexes[bytes[i]];return hex};exports.hexToBytes=function(hex){if("string"!==typeof hex)throw Error("hex string expected, got "+typeof hex);var len=hex.length;if(len%2)throw Error("padded hex string expected, got unpadded hex of length "+len);len=new Uint8Array(len/2);for(let i=0;i<len.length;i++){var j=2*i;j=hex.slice(j,j+2);j=Number.parseInt(j,16);if(Number.isNaN(j)||0>j)throw Error("Invalid byte sequence");len[i]=j}return len};exports.nextTick=async()=>
{};exports.asyncLoop=async function(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;0<=diff&&diff<tick||(await (0,exports.nextTick)(),ts+=diff)}};exports.utf8ToBytes=utf8ToBytes;exports.toBytes=toBytes;exports.concatBytes=function(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!(a instanceof Uint8Array))throw Error("Uint8Array expected");r.set(a,pad);pad+=a.length});return r};class Hash{clone(){return this._cloneInto()}}
exports.Hash=Hash;const toStr={}.toString;exports.checkOpts=function(defaults,opts){if(void 0!==opts&&"[object Object]"!==toStr.call(opts))throw Error("Options should be object or undefined");return Object.assign(defaults,opts)};exports.wrapConstructor=function(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=()=>hashCons();return hashC};exports.wrapConstructorWithOpts=function(hashCons){const hashC=
(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=opts=>hashCons(opts);return hashC};exports.wrapXOFConstructorWithOpts=function(hashCons){const hashC=(msg,opts)=>hashCons(opts).update(toBytes(msg)).digest(),tmp=hashCons({});hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=opts=>hashCons(opts);return hashC};exports.randomBytes=function(bytesLength=32){if(crypto_1.crypto&&"function"===
typeof crypto_1.crypto.getRandomValues)return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));throw Error("crypto.getRandomValues must be defined");}}
//# sourceMappingURL=module$node_modules$$noble$hashes$utils.js.map
