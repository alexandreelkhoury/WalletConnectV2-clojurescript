["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_transform.js"],"~:js","shadow$provide[221]=function(S,A,V,q){function F(h,k){var t=this._transformState;t.transforming=!1;var B=t.writecb;if(null===B)return this.emit(\"error\",new u);t.writechunk=null;t.writecb=null;null!=k&&this.push(k);B(h);h=this._readableState;h.reading=!1;(h.needReadable||h.length<h.highWaterMark)&&this._read(h.highWaterMark)}function G(h){if(!(this instanceof G))return new G(h);l.call(this,h);this._transformState={afterTransform:F.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,\nwriteencoding:null};this._readableState.needReadable=!0;this._readableState.sync=!1;h&&(\"function\"===typeof h.transform&&(this._transform=h.transform),\"function\"===typeof h.flush&&(this._flush=h.flush));this.on(\"prefinish\",r)}function r(){var h=this;\"function\"!==typeof this._flush||this._readableState.destroyed?y(this,null,null):this._flush(function(k,t){y(h,k,t)})}function y(h,k,t){if(k)return h.emit(\"error\",k);null!=t&&h.push(t);if(h._writableState.length)throw new n;if(h._transformState.transforming)throw new p;\nreturn h.push(null)}V.exports=G;S=A(213).codes;var e=S.ERR_METHOD_NOT_IMPLEMENTED,u=S.ERR_MULTIPLE_CALLBACK,p=S.ERR_TRANSFORM_ALREADY_TRANSFORMING,n=S.ERR_TRANSFORM_WITH_LENGTH_0,l=A(216);A(76)(G,l);G.prototype.push=function(h,k){this._transformState.needTransform=!1;return l.prototype.push.call(this,h,k)};G.prototype._transform=function(h,k,t){t(new e(\"_transform()\"))};G.prototype._write=function(h,k,t){var B=this._transformState;B.writecb=t;B.writechunk=h;B.writeencoding=k;B.transforming||(h=this._readableState,\n(B.needTransform||h.needReadable||h.length<h.highWaterMark)&&this._read(h.highWaterMark))};G.prototype._read=function(h){h=this._transformState;null===h.writechunk||h.transforming?h.needTransform=!0:(h.transforming=!0,this._transform(h.writechunk,h.writeencoding,h.afterTransform))};G.prototype._destroy=function(h,k){l.prototype._destroy.call(this,h,function(t){k(t)})}}","~:source","shadow$provide[221] = function(global,require,module,exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nvar _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$inherits$inherits_browser","~$module$node_modules$browserify_sign$node_modules$readable_stream$lib$_stream_duplex","~$module$node_modules$browserify_sign$node_modules$readable_stream$errors"]],"~:properties",["^5",["_destroy","writeencoding","reading","writecb","transforming","push","_transformState","writechunk","_read","_transform","sync","needTransform","_flush","needReadable","_write","afterTransform"]],"~:compiled-at",1695041440849,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$browserify_sign$node_modules$readable_stream$lib$_stream_transform.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_transform.js\"],\n\"sourcesContent\":[\"shadow$provide[221] = function(global,require,module,exports) {\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// a transform stream is a readable/writable stream where you do\\n// something with the data.  Sometimes it's called a \\\"filter\\\",\\n// but that's not a great name for it, since that implies a thing where\\n// some bits pass through, and others are simply ignored.  (That would\\n// be a valid example of a transform, of course.)\\n//\\n// While the output is causally related to the input, it's not a\\n// necessarily symmetric or synchronous transformation.  For example,\\n// a zlib stream might take multiple plain-text writes(), and then\\n// emit a single compressed chunk some time in the future.\\n//\\n// Here's how this works:\\n//\\n// The Transform stream has all the aspects of the readable and writable\\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\\n// internally, and returns false if there's a lot of pending writes\\n// buffered up.  When you call read(), that calls _read(n) until\\n// there's enough pending readable data buffered up.\\n//\\n// In a transform stream, the written data is placed in a buffer.  When\\n// _read(n) is called, it transforms the queued up data, calling the\\n// buffered _write cb's as it consumes chunks.  If consuming a single\\n// written chunk would result in multiple output chunks, then the first\\n// outputted bit calls the readcb, and subsequent chunks just go into\\n// the read buffer, and will cause it to emit 'readable' if necessary.\\n//\\n// This way, back-pressure is actually determined by the reading side,\\n// since _read has to be called to start processing a new chunk.  However,\\n// a pathological inflate type of transform can cause excessive buffering\\n// here.  For example, imagine a stream where every byte of input is\\n// interpreted as an integer from 0-255, and then results in that many\\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\\n// 1kb of data being output.  In this case, you could write a very small\\n// amount of input, and end up with a very large amount of output.  In\\n// such a pathological inflating mechanism, there'd be no way to tell\\n// the system to stop doing the transform.  A single 4MB write could\\n// cause the system to run out of memory.\\n//\\n// However, even in such a pathological case, only a single written chunk\\n// would be consumed, and then the rest would wait (un-transformed) until\\n// the results of the previous transformed chunk were consumed.\\n\\n'use strict';\\n\\nmodule.exports = Transform;\\nvar _require$codes = require('../errors').codes,\\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\\nvar Duplex = require('./_stream_duplex');\\nrequire('inherits')(Transform, Duplex);\\nfunction afterTransform(er, data) {\\n  var ts = this._transformState;\\n  ts.transforming = false;\\n  var cb = ts.writecb;\\n  if (cb === null) {\\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\\n  }\\n  ts.writechunk = null;\\n  ts.writecb = null;\\n  if (data != null)\\n    // single equals check for both `null` and `undefined`\\n    this.push(data);\\n  cb(er);\\n  var rs = this._readableState;\\n  rs.reading = false;\\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\\n    this._read(rs.highWaterMark);\\n  }\\n}\\nfunction Transform(options) {\\n  if (!(this instanceof Transform)) return new Transform(options);\\n  Duplex.call(this, options);\\n  this._transformState = {\\n    afterTransform: afterTransform.bind(this),\\n    needTransform: false,\\n    transforming: false,\\n    writecb: null,\\n    writechunk: null,\\n    writeencoding: null\\n  };\\n\\n  // start out asking for a readable event once data is transformed.\\n  this._readableState.needReadable = true;\\n\\n  // we have implemented the _read method, and done the other things\\n  // that Readable wants before the first _read call, so unset the\\n  // sync guard flag.\\n  this._readableState.sync = false;\\n  if (options) {\\n    if (typeof options.transform === 'function') this._transform = options.transform;\\n    if (typeof options.flush === 'function') this._flush = options.flush;\\n  }\\n\\n  // When the writable side finishes, then flush out anything remaining.\\n  this.on('prefinish', prefinish);\\n}\\nfunction prefinish() {\\n  var _this = this;\\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\\n    this._flush(function (er, data) {\\n      done(_this, er, data);\\n    });\\n  } else {\\n    done(this, null, null);\\n  }\\n}\\nTransform.prototype.push = function (chunk, encoding) {\\n  this._transformState.needTransform = false;\\n  return Duplex.prototype.push.call(this, chunk, encoding);\\n};\\n\\n// This is the part where you do stuff!\\n// override this function in implementation classes.\\n// 'chunk' is an input chunk.\\n//\\n// Call `push(newChunk)` to pass along transformed output\\n// to the readable side.  You may call 'push' zero or more times.\\n//\\n// Call `cb(err)` when you are done with this chunk.  If you pass\\n// an error, then that'll put the hurt on the whole operation.  If you\\n// never call cb(), then you'll never get another chunk.\\nTransform.prototype._transform = function (chunk, encoding, cb) {\\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\\n};\\nTransform.prototype._write = function (chunk, encoding, cb) {\\n  var ts = this._transformState;\\n  ts.writecb = cb;\\n  ts.writechunk = chunk;\\n  ts.writeencoding = encoding;\\n  if (!ts.transforming) {\\n    var rs = this._readableState;\\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\\n  }\\n};\\n\\n// Doesn't matter what the args are here.\\n// _transform does all the work.\\n// That we got here means that the readable side wants more data.\\nTransform.prototype._read = function (n) {\\n  var ts = this._transformState;\\n  if (ts.writechunk !== null && !ts.transforming) {\\n    ts.transforming = true;\\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\\n  } else {\\n    // mark that we need a transform, so that any data that comes in\\n    // will get processed, now that we've asked for it.\\n    ts.needTransform = true;\\n  }\\n};\\nTransform.prototype._destroy = function (err, cb) {\\n  Duplex.prototype._destroy.call(this, err, function (err2) {\\n    cb(err2);\\n  });\\n};\\nfunction done(stream, er, data) {\\n  if (er) return stream.emit('error', er);\\n  if (data != null)\\n    // single equals check for both `null` and `undefined`\\n    stream.push(data);\\n\\n  // TODO(BridgeAR): Write a test for these two error cases\\n  // if there's nothing in the write buffer, then that means\\n  // that nothing more will ever be provided\\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\\n  return stream.push(null);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"afterTransform\",\"er\",\"data\",\"ts\",\"_transformState\",\"transforming\",\"cb\",\"writecb\",\"emit\",\"ERR_MULTIPLE_CALLBACK\",\"writechunk\",\"push\",\"rs\",\"_readableState\",\"reading\",\"needReadable\",\"length\",\"highWaterMark\",\"_read\",\"Transform\",\"options\",\"Duplex\",\"call\",\"bind\",\"needTransform\",\"writeencoding\",\"sync\",\"transform\",\"_transform\",\"flush\",\"_flush\",\"on\",\"prefinish\",\"_this\",\"destroyed\",\"done\",\"stream\",\"_writableState\",\"ERR_TRANSFORM_WITH_LENGTH_0\",\"ERR_TRANSFORM_ALREADY_TRANSFORMING\",\"_require$codes\",\"codes\",\"ERR_METHOD_NOT_IMPLEMENTED\",\"prototype\",\"Transform.prototype.push\",\"chunk\",\"encoding\",\"Transform.prototype._transform\",\"_write\",\"Transform.prototype._write\",\"Transform.prototype._read\",\"n\",\"_destroy\",\"Transform.prototype._destroy\",\"err\",\"err2\"]\n}\n"]