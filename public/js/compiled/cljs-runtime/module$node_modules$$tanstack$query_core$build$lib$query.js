shadow$provide.module$node_modules$$tanstack$query_core$build$lib$query=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});var utils=require("module$node_modules$$tanstack$query_core$build$lib$utils"),logger=require("module$node_modules$$tanstack$query_core$build$lib$logger"),notifyManager=require("module$node_modules$$tanstack$query_core$build$lib$notifyManager"),retryer=require("module$node_modules$$tanstack$query_core$build$lib$retryer");global=require("module$node_modules$$tanstack$query_core$build$lib$removable");
class Query extends global.Removable{constructor(config){super();this.abortSignalConsumed=!1;this.defaultOptions=config.defaultOptions;this.setOptions(config.options);this.observers=[];this.cache=config.cache;this.logger=config.logger||logger.defaultLogger;this.queryKey=config.queryKey;this.queryHash=config.queryHash;if(!(config=config.state)){var options=this.options;config="function"===typeof options.initialData?options.initialData():options.initialData;const hasData="undefined"!==typeof config;
options=hasData?"function"===typeof options.initialDataUpdatedAt?options.initialDataUpdatedAt():options.initialDataUpdatedAt:0;config={data:config,dataUpdateCount:0,dataUpdatedAt:hasData?null!=options?options:Date.now():0,error:null,errorUpdateCount:0,errorUpdatedAt:0,fetchFailureCount:0,fetchFailureReason:null,fetchMeta:null,isInvalidated:!1,status:hasData?"success":"loading",fetchStatus:"idle"}}this.state=this.initialState=config;this.scheduleGc()}get meta(){return this.options.meta}setOptions(options){this.options=
{...this.defaultOptions,...options};this.updateCacheTime(this.options.cacheTime)}optionalRemove(){this.observers.length||"idle"!==this.state.fetchStatus||this.cache.remove(this)}setData(newData,options){newData=utils.replaceData(this.state.data,newData,this.options);this.dispatch({data:newData,type:"success",dataUpdatedAt:null==options?void 0:options.updatedAt,manual:null==options?void 0:options.manual});return newData}setState(state,setStateOptions){this.dispatch({type:"setState",state,setStateOptions})}cancel(options){var _this$retryer;
const promise=this.promise;null==(_this$retryer=this.retryer)?void 0:_this$retryer.cancel(options);return promise?promise.then(utils.noop).catch(utils.noop):Promise.resolve()}destroy(){super.destroy();this.cancel({silent:!0})}reset(){this.destroy();this.setState(this.initialState)}isActive(){return this.observers.some(observer=>!1!==observer.options.enabled)}isDisabled(){return 0<this.getObserversCount()&&!this.isActive()}isStale(){return this.state.isInvalidated||!this.state.dataUpdatedAt||this.observers.some(observer=>
observer.getCurrentResult().isStale)}isStaleByTime(staleTime=0){return this.state.isInvalidated||!this.state.dataUpdatedAt||!utils.timeUntilStale(this.state.dataUpdatedAt,staleTime)}onFocus(){var _this$retryer2;const observer=this.observers.find(x=>x.shouldFetchOnWindowFocus());observer&&observer.refetch({cancelRefetch:!1});null==(_this$retryer2=this.retryer)?void 0:_this$retryer2.continue()}onOnline(){var _this$retryer3;const observer=this.observers.find(x=>x.shouldFetchOnReconnect());observer&&
observer.refetch({cancelRefetch:!1});null==(_this$retryer3=this.retryer)?void 0:_this$retryer3.continue()}addObserver(observer){this.observers.includes(observer)||(this.observers.push(observer),this.clearGcTimeout(),this.cache.notify({type:"observerAdded",query:this,observer}))}removeObserver(observer){this.observers.includes(observer)&&(this.observers=this.observers.filter(x=>x!==observer),this.observers.length||(this.retryer&&(this.abortSignalConsumed?this.retryer.cancel({revert:!0}):this.retryer.cancelRetry()),
this.scheduleGc()),this.cache.notify({type:"observerRemoved",query:this,observer}))}getObserversCount(){return this.observers.length}invalidate(){this.state.isInvalidated||this.dispatch({type:"invalidate"})}fetch(options,fetchOptions){var _this$options$behavio,_context$fetchOptions;if("idle"!==this.state.fetchStatus)if(this.state.dataUpdatedAt&&null!=fetchOptions&&fetchOptions.cancelRefetch)this.cancel({silent:!0});else if(this.promise){var _this$retryer4;null==(_this$retryer4=this.retryer)?void 0:
_this$retryer4.continueRetry();return this.promise}options&&this.setOptions(options);this.options.queryFn||(options=this.observers.find(x=>x.options.queryFn))&&this.setOptions(options.options);Array.isArray(this.options.queryKey)||this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");const abortController=utils.getAbortController(),queryFnContext={queryKey:this.queryKey,pageParam:void 0,meta:this.meta};
options=object=>{Object.defineProperty(object,"signal",{enumerable:!0,get:()=>{if(abortController)return this.abortSignalConsumed=!0,abortController.signal}})};options(queryFnContext);fetchOptions={fetchOptions,options:this.options,queryKey:this.queryKey,state:this.state,fetchFn:()=>{if(!this.options.queryFn)return Promise.reject("Missing queryFn for queryKey '"+this.options.queryHash+"'");this.abortSignalConsumed=!1;return this.options.queryFn(queryFnContext)}};options(fetchOptions);null==(_this$options$behavio=
this.options.behavior)?void 0:_this$options$behavio.onFetch(fetchOptions);this.revertState=this.state;if("idle"===this.state.fetchStatus||this.state.fetchMeta!==(null==(_context$fetchOptions=fetchOptions.fetchOptions)?void 0:_context$fetchOptions.meta)){var _context$fetchOptions2;this.dispatch({type:"fetch",meta:null==(_context$fetchOptions2=fetchOptions.fetchOptions)?void 0:_context$fetchOptions2.meta})}const onError=error=>{retryer.isCancelledError(error)&&error.silent||this.dispatch({type:"error",
error});if(!retryer.isCancelledError(error)){var _this$cache$config$on,_this$cache$config,_this$cache$config$on2,_this$cache$config2;null==(_this$cache$config$on=(_this$cache$config=this.cache.config).onError)?void 0:_this$cache$config$on.call(_this$cache$config,error,this);null==(_this$cache$config$on2=(_this$cache$config2=this.cache.config).onSettled)?void 0:_this$cache$config$on2.call(_this$cache$config2,this.state.data,error,this);this.logger.error(error)}this.isFetchingOptimistic||this.scheduleGc();
this.isFetchingOptimistic=!1};this.retryer=retryer.createRetryer({fn:fetchOptions.fetchFn,abort:null==abortController?void 0:abortController.abort.bind(abortController),onSuccess:data=>{var _this$cache$config$on3,_this$cache$config3,_this$cache$config$on4,_this$cache$config4;"undefined"===typeof data?(this.logger.error("Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: "+this.queryHash),onError(Error(this.queryHash+
" data is undefined"))):(this.setData(data),null==(_this$cache$config$on3=(_this$cache$config3=this.cache.config).onSuccess)?void 0:_this$cache$config$on3.call(_this$cache$config3,data,this),null==(_this$cache$config$on4=(_this$cache$config4=this.cache.config).onSettled)?void 0:_this$cache$config$on4.call(_this$cache$config4,data,this.state.error,this),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1)},onError,onFail:(failureCount,error)=>{this.dispatch({type:"failed",failureCount,
error})},onPause:()=>{this.dispatch({type:"pause"})},onContinue:()=>{this.dispatch({type:"continue"})},retry:fetchOptions.options.retry,retryDelay:fetchOptions.options.retryDelay,networkMode:fetchOptions.options.networkMode});return this.promise=this.retryer.promise}dispatch(action){this.state=(state=>{var _action$meta,_action$dataUpdatedAt;switch(action.type){case "failed":return{...state,fetchFailureCount:action.failureCount,fetchFailureReason:action.error};case "pause":return{...state,fetchStatus:"paused"};
case "continue":return{...state,fetchStatus:"fetching"};case "fetch":return{...state,fetchFailureCount:0,fetchFailureReason:null,fetchMeta:null!=(_action$meta=action.meta)?_action$meta:null,fetchStatus:retryer.canFetch(this.options.networkMode)?"fetching":"paused",...(!state.dataUpdatedAt&&{error:null,status:"loading"})};case "success":return{...state,data:action.data,dataUpdateCount:state.dataUpdateCount+1,dataUpdatedAt:null!=(_action$dataUpdatedAt=action.dataUpdatedAt)?_action$dataUpdatedAt:Date.now(),
error:null,isInvalidated:!1,status:"success",...(!action.manual&&{fetchStatus:"idle",fetchFailureCount:0,fetchFailureReason:null})};case "error":return _action$meta=action.error,retryer.isCancelledError(_action$meta)&&_action$meta.revert&&this.revertState?{...this.revertState,fetchStatus:"idle"}:{...state,error:_action$meta,errorUpdateCount:state.errorUpdateCount+1,errorUpdatedAt:Date.now(),fetchFailureCount:state.fetchFailureCount+1,fetchFailureReason:_action$meta,fetchStatus:"idle",status:"error"};
case "invalidate":return{...state,isInvalidated:!0};case "setState":return{...state,...action.state}}})(this.state);notifyManager.notifyManager.batch(()=>{this.observers.forEach(observer=>{observer.onQueryUpdate(action)});this.cache.notify({query:this,type:"updated",action})})}}exports.Query=Query}
//# sourceMappingURL=module$node_modules$$tanstack$query_core$build$lib$query.js.map
