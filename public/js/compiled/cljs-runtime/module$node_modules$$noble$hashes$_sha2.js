shadow$provide.module$node_modules$$noble$hashes$_sha2=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.SHA2=void 0;const _assert_js_1=require("module$node_modules$$noble$hashes$_assert"),utils_js_1=require("module$node_modules$$noble$hashes$utils");class SHA2 extends utils_js_1.Hash{constructor(blockLen,outputLen,padOffset,isLE){super();this.blockLen=blockLen;this.outputLen=outputLen;this.padOffset=padOffset;this.isLE=isLE;this.finished=!1;this.pos=
this.length=0;this.destroyed=!1;this.buffer=new Uint8Array(blockLen);this.view=(0,utils_js_1.createView)(this.buffer)}update(data){(0,_assert_js_1.exists)(this);const {view,buffer,blockLen}=this;data=(0,utils_js_1.toBytes)(data);const len=data.length;for(let pos=0;pos<len;){var take=Math.min(blockLen-this.pos,len-pos);if(take===blockLen)for(take=(0,utils_js_1.createView)(data);blockLen<=len-pos;pos+=blockLen)this.process(take,pos);else buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,
pos+=take,this.pos===blockLen&&(this.process(view,0),this.pos=0)}this.length+=data.length;this.roundClean();return this}digestInto(out){(0,_assert_js_1.exists)(this);(0,_assert_js_1.output)(out,this);this.finished=!0;const {buffer,view,blockLen,isLE}=this;var {pos}=this;buffer[pos++]=128;this.buffer.subarray(pos).fill(0);this.padOffset>blockLen-pos&&(this.process(view,0),pos=0);for(;pos<blockLen;pos++)buffer[pos]=0;pos=blockLen-8;var value=BigInt(8*this.length);if("function"===typeof view.setBigUint64)view.setBigUint64(pos,
value,isLE);else{var _u32_max=BigInt(4294967295),wl=Number(value&_u32_max),l=isLE?0:4;view.setUint32(pos+(isLE?4:0),Number(value>>BigInt(32)&_u32_max),isLE);view.setUint32(pos+l,wl,isLE)}this.process(view,0);out=(0,utils_js_1.createView)(out);pos=this.outputLen;if(pos%4)throw Error("_sha2: outputLen should be aligned to 32bit");pos/=4;value=this.get();if(pos>value.length)throw Error("_sha2: outputLen bigger than state");for(_u32_max=0;_u32_max<pos;_u32_max++)out.setUint32(4*_u32_max,value[_u32_max],
isLE)}digest(){const {buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);this.destroy();return res}_cloneInto(to){to||(to=new this.constructor);to.set(...this.get());const {blockLen,buffer,length,finished,destroyed,pos}=this;to.length=length;to.pos=pos;to.finished=finished;to.destroyed=destroyed;length%blockLen&&to.buffer.set(buffer);return to}}exports.SHA2=SHA2}
//# sourceMappingURL=module$node_modules$$noble$hashes$_sha2.js.map
