["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/pako/lib/zlib/deflate.js"],"~:js","shadow$provide.module$node_modules$pako$lib$zlib$deflate=function(global,require,module,exports){function err(strm,errorCode){strm.msg=msg[errorCode];return errorCode}function zero(buf){for(var len=buf.length;0<=--len;)buf[len]=0}function flush_pending(strm){var s=strm.state,len=s.pending;len>strm.avail_out&&(len=strm.avail_out);0!==len&&(utils.arraySet(strm.output,s.pending_buf,s.pending_out,len,strm.next_out),strm.next_out+=len,s.pending_out+=len,strm.total_out+=len,strm.avail_out-=len,s.pending-=\nlen,0===s.pending&&(s.pending_out=0))}function flush_block_only(s,last){trees._tr_flush_block(s,0<=s.block_start?s.block_start:-1,s.strstart-s.block_start,last);s.block_start=s.strstart;flush_pending(s.strm)}function put_byte(s,b){s.pending_buf[s.pending++]=b}function putShortMSB(s,b){s.pending_buf[s.pending++]=b>>>8&255;s.pending_buf[s.pending++]=b&255}function longest_match(s,cur_match){var chain_length=s.max_chain_length,scan=s.strstart,best_len=s.prev_length,nice_match=s.nice_match,limit=s.strstart>\ns.w_size-262?s.strstart-(s.w_size-262):0,_win=s.window,wmask=s.w_mask,prev=s.prev,strend=s.strstart+258,scan_end1=_win[scan+best_len-1],scan_end=_win[scan+best_len];s.prev_length>=s.good_match&&(chain_length>>=2);nice_match>s.lookahead&&(nice_match=s.lookahead);do{var match=cur_match;if(_win[match+best_len]===scan_end&&_win[match+best_len-1]===scan_end1&&_win[match]===_win[scan]&&_win[++match]===_win[scan+1]){scan+=2;for(match++;_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===\n_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&scan<strend;);match=258-(strend-scan);scan=strend-258;if(match>best_len){s.match_start=cur_match;best_len=match;if(match>=nice_match)break;scan_end1=_win[scan+best_len-1];scan_end=_win[scan+best_len]}}}while((cur_match=prev[cur_match&wmask])>limit&&0!==--chain_length);return best_len<=s.lookahead?best_len:s.lookahead}function fill_window(s){var _w_size=\ns.w_size,n;do{var more=s.window_size-s.lookahead-s.strstart;if(s.strstart>=_w_size+(_w_size-262)){utils.arraySet(s.window,s.window,_w_size,_w_size,0);s.match_start-=_w_size;s.strstart-=_w_size;s.block_start-=_w_size;var p=n=s.hash_size;do{var m=s.head[--p];s.head[p]=m>=_w_size?m-_w_size:0}while(--n);p=n=_w_size;do m=s.prev[--p],s.prev[p]=m>=_w_size?m-_w_size:0;while(--n);more+=_w_size}if(0===s.strm.avail_in)break;p=s.strm;n=s.window;m=s.strstart+s.lookahead;var len=p.avail_in;len>more&&(len=more);\n0===len?n=0:(p.avail_in-=len,utils.arraySet(n,p.input,p.next_in,len,m),1===p.state.wrap?p.adler=adler32(p.adler,n,len,m):2===p.state.wrap&&(p.adler=crc32(p.adler,n,len,m)),p.next_in+=len,p.total_in+=len,n=len);s.lookahead+=n;if(3<=s.lookahead+s.insert)for(more=s.strstart-s.insert,s.ins_h=s.window[more],s.ins_h=(s.ins_h<<s.hash_shift^s.window[more+1])&s.hash_mask;s.insert&&!(s.ins_h=(s.ins_h<<s.hash_shift^s.window[more+3-1])&s.hash_mask,s.prev[more&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=more,more++,\ns.insert--,3>s.lookahead+s.insert););}while(262>s.lookahead&&0!==s.strm.avail_in)}function deflate_fast(s,flush){for(var hash_head;;){if(262>s.lookahead){fill_window(s);if(262>s.lookahead&&0===flush)return 1;if(0===s.lookahead)break}hash_head=0;3<=s.lookahead&&(s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+3-1])&s.hash_mask,hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart);0!==hash_head&&s.strstart-hash_head<=s.w_size-262&&(s.match_length=longest_match(s,hash_head));\nif(3<=s.match_length)if(hash_head=trees._tr_tally(s,s.strstart-s.match_start,s.match_length-3),s.lookahead-=s.match_length,s.match_length<=s.max_lazy_match&&3<=s.lookahead){s.match_length--;do s.strstart++,s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+3-1])&s.hash_mask,s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart;while(0!==--s.match_length);s.strstart++}else s.strstart+=s.match_length,s.match_length=0,s.ins_h=s.window[s.strstart],s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+\n1])&s.hash_mask;else hash_head=trees._tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++;if(hash_head&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}s.insert=2>s.strstart?s.strstart:2;return 4===flush?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.last_lit&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2}function deflate_slow(s,flush){for(var hash_head,max_insert;;){if(262>s.lookahead){fill_window(s);if(262>s.lookahead&&0===flush)return 1;if(0===s.lookahead)break}hash_head=\n0;3<=s.lookahead&&(s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+3-1])&s.hash_mask,hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart);s.prev_length=s.match_length;s.prev_match=s.match_start;s.match_length=2;0!==hash_head&&s.prev_length<s.max_lazy_match&&s.strstart-hash_head<=s.w_size-262&&(s.match_length=longest_match(s,hash_head),5>=s.match_length&&(1===s.strategy||3===s.match_length&&4096<s.strstart-s.match_start)&&(s.match_length=2));if(3<=s.prev_length&&s.match_length<=\ns.prev_length){max_insert=s.strstart+s.lookahead-3;hash_head=trees._tr_tally(s,s.strstart-1-s.prev_match,s.prev_length-3);s.lookahead-=s.prev_length-1;s.prev_length-=2;do++s.strstart<=max_insert&&(s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+3-1])&s.hash_mask,s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart);while(0!==--s.prev_length);s.match_available=0;s.match_length=2;s.strstart++;if(hash_head&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}else if(s.match_available){if((hash_head=\ntrees._tr_tally(s,0,s.window[s.strstart-1]))&&flush_block_only(s,!1),s.strstart++,s.lookahead--,0===s.strm.avail_out)return 1}else s.match_available=1,s.strstart++,s.lookahead--}s.match_available&&(trees._tr_tally(s,0,s.window[s.strstart-1]),s.match_available=0);s.insert=2>s.strstart?s.strstart:2;return 4===flush?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.last_lit&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2}function deflate_rle(s,flush){for(var bflush,scan,strend,_win=s.window;;){if(258>=\ns.lookahead){fill_window(s);if(258>=s.lookahead&&0===flush)return 1;if(0===s.lookahead)break}s.match_length=0;if(3<=s.lookahead&&0<s.strstart&&(scan=s.strstart-1,bflush=_win[scan],bflush===_win[++scan]&&bflush===_win[++scan]&&bflush===_win[++scan])){for(strend=s.strstart+258;bflush===_win[++scan]&&bflush===_win[++scan]&&bflush===_win[++scan]&&bflush===_win[++scan]&&bflush===_win[++scan]&&bflush===_win[++scan]&&bflush===_win[++scan]&&bflush===_win[++scan]&&scan<strend;);s.match_length=258-(strend-\nscan);s.match_length>s.lookahead&&(s.match_length=s.lookahead)}3<=s.match_length?(bflush=trees._tr_tally(s,1,s.match_length-3),s.lookahead-=s.match_length,s.strstart+=s.match_length,s.match_length=0):(bflush=trees._tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++);if(bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}s.insert=0;return 4===flush?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.last_lit&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2}function deflate_huff(s,\nflush){for(var bflush;;){if(0===s.lookahead&&(fill_window(s),0===s.lookahead)){if(0===flush)return 1;break}s.match_length=0;bflush=trees._tr_tally(s,0,s.window[s.strstart]);s.lookahead--;s.strstart++;if(bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}s.insert=0;return 4===flush?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.last_lit&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2}function Config(good_length,max_lazy,nice_length,max_chain,func){this.good_length=good_length;this.max_lazy=\nmax_lazy;this.nice_length=nice_length;this.max_chain=max_chain;this.func=func}function DeflateState(){this.strm=null;this.status=0;this.pending_buf=null;this.wrap=this.pending=this.pending_out=this.pending_buf_size=0;this.gzhead=null;this.gzindex=0;this.method=8;this.last_flush=-1;this.w_mask=this.w_bits=this.w_size=0;this.window=null;this.window_size=0;this.head=this.prev=null;this.nice_match=this.good_match=this.strategy=this.level=this.max_lazy_match=this.max_chain_length=this.prev_length=this.lookahead=\nthis.match_start=this.strstart=this.match_available=this.prev_match=this.match_length=this.block_start=this.hash_shift=this.hash_mask=this.hash_bits=this.hash_size=this.ins_h=0;this.dyn_ltree=new utils.Buf16(1146);this.dyn_dtree=new utils.Buf16(122);this.bl_tree=new utils.Buf16(78);zero(this.dyn_ltree);zero(this.dyn_dtree);zero(this.bl_tree);this.bl_desc=this.d_desc=this.l_desc=null;this.bl_count=new utils.Buf16(16);this.heap=new utils.Buf16(573);zero(this.heap);this.heap_max=this.heap_len=0;this.depth=\nnew utils.Buf16(573);zero(this.depth);this.bi_valid=this.bi_buf=this.insert=this.matches=this.static_len=this.opt_len=this.d_buf=this.last_lit=this.lit_bufsize=this.l_buf=0}function deflateResetKeep(strm){if(!strm||!strm.state)return err(strm,-2);strm.total_in=strm.total_out=0;strm.data_type=2;var s=strm.state;s.pending=0;s.pending_out=0;0>s.wrap&&(s.wrap=-s.wrap);s.status=s.wrap?42:113;strm.adler=2===s.wrap?0:1;s.last_flush=0;trees._tr_init(s);return 0}function deflateReset(strm){var ret=deflateResetKeep(strm);\n0===ret&&(strm=strm.state,strm.window_size=2*strm.w_size,zero(strm.head),strm.max_lazy_match=configuration_table[strm.level].max_lazy,strm.good_match=configuration_table[strm.level].good_length,strm.nice_match=configuration_table[strm.level].nice_length,strm.max_chain_length=configuration_table[strm.level].max_chain,strm.strstart=0,strm.block_start=0,strm.lookahead=0,strm.insert=0,strm.match_length=strm.prev_length=2,strm.match_available=0,strm.ins_h=0);return ret}function deflateInit2(strm,level,\nmethod,windowBits,memLevel,strategy){if(!strm)return-2;var wrap=1;-1===level&&(level=6);0>windowBits?(wrap=0,windowBits=-windowBits):15<windowBits&&(wrap=2,windowBits-=16);if(1>memLevel||9<memLevel||8!==method||8>windowBits||15<windowBits||0>level||9<level||0>strategy||4<strategy)return err(strm,-2);8===windowBits&&(windowBits=9);var s=new DeflateState;strm.state=s;s.strm=strm;s.wrap=wrap;s.gzhead=null;s.w_bits=windowBits;s.w_size=1<<s.w_bits;s.w_mask=s.w_size-1;s.hash_bits=memLevel+7;s.hash_size=\n1<<s.hash_bits;s.hash_mask=s.hash_size-1;s.hash_shift=~~((s.hash_bits+3-1)/3);s.window=new utils.Buf8(2*s.w_size);s.head=new utils.Buf16(s.hash_size);s.prev=new utils.Buf16(s.w_size);s.lit_bufsize=1<<memLevel+6;s.pending_buf_size=4*s.lit_bufsize;s.pending_buf=new utils.Buf8(s.pending_buf_size);s.d_buf=1*s.lit_bufsize;s.l_buf=3*s.lit_bufsize;s.level=level;s.strategy=strategy;s.method=method;return deflateReset(strm)}var utils=require(\"module$node_modules$pako$lib$utils$common\"),trees=require(\"module$node_modules$pako$lib$zlib$trees\"),\nadler32=require(\"module$node_modules$pako$lib$zlib$adler32\"),crc32=require(\"module$node_modules$pako$lib$zlib$crc32\"),msg=require(\"module$node_modules$pako$lib$zlib$messages\");var configuration_table=[new Config(0,0,0,0,function(s,flush){var max_block_size=65535;for(max_block_size>s.pending_buf_size-5&&(max_block_size=s.pending_buf_size-5);;){if(1>=s.lookahead){fill_window(s);if(0===s.lookahead&&0===flush)return 1;if(0===s.lookahead)break}s.strstart+=s.lookahead;s.lookahead=0;var max_start=s.block_start+\nmax_block_size;if(0===s.strstart||s.strstart>=max_start)if(s.lookahead=s.strstart-max_start,s.strstart=max_start,flush_block_only(s,!1),0===s.strm.avail_out)return 1;if(s.strstart-s.block_start>=s.w_size-262&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}s.insert=0;if(4===flush)return flush_block_only(s,!0),0===s.strm.avail_out?3:4;s.strstart>s.block_start&&flush_block_only(s,!1);return 1}),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),\nnew Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)];exports.deflateInit=function(strm,level){return deflateInit2(strm,level,8,15,8,0)};exports.deflateInit2=deflateInit2;exports.deflateReset=deflateReset;exports.deflateResetKeep=deflateResetKeep;exports.deflateSetHeader=function(strm,head){if(!strm||!strm.state||2!==strm.state.wrap)return-2;\nstrm.state.gzhead=head;return 0};exports.deflate=function(strm,flush){if(!strm||!strm.state||5<flush||0>flush)return strm?err(strm,-2):-2;var s=strm.state;if(!strm.output||!strm.input&&0!==strm.avail_in||666===s.status&&4!==flush)return err(strm,0===strm.avail_out?-5:-2);s.strm=strm;var old_flush=s.last_flush;s.last_flush=flush;if(42===s.status)if(2===s.wrap)strm.adler=0,put_byte(s,31),put_byte(s,139),put_byte(s,8),s.gzhead?(put_byte(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(s.gzhead.extra?4:0)+\n(s.gzhead.name?8:0)+(s.gzhead.comment?16:0)),put_byte(s,s.gzhead.time&255),put_byte(s,s.gzhead.time>>8&255),put_byte(s,s.gzhead.time>>16&255),put_byte(s,s.gzhead.time>>24&255),put_byte(s,9===s.level?2:2<=s.strategy||2>s.level?4:0),put_byte(s,s.gzhead.os&255),s.gzhead.extra&&s.gzhead.extra.length&&(put_byte(s,s.gzhead.extra.length&255),put_byte(s,s.gzhead.extra.length>>8&255)),s.gzhead.hcrc&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending,0)),s.gzindex=0,s.status=69):(put_byte(s,0),put_byte(s,\n0),put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,9===s.level?2:2<=s.strategy||2>s.level?4:0),put_byte(s,3),s.status=113);else{var beg=8+(s.w_bits-8<<4)<<8;beg|=(2<=s.strategy||2>s.level?0:6>s.level?1:6===s.level?2:3)<<6;0!==s.strstart&&(beg|=32);s.status=113;putShortMSB(s,beg+(31-beg%31));0!==s.strstart&&(putShortMSB(s,strm.adler>>>16),putShortMSB(s,strm.adler&65535));strm.adler=1}if(69===s.status)if(s.gzhead.extra){for(beg=s.pending;s.gzindex<(s.gzhead.extra.length&65535)&&(s.pending!==s.pending_buf_size||\n(s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),beg=s.pending,s.pending!==s.pending_buf_size));)put_byte(s,s.gzhead.extra[s.gzindex]&255),s.gzindex++;s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg));s.gzindex===s.gzhead.extra.length&&(s.gzindex=0,s.status=73)}else s.status=73;if(73===s.status)if(s.gzhead.name){beg=s.pending;do{if(s.pending===s.pending_buf_size&&(s.gzhead.hcrc&&s.pending>beg&&\n(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),beg=s.pending,s.pending===s.pending_buf_size)){var val=1;break}val=s.gzindex<s.gzhead.name.length?s.gzhead.name.charCodeAt(s.gzindex++)&255:0;put_byte(s,val)}while(0!==val);s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg));0===val&&(s.gzindex=0,s.status=91)}else s.status=91;if(91===s.status)if(s.gzhead.comment){beg=s.pending;do{if(s.pending===s.pending_buf_size&&(s.gzhead.hcrc&&\ns.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),beg=s.pending,s.pending===s.pending_buf_size)){val=1;break}val=s.gzindex<s.gzhead.comment.length?s.gzhead.comment.charCodeAt(s.gzindex++)&255:0;put_byte(s,val)}while(0!==val);s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg));0===val&&(s.status=103)}else s.status=103;103===s.status&&(s.gzhead.hcrc?(s.pending+2>s.pending_buf_size&&flush_pending(strm),s.pending+\n2<=s.pending_buf_size&&(put_byte(s,strm.adler&255),put_byte(s,strm.adler>>8&255),strm.adler=0,s.status=113)):s.status=113);if(0!==s.pending){if(flush_pending(strm),0===strm.avail_out)return s.last_flush=-1,0}else if(0===strm.avail_in&&(flush<<1)-(4<flush?9:0)<=(old_flush<<1)-(4<old_flush?9:0)&&4!==flush)return err(strm,-5);if(666===s.status&&0!==strm.avail_in)return err(strm,-5);if(0!==strm.avail_in||0!==s.lookahead||0!==flush&&666!==s.status){old_flush=2===s.strategy?deflate_huff(s,flush):3===s.strategy?\ndeflate_rle(s,flush):configuration_table[s.level].func(s,flush);if(3===old_flush||4===old_flush)s.status=666;if(1===old_flush||3===old_flush)return 0===strm.avail_out&&(s.last_flush=-1),0;if(2===old_flush&&(1===flush?trees._tr_align(s):5!==flush&&(trees._tr_stored_block(s,0,0,!1),3===flush&&(zero(s.head),0===s.lookahead&&(s.strstart=0,s.block_start=0,s.insert=0))),flush_pending(strm),0===strm.avail_out))return s.last_flush=-1,0}if(4!==flush)return 0;if(0>=s.wrap)return 1;2===s.wrap?(put_byte(s,strm.adler&\n255),put_byte(s,strm.adler>>8&255),put_byte(s,strm.adler>>16&255),put_byte(s,strm.adler>>24&255),put_byte(s,strm.total_in&255),put_byte(s,strm.total_in>>8&255),put_byte(s,strm.total_in>>16&255),put_byte(s,strm.total_in>>24&255)):(putShortMSB(s,strm.adler>>>16),putShortMSB(s,strm.adler&65535));flush_pending(strm);0<s.wrap&&(s.wrap=-s.wrap);return 0!==s.pending?0:1};exports.deflateEnd=function(strm){if(!strm||!strm.state)return-2;var status=strm.state.status;if(42!==status&&69!==status&&73!==status&&\n91!==status&&103!==status&&113!==status&&666!==status)return err(strm,-2);strm.state=null;return 113===status?err(strm,-3):0};exports.deflateSetDictionary=function(strm,dictionary){var dictLength=dictionary.length;if(!strm||!strm.state)return-2;var s=strm.state;var wrap=s.wrap;if(2===wrap||1===wrap&&42!==s.status||s.lookahead)return-2;1===wrap&&(strm.adler=adler32(strm.adler,dictionary,dictLength,0));s.wrap=0;if(dictLength>=s.w_size){0===wrap&&(zero(s.head),s.strstart=0,s.block_start=0,s.insert=0);\nvar avail=new utils.Buf8(s.w_size);utils.arraySet(avail,dictionary,dictLength-s.w_size,s.w_size,0);dictionary=avail;dictLength=s.w_size}avail=strm.avail_in;var next=strm.next_in;var input=strm.input;strm.avail_in=dictLength;strm.next_in=0;strm.input=dictionary;for(fill_window(s);3<=s.lookahead;){dictionary=s.strstart;dictLength=s.lookahead-2;do s.ins_h=(s.ins_h<<s.hash_shift^s.window[dictionary+3-1])&s.hash_mask,s.prev[dictionary&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=dictionary,dictionary++;while(--dictLength);\ns.strstart=dictionary;s.lookahead=2;fill_window(s)}s.strstart+=s.lookahead;s.block_start=s.strstart;s.insert=s.lookahead;s.lookahead=0;s.match_length=s.prev_length=2;s.match_available=0;strm.next_in=next;strm.input=input;strm.avail_in=avail;s.wrap=wrap;return 0};exports.deflateInfo=\"pako deflate (from Nodeca project)\"}","~:source","shadow$provide[\"module$node_modules$pako$lib$zlib$deflate\"] = function(global,require,module,exports) {\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$pako$lib$zlib$adler32","~$shadow.js","~$module$node_modules$pako$lib$zlib$trees","~$module$node_modules$pako$lib$utils$common","~$module$node_modules$pako$lib$zlib$crc32","~$module$node_modules$pako$lib$zlib$messages"]],"~:properties",["^5",["func","window","deflateReset","match_start","deflateSetDictionary","max_lazy","total_in","dyn_dtree","heap_len","prev_length","pending_buf","hash_shift","next_out","data_type","strategy","opt_len","deflateInfo","deflateInit2","d_desc","avail_out","msg","adler","bl_tree","prev_match","good_length","hash_mask","max_chain","bl_desc","method","pending_out","good_match","dyn_ltree","l_buf","hash_size","avail_in","lookahead","strm","gzhead","deflateInit","w_size","bi_buf","wrap","strstart","deflateSetHeader","level","max_lazy_match","hash_bits","status","prev","deflateResetKeep","d_buf","w_mask","bl_count","match_length","gzindex","input","last_flush","window_size","heap","pending_buf_size","head","w_bits","matches","ins_h","state","depth","lit_bufsize","insert","static_len","deflate","match_available","nice_match","l_desc","next_in","deflateEnd","heap_max","last_lit","pending","nice_length","total_out","max_chain_length","block_start","bi_valid"]],"~:compiled-at",1695040653752,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$pako$lib$zlib$deflate.js\",\n\"lineCount\":36,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/pako/lib/zlib/deflate.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$pako$lib$zlib$deflate\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\\n//\\n// This software is provided 'as-is', without any express or implied\\n// warranty. In no event will the authors be held liable for any damages\\n// arising from the use of this software.\\n//\\n// Permission is granted to anyone to use this software for any purpose,\\n// including commercial applications, and to alter it and redistribute it\\n// freely, subject to the following restrictions:\\n//\\n// 1. The origin of this software must not be misrepresented; you must not\\n//   claim that you wrote the original software. If you use this software\\n//   in a product, an acknowledgment in the product documentation would be\\n//   appreciated but is not required.\\n// 2. Altered source versions must be plainly marked as such, and must not be\\n//   misrepresented as being the original software.\\n// 3. This notice may not be removed or altered from any source distribution.\\n\\nvar utils   = require('../utils/common');\\nvar trees   = require('./trees');\\nvar adler32 = require('./adler32');\\nvar crc32   = require('./crc32');\\nvar msg     = require('./messages');\\n\\n/* Public constants ==========================================================*/\\n/* ===========================================================================*/\\n\\n\\n/* Allowed flush values; see deflate() and inflate() below for details */\\nvar Z_NO_FLUSH      = 0;\\nvar Z_PARTIAL_FLUSH = 1;\\n//var Z_SYNC_FLUSH    = 2;\\nvar Z_FULL_FLUSH    = 3;\\nvar Z_FINISH        = 4;\\nvar Z_BLOCK         = 5;\\n//var Z_TREES         = 6;\\n\\n\\n/* Return codes for the compression/decompression functions. Negative values\\n * are errors, positive values are used for special but normal events.\\n */\\nvar Z_OK            = 0;\\nvar Z_STREAM_END    = 1;\\n//var Z_NEED_DICT     = 2;\\n//var Z_ERRNO         = -1;\\nvar Z_STREAM_ERROR  = -2;\\nvar Z_DATA_ERROR    = -3;\\n//var Z_MEM_ERROR     = -4;\\nvar Z_BUF_ERROR     = -5;\\n//var Z_VERSION_ERROR = -6;\\n\\n\\n/* compression levels */\\n//var Z_NO_COMPRESSION      = 0;\\n//var Z_BEST_SPEED          = 1;\\n//var Z_BEST_COMPRESSION    = 9;\\nvar Z_DEFAULT_COMPRESSION = -1;\\n\\n\\nvar Z_FILTERED            = 1;\\nvar Z_HUFFMAN_ONLY        = 2;\\nvar Z_RLE                 = 3;\\nvar Z_FIXED               = 4;\\nvar Z_DEFAULT_STRATEGY    = 0;\\n\\n/* Possible values of the data_type field (though see inflate()) */\\n//var Z_BINARY              = 0;\\n//var Z_TEXT                = 1;\\n//var Z_ASCII               = 1; // = Z_TEXT\\nvar Z_UNKNOWN             = 2;\\n\\n\\n/* The deflate compression method */\\nvar Z_DEFLATED  = 8;\\n\\n/*============================================================================*/\\n\\n\\nvar MAX_MEM_LEVEL = 9;\\n/* Maximum value for memLevel in deflateInit2 */\\nvar MAX_WBITS = 15;\\n/* 32K LZ77 window */\\nvar DEF_MEM_LEVEL = 8;\\n\\n\\nvar LENGTH_CODES  = 29;\\n/* number of length codes, not counting the special END_BLOCK code */\\nvar LITERALS      = 256;\\n/* number of literal bytes 0..255 */\\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\\n/* number of Literal or Length codes, including the END_BLOCK code */\\nvar D_CODES       = 30;\\n/* number of distance codes */\\nvar BL_CODES      = 19;\\n/* number of codes used to transfer the bit lengths */\\nvar HEAP_SIZE     = 2 * L_CODES + 1;\\n/* maximum heap size */\\nvar MAX_BITS  = 15;\\n/* All codes must not exceed MAX_BITS bits */\\n\\nvar MIN_MATCH = 3;\\nvar MAX_MATCH = 258;\\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\\n\\nvar PRESET_DICT = 0x20;\\n\\nvar INIT_STATE = 42;\\nvar EXTRA_STATE = 69;\\nvar NAME_STATE = 73;\\nvar COMMENT_STATE = 91;\\nvar HCRC_STATE = 103;\\nvar BUSY_STATE = 113;\\nvar FINISH_STATE = 666;\\n\\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\\n\\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\\n\\nfunction err(strm, errorCode) {\\n  strm.msg = msg[errorCode];\\n  return errorCode;\\n}\\n\\nfunction rank(f) {\\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\\n}\\n\\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\\n\\n\\n/* =========================================================================\\n * Flush as much pending output as possible. All deflate() output goes\\n * through this function so some applications may wish to modify it\\n * to avoid allocating a large strm->output buffer and copying into it.\\n * (See also read_buf()).\\n */\\nfunction flush_pending(strm) {\\n  var s = strm.state;\\n\\n  //_tr_flush_bits(s);\\n  var len = s.pending;\\n  if (len > strm.avail_out) {\\n    len = strm.avail_out;\\n  }\\n  if (len === 0) { return; }\\n\\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\\n  strm.next_out += len;\\n  s.pending_out += len;\\n  strm.total_out += len;\\n  strm.avail_out -= len;\\n  s.pending -= len;\\n  if (s.pending === 0) {\\n    s.pending_out = 0;\\n  }\\n}\\n\\n\\nfunction flush_block_only(s, last) {\\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\\n  s.block_start = s.strstart;\\n  flush_pending(s.strm);\\n}\\n\\n\\nfunction put_byte(s, b) {\\n  s.pending_buf[s.pending++] = b;\\n}\\n\\n\\n/* =========================================================================\\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\\n * IN assertion: the stream state is correct and there is enough room in\\n * pending_buf.\\n */\\nfunction putShortMSB(s, b) {\\n//  put_byte(s, (Byte)(b >> 8));\\n//  put_byte(s, (Byte)(b & 0xff));\\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\\n  s.pending_buf[s.pending++] = b & 0xff;\\n}\\n\\n\\n/* ===========================================================================\\n * Read a new buffer from the current input stream, update the adler32\\n * and total number of bytes read.  All deflate() input goes through\\n * this function so some applications may wish to modify it to avoid\\n * allocating a large strm->input buffer and copying from it.\\n * (See also flush_pending()).\\n */\\nfunction read_buf(strm, buf, start, size) {\\n  var len = strm.avail_in;\\n\\n  if (len > size) { len = size; }\\n  if (len === 0) { return 0; }\\n\\n  strm.avail_in -= len;\\n\\n  // zmemcpy(buf, strm->next_in, len);\\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\\n  if (strm.state.wrap === 1) {\\n    strm.adler = adler32(strm.adler, buf, len, start);\\n  }\\n\\n  else if (strm.state.wrap === 2) {\\n    strm.adler = crc32(strm.adler, buf, len, start);\\n  }\\n\\n  strm.next_in += len;\\n  strm.total_in += len;\\n\\n  return len;\\n}\\n\\n\\n/* ===========================================================================\\n * Set match_start to the longest match starting at the given string and\\n * return its length. Matches shorter or equal to prev_length are discarded,\\n * in which case the result is equal to prev_length and match_start is\\n * garbage.\\n * IN assertions: cur_match is the head of the hash chain for the current\\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\\n * OUT assertion: the match length is not greater than s->lookahead.\\n */\\nfunction longest_match(s, cur_match) {\\n  var chain_length = s.max_chain_length;      /* max hash chain length */\\n  var scan = s.strstart; /* current string */\\n  var match;                       /* matched string */\\n  var len;                           /* length of current match */\\n  var best_len = s.prev_length;              /* best match length so far */\\n  var nice_match = s.nice_match;             /* stop if match long enough */\\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\\n\\n  var _win = s.window; // shortcut\\n\\n  var wmask = s.w_mask;\\n  var prev  = s.prev;\\n\\n  /* Stop when cur_match becomes <= limit. To simplify the code,\\n   * we prevent matches with the string of window index 0.\\n   */\\n\\n  var strend = s.strstart + MAX_MATCH;\\n  var scan_end1  = _win[scan + best_len - 1];\\n  var scan_end   = _win[scan + best_len];\\n\\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\\n   * It is easy to get rid of this optimization if necessary.\\n   */\\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \\\"Code too clever\\\");\\n\\n  /* Do not waste too much time if we already have a good match: */\\n  if (s.prev_length >= s.good_match) {\\n    chain_length >>= 2;\\n  }\\n  /* Do not look for matches beyond the end of the input. This is necessary\\n   * to make deflate deterministic.\\n   */\\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\\n\\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \\\"need lookahead\\\");\\n\\n  do {\\n    // Assert(cur_match < s->strstart, \\\"no future\\\");\\n    match = cur_match;\\n\\n    /* Skip to next match if the match length cannot increase\\n     * or if the match length is less than 2.  Note that the checks below\\n     * for insufficient lookahead only occur occasionally for performance\\n     * reasons.  Therefore uninitialized memory will be accessed, and\\n     * conditional jumps will be made that depend on those values.\\n     * However the length of the match is limited to the lookahead, so\\n     * the output of deflate is not affected by the uninitialized values.\\n     */\\n\\n    if (_win[match + best_len]     !== scan_end  ||\\n        _win[match + best_len - 1] !== scan_end1 ||\\n        _win[match]                !== _win[scan] ||\\n        _win[++match]              !== _win[scan + 1]) {\\n      continue;\\n    }\\n\\n    /* The check at best_len-1 can be removed because it will be made\\n     * again later. (This heuristic is not always a win.)\\n     * It is not necessary to compare scan[2] and match[2] since they\\n     * are always equal when the other bytes match, given that\\n     * the hash keys are equal and that HASH_BITS >= 8.\\n     */\\n    scan += 2;\\n    match++;\\n    // Assert(*scan == *match, \\\"match[2]?\\\");\\n\\n    /* We check for insufficient lookahead only every 8th comparison;\\n     * the 256th check will be made at strstart+258.\\n     */\\n    do {\\n      /*jshint noempty:false*/\\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\\n             scan < strend);\\n\\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \\\"wild scan\\\");\\n\\n    len = MAX_MATCH - (strend - scan);\\n    scan = strend - MAX_MATCH;\\n\\n    if (len > best_len) {\\n      s.match_start = cur_match;\\n      best_len = len;\\n      if (len >= nice_match) {\\n        break;\\n      }\\n      scan_end1  = _win[scan + best_len - 1];\\n      scan_end   = _win[scan + best_len];\\n    }\\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\\n\\n  if (best_len <= s.lookahead) {\\n    return best_len;\\n  }\\n  return s.lookahead;\\n}\\n\\n\\n/* ===========================================================================\\n * Fill the window when the lookahead becomes insufficient.\\n * Updates strstart and lookahead.\\n *\\n * IN assertion: lookahead < MIN_LOOKAHEAD\\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\\n *    At least one byte has been read, or avail_in == 0; reads are\\n *    performed for at least two bytes (required for the zip translate_eol\\n *    option -- not supported here).\\n */\\nfunction fill_window(s) {\\n  var _w_size = s.w_size;\\n  var p, n, m, more, str;\\n\\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \\\"already enough lookahead\\\");\\n\\n  do {\\n    more = s.window_size - s.lookahead - s.strstart;\\n\\n    // JS ints have 32 bit, block below not needed\\n    /* Deal with !@#$% 64K limit: */\\n    //if (sizeof(int) <= 2) {\\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\\n    //        more = wsize;\\n    //\\n    //  } else if (more == (unsigned)(-1)) {\\n    //        /* Very unlikely, but possible on 16 bit machine if\\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\\n    //         */\\n    //        more--;\\n    //    }\\n    //}\\n\\n\\n    /* If the window is almost full and there is insufficient lookahead,\\n     * move the upper half to the lower one to make room in the upper half.\\n     */\\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\\n\\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\\n      s.match_start -= _w_size;\\n      s.strstart -= _w_size;\\n      /* we now have strstart >= MAX_DIST */\\n      s.block_start -= _w_size;\\n\\n      /* Slide the hash table (could be avoided with 32 bit values\\n       at the expense of memory usage). We slide even when level == 0\\n       to keep the hash table consistent if we switch back to level > 0\\n       later. (Using level 0 permanently is not an optimal usage of\\n       zlib, so we don't care about this pathological case.)\\n       */\\n\\n      n = s.hash_size;\\n      p = n;\\n      do {\\n        m = s.head[--p];\\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\\n      } while (--n);\\n\\n      n = _w_size;\\n      p = n;\\n      do {\\n        m = s.prev[--p];\\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\\n        /* If n is not on any hash chain, prev[n] is garbage but\\n         * its value will never be used.\\n         */\\n      } while (--n);\\n\\n      more += _w_size;\\n    }\\n    if (s.strm.avail_in === 0) {\\n      break;\\n    }\\n\\n    /* If there was no sliding:\\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\\n     *    more == window_size - lookahead - strstart\\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\\n     * => more >= window_size - 2*WSIZE + 2\\n     * In the BIG_MEM or MMAP case (not yet supported),\\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\\n     */\\n    //Assert(more >= 2, \\\"more < 2\\\");\\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\\n    s.lookahead += n;\\n\\n    /* Initialize the hash value now that we have some input: */\\n    if (s.lookahead + s.insert >= MIN_MATCH) {\\n      str = s.strstart - s.insert;\\n      s.ins_h = s.window[str];\\n\\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\\n//#if MIN_MATCH != 3\\n//        Call update_hash() MIN_MATCH-3 more times\\n//#endif\\n      while (s.insert) {\\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\\n\\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\\n        s.head[s.ins_h] = str;\\n        str++;\\n        s.insert--;\\n        if (s.lookahead + s.insert < MIN_MATCH) {\\n          break;\\n        }\\n      }\\n    }\\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\\n     * but this is not important since only literal bytes will be emitted.\\n     */\\n\\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\\n\\n  /* If the WIN_INIT bytes after the end of the current data have never been\\n   * written, then zero those bytes in order to avoid memory check reports of\\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\\n   * the longest match routines.  Update the high water mark for the next\\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\\n   */\\n//  if (s.high_water < s.window_size) {\\n//    var curr = s.strstart + s.lookahead;\\n//    var init = 0;\\n//\\n//    if (s.high_water < curr) {\\n//      /* Previous high water mark below current data -- zero WIN_INIT\\n//       * bytes or up to end of window, whichever is less.\\n//       */\\n//      init = s.window_size - curr;\\n//      if (init > WIN_INIT)\\n//        init = WIN_INIT;\\n//      zmemzero(s->window + curr, (unsigned)init);\\n//      s->high_water = curr + init;\\n//    }\\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\\n//      /* High water mark at or above current data, but below current data\\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\\n//       * to end of window, whichever is less.\\n//       */\\n//      init = (ulg)curr + WIN_INIT - s->high_water;\\n//      if (init > s->window_size - s->high_water)\\n//        init = s->window_size - s->high_water;\\n//      zmemzero(s->window + s->high_water, (unsigned)init);\\n//      s->high_water += init;\\n//    }\\n//  }\\n//\\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\\n//    \\\"not enough room for search\\\");\\n}\\n\\n/* ===========================================================================\\n * Copy without compression as much as possible from the input stream, return\\n * the current block state.\\n * This function does not insert new strings in the dictionary since\\n * uncompressible data is probably not useful. This function is used\\n * only for the level=0 compression option.\\n * NOTE: this function should be optimized to avoid extra copying from\\n * window to pending_buf.\\n */\\nfunction deflate_stored(s, flush) {\\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\\n   * to pending_buf_size, and each stored block has a 5 byte header:\\n   */\\n  var max_block_size = 0xffff;\\n\\n  if (max_block_size > s.pending_buf_size - 5) {\\n    max_block_size = s.pending_buf_size - 5;\\n  }\\n\\n  /* Copy as much as possible from input to output: */\\n  for (;;) {\\n    /* Fill the window as much as possible: */\\n    if (s.lookahead <= 1) {\\n\\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\\n      //  s->block_start >= (long)s->w_size, \\\"slide too late\\\");\\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\\n//        s.block_start >= s.w_size)) {\\n//        throw  new Error(\\\"slide too late\\\");\\n//      }\\n\\n      fill_window(s);\\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\\n        return BS_NEED_MORE;\\n      }\\n\\n      if (s.lookahead === 0) {\\n        break;\\n      }\\n      /* flush the current block */\\n    }\\n    //Assert(s->block_start >= 0L, \\\"block gone\\\");\\n//    if (s.block_start < 0) throw new Error(\\\"block gone\\\");\\n\\n    s.strstart += s.lookahead;\\n    s.lookahead = 0;\\n\\n    /* Emit a stored block if pending_buf will be full: */\\n    var max_start = s.block_start + max_block_size;\\n\\n    if (s.strstart === 0 || s.strstart >= max_start) {\\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\\n      s.lookahead = s.strstart - max_start;\\n      s.strstart = max_start;\\n      /*** FLUSH_BLOCK(s, 0); ***/\\n      flush_block_only(s, false);\\n      if (s.strm.avail_out === 0) {\\n        return BS_NEED_MORE;\\n      }\\n      /***/\\n\\n\\n    }\\n    /* Flush if we may have to slide, otherwise block_start may become\\n     * negative and the data will be gone:\\n     */\\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\\n      /*** FLUSH_BLOCK(s, 0); ***/\\n      flush_block_only(s, false);\\n      if (s.strm.avail_out === 0) {\\n        return BS_NEED_MORE;\\n      }\\n      /***/\\n    }\\n  }\\n\\n  s.insert = 0;\\n\\n  if (flush === Z_FINISH) {\\n    /*** FLUSH_BLOCK(s, 1); ***/\\n    flush_block_only(s, true);\\n    if (s.strm.avail_out === 0) {\\n      return BS_FINISH_STARTED;\\n    }\\n    /***/\\n    return BS_FINISH_DONE;\\n  }\\n\\n  if (s.strstart > s.block_start) {\\n    /*** FLUSH_BLOCK(s, 0); ***/\\n    flush_block_only(s, false);\\n    if (s.strm.avail_out === 0) {\\n      return BS_NEED_MORE;\\n    }\\n    /***/\\n  }\\n\\n  return BS_NEED_MORE;\\n}\\n\\n/* ===========================================================================\\n * Compress as much as possible from the input stream, return the current\\n * block state.\\n * This function does not perform lazy evaluation of matches and inserts\\n * new strings in the dictionary only for unmatched strings or for short\\n * matches. It is used only for the fast compression options.\\n */\\nfunction deflate_fast(s, flush) {\\n  var hash_head;        /* head of the hash chain */\\n  var bflush;           /* set if current block must be flushed */\\n\\n  for (;;) {\\n    /* Make sure that we always have enough lookahead, except\\n     * at the end of the input file. We need MAX_MATCH bytes\\n     * for the next match, plus MIN_MATCH bytes to insert the\\n     * string following the next match.\\n     */\\n    if (s.lookahead < MIN_LOOKAHEAD) {\\n      fill_window(s);\\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\\n        return BS_NEED_MORE;\\n      }\\n      if (s.lookahead === 0) {\\n        break; /* flush the current block */\\n      }\\n    }\\n\\n    /* Insert the string window[strstart .. strstart+2] in the\\n     * dictionary, and set hash_head to the head of the hash chain:\\n     */\\n    hash_head = 0/*NIL*/;\\n    if (s.lookahead >= MIN_MATCH) {\\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\\n      s.head[s.ins_h] = s.strstart;\\n      /***/\\n    }\\n\\n    /* Find the longest match, discarding those <= prev_length.\\n     * At this point we have always match_length < MIN_MATCH\\n     */\\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\\n      /* To simplify the code, we prevent matches with the string\\n       * of window index 0 (in particular we have to avoid a match\\n       * of the string with itself at the start of the input file).\\n       */\\n      s.match_length = longest_match(s, hash_head);\\n      /* longest_match() sets match_start */\\n    }\\n    if (s.match_length >= MIN_MATCH) {\\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\\n\\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\\n                     s.match_length - MIN_MATCH, bflush); ***/\\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\\n\\n      s.lookahead -= s.match_length;\\n\\n      /* Insert new strings in the hash table only if the match length\\n       * is not too large. This saves time but degrades compression.\\n       */\\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\\n        s.match_length--; /* string at strstart already in table */\\n        do {\\n          s.strstart++;\\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\\n          s.head[s.ins_h] = s.strstart;\\n          /***/\\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\\n           * always MIN_MATCH bytes ahead.\\n           */\\n        } while (--s.match_length !== 0);\\n        s.strstart++;\\n      } else\\n      {\\n        s.strstart += s.match_length;\\n        s.match_length = 0;\\n        s.ins_h = s.window[s.strstart];\\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\\n\\n//#if MIN_MATCH != 3\\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\\n//#endif\\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\\n         * matter since it will be recomputed at next deflate call.\\n         */\\n      }\\n    } else {\\n      /* No match, output a literal byte */\\n      //Tracevv((stderr,\\\"%c\\\", s.window[s.strstart]));\\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\\n\\n      s.lookahead--;\\n      s.strstart++;\\n    }\\n    if (bflush) {\\n      /*** FLUSH_BLOCK(s, 0); ***/\\n      flush_block_only(s, false);\\n      if (s.strm.avail_out === 0) {\\n        return BS_NEED_MORE;\\n      }\\n      /***/\\n    }\\n  }\\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\\n  if (flush === Z_FINISH) {\\n    /*** FLUSH_BLOCK(s, 1); ***/\\n    flush_block_only(s, true);\\n    if (s.strm.avail_out === 0) {\\n      return BS_FINISH_STARTED;\\n    }\\n    /***/\\n    return BS_FINISH_DONE;\\n  }\\n  if (s.last_lit) {\\n    /*** FLUSH_BLOCK(s, 0); ***/\\n    flush_block_only(s, false);\\n    if (s.strm.avail_out === 0) {\\n      return BS_NEED_MORE;\\n    }\\n    /***/\\n  }\\n  return BS_BLOCK_DONE;\\n}\\n\\n/* ===========================================================================\\n * Same as above, but achieves better compression. We use a lazy\\n * evaluation for matches: a match is finally adopted only if there is\\n * no better match at the next window position.\\n */\\nfunction deflate_slow(s, flush) {\\n  var hash_head;          /* head of hash chain */\\n  var bflush;              /* set if current block must be flushed */\\n\\n  var max_insert;\\n\\n  /* Process the input block. */\\n  for (;;) {\\n    /* Make sure that we always have enough lookahead, except\\n     * at the end of the input file. We need MAX_MATCH bytes\\n     * for the next match, plus MIN_MATCH bytes to insert the\\n     * string following the next match.\\n     */\\n    if (s.lookahead < MIN_LOOKAHEAD) {\\n      fill_window(s);\\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\\n        return BS_NEED_MORE;\\n      }\\n      if (s.lookahead === 0) { break; } /* flush the current block */\\n    }\\n\\n    /* Insert the string window[strstart .. strstart+2] in the\\n     * dictionary, and set hash_head to the head of the hash chain:\\n     */\\n    hash_head = 0/*NIL*/;\\n    if (s.lookahead >= MIN_MATCH) {\\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\\n      s.head[s.ins_h] = s.strstart;\\n      /***/\\n    }\\n\\n    /* Find the longest match, discarding those <= prev_length.\\n     */\\n    s.prev_length = s.match_length;\\n    s.prev_match = s.match_start;\\n    s.match_length = MIN_MATCH - 1;\\n\\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\\n      /* To simplify the code, we prevent matches with the string\\n       * of window index 0 (in particular we have to avoid a match\\n       * of the string with itself at the start of the input file).\\n       */\\n      s.match_length = longest_match(s, hash_head);\\n      /* longest_match() sets match_start */\\n\\n      if (s.match_length <= 5 &&\\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\\n\\n        /* If prev_match is also MIN_MATCH, match_start is garbage\\n         * but we will ignore the current match anyway.\\n         */\\n        s.match_length = MIN_MATCH - 1;\\n      }\\n    }\\n    /* If there was a match at the previous step and the current\\n     * match is not better, output the previous match:\\n     */\\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\\n      /* Do not insert strings in hash table beyond this. */\\n\\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\\n\\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\\n                     s.prev_length - MIN_MATCH, bflush);***/\\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\\n      /* Insert in hash table all strings up to the end of the match.\\n       * strstart-1 and strstart are already inserted. If there is not\\n       * enough lookahead, the last two strings are not inserted in\\n       * the hash table.\\n       */\\n      s.lookahead -= s.prev_length - 1;\\n      s.prev_length -= 2;\\n      do {\\n        if (++s.strstart <= max_insert) {\\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\\n          s.head[s.ins_h] = s.strstart;\\n          /***/\\n        }\\n      } while (--s.prev_length !== 0);\\n      s.match_available = 0;\\n      s.match_length = MIN_MATCH - 1;\\n      s.strstart++;\\n\\n      if (bflush) {\\n        /*** FLUSH_BLOCK(s, 0); ***/\\n        flush_block_only(s, false);\\n        if (s.strm.avail_out === 0) {\\n          return BS_NEED_MORE;\\n        }\\n        /***/\\n      }\\n\\n    } else if (s.match_available) {\\n      /* If there was no match at the previous position, output a\\n       * single literal. If there was a match but the current match\\n       * is longer, truncate the previous match to a single literal.\\n       */\\n      //Tracevv((stderr,\\\"%c\\\", s->window[s->strstart-1]));\\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\\n\\n      if (bflush) {\\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\\n        flush_block_only(s, false);\\n        /***/\\n      }\\n      s.strstart++;\\n      s.lookahead--;\\n      if (s.strm.avail_out === 0) {\\n        return BS_NEED_MORE;\\n      }\\n    } else {\\n      /* There is no previous match to compare with, wait for\\n       * the next step to decide.\\n       */\\n      s.match_available = 1;\\n      s.strstart++;\\n      s.lookahead--;\\n    }\\n  }\\n  //Assert (flush != Z_NO_FLUSH, \\\"no flush?\\\");\\n  if (s.match_available) {\\n    //Tracevv((stderr,\\\"%c\\\", s->window[s->strstart-1]));\\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\\n\\n    s.match_available = 0;\\n  }\\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\\n  if (flush === Z_FINISH) {\\n    /*** FLUSH_BLOCK(s, 1); ***/\\n    flush_block_only(s, true);\\n    if (s.strm.avail_out === 0) {\\n      return BS_FINISH_STARTED;\\n    }\\n    /***/\\n    return BS_FINISH_DONE;\\n  }\\n  if (s.last_lit) {\\n    /*** FLUSH_BLOCK(s, 0); ***/\\n    flush_block_only(s, false);\\n    if (s.strm.avail_out === 0) {\\n      return BS_NEED_MORE;\\n    }\\n    /***/\\n  }\\n\\n  return BS_BLOCK_DONE;\\n}\\n\\n\\n/* ===========================================================================\\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\\n * deflate switches away from Z_RLE.)\\n */\\nfunction deflate_rle(s, flush) {\\n  var bflush;            /* set if current block must be flushed */\\n  var prev;              /* byte at distance one to match */\\n  var scan, strend;      /* scan goes up to strend for length of run */\\n\\n  var _win = s.window;\\n\\n  for (;;) {\\n    /* Make sure that we always have enough lookahead, except\\n     * at the end of the input file. We need MAX_MATCH bytes\\n     * for the longest run, plus one for the unrolled loop.\\n     */\\n    if (s.lookahead <= MAX_MATCH) {\\n      fill_window(s);\\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\\n        return BS_NEED_MORE;\\n      }\\n      if (s.lookahead === 0) { break; } /* flush the current block */\\n    }\\n\\n    /* See how many times the previous byte repeats */\\n    s.match_length = 0;\\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\\n      scan = s.strstart - 1;\\n      prev = _win[scan];\\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\\n        strend = s.strstart + MAX_MATCH;\\n        do {\\n          /*jshint noempty:false*/\\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\\n                 prev === _win[++scan] && prev === _win[++scan] &&\\n                 prev === _win[++scan] && prev === _win[++scan] &&\\n                 prev === _win[++scan] && prev === _win[++scan] &&\\n                 scan < strend);\\n        s.match_length = MAX_MATCH - (strend - scan);\\n        if (s.match_length > s.lookahead) {\\n          s.match_length = s.lookahead;\\n        }\\n      }\\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \\\"wild scan\\\");\\n    }\\n\\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\\n    if (s.match_length >= MIN_MATCH) {\\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\\n\\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\\n\\n      s.lookahead -= s.match_length;\\n      s.strstart += s.match_length;\\n      s.match_length = 0;\\n    } else {\\n      /* No match, output a literal byte */\\n      //Tracevv((stderr,\\\"%c\\\", s->window[s->strstart]));\\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\\n\\n      s.lookahead--;\\n      s.strstart++;\\n    }\\n    if (bflush) {\\n      /*** FLUSH_BLOCK(s, 0); ***/\\n      flush_block_only(s, false);\\n      if (s.strm.avail_out === 0) {\\n        return BS_NEED_MORE;\\n      }\\n      /***/\\n    }\\n  }\\n  s.insert = 0;\\n  if (flush === Z_FINISH) {\\n    /*** FLUSH_BLOCK(s, 1); ***/\\n    flush_block_only(s, true);\\n    if (s.strm.avail_out === 0) {\\n      return BS_FINISH_STARTED;\\n    }\\n    /***/\\n    return BS_FINISH_DONE;\\n  }\\n  if (s.last_lit) {\\n    /*** FLUSH_BLOCK(s, 0); ***/\\n    flush_block_only(s, false);\\n    if (s.strm.avail_out === 0) {\\n      return BS_NEED_MORE;\\n    }\\n    /***/\\n  }\\n  return BS_BLOCK_DONE;\\n}\\n\\n/* ===========================================================================\\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\\n * (It will be regenerated if this run of deflate switches away from Huffman.)\\n */\\nfunction deflate_huff(s, flush) {\\n  var bflush;             /* set if current block must be flushed */\\n\\n  for (;;) {\\n    /* Make sure that we have a literal to write. */\\n    if (s.lookahead === 0) {\\n      fill_window(s);\\n      if (s.lookahead === 0) {\\n        if (flush === Z_NO_FLUSH) {\\n          return BS_NEED_MORE;\\n        }\\n        break;      /* flush the current block */\\n      }\\n    }\\n\\n    /* Output a literal byte */\\n    s.match_length = 0;\\n    //Tracevv((stderr,\\\"%c\\\", s->window[s->strstart]));\\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\\n    s.lookahead--;\\n    s.strstart++;\\n    if (bflush) {\\n      /*** FLUSH_BLOCK(s, 0); ***/\\n      flush_block_only(s, false);\\n      if (s.strm.avail_out === 0) {\\n        return BS_NEED_MORE;\\n      }\\n      /***/\\n    }\\n  }\\n  s.insert = 0;\\n  if (flush === Z_FINISH) {\\n    /*** FLUSH_BLOCK(s, 1); ***/\\n    flush_block_only(s, true);\\n    if (s.strm.avail_out === 0) {\\n      return BS_FINISH_STARTED;\\n    }\\n    /***/\\n    return BS_FINISH_DONE;\\n  }\\n  if (s.last_lit) {\\n    /*** FLUSH_BLOCK(s, 0); ***/\\n    flush_block_only(s, false);\\n    if (s.strm.avail_out === 0) {\\n      return BS_NEED_MORE;\\n    }\\n    /***/\\n  }\\n  return BS_BLOCK_DONE;\\n}\\n\\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\\n * the desired pack level (0..9). The values given below have been tuned to\\n * exclude worst case performance for pathological files. Better values may be\\n * found for specific files.\\n */\\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\\n  this.good_length = good_length;\\n  this.max_lazy = max_lazy;\\n  this.nice_length = nice_length;\\n  this.max_chain = max_chain;\\n  this.func = func;\\n}\\n\\nvar configuration_table;\\n\\nconfiguration_table = [\\n  /*      good lazy nice chain */\\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\\n\\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\\n];\\n\\n\\n/* ===========================================================================\\n * Initialize the \\\"longest match\\\" routines for a new zlib stream\\n */\\nfunction lm_init(s) {\\n  s.window_size = 2 * s.w_size;\\n\\n  /*** CLEAR_HASH(s); ***/\\n  zero(s.head); // Fill with NIL (= 0);\\n\\n  /* Set the default configuration parameters:\\n   */\\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\\n  s.good_match = configuration_table[s.level].good_length;\\n  s.nice_match = configuration_table[s.level].nice_length;\\n  s.max_chain_length = configuration_table[s.level].max_chain;\\n\\n  s.strstart = 0;\\n  s.block_start = 0;\\n  s.lookahead = 0;\\n  s.insert = 0;\\n  s.match_length = s.prev_length = MIN_MATCH - 1;\\n  s.match_available = 0;\\n  s.ins_h = 0;\\n}\\n\\n\\nfunction DeflateState() {\\n  this.strm = null;            /* pointer back to this zlib stream */\\n  this.status = 0;            /* as the name implies */\\n  this.pending_buf = null;      /* output still pending */\\n  this.pending_buf_size = 0;  /* size of pending_buf */\\n  this.pending_out = 0;       /* next pending byte to output to the stream */\\n  this.pending = 0;           /* nb of bytes in the pending buffer */\\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\\n  this.gzhead = null;         /* gzip header information to write */\\n  this.gzindex = 0;           /* where in extra, name, or comment */\\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\\n\\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\\n  this.w_mask = 0;  /* w_size - 1 */\\n\\n  this.window = null;\\n  /* Sliding window. Input bytes are read into the second half of the window,\\n   * and move to the first half later to keep a dictionary of at least wSize\\n   * bytes. With this organization, matches are limited to a distance of\\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\\n   * performed with a length multiple of the block size.\\n   */\\n\\n  this.window_size = 0;\\n  /* Actual size of window: 2*wSize, except when the user input buffer\\n   * is directly used as sliding window.\\n   */\\n\\n  this.prev = null;\\n  /* Link to older string with same hash index. To limit the size of this\\n   * array to 64K, this link is maintained only for the last 32K strings.\\n   * An index in this array is thus a window index modulo 32K.\\n   */\\n\\n  this.head = null;   /* Heads of the hash chains or NIL. */\\n\\n  this.ins_h = 0;       /* hash index of string to be inserted */\\n  this.hash_size = 0;   /* number of elements in hash table */\\n  this.hash_bits = 0;   /* log2(hash_size) */\\n  this.hash_mask = 0;   /* hash_size-1 */\\n\\n  this.hash_shift = 0;\\n  /* Number of bits by which ins_h must be shifted at each input\\n   * step. It must be such that after MIN_MATCH steps, the oldest\\n   * byte no longer takes part in the hash key, that is:\\n   *   hash_shift * MIN_MATCH >= hash_bits\\n   */\\n\\n  this.block_start = 0;\\n  /* Window position at the beginning of the current output block. Gets\\n   * negative when the window is moved backwards.\\n   */\\n\\n  this.match_length = 0;      /* length of best match */\\n  this.prev_match = 0;        /* previous match */\\n  this.match_available = 0;   /* set if previous match exists */\\n  this.strstart = 0;          /* start of string to insert */\\n  this.match_start = 0;       /* start of matching string */\\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\\n\\n  this.prev_length = 0;\\n  /* Length of the best match at previous step. Matches not greater than this\\n   * are discarded. This is used in the lazy match evaluation.\\n   */\\n\\n  this.max_chain_length = 0;\\n  /* To speed up deflation, hash chains are never searched beyond this\\n   * length.  A higher limit improves compression ratio but degrades the\\n   * speed.\\n   */\\n\\n  this.max_lazy_match = 0;\\n  /* Attempt to find a better match only when the current match is strictly\\n   * smaller than this value. This mechanism is used only for compression\\n   * levels >= 4.\\n   */\\n  // That's alias to max_lazy_match, don't use directly\\n  //this.max_insert_length = 0;\\n  /* Insert new strings in the hash table only if the match length is not\\n   * greater than this length. This saves time but degrades compression.\\n   * max_insert_length is used only for compression levels <= 3.\\n   */\\n\\n  this.level = 0;     /* compression level (1..9) */\\n  this.strategy = 0;  /* favor or force Huffman coding*/\\n\\n  this.good_match = 0;\\n  /* Use a faster search when the previous match is longer than this */\\n\\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\\n\\n              /* used by trees.c: */\\n\\n  /* Didn't use ct_data typedef below to suppress compiler warning */\\n\\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\\n\\n  // Use flat array of DOUBLE size, with interleaved fata,\\n  // because JS does not support effective\\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\\n  zero(this.dyn_ltree);\\n  zero(this.dyn_dtree);\\n  zero(this.bl_tree);\\n\\n  this.l_desc   = null;         /* desc. for literal tree */\\n  this.d_desc   = null;         /* desc. for distance tree */\\n  this.bl_desc  = null;         /* desc. for bit length tree */\\n\\n  //ush bl_count[MAX_BITS+1];\\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\\n  /* number of codes at each bit length for an optimal tree */\\n\\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\\n  zero(this.heap);\\n\\n  this.heap_len = 0;               /* number of elements in the heap */\\n  this.heap_max = 0;               /* element of largest frequency */\\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\\n   * The same heap array is used to build all trees.\\n   */\\n\\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\\n  zero(this.depth);\\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\\n   */\\n\\n  this.l_buf = 0;          /* buffer index for literals or lengths */\\n\\n  this.lit_bufsize = 0;\\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\\n   * limiting lit_bufsize to 64K:\\n   *   - frequencies can be kept in 16 bit counters\\n   *   - if compression is not successful for the first block, all input\\n   *     data is still in the window so we can still emit a stored block even\\n   *     when input comes from standard input.  (This can also be done for\\n   *     all blocks if lit_bufsize is not greater than 32K.)\\n   *   - if compression is not successful for a file smaller than 64K, we can\\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\\n   *     This is applicable only for zip (not gzip or zlib).\\n   *   - creating new Huffman trees less frequently may not provide fast\\n   *     adaptation to changes in the input data statistics. (Take for\\n   *     example a binary file with poorly compressible code followed by\\n   *     a highly compressible string table.) Smaller buffer sizes give\\n   *     fast adaptation but have of course the overhead of transmitting\\n   *     trees more frequently.\\n   *   - I can't count above 4\\n   */\\n\\n  this.last_lit = 0;      /* running index in l_buf */\\n\\n  this.d_buf = 0;\\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\\n   * the same number of elements. To use different lengths, an extra flag\\n   * array would be necessary.\\n   */\\n\\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\\n  this.static_len = 0;    /* bit length of current block with static trees */\\n  this.matches = 0;       /* number of string matches in current block */\\n  this.insert = 0;        /* bytes at end of window left to insert */\\n\\n\\n  this.bi_buf = 0;\\n  /* Output buffer. bits are inserted starting at the bottom (least\\n   * significant bits).\\n   */\\n  this.bi_valid = 0;\\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\\n   * are always zero.\\n   */\\n\\n  // Used for window memory init. We safely ignore it for JS. That makes\\n  // sense only for pointers and memory check tools.\\n  //this.high_water = 0;\\n  /* High water mark offset in window for initialized bytes -- bytes above\\n   * this are set to zero in order to avoid memory check warnings when\\n   * longest match routines access bytes past the input.  This is then\\n   * updated to the new high water mark.\\n   */\\n}\\n\\n\\nfunction deflateResetKeep(strm) {\\n  var s;\\n\\n  if (!strm || !strm.state) {\\n    return err(strm, Z_STREAM_ERROR);\\n  }\\n\\n  strm.total_in = strm.total_out = 0;\\n  strm.data_type = Z_UNKNOWN;\\n\\n  s = strm.state;\\n  s.pending = 0;\\n  s.pending_out = 0;\\n\\n  if (s.wrap < 0) {\\n    s.wrap = -s.wrap;\\n    /* was made negative by deflate(..., Z_FINISH); */\\n  }\\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\\n  strm.adler = (s.wrap === 2) ?\\n    0  // crc32(0, Z_NULL, 0)\\n  :\\n    1; // adler32(0, Z_NULL, 0)\\n  s.last_flush = Z_NO_FLUSH;\\n  trees._tr_init(s);\\n  return Z_OK;\\n}\\n\\n\\nfunction deflateReset(strm) {\\n  var ret = deflateResetKeep(strm);\\n  if (ret === Z_OK) {\\n    lm_init(strm.state);\\n  }\\n  return ret;\\n}\\n\\n\\nfunction deflateSetHeader(strm, head) {\\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\\n  strm.state.gzhead = head;\\n  return Z_OK;\\n}\\n\\n\\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\\n  if (!strm) { // === Z_NULL\\n    return Z_STREAM_ERROR;\\n  }\\n  var wrap = 1;\\n\\n  if (level === Z_DEFAULT_COMPRESSION) {\\n    level = 6;\\n  }\\n\\n  if (windowBits < 0) { /* suppress zlib wrapper */\\n    wrap = 0;\\n    windowBits = -windowBits;\\n  }\\n\\n  else if (windowBits > 15) {\\n    wrap = 2;           /* write gzip wrapper instead */\\n    windowBits -= 16;\\n  }\\n\\n\\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\\n    strategy < 0 || strategy > Z_FIXED) {\\n    return err(strm, Z_STREAM_ERROR);\\n  }\\n\\n\\n  if (windowBits === 8) {\\n    windowBits = 9;\\n  }\\n  /* until 256-byte window bug fixed */\\n\\n  var s = new DeflateState();\\n\\n  strm.state = s;\\n  s.strm = strm;\\n\\n  s.wrap = wrap;\\n  s.gzhead = null;\\n  s.w_bits = windowBits;\\n  s.w_size = 1 << s.w_bits;\\n  s.w_mask = s.w_size - 1;\\n\\n  s.hash_bits = memLevel + 7;\\n  s.hash_size = 1 << s.hash_bits;\\n  s.hash_mask = s.hash_size - 1;\\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\\n\\n  s.window = new utils.Buf8(s.w_size * 2);\\n  s.head = new utils.Buf16(s.hash_size);\\n  s.prev = new utils.Buf16(s.w_size);\\n\\n  // Don't need mem init magic for JS.\\n  //s.high_water = 0;  /* nothing written to s->window yet */\\n\\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\\n\\n  s.pending_buf_size = s.lit_bufsize * 4;\\n\\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\\n  //s->pending_buf = (uchf *) overlay;\\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\\n\\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\\n  s.d_buf = 1 * s.lit_bufsize;\\n\\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\\n  s.l_buf = (1 + 2) * s.lit_bufsize;\\n\\n  s.level = level;\\n  s.strategy = strategy;\\n  s.method = method;\\n\\n  return deflateReset(strm);\\n}\\n\\nfunction deflateInit(strm, level) {\\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\\n}\\n\\n\\nfunction deflate(strm, flush) {\\n  var old_flush, s;\\n  var beg, val; // for gzip header write only\\n\\n  if (!strm || !strm.state ||\\n    flush > Z_BLOCK || flush < 0) {\\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\\n  }\\n\\n  s = strm.state;\\n\\n  if (!strm.output ||\\n      (!strm.input && strm.avail_in !== 0) ||\\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\\n  }\\n\\n  s.strm = strm; /* just in case */\\n  old_flush = s.last_flush;\\n  s.last_flush = flush;\\n\\n  /* Write the header */\\n  if (s.status === INIT_STATE) {\\n\\n    if (s.wrap === 2) { // GZIP header\\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\\n      put_byte(s, 31);\\n      put_byte(s, 139);\\n      put_byte(s, 8);\\n      if (!s.gzhead) { // s->gzhead == Z_NULL\\n        put_byte(s, 0);\\n        put_byte(s, 0);\\n        put_byte(s, 0);\\n        put_byte(s, 0);\\n        put_byte(s, 0);\\n        put_byte(s, s.level === 9 ? 2 :\\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\\n                     4 : 0));\\n        put_byte(s, OS_CODE);\\n        s.status = BUSY_STATE;\\n      }\\n      else {\\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\\n                    (s.gzhead.hcrc ? 2 : 0) +\\n                    (!s.gzhead.extra ? 0 : 4) +\\n                    (!s.gzhead.name ? 0 : 8) +\\n                    (!s.gzhead.comment ? 0 : 16)\\n        );\\n        put_byte(s, s.gzhead.time & 0xff);\\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\\n        put_byte(s, s.level === 9 ? 2 :\\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\\n                     4 : 0));\\n        put_byte(s, s.gzhead.os & 0xff);\\n        if (s.gzhead.extra && s.gzhead.extra.length) {\\n          put_byte(s, s.gzhead.extra.length & 0xff);\\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\\n        }\\n        if (s.gzhead.hcrc) {\\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\\n        }\\n        s.gzindex = 0;\\n        s.status = EXTRA_STATE;\\n      }\\n    }\\n    else // DEFLATE header\\n    {\\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\\n      var level_flags = -1;\\n\\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\\n        level_flags = 0;\\n      } else if (s.level < 6) {\\n        level_flags = 1;\\n      } else if (s.level === 6) {\\n        level_flags = 2;\\n      } else {\\n        level_flags = 3;\\n      }\\n      header |= (level_flags << 6);\\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\\n      header += 31 - (header % 31);\\n\\n      s.status = BUSY_STATE;\\n      putShortMSB(s, header);\\n\\n      /* Save the adler32 of the preset dictionary: */\\n      if (s.strstart !== 0) {\\n        putShortMSB(s, strm.adler >>> 16);\\n        putShortMSB(s, strm.adler & 0xffff);\\n      }\\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\\n    }\\n  }\\n\\n//#ifdef GZIP\\n  if (s.status === EXTRA_STATE) {\\n    if (s.gzhead.extra/* != Z_NULL*/) {\\n      beg = s.pending;  /* start of bytes to update crc */\\n\\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\\n        if (s.pending === s.pending_buf_size) {\\n          if (s.gzhead.hcrc && s.pending > beg) {\\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\\n          }\\n          flush_pending(strm);\\n          beg = s.pending;\\n          if (s.pending === s.pending_buf_size) {\\n            break;\\n          }\\n        }\\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\\n        s.gzindex++;\\n      }\\n      if (s.gzhead.hcrc && s.pending > beg) {\\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\\n      }\\n      if (s.gzindex === s.gzhead.extra.length) {\\n        s.gzindex = 0;\\n        s.status = NAME_STATE;\\n      }\\n    }\\n    else {\\n      s.status = NAME_STATE;\\n    }\\n  }\\n  if (s.status === NAME_STATE) {\\n    if (s.gzhead.name/* != Z_NULL*/) {\\n      beg = s.pending;  /* start of bytes to update crc */\\n      //int val;\\n\\n      do {\\n        if (s.pending === s.pending_buf_size) {\\n          if (s.gzhead.hcrc && s.pending > beg) {\\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\\n          }\\n          flush_pending(strm);\\n          beg = s.pending;\\n          if (s.pending === s.pending_buf_size) {\\n            val = 1;\\n            break;\\n          }\\n        }\\n        // JS specific: little magic to add zero terminator to end of string\\n        if (s.gzindex < s.gzhead.name.length) {\\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\\n        } else {\\n          val = 0;\\n        }\\n        put_byte(s, val);\\n      } while (val !== 0);\\n\\n      if (s.gzhead.hcrc && s.pending > beg) {\\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\\n      }\\n      if (val === 0) {\\n        s.gzindex = 0;\\n        s.status = COMMENT_STATE;\\n      }\\n    }\\n    else {\\n      s.status = COMMENT_STATE;\\n    }\\n  }\\n  if (s.status === COMMENT_STATE) {\\n    if (s.gzhead.comment/* != Z_NULL*/) {\\n      beg = s.pending;  /* start of bytes to update crc */\\n      //int val;\\n\\n      do {\\n        if (s.pending === s.pending_buf_size) {\\n          if (s.gzhead.hcrc && s.pending > beg) {\\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\\n          }\\n          flush_pending(strm);\\n          beg = s.pending;\\n          if (s.pending === s.pending_buf_size) {\\n            val = 1;\\n            break;\\n          }\\n        }\\n        // JS specific: little magic to add zero terminator to end of string\\n        if (s.gzindex < s.gzhead.comment.length) {\\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\\n        } else {\\n          val = 0;\\n        }\\n        put_byte(s, val);\\n      } while (val !== 0);\\n\\n      if (s.gzhead.hcrc && s.pending > beg) {\\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\\n      }\\n      if (val === 0) {\\n        s.status = HCRC_STATE;\\n      }\\n    }\\n    else {\\n      s.status = HCRC_STATE;\\n    }\\n  }\\n  if (s.status === HCRC_STATE) {\\n    if (s.gzhead.hcrc) {\\n      if (s.pending + 2 > s.pending_buf_size) {\\n        flush_pending(strm);\\n      }\\n      if (s.pending + 2 <= s.pending_buf_size) {\\n        put_byte(s, strm.adler & 0xff);\\n        put_byte(s, (strm.adler >> 8) & 0xff);\\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\\n        s.status = BUSY_STATE;\\n      }\\n    }\\n    else {\\n      s.status = BUSY_STATE;\\n    }\\n  }\\n//#endif\\n\\n  /* Flush as much pending output as possible */\\n  if (s.pending !== 0) {\\n    flush_pending(strm);\\n    if (strm.avail_out === 0) {\\n      /* Since avail_out is 0, deflate will be called again with\\n       * more output space, but possibly with both pending and\\n       * avail_in equal to zero. There won't be anything to do,\\n       * but this is not an error situation so make sure we\\n       * return OK instead of BUF_ERROR at next call of deflate:\\n       */\\n      s.last_flush = -1;\\n      return Z_OK;\\n    }\\n\\n    /* Make sure there is something to do and avoid duplicate consecutive\\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\\n     */\\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\\n    flush !== Z_FINISH) {\\n    return err(strm, Z_BUF_ERROR);\\n  }\\n\\n  /* User must not provide more input after the first FINISH: */\\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\\n    return err(strm, Z_BUF_ERROR);\\n  }\\n\\n  /* Start a new block or continue the current one.\\n   */\\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\\n        configuration_table[s.level].func(s, flush));\\n\\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\\n      s.status = FINISH_STATE;\\n    }\\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\\n      if (strm.avail_out === 0) {\\n        s.last_flush = -1;\\n        /* avoid BUF_ERROR next call, see above */\\n      }\\n      return Z_OK;\\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\\n       * of deflate should use the same flush parameter to make sure\\n       * that the flush is complete. So we don't have to output an\\n       * empty block here, this will be done at next call. This also\\n       * ensures that for a very small output buffer, we emit at most\\n       * one empty block.\\n       */\\n    }\\n    if (bstate === BS_BLOCK_DONE) {\\n      if (flush === Z_PARTIAL_FLUSH) {\\n        trees._tr_align(s);\\n      }\\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\\n\\n        trees._tr_stored_block(s, 0, 0, false);\\n        /* For a full flush, this empty block will be recognized\\n         * as a special marker by inflate_sync().\\n         */\\n        if (flush === Z_FULL_FLUSH) {\\n          /*** CLEAR_HASH(s); ***/             /* forget history */\\n          zero(s.head); // Fill with NIL (= 0);\\n\\n          if (s.lookahead === 0) {\\n            s.strstart = 0;\\n            s.block_start = 0;\\n            s.insert = 0;\\n          }\\n        }\\n      }\\n      flush_pending(strm);\\n      if (strm.avail_out === 0) {\\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\\n        return Z_OK;\\n      }\\n    }\\n  }\\n  //Assert(strm->avail_out > 0, \\\"bug2\\\");\\n  //if (strm.avail_out <= 0) { throw new Error(\\\"bug2\\\");}\\n\\n  if (flush !== Z_FINISH) { return Z_OK; }\\n  if (s.wrap <= 0) { return Z_STREAM_END; }\\n\\n  /* Write the trailer */\\n  if (s.wrap === 2) {\\n    put_byte(s, strm.adler & 0xff);\\n    put_byte(s, (strm.adler >> 8) & 0xff);\\n    put_byte(s, (strm.adler >> 16) & 0xff);\\n    put_byte(s, (strm.adler >> 24) & 0xff);\\n    put_byte(s, strm.total_in & 0xff);\\n    put_byte(s, (strm.total_in >> 8) & 0xff);\\n    put_byte(s, (strm.total_in >> 16) & 0xff);\\n    put_byte(s, (strm.total_in >> 24) & 0xff);\\n  }\\n  else\\n  {\\n    putShortMSB(s, strm.adler >>> 16);\\n    putShortMSB(s, strm.adler & 0xffff);\\n  }\\n\\n  flush_pending(strm);\\n  /* If avail_out is zero, the application will call deflate again\\n   * to flush the rest.\\n   */\\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\\n  /* write the trailer only once! */\\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\\n}\\n\\nfunction deflateEnd(strm) {\\n  var status;\\n\\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\\n    return Z_STREAM_ERROR;\\n  }\\n\\n  status = strm.state.status;\\n  if (status !== INIT_STATE &&\\n    status !== EXTRA_STATE &&\\n    status !== NAME_STATE &&\\n    status !== COMMENT_STATE &&\\n    status !== HCRC_STATE &&\\n    status !== BUSY_STATE &&\\n    status !== FINISH_STATE\\n  ) {\\n    return err(strm, Z_STREAM_ERROR);\\n  }\\n\\n  strm.state = null;\\n\\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\\n}\\n\\n\\n/* =========================================================================\\n * Initializes the compression dictionary from the given byte\\n * sequence without producing any compressed output.\\n */\\nfunction deflateSetDictionary(strm, dictionary) {\\n  var dictLength = dictionary.length;\\n\\n  var s;\\n  var str, n;\\n  var wrap;\\n  var avail;\\n  var next;\\n  var input;\\n  var tmpDict;\\n\\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\\n    return Z_STREAM_ERROR;\\n  }\\n\\n  s = strm.state;\\n  wrap = s.wrap;\\n\\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\\n    return Z_STREAM_ERROR;\\n  }\\n\\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\\n  if (wrap === 1) {\\n    /* adler32(strm->adler, dictionary, dictLength); */\\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\\n  }\\n\\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\\n\\n  /* if dictionary would fill window, just replace the history */\\n  if (dictLength >= s.w_size) {\\n    if (wrap === 0) {            /* already empty otherwise */\\n      /*** CLEAR_HASH(s); ***/\\n      zero(s.head); // Fill with NIL (= 0);\\n      s.strstart = 0;\\n      s.block_start = 0;\\n      s.insert = 0;\\n    }\\n    /* use the tail */\\n    // dictionary = dictionary.slice(dictLength - s.w_size);\\n    tmpDict = new utils.Buf8(s.w_size);\\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\\n    dictionary = tmpDict;\\n    dictLength = s.w_size;\\n  }\\n  /* insert dictionary into window and hash */\\n  avail = strm.avail_in;\\n  next = strm.next_in;\\n  input = strm.input;\\n  strm.avail_in = dictLength;\\n  strm.next_in = 0;\\n  strm.input = dictionary;\\n  fill_window(s);\\n  while (s.lookahead >= MIN_MATCH) {\\n    str = s.strstart;\\n    n = s.lookahead - (MIN_MATCH - 1);\\n    do {\\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\\n\\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\\n\\n      s.head[s.ins_h] = str;\\n      str++;\\n    } while (--n);\\n    s.strstart = str;\\n    s.lookahead = MIN_MATCH - 1;\\n    fill_window(s);\\n  }\\n  s.strstart += s.lookahead;\\n  s.block_start = s.strstart;\\n  s.insert = s.lookahead;\\n  s.lookahead = 0;\\n  s.match_length = s.prev_length = MIN_MATCH - 1;\\n  s.match_available = 0;\\n  strm.next_in = next;\\n  strm.input = input;\\n  strm.avail_in = avail;\\n  s.wrap = wrap;\\n  return Z_OK;\\n}\\n\\n\\nexports.deflateInit = deflateInit;\\nexports.deflateInit2 = deflateInit2;\\nexports.deflateReset = deflateReset;\\nexports.deflateResetKeep = deflateResetKeep;\\nexports.deflateSetHeader = deflateSetHeader;\\nexports.deflate = deflate;\\nexports.deflateEnd = deflateEnd;\\nexports.deflateSetDictionary = deflateSetDictionary;\\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\\n\\n/* Not implemented\\nexports.deflateBound = deflateBound;\\nexports.deflateCopy = deflateCopy;\\nexports.deflateParams = deflateParams;\\nexports.deflatePending = deflatePending;\\nexports.deflatePrime = deflatePrime;\\nexports.deflateTune = deflateTune;\\n*/\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"err\",\"strm\",\"errorCode\",\"msg\",\"zero\",\"buf\",\"len\",\"length\",\"flush_pending\",\"s\",\"state\",\"pending\",\"avail_out\",\"utils\",\"arraySet\",\"output\",\"pending_buf\",\"pending_out\",\"next_out\",\"total_out\",\"flush_block_only\",\"last\",\"trees\",\"_tr_flush_block\",\"block_start\",\"strstart\",\"put_byte\",\"b\",\"putShortMSB\",\"longest_match\",\"cur_match\",\"chain_length\",\"max_chain_length\",\"scan\",\"best_len\",\"prev_length\",\"nice_match\",\"limit\",\"w_size\",\"MIN_LOOKAHEAD\",\"_win\",\"window\",\"wmask\",\"w_mask\",\"prev\",\"strend\",\"MAX_MATCH\",\"scan_end1\",\"scan_end\",\"good_match\",\"lookahead\",\"match\",\"match_start\",\"fill_window\",\"_w_size\",\"n\",\"more\",\"window_size\",\"p\",\"hash_size\",\"m\",\"head\",\"avail_in\",\"input\",\"next_in\",\"start\",\"wrap\",\"adler\",\"adler32\",\"crc32\",\"total_in\",\"MIN_MATCH\",\"insert\",\"str\",\"ins_h\",\"hash_shift\",\"hash_mask\",\"deflate_fast\",\"flush\",\"hash_head\",\"Z_NO_FLUSH\",\"BS_NEED_MORE\",\"match_length\",\"bflush\",\"_tr_tally\",\"max_lazy_match\",\"Z_FINISH\",\"BS_FINISH_STARTED\",\"BS_FINISH_DONE\",\"last_lit\",\"BS_BLOCK_DONE\",\"deflate_slow\",\"max_insert\",\"prev_match\",\"Z_FILTERED\",\"strategy\",\"match_available\",\"deflate_rle\",\"deflate_huff\",\"Config\",\"good_length\",\"max_lazy\",\"nice_length\",\"max_chain\",\"func\",\"DeflateState\",\"status\",\"pending_buf_size\",\"gzhead\",\"gzindex\",\"method\",\"Z_DEFLATED\",\"last_flush\",\"w_bits\",\"level\",\"hash_bits\",\"dyn_ltree\",\"Buf16\",\"dyn_dtree\",\"bl_tree\",\"bl_desc\",\"d_desc\",\"l_desc\",\"bl_count\",\"heap\",\"heap_max\",\"heap_len\",\"depth\",\"bi_valid\",\"bi_buf\",\"matches\",\"static_len\",\"opt_len\",\"d_buf\",\"lit_bufsize\",\"l_buf\",\"deflateResetKeep\",\"Z_STREAM_ERROR\",\"data_type\",\"Z_UNKNOWN\",\"INIT_STATE\",\"BUSY_STATE\",\"_tr_init\",\"Z_OK\",\"deflateReset\",\"ret\",\"configuration_table\",\"deflateInit2\",\"windowBits\",\"memLevel\",\"Z_DEFAULT_COMPRESSION\",\"MAX_MEM_LEVEL\",\"Z_FIXED\",\"Buf8\",\"deflate_stored\",\"max_block_size\",\"max_start\",\"deflateInit\",\"MAX_WBITS\",\"DEF_MEM_LEVEL\",\"Z_DEFAULT_STRATEGY\",\"deflateSetHeader\",\"deflate\",\"Z_BLOCK\",\"FINISH_STATE\",\"Z_BUF_ERROR\",\"old_flush\",\"text\",\"hcrc\",\"extra\",\"name\",\"comment\",\"time\",\"Z_HUFFMAN_ONLY\",\"os\",\"EXTRA_STATE\",\"OS_CODE\",\"header\",\"level_flags\",\"PRESET_DICT\",\"beg\",\"NAME_STATE\",\"val\",\"charCodeAt\",\"COMMENT_STATE\",\"HCRC_STATE\",\"bstate\",\"Z_RLE\",\"Z_PARTIAL_FLUSH\",\"_tr_align\",\"_tr_stored_block\",\"Z_FULL_FLUSH\",\"Z_STREAM_END\",\"deflateEnd\",\"Z_DATA_ERROR\",\"deflateSetDictionary\",\"dictionary\",\"dictLength\",\"tmpDict\",\"avail\",\"next\",\"deflateInfo\"]\n}\n"]