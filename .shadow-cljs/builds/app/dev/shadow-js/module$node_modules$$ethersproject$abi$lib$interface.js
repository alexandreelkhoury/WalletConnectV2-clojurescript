["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/abi/lib/interface.js"],"~:js","shadow$provide.module$node_modules$$ethersproject$abi$lib$interface=function(global,require,module,exports){function wrapAccessError(property,error){property=Error(\"deferred error during ABI decoding triggered accessing \"+property);property.error=error;return property}var __extends=this&&this.__extends||function(){var extendStatics=function(d$jscomp$0,b$jscomp$0){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)Object.prototype.hasOwnProperty.call(b,\np)&&(d[p]=b[p])};return extendStatics(d$jscomp$0,b$jscomp$0)};return function(d,b){function __(){this.constructor=d}if(\"function\"!==typeof b&&null!==b)throw new TypeError(\"Class extends value \"+String(b)+\" is not a constructor or null\");extendStatics(d,b);d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,\"__esModule\",{value:!0});exports.Interface=exports.Indexed=exports.ErrorDescription=exports.TransactionDescription=exports.LogDescription=exports.checkResultErrors=\nvoid 0;var address_1=require(\"module$node_modules$$ethersproject$address$lib$index\"),bignumber_1=require(\"module$node_modules$$ethersproject$bignumber$lib$index\"),bytes_1=require(\"module$node_modules$$ethersproject$bytes$lib$index\"),hash_1=require(\"module$node_modules$$ethersproject$hash$lib$index\"),keccak256_1=require(\"module$node_modules$$ethersproject$keccak256$lib$index\"),properties_1=require(\"module$node_modules$$ethersproject$properties$lib$index\"),abi_coder_1=require(\"module$node_modules$$ethersproject$abi$lib$abi_coder\"),\nabstract_coder_1=require(\"module$node_modules$$ethersproject$abi$lib$coders$abstract_coder\");Object.defineProperty(exports,\"checkResultErrors\",{enumerable:!0,get:function(){return abstract_coder_1.checkResultErrors}});var fragments_1=require(\"module$node_modules$$ethersproject$abi$lib$fragments\"),logger_1=require(\"module$node_modules$$ethersproject$logger$lib$index\");global=require(\"module$node_modules$$ethersproject$abi$lib$_version\");var logger=new logger_1.Logger(global.version),LogDescription=\nfunction(_super){function LogDescription(){return null!==_super&&_super.apply(this,arguments)||this}__extends(LogDescription,_super);return LogDescription}(properties_1.Description);exports.LogDescription=LogDescription;var TransactionDescription=function(_super){function TransactionDescription(){return null!==_super&&_super.apply(this,arguments)||this}__extends(TransactionDescription,_super);return TransactionDescription}(properties_1.Description);exports.TransactionDescription=TransactionDescription;\nvar ErrorDescription=function(_super){function ErrorDescription(){return null!==_super&&_super.apply(this,arguments)||this}__extends(ErrorDescription,_super);return ErrorDescription}(properties_1.Description);exports.ErrorDescription=ErrorDescription;var Indexed=function(_super){function Indexed(){return null!==_super&&_super.apply(this,arguments)||this}__extends(Indexed,_super);Indexed.isIndexed=function(value){return!(!value||!value._isIndexed)};return Indexed}(properties_1.Description);exports.Indexed=\nIndexed;var BuiltinErrors={\"0x08c379a0\":{signature:\"Error(string)\",name:\"Error\",inputs:[\"string\"],reason:!0},\"0x4e487b71\":{signature:\"Panic(uint256)\",name:\"Panic\",inputs:[\"uint256\"]}};global=function(){function Interface(fragments){var _newTarget=this.constructor,_this=this,abi=[];abi=\"string\"===typeof fragments?JSON.parse(fragments):fragments;(0,properties_1.defineReadOnly)(this,\"fragments\",abi.map(function(fragment){return fragments_1.Fragment.from(fragment)}).filter(function(fragment){return null!=\nfragment}));(0,properties_1.defineReadOnly)(this,\"_abiCoder\",(0,properties_1.getStatic)(_newTarget,\"getAbiCoder\")());(0,properties_1.defineReadOnly)(this,\"functions\",{});(0,properties_1.defineReadOnly)(this,\"errors\",{});(0,properties_1.defineReadOnly)(this,\"events\",{});(0,properties_1.defineReadOnly)(this,\"structs\",{});this.fragments.forEach(function(fragment){switch(fragment.type){case \"constructor\":if(_this.deploy){logger.warn(\"duplicate definition - constructor\");return}(0,properties_1.defineReadOnly)(_this,\n\"deploy\",fragment);return;case \"function\":var bucket=_this.functions;break;case \"event\":bucket=_this.events;break;case \"error\":bucket=_this.errors;break;default:return}var signature=fragment.format();bucket[signature]?logger.warn(\"duplicate definition - \"+signature):bucket[signature]=fragment});this.deploy||(0,properties_1.defineReadOnly)(this,\"deploy\",fragments_1.ConstructorFragment.from({payable:!1,type:\"constructor\"}));(0,properties_1.defineReadOnly)(this,\"_isInterface\",!0)}Interface.prototype.format=\nfunction(format){format||(format=fragments_1.FormatTypes.full);format===fragments_1.FormatTypes.sighash&&logger.throwArgumentError(\"interface does not support formatting sighash\",\"format\",format);var abi=this.fragments.map(function(fragment){return fragment.format(format)});return format===fragments_1.FormatTypes.json?JSON.stringify(abi.map(function(j){return JSON.parse(j)})):abi};Interface.getAbiCoder=function(){return abi_coder_1.defaultAbiCoder};Interface.getAddress=function(address){return(0,address_1.getAddress)(address)};\nInterface.getSighash=function(fragment){return(0,bytes_1.hexDataSlice)((0,hash_1.id)(fragment.format()),0,4)};Interface.getEventTopic=function(eventFragment){return(0,hash_1.id)(eventFragment.format())};Interface.prototype.getFunction=function(nameOrSignatureOrSighash){if((0,bytes_1.isHexString)(nameOrSignatureOrSighash)){for(var name_1 in this.functions)if(nameOrSignatureOrSighash===this.getSighash(name_1))return this.functions[name_1];logger.throwArgumentError(\"no matching function\",\"sighash\",nameOrSignatureOrSighash)}if(-1===\nnameOrSignatureOrSighash.indexOf(\"(\")){var name_2=nameOrSignatureOrSighash.trim();nameOrSignatureOrSighash=Object.keys(this.functions).filter(function(f){return f.split(\"(\")[0]===name_2});0===nameOrSignatureOrSighash.length?logger.throwArgumentError(\"no matching function\",\"name\",name_2):1<nameOrSignatureOrSighash.length&&logger.throwArgumentError(\"multiple matching functions\",\"name\",name_2);return this.functions[nameOrSignatureOrSighash[0]]}(name_1=this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()])||\nlogger.throwArgumentError(\"no matching function\",\"signature\",nameOrSignatureOrSighash);return name_1};Interface.prototype.getEvent=function(nameOrSignatureOrTopic){if((0,bytes_1.isHexString)(nameOrSignatureOrTopic)){var topichash=nameOrSignatureOrTopic.toLowerCase(),name_3;for(name_3 in this.events)if(topichash===this.getEventTopic(name_3))return this.events[name_3];logger.throwArgumentError(\"no matching event\",\"topichash\",topichash)}if(-1===nameOrSignatureOrTopic.indexOf(\"(\")){var name_4=nameOrSignatureOrTopic.trim();\nnameOrSignatureOrTopic=Object.keys(this.events).filter(function(f){return f.split(\"(\")[0]===name_4});0===nameOrSignatureOrTopic.length?logger.throwArgumentError(\"no matching event\",\"name\",name_4):1<nameOrSignatureOrTopic.length&&logger.throwArgumentError(\"multiple matching events\",\"name\",name_4);return this.events[nameOrSignatureOrTopic[0]]}(topichash=this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()])||logger.throwArgumentError(\"no matching event\",\"signature\",nameOrSignatureOrTopic);\nreturn topichash};Interface.prototype.getError=function(nameOrSignatureOrSighash){if((0,bytes_1.isHexString)(nameOrSignatureOrSighash)){var getSighash=(0,properties_1.getStatic)(this.constructor,\"getSighash\"),name_5;for(name_5 in this.errors)if(nameOrSignatureOrSighash===getSighash(this.errors[name_5]))return this.errors[name_5];logger.throwArgumentError(\"no matching error\",\"sighash\",nameOrSignatureOrSighash)}if(-1===nameOrSignatureOrSighash.indexOf(\"(\")){var name_6=nameOrSignatureOrSighash.trim();\nnameOrSignatureOrSighash=Object.keys(this.errors).filter(function(f){return f.split(\"(\")[0]===name_6});0===nameOrSignatureOrSighash.length?logger.throwArgumentError(\"no matching error\",\"name\",name_6):1<nameOrSignatureOrSighash.length&&logger.throwArgumentError(\"multiple matching errors\",\"name\",name_6);return this.errors[nameOrSignatureOrSighash[0]]}(getSighash=this.errors[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()])||logger.throwArgumentError(\"no matching error\",\"signature\",\nnameOrSignatureOrSighash);return getSighash};Interface.prototype.getSighash=function(fragment){if(\"string\"===typeof fragment)try{fragment=this.getFunction(fragment)}catch(error){try{fragment=this.getError(fragment)}catch(_){throw error;}}return(0,properties_1.getStatic)(this.constructor,\"getSighash\")(fragment)};Interface.prototype.getEventTopic=function(eventFragment){\"string\"===typeof eventFragment&&(eventFragment=this.getEvent(eventFragment));return(0,properties_1.getStatic)(this.constructor,\"getEventTopic\")(eventFragment)};\nInterface.prototype._decodeParams=function(params,data){return this._abiCoder.decode(params,data)};Interface.prototype._encodeParams=function(params,values){return this._abiCoder.encode(params,values)};Interface.prototype.encodeDeploy=function(values){return this._encodeParams(this.deploy.inputs,values||[])};Interface.prototype.decodeErrorResult=function(fragment,data){\"string\"===typeof fragment&&(fragment=this.getError(fragment));data=(0,bytes_1.arrayify)(data);(0,bytes_1.hexlify)(data.slice(0,4))!==\nthis.getSighash(fragment)&&logger.throwArgumentError(\"data signature does not match error \"+fragment.name+\".\",\"data\",(0,bytes_1.hexlify)(data));return this._decodeParams(fragment.inputs,data.slice(4))};Interface.prototype.encodeErrorResult=function(fragment,values){\"string\"===typeof fragment&&(fragment=this.getError(fragment));return(0,bytes_1.hexlify)((0,bytes_1.concat)([this.getSighash(fragment),this._encodeParams(fragment.inputs,values||[])]))};Interface.prototype.decodeFunctionData=function(functionFragment,\ndata){\"string\"===typeof functionFragment&&(functionFragment=this.getFunction(functionFragment));data=(0,bytes_1.arrayify)(data);(0,bytes_1.hexlify)(data.slice(0,4))!==this.getSighash(functionFragment)&&logger.throwArgumentError(\"data signature does not match function \"+functionFragment.name+\".\",\"data\",(0,bytes_1.hexlify)(data));return this._decodeParams(functionFragment.inputs,data.slice(4))};Interface.prototype.encodeFunctionData=function(functionFragment,values){\"string\"===typeof functionFragment&&\n(functionFragment=this.getFunction(functionFragment));return(0,bytes_1.hexlify)((0,bytes_1.concat)([this.getSighash(functionFragment),this._encodeParams(functionFragment.inputs,values||[])]))};Interface.prototype.decodeFunctionResult=function(functionFragment,data){\"string\"===typeof functionFragment&&(functionFragment=this.getFunction(functionFragment));var bytes=(0,bytes_1.arrayify)(data),reason=null,message=\"\",errorArgs=null,errorName=null,errorSignature=null;switch(bytes.length%this._abiCoder._getWordSize()){case 0:try{return this._abiCoder.decode(functionFragment.outputs,\nbytes)}catch(error){}break;case 4:var selector=(0,bytes_1.hexlify)(bytes.slice(0,4)),builtin=BuiltinErrors[selector];if(builtin)errorArgs=this._abiCoder.decode(builtin.inputs,bytes.slice(4)),errorName=builtin.name,errorSignature=builtin.signature,builtin.reason&&(reason=errorArgs[0]),\"Error\"===errorName?message=\"; VM Exception while processing transaction: reverted with reason string \"+JSON.stringify(errorArgs[0]):\"Panic\"===errorName&&(message=\"; VM Exception while processing transaction: reverted with panic code \"+\nerrorArgs[0]);else try{var error$jscomp$0=this.getError(selector);errorArgs=this._abiCoder.decode(error$jscomp$0.inputs,bytes.slice(4));errorName=error$jscomp$0.name;errorSignature=error$jscomp$0.format()}catch(error){}}return logger.throwError(\"call revert exception\"+message,logger_1.Logger.errors.CALL_EXCEPTION,{method:functionFragment.format(),data:(0,bytes_1.hexlify)(data),errorArgs,errorName,errorSignature,reason})};Interface.prototype.encodeFunctionResult=function(functionFragment,values){\"string\"===\ntypeof functionFragment&&(functionFragment=this.getFunction(functionFragment));return(0,bytes_1.hexlify)(this._abiCoder.encode(functionFragment.outputs,values||[]))};Interface.prototype.encodeFilterTopics=function(eventFragment,values){var _this=this;\"string\"===typeof eventFragment&&(eventFragment=this.getEvent(eventFragment));values.length>eventFragment.inputs.length&&logger.throwError(\"too many arguments for \"+eventFragment.format(),logger_1.Logger.errors.UNEXPECTED_ARGUMENT,{argument:\"values\",\nvalue:values});var topics=[];eventFragment.anonymous||topics.push(this.getEventTopic(eventFragment));var encodeTopic=function(param,value){if(\"string\"===param.type)return(0,hash_1.id)(value);if(\"bytes\"===param.type)return(0,keccak256_1.keccak256)((0,bytes_1.hexlify)(value));\"bool\"===param.type&&\"boolean\"===typeof value&&(value=value?\"0x01\":\"0x00\");param.type.match(/^u?int/)&&(value=bignumber_1.BigNumber.from(value).toHexString());\"address\"===param.type&&_this._abiCoder.encode([\"address\"],[value]);\nreturn(0,bytes_1.hexZeroPad)((0,bytes_1.hexlify)(value),32)};for(values.forEach(function(value$jscomp$0,index){var param=eventFragment.inputs[index];param.indexed?null==value$jscomp$0?topics.push(null):\"array\"===param.baseType||\"tuple\"===param.baseType?logger.throwArgumentError(\"filtering with tuples or arrays not supported\",\"contract.\"+param.name,value$jscomp$0):Array.isArray(value$jscomp$0)?topics.push(value$jscomp$0.map(function(value){return encodeTopic(param,value)})):topics.push(encodeTopic(param,\nvalue$jscomp$0)):null!=value$jscomp$0&&logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\",\"contract.\"+param.name,value$jscomp$0)});topics.length&&null===topics[topics.length-1];)topics.pop();return topics};Interface.prototype.encodeEventLog=function(eventFragment,values){var _this=this;\"string\"===typeof eventFragment&&(eventFragment=this.getEvent(eventFragment));var topics=[],dataTypes=[],dataValues=[];eventFragment.anonymous||topics.push(this.getEventTopic(eventFragment));\nvalues.length!==eventFragment.inputs.length&&logger.throwArgumentError(\"event arguments/values mismatch\",\"values\",values);eventFragment.inputs.forEach(function(param,index){index=values[index];if(param.indexed)if(\"string\"===param.type)topics.push((0,hash_1.id)(index));else if(\"bytes\"===param.type)topics.push((0,keccak256_1.keccak256)(index));else{if(\"tuple\"===param.baseType||\"array\"===param.baseType)throw Error(\"not implemented\");topics.push(_this._abiCoder.encode([param.type],[index]))}else dataTypes.push(param),\ndataValues.push(index)});return{data:this._abiCoder.encode(dataTypes,dataValues),topics}};Interface.prototype.decodeEventLog=function(eventFragment,data,topics){\"string\"===typeof eventFragment&&(eventFragment=this.getEvent(eventFragment));if(null!=topics&&!eventFragment.anonymous){var topicHash=this.getEventTopic(eventFragment);(0,bytes_1.isHexString)(topics[0],32)&&topics[0].toLowerCase()===topicHash||logger.throwError(\"fragment/topic mismatch\",logger_1.Logger.errors.INVALID_ARGUMENT,{argument:\"topics[0]\",\nexpected:topicHash,value:topics[0]});topics=topics.slice(1)}var indexed=[],nonIndexed=[],dynamic=[];eventFragment.inputs.forEach(function(param,index){param.indexed?\"string\"===param.type||\"bytes\"===param.type||\"tuple\"===param.baseType||\"array\"===param.baseType?(indexed.push(fragments_1.ParamType.fromObject({type:\"bytes32\",name:param.name})),dynamic.push(!0)):(indexed.push(param),dynamic.push(!1)):(nonIndexed.push(param),dynamic.push(!1))});var resultIndexed=null!=topics?this._abiCoder.decode(indexed,\n(0,bytes_1.concat)(topics)):null,resultNonIndexed=this._abiCoder.decode(nonIndexed,data,!0),result=[],nonIndexedIndex=0,indexedIndex=0;eventFragment.inputs.forEach(function(param,index){if(param.indexed)if(null==resultIndexed)result[index]=new Indexed({_isIndexed:!0,hash:null});else if(dynamic[index])result[index]=new Indexed({_isIndexed:!0,hash:resultIndexed[indexedIndex++]});else try{result[index]=resultIndexed[indexedIndex++]}catch(error){result[index]=error}else try{result[index]=resultNonIndexed[nonIndexedIndex++]}catch(error){result[index]=\nerror}if(param.name&&null==result[param.name]){var value_1=result[index];value_1 instanceof Error?Object.defineProperty(result,param.name,{enumerable:!0,get:function(){throw wrapAccessError(\"property \"+JSON.stringify(param.name),value_1);}}):result[param.name]=value_1}});eventFragment=function(i){var value=result[i];value instanceof Error&&Object.defineProperty(result,i,{enumerable:!0,get:function(){throw wrapAccessError(\"index \"+i,value);}})};for(data=0;data<result.length;data++)eventFragment(data);\nreturn Object.freeze(result)};Interface.prototype.parseTransaction=function(tx){var fragment=this.getFunction(tx.data.substring(0,10).toLowerCase());return fragment?new TransactionDescription({args:this._abiCoder.decode(fragment.inputs,\"0x\"+tx.data.substring(10)),functionFragment:fragment,name:fragment.name,signature:fragment.format(),sighash:this.getSighash(fragment),value:bignumber_1.BigNumber.from(tx.value||\"0\")}):null};Interface.prototype.parseLog=function(log){var fragment=this.getEvent(log.topics[0]);\nreturn!fragment||fragment.anonymous?null:new LogDescription({eventFragment:fragment,name:fragment.name,signature:fragment.format(),topic:this.getEventTopic(fragment),args:this.decodeEventLog(fragment,log.data,log.topics)})};Interface.prototype.parseError=function(data){data=(0,bytes_1.hexlify)(data);var fragment=this.getError(data.substring(0,10).toLowerCase());return fragment?new ErrorDescription({args:this._abiCoder.decode(fragment.inputs,\"0x\"+data.substring(10)),errorFragment:fragment,name:fragment.name,\nsignature:fragment.format(),sighash:this.getSighash(fragment)}):null};Interface.isInterface=function(value){return!(!value||!value._isInterface)};return Interface}();exports.Interface=global}","~:source","shadow$provide[\"module$node_modules$$ethersproject$abi$lib$interface\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = void 0;\nvar address_1 = require(\"@ethersproject/address\");\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\nvar bytes_1 = require(\"@ethersproject/bytes\");\nvar hash_1 = require(\"@ethersproject/hash\");\nvar keccak256_1 = require(\"@ethersproject/keccak256\");\nvar properties_1 = require(\"@ethersproject/properties\");\nvar abi_coder_1 = require(\"./abi-coder\");\nvar abstract_coder_1 = require(\"./coders/abstract-coder\");\nObject.defineProperty(exports, \"checkResultErrors\", { enumerable: true, get: function () { return abstract_coder_1.checkResultErrors; } });\nvar fragments_1 = require(\"./fragments\");\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar LogDescription = /** @class */ (function (_super) {\n    __extends(LogDescription, _super);\n    function LogDescription() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LogDescription;\n}(properties_1.Description));\nexports.LogDescription = LogDescription;\nvar TransactionDescription = /** @class */ (function (_super) {\n    __extends(TransactionDescription, _super);\n    function TransactionDescription() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return TransactionDescription;\n}(properties_1.Description));\nexports.TransactionDescription = TransactionDescription;\nvar ErrorDescription = /** @class */ (function (_super) {\n    __extends(ErrorDescription, _super);\n    function ErrorDescription() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ErrorDescription;\n}(properties_1.Description));\nexports.ErrorDescription = ErrorDescription;\nvar Indexed = /** @class */ (function (_super) {\n    __extends(Indexed, _super);\n    function Indexed() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Indexed.isIndexed = function (value) {\n        return !!(value && value._isIndexed);\n    };\n    return Indexed;\n}(properties_1.Description));\nexports.Indexed = Indexed;\nvar BuiltinErrors = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [\"string\"], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [\"uint256\"] }\n};\nfunction wrapAccessError(property, error) {\n    var wrap = new Error(\"deferred error during ABI decoding triggered accessing \" + property);\n    wrap.error = error;\n    return wrap;\n}\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nvar Interface = /** @class */ (function () {\n    function Interface(fragments) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        var abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        (0, properties_1.defineReadOnly)(this, \"fragments\", abi.map(function (fragment) {\n            return fragments_1.Fragment.from(fragment);\n        }).filter(function (fragment) { return (fragment != null); }));\n        (0, properties_1.defineReadOnly)(this, \"_abiCoder\", (0, properties_1.getStatic)(_newTarget, \"getAbiCoder\")());\n        (0, properties_1.defineReadOnly)(this, \"functions\", {});\n        (0, properties_1.defineReadOnly)(this, \"errors\", {});\n        (0, properties_1.defineReadOnly)(this, \"events\", {});\n        (0, properties_1.defineReadOnly)(this, \"structs\", {});\n        // Add all fragments by their signature\n        this.fragments.forEach(function (fragment) {\n            var bucket = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (_this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0, properties_1.defineReadOnly)(_this, \"deploy\", fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = _this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = _this.events;\n                    break;\n                case \"error\":\n                    bucket = _this.errors;\n                    break;\n                default:\n                    return;\n            }\n            var signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n            bucket[signature] = fragment;\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0, properties_1.defineReadOnly)(this, \"deploy\", fragments_1.ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n        (0, properties_1.defineReadOnly)(this, \"_isInterface\", true);\n    }\n    Interface.prototype.format = function (format) {\n        if (!format) {\n            format = fragments_1.FormatTypes.full;\n        }\n        if (format === fragments_1.FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n        var abi = this.fragments.map(function (fragment) { return fragment.format(format); });\n        // We need to re-bundle the JSON fragments a bit\n        if (format === fragments_1.FormatTypes.json) {\n            return JSON.stringify(abi.map(function (j) { return JSON.parse(j); }));\n        }\n        return abi;\n    };\n    // Sub-classes can override these to handle other blockchains\n    Interface.getAbiCoder = function () {\n        return abi_coder_1.defaultAbiCoder;\n    };\n    Interface.getAddress = function (address) {\n        return (0, address_1.getAddress)(address);\n    };\n    Interface.getSighash = function (fragment) {\n        return (0, bytes_1.hexDataSlice)((0, hash_1.id)(fragment.format()), 0, 4);\n    };\n    Interface.getEventTopic = function (eventFragment) {\n        return (0, hash_1.id)(eventFragment.format());\n    };\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    Interface.prototype.getFunction = function (nameOrSignatureOrSighash) {\n        if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {\n            for (var name_1 in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name_1)) {\n                    return this.functions[name_1];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            var name_2 = nameOrSignatureOrSighash.trim();\n            var matching = Object.keys(this.functions).filter(function (f) { return (f.split(\"(\" /* fix:) */)[0] === name_2); });\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name_2);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name_2);\n            }\n            return this.functions[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        var result = this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    };\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    Interface.prototype.getEvent = function (nameOrSignatureOrTopic) {\n        if ((0, bytes_1.isHexString)(nameOrSignatureOrTopic)) {\n            var topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (var name_3 in this.events) {\n                if (topichash === this.getEventTopic(name_3)) {\n                    return this.events[name_3];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            var name_4 = nameOrSignatureOrTopic.trim();\n            var matching = Object.keys(this.events).filter(function (f) { return (f.split(\"(\" /* fix:) */)[0] === name_4); });\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name_4);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name_4);\n            }\n            return this.events[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        var result = this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    };\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    Interface.prototype.getError = function (nameOrSignatureOrSighash) {\n        if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {\n            var getSighash = (0, properties_1.getStatic)(this.constructor, \"getSighash\");\n            for (var name_5 in this.errors) {\n                var error = this.errors[name_5];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name_5];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            var name_6 = nameOrSignatureOrSighash.trim();\n            var matching = Object.keys(this.errors).filter(function (f) { return (f.split(\"(\" /* fix:) */)[0] === name_6); });\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name_6);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name_6);\n            }\n            return this.errors[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        var result = this.errors[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    };\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    Interface.prototype.getSighash = function (fragment) {\n        if (typeof (fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            }\n            catch (error) {\n                try {\n                    fragment = this.getError(fragment);\n                }\n                catch (_) {\n                    throw error;\n                }\n            }\n        }\n        return (0, properties_1.getStatic)(this.constructor, \"getSighash\")(fragment);\n    };\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    Interface.prototype.getEventTopic = function (eventFragment) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        return (0, properties_1.getStatic)(this.constructor, \"getEventTopic\")(eventFragment);\n    };\n    Interface.prototype._decodeParams = function (params, data) {\n        return this._abiCoder.decode(params, data);\n    };\n    Interface.prototype._encodeParams = function (params, values) {\n        return this._abiCoder.encode(params, values);\n    };\n    Interface.prototype.encodeDeploy = function (values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    };\n    Interface.prototype.decodeErrorResult = function (fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        var bytes = (0, bytes_1.arrayify)(data);\n        if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(\"data signature does not match error \" + fragment.name + \".\", \"data\", (0, bytes_1.hexlify)(bytes));\n        }\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    };\n    Interface.prototype.encodeErrorResult = function (fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        return (0, bytes_1.hexlify)((0, bytes_1.concat)([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [])\n        ]));\n    };\n    // Decode the data for a function call (e.g. tx.data)\n    Interface.prototype.decodeFunctionData = function (functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        var bytes = (0, bytes_1.arrayify)(data);\n        if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(\"data signature does not match function \" + functionFragment.name + \".\", \"data\", (0, bytes_1.hexlify)(bytes));\n        }\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    };\n    // Encode the data for a function call (e.g. tx.data)\n    Interface.prototype.encodeFunctionData = function (functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return (0, bytes_1.hexlify)((0, bytes_1.concat)([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [])\n        ]));\n    };\n    // Decode the result from a function call (e.g. from eth_call)\n    Interface.prototype.decodeFunctionResult = function (functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        var bytes = (0, bytes_1.arrayify)(data);\n        var reason = null;\n        var message = \"\";\n        var errorArgs = null;\n        var errorName = null;\n        var errorSignature = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                }\n                catch (error) { }\n                break;\n            case 4: {\n                var selector = (0, bytes_1.hexlify)(bytes.slice(0, 4));\n                var builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) {\n                        reason = errorArgs[0];\n                    }\n                    if (errorName === \"Error\") {\n                        message = \"; VM Exception while processing transaction: reverted with reason string \" + JSON.stringify(errorArgs[0]);\n                    }\n                    else if (errorName === \"Panic\") {\n                        message = \"; VM Exception while processing transaction: reverted with panic code \" + errorArgs[0];\n                    }\n                }\n                else {\n                    try {\n                        var error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    }\n                    catch (error) { }\n                }\n                break;\n            }\n        }\n        return logger.throwError(\"call revert exception\" + message, logger_1.Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: (0, bytes_1.hexlify)(data),\n            errorArgs: errorArgs,\n            errorName: errorName,\n            errorSignature: errorSignature,\n            reason: reason\n        });\n    };\n    // Encode the result for a function call (e.g. for eth_call)\n    Interface.prototype.encodeFunctionResult = function (functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return (0, bytes_1.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));\n    };\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    Interface.prototype.encodeFilterTopics = function (eventFragment, values) {\n        var _this = this;\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            });\n        }\n        var topics = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        var encodeTopic = function (param, value) {\n            if (param.type === \"string\") {\n                return (0, hash_1.id)(value);\n            }\n            else if (param.type === \"bytes\") {\n                return (0, keccak256_1.keccak256)((0, bytes_1.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\n                value = (value ? \"0x01\" : \"0x00\");\n            }\n            if (param.type.match(/^u?int/)) {\n                value = bignumber_1.BigNumber.from(value).toHexString();\n            }\n            // Check addresses are valid\n            if (param.type === \"address\") {\n                _this._abiCoder.encode([\"address\"], [value]);\n            }\n            return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);\n        };\n        values.forEach(function (value, index) {\n            var param = eventFragment.inputs[index];\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map(function (value) { return encodeTopic(param, value); }));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    };\n    Interface.prototype.encodeEventLog = function (eventFragment, values) {\n        var _this = this;\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        var topics = [];\n        var dataTypes = [];\n        var dataValues = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n        eventFragment.inputs.forEach(function (param, index) {\n            var value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0, hash_1.id)(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push((0, keccak256_1.keccak256)(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(_this._abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this._abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    };\n    // Decode a filter for the event and the search criteria\n    Interface.prototype.decodeEventLog = function (eventFragment, data, topics) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (topics != null && !eventFragment.anonymous) {\n            var topicHash = this.getEventTopic(eventFragment);\n            if (!(0, bytes_1.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n        var indexed = [];\n        var nonIndexed = [];\n        var dynamic = [];\n        eventFragment.inputs.forEach(function (param, index) {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(fragments_1.ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        var resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, (0, bytes_1.concat)(topics)) : null;\n        var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n        var result = [];\n        var nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach(function (param, index) {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n                }\n                else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n                }\n                else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        result[index] = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    result[index] = error;\n                }\n            }\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                var value_1 = result[index];\n                // Make error named values throw on access\n                if (value_1 instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: function () { throw wrapAccessError(\"property \" + JSON.stringify(param.name), value_1); }\n                    });\n                }\n                else {\n                    result[param.name] = value_1;\n                }\n            }\n        });\n        var _loop_1 = function (i) {\n            var value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: function () { throw wrapAccessError(\"index \" + i, value); }\n                });\n            }\n        };\n        // Make all error indexed values throw on access\n        for (var i = 0; i < result.length; i++) {\n            _loop_1(i);\n        }\n        return Object.freeze(result);\n    };\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    Interface.prototype.parseTransaction = function (tx) {\n        var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: bignumber_1.BigNumber.from(tx.value || \"0\"),\n        });\n    };\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    Interface.prototype.parseLog = function (log) {\n        var fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    };\n    Interface.prototype.parseError = function (data) {\n        var hexData = (0, bytes_1.hexlify)(data);\n        var fragment = this.getError(hexData.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    };\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n    Interface.isInterface = function (value) {\n        return !!(value && value._isInterface);\n    };\n    return Interface;\n}());\nexports.Interface = Interface;\n//# sourceMappingURL=interface.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$ethersproject$bytes$lib$index","~$module$node_modules$$ethersproject$abi$lib$fragments","~$module$node_modules$$ethersproject$bignumber$lib$index","~$module$node_modules$$ethersproject$address$lib$index","~$module$node_modules$$ethersproject$keccak256$lib$index","~$module$node_modules$$ethersproject$abi$lib$coders$abstract_coder","~$module$node_modules$$ethersproject$abi$lib$abi_coder","~$module$node_modules$$ethersproject$logger$lib$index","~$module$node_modules$$ethersproject$properties$lib$index","~$module$node_modules$$ethersproject$hash$lib$index","~$module$node_modules$$ethersproject$abi$lib$_version"]],"~:properties",["^5",["isIndexed","encodeEventLog","topics","LogDescription","functionFragment","encodeErrorResult","encodeFunctionData","parseTransaction","TransactionDescription","getFunction","errorName","encodeFilterTopics","prototype","errorArgs","args","getEvent","hash","method","__esModule","error","parseLog","checkResultErrors","getAddress","Interface","isInterface","_isIndexed","errorFragment","Indexed","expected","getError","name","decodeFunctionResult","value","getSighash","parseError","enumerable","getEventTopic","_encodeParams","payable","encodeDeploy","signature","encodeFunctionResult","decodeEventLog","ErrorDescription","decodeFunctionData","type","__proto__","argument","reason","decodeErrorResult","inputs","_decodeParams","getAbiCoder","errorSignature","data","get","eventFragment","sighash","format","constructor","topic"]],"~:compiled-at",1695040653458,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$abi$lib$interface.js\",\n\"lineCount\":35,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@ethersproject/abi/lib/interface.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$ethersproject$abi$lib$interface\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        if (typeof b !== \\\"function\\\" && b !== null)\\n            throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = void 0;\\nvar address_1 = require(\\\"@ethersproject/address\\\");\\nvar bignumber_1 = require(\\\"@ethersproject/bignumber\\\");\\nvar bytes_1 = require(\\\"@ethersproject/bytes\\\");\\nvar hash_1 = require(\\\"@ethersproject/hash\\\");\\nvar keccak256_1 = require(\\\"@ethersproject/keccak256\\\");\\nvar properties_1 = require(\\\"@ethersproject/properties\\\");\\nvar abi_coder_1 = require(\\\"./abi-coder\\\");\\nvar abstract_coder_1 = require(\\\"./coders/abstract-coder\\\");\\nObject.defineProperty(exports, \\\"checkResultErrors\\\", { enumerable: true, get: function () { return abstract_coder_1.checkResultErrors; } });\\nvar fragments_1 = require(\\\"./fragments\\\");\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"./_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\nvar LogDescription = /** @class */ (function (_super) {\\n    __extends(LogDescription, _super);\\n    function LogDescription() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return LogDescription;\\n}(properties_1.Description));\\nexports.LogDescription = LogDescription;\\nvar TransactionDescription = /** @class */ (function (_super) {\\n    __extends(TransactionDescription, _super);\\n    function TransactionDescription() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return TransactionDescription;\\n}(properties_1.Description));\\nexports.TransactionDescription = TransactionDescription;\\nvar ErrorDescription = /** @class */ (function (_super) {\\n    __extends(ErrorDescription, _super);\\n    function ErrorDescription() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    return ErrorDescription;\\n}(properties_1.Description));\\nexports.ErrorDescription = ErrorDescription;\\nvar Indexed = /** @class */ (function (_super) {\\n    __extends(Indexed, _super);\\n    function Indexed() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    Indexed.isIndexed = function (value) {\\n        return !!(value && value._isIndexed);\\n    };\\n    return Indexed;\\n}(properties_1.Description));\\nexports.Indexed = Indexed;\\nvar BuiltinErrors = {\\n    \\\"0x08c379a0\\\": { signature: \\\"Error(string)\\\", name: \\\"Error\\\", inputs: [\\\"string\\\"], reason: true },\\n    \\\"0x4e487b71\\\": { signature: \\\"Panic(uint256)\\\", name: \\\"Panic\\\", inputs: [\\\"uint256\\\"] }\\n};\\nfunction wrapAccessError(property, error) {\\n    var wrap = new Error(\\\"deferred error during ABI decoding triggered accessing \\\" + property);\\n    wrap.error = error;\\n    return wrap;\\n}\\n/*\\nfunction checkNames(fragment: Fragment, type: \\\"input\\\" | \\\"output\\\", params: Array<ParamType>): void {\\n    params.reduce((accum, param) => {\\n        if (param.name) {\\n            if (accum[param.name]) {\\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\\\"full\\\") }`, \\\"fragment\\\", fragment);\\n            }\\n            accum[param.name] = true;\\n        }\\n        return accum;\\n    }, <{ [ name: string ]: boolean }>{ });\\n}\\n*/\\nvar Interface = /** @class */ (function () {\\n    function Interface(fragments) {\\n        var _newTarget = this.constructor;\\n        var _this = this;\\n        var abi = [];\\n        if (typeof (fragments) === \\\"string\\\") {\\n            abi = JSON.parse(fragments);\\n        }\\n        else {\\n            abi = fragments;\\n        }\\n        (0, properties_1.defineReadOnly)(this, \\\"fragments\\\", abi.map(function (fragment) {\\n            return fragments_1.Fragment.from(fragment);\\n        }).filter(function (fragment) { return (fragment != null); }));\\n        (0, properties_1.defineReadOnly)(this, \\\"_abiCoder\\\", (0, properties_1.getStatic)(_newTarget, \\\"getAbiCoder\\\")());\\n        (0, properties_1.defineReadOnly)(this, \\\"functions\\\", {});\\n        (0, properties_1.defineReadOnly)(this, \\\"errors\\\", {});\\n        (0, properties_1.defineReadOnly)(this, \\\"events\\\", {});\\n        (0, properties_1.defineReadOnly)(this, \\\"structs\\\", {});\\n        // Add all fragments by their signature\\n        this.fragments.forEach(function (fragment) {\\n            var bucket = null;\\n            switch (fragment.type) {\\n                case \\\"constructor\\\":\\n                    if (_this.deploy) {\\n                        logger.warn(\\\"duplicate definition - constructor\\\");\\n                        return;\\n                    }\\n                    //checkNames(fragment, \\\"input\\\", fragment.inputs);\\n                    (0, properties_1.defineReadOnly)(_this, \\\"deploy\\\", fragment);\\n                    return;\\n                case \\\"function\\\":\\n                    //checkNames(fragment, \\\"input\\\", fragment.inputs);\\n                    //checkNames(fragment, \\\"output\\\", (<FunctionFragment>fragment).outputs);\\n                    bucket = _this.functions;\\n                    break;\\n                case \\\"event\\\":\\n                    //checkNames(fragment, \\\"input\\\", fragment.inputs);\\n                    bucket = _this.events;\\n                    break;\\n                case \\\"error\\\":\\n                    bucket = _this.errors;\\n                    break;\\n                default:\\n                    return;\\n            }\\n            var signature = fragment.format();\\n            if (bucket[signature]) {\\n                logger.warn(\\\"duplicate definition - \\\" + signature);\\n                return;\\n            }\\n            bucket[signature] = fragment;\\n        });\\n        // If we do not have a constructor add a default\\n        if (!this.deploy) {\\n            (0, properties_1.defineReadOnly)(this, \\\"deploy\\\", fragments_1.ConstructorFragment.from({\\n                payable: false,\\n                type: \\\"constructor\\\"\\n            }));\\n        }\\n        (0, properties_1.defineReadOnly)(this, \\\"_isInterface\\\", true);\\n    }\\n    Interface.prototype.format = function (format) {\\n        if (!format) {\\n            format = fragments_1.FormatTypes.full;\\n        }\\n        if (format === fragments_1.FormatTypes.sighash) {\\n            logger.throwArgumentError(\\\"interface does not support formatting sighash\\\", \\\"format\\\", format);\\n        }\\n        var abi = this.fragments.map(function (fragment) { return fragment.format(format); });\\n        // We need to re-bundle the JSON fragments a bit\\n        if (format === fragments_1.FormatTypes.json) {\\n            return JSON.stringify(abi.map(function (j) { return JSON.parse(j); }));\\n        }\\n        return abi;\\n    };\\n    // Sub-classes can override these to handle other blockchains\\n    Interface.getAbiCoder = function () {\\n        return abi_coder_1.defaultAbiCoder;\\n    };\\n    Interface.getAddress = function (address) {\\n        return (0, address_1.getAddress)(address);\\n    };\\n    Interface.getSighash = function (fragment) {\\n        return (0, bytes_1.hexDataSlice)((0, hash_1.id)(fragment.format()), 0, 4);\\n    };\\n    Interface.getEventTopic = function (eventFragment) {\\n        return (0, hash_1.id)(eventFragment.format());\\n    };\\n    // Find a function definition by any means necessary (unless it is ambiguous)\\n    Interface.prototype.getFunction = function (nameOrSignatureOrSighash) {\\n        if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {\\n            for (var name_1 in this.functions) {\\n                if (nameOrSignatureOrSighash === this.getSighash(name_1)) {\\n                    return this.functions[name_1];\\n                }\\n            }\\n            logger.throwArgumentError(\\\"no matching function\\\", \\\"sighash\\\", nameOrSignatureOrSighash);\\n        }\\n        // It is a bare name, look up the function (will return null if ambiguous)\\n        if (nameOrSignatureOrSighash.indexOf(\\\"(\\\") === -1) {\\n            var name_2 = nameOrSignatureOrSighash.trim();\\n            var matching = Object.keys(this.functions).filter(function (f) { return (f.split(\\\"(\\\" /* fix:) */)[0] === name_2); });\\n            if (matching.length === 0) {\\n                logger.throwArgumentError(\\\"no matching function\\\", \\\"name\\\", name_2);\\n            }\\n            else if (matching.length > 1) {\\n                logger.throwArgumentError(\\\"multiple matching functions\\\", \\\"name\\\", name_2);\\n            }\\n            return this.functions[matching[0]];\\n        }\\n        // Normalize the signature and lookup the function\\n        var result = this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\\n        if (!result) {\\n            logger.throwArgumentError(\\\"no matching function\\\", \\\"signature\\\", nameOrSignatureOrSighash);\\n        }\\n        return result;\\n    };\\n    // Find an event definition by any means necessary (unless it is ambiguous)\\n    Interface.prototype.getEvent = function (nameOrSignatureOrTopic) {\\n        if ((0, bytes_1.isHexString)(nameOrSignatureOrTopic)) {\\n            var topichash = nameOrSignatureOrTopic.toLowerCase();\\n            for (var name_3 in this.events) {\\n                if (topichash === this.getEventTopic(name_3)) {\\n                    return this.events[name_3];\\n                }\\n            }\\n            logger.throwArgumentError(\\\"no matching event\\\", \\\"topichash\\\", topichash);\\n        }\\n        // It is a bare name, look up the function (will return null if ambiguous)\\n        if (nameOrSignatureOrTopic.indexOf(\\\"(\\\") === -1) {\\n            var name_4 = nameOrSignatureOrTopic.trim();\\n            var matching = Object.keys(this.events).filter(function (f) { return (f.split(\\\"(\\\" /* fix:) */)[0] === name_4); });\\n            if (matching.length === 0) {\\n                logger.throwArgumentError(\\\"no matching event\\\", \\\"name\\\", name_4);\\n            }\\n            else if (matching.length > 1) {\\n                logger.throwArgumentError(\\\"multiple matching events\\\", \\\"name\\\", name_4);\\n            }\\n            return this.events[matching[0]];\\n        }\\n        // Normalize the signature and lookup the function\\n        var result = this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()];\\n        if (!result) {\\n            logger.throwArgumentError(\\\"no matching event\\\", \\\"signature\\\", nameOrSignatureOrTopic);\\n        }\\n        return result;\\n    };\\n    // Find a function definition by any means necessary (unless it is ambiguous)\\n    Interface.prototype.getError = function (nameOrSignatureOrSighash) {\\n        if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {\\n            var getSighash = (0, properties_1.getStatic)(this.constructor, \\\"getSighash\\\");\\n            for (var name_5 in this.errors) {\\n                var error = this.errors[name_5];\\n                if (nameOrSignatureOrSighash === getSighash(error)) {\\n                    return this.errors[name_5];\\n                }\\n            }\\n            logger.throwArgumentError(\\\"no matching error\\\", \\\"sighash\\\", nameOrSignatureOrSighash);\\n        }\\n        // It is a bare name, look up the function (will return null if ambiguous)\\n        if (nameOrSignatureOrSighash.indexOf(\\\"(\\\") === -1) {\\n            var name_6 = nameOrSignatureOrSighash.trim();\\n            var matching = Object.keys(this.errors).filter(function (f) { return (f.split(\\\"(\\\" /* fix:) */)[0] === name_6); });\\n            if (matching.length === 0) {\\n                logger.throwArgumentError(\\\"no matching error\\\", \\\"name\\\", name_6);\\n            }\\n            else if (matching.length > 1) {\\n                logger.throwArgumentError(\\\"multiple matching errors\\\", \\\"name\\\", name_6);\\n            }\\n            return this.errors[matching[0]];\\n        }\\n        // Normalize the signature and lookup the function\\n        var result = this.errors[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\\n        if (!result) {\\n            logger.throwArgumentError(\\\"no matching error\\\", \\\"signature\\\", nameOrSignatureOrSighash);\\n        }\\n        return result;\\n    };\\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\\n    Interface.prototype.getSighash = function (fragment) {\\n        if (typeof (fragment) === \\\"string\\\") {\\n            try {\\n                fragment = this.getFunction(fragment);\\n            }\\n            catch (error) {\\n                try {\\n                    fragment = this.getError(fragment);\\n                }\\n                catch (_) {\\n                    throw error;\\n                }\\n            }\\n        }\\n        return (0, properties_1.getStatic)(this.constructor, \\\"getSighash\\\")(fragment);\\n    };\\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\\n    Interface.prototype.getEventTopic = function (eventFragment) {\\n        if (typeof (eventFragment) === \\\"string\\\") {\\n            eventFragment = this.getEvent(eventFragment);\\n        }\\n        return (0, properties_1.getStatic)(this.constructor, \\\"getEventTopic\\\")(eventFragment);\\n    };\\n    Interface.prototype._decodeParams = function (params, data) {\\n        return this._abiCoder.decode(params, data);\\n    };\\n    Interface.prototype._encodeParams = function (params, values) {\\n        return this._abiCoder.encode(params, values);\\n    };\\n    Interface.prototype.encodeDeploy = function (values) {\\n        return this._encodeParams(this.deploy.inputs, values || []);\\n    };\\n    Interface.prototype.decodeErrorResult = function (fragment, data) {\\n        if (typeof (fragment) === \\\"string\\\") {\\n            fragment = this.getError(fragment);\\n        }\\n        var bytes = (0, bytes_1.arrayify)(data);\\n        if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\\n            logger.throwArgumentError(\\\"data signature does not match error \\\" + fragment.name + \\\".\\\", \\\"data\\\", (0, bytes_1.hexlify)(bytes));\\n        }\\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\\n    };\\n    Interface.prototype.encodeErrorResult = function (fragment, values) {\\n        if (typeof (fragment) === \\\"string\\\") {\\n            fragment = this.getError(fragment);\\n        }\\n        return (0, bytes_1.hexlify)((0, bytes_1.concat)([\\n            this.getSighash(fragment),\\n            this._encodeParams(fragment.inputs, values || [])\\n        ]));\\n    };\\n    // Decode the data for a function call (e.g. tx.data)\\n    Interface.prototype.decodeFunctionData = function (functionFragment, data) {\\n        if (typeof (functionFragment) === \\\"string\\\") {\\n            functionFragment = this.getFunction(functionFragment);\\n        }\\n        var bytes = (0, bytes_1.arrayify)(data);\\n        if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\\n            logger.throwArgumentError(\\\"data signature does not match function \\\" + functionFragment.name + \\\".\\\", \\\"data\\\", (0, bytes_1.hexlify)(bytes));\\n        }\\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\\n    };\\n    // Encode the data for a function call (e.g. tx.data)\\n    Interface.prototype.encodeFunctionData = function (functionFragment, values) {\\n        if (typeof (functionFragment) === \\\"string\\\") {\\n            functionFragment = this.getFunction(functionFragment);\\n        }\\n        return (0, bytes_1.hexlify)((0, bytes_1.concat)([\\n            this.getSighash(functionFragment),\\n            this._encodeParams(functionFragment.inputs, values || [])\\n        ]));\\n    };\\n    // Decode the result from a function call (e.g. from eth_call)\\n    Interface.prototype.decodeFunctionResult = function (functionFragment, data) {\\n        if (typeof (functionFragment) === \\\"string\\\") {\\n            functionFragment = this.getFunction(functionFragment);\\n        }\\n        var bytes = (0, bytes_1.arrayify)(data);\\n        var reason = null;\\n        var message = \\\"\\\";\\n        var errorArgs = null;\\n        var errorName = null;\\n        var errorSignature = null;\\n        switch (bytes.length % this._abiCoder._getWordSize()) {\\n            case 0:\\n                try {\\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\\n                }\\n                catch (error) { }\\n                break;\\n            case 4: {\\n                var selector = (0, bytes_1.hexlify)(bytes.slice(0, 4));\\n                var builtin = BuiltinErrors[selector];\\n                if (builtin) {\\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\\n                    errorName = builtin.name;\\n                    errorSignature = builtin.signature;\\n                    if (builtin.reason) {\\n                        reason = errorArgs[0];\\n                    }\\n                    if (errorName === \\\"Error\\\") {\\n                        message = \\\"; VM Exception while processing transaction: reverted with reason string \\\" + JSON.stringify(errorArgs[0]);\\n                    }\\n                    else if (errorName === \\\"Panic\\\") {\\n                        message = \\\"; VM Exception while processing transaction: reverted with panic code \\\" + errorArgs[0];\\n                    }\\n                }\\n                else {\\n                    try {\\n                        var error = this.getError(selector);\\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\\n                        errorName = error.name;\\n                        errorSignature = error.format();\\n                    }\\n                    catch (error) { }\\n                }\\n                break;\\n            }\\n        }\\n        return logger.throwError(\\\"call revert exception\\\" + message, logger_1.Logger.errors.CALL_EXCEPTION, {\\n            method: functionFragment.format(),\\n            data: (0, bytes_1.hexlify)(data),\\n            errorArgs: errorArgs,\\n            errorName: errorName,\\n            errorSignature: errorSignature,\\n            reason: reason\\n        });\\n    };\\n    // Encode the result for a function call (e.g. for eth_call)\\n    Interface.prototype.encodeFunctionResult = function (functionFragment, values) {\\n        if (typeof (functionFragment) === \\\"string\\\") {\\n            functionFragment = this.getFunction(functionFragment);\\n        }\\n        return (0, bytes_1.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));\\n    };\\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\\n    Interface.prototype.encodeFilterTopics = function (eventFragment, values) {\\n        var _this = this;\\n        if (typeof (eventFragment) === \\\"string\\\") {\\n            eventFragment = this.getEvent(eventFragment);\\n        }\\n        if (values.length > eventFragment.inputs.length) {\\n            logger.throwError(\\\"too many arguments for \\\" + eventFragment.format(), logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {\\n                argument: \\\"values\\\",\\n                value: values\\n            });\\n        }\\n        var topics = [];\\n        if (!eventFragment.anonymous) {\\n            topics.push(this.getEventTopic(eventFragment));\\n        }\\n        var encodeTopic = function (param, value) {\\n            if (param.type === \\\"string\\\") {\\n                return (0, hash_1.id)(value);\\n            }\\n            else if (param.type === \\\"bytes\\\") {\\n                return (0, keccak256_1.keccak256)((0, bytes_1.hexlify)(value));\\n            }\\n            if (param.type === \\\"bool\\\" && typeof (value) === \\\"boolean\\\") {\\n                value = (value ? \\\"0x01\\\" : \\\"0x00\\\");\\n            }\\n            if (param.type.match(/^u?int/)) {\\n                value = bignumber_1.BigNumber.from(value).toHexString();\\n            }\\n            // Check addresses are valid\\n            if (param.type === \\\"address\\\") {\\n                _this._abiCoder.encode([\\\"address\\\"], [value]);\\n            }\\n            return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);\\n        };\\n        values.forEach(function (value, index) {\\n            var param = eventFragment.inputs[index];\\n            if (!param.indexed) {\\n                if (value != null) {\\n                    logger.throwArgumentError(\\\"cannot filter non-indexed parameters; must be null\\\", (\\\"contract.\\\" + param.name), value);\\n                }\\n                return;\\n            }\\n            if (value == null) {\\n                topics.push(null);\\n            }\\n            else if (param.baseType === \\\"array\\\" || param.baseType === \\\"tuple\\\") {\\n                logger.throwArgumentError(\\\"filtering with tuples or arrays not supported\\\", (\\\"contract.\\\" + param.name), value);\\n            }\\n            else if (Array.isArray(value)) {\\n                topics.push(value.map(function (value) { return encodeTopic(param, value); }));\\n            }\\n            else {\\n                topics.push(encodeTopic(param, value));\\n            }\\n        });\\n        // Trim off trailing nulls\\n        while (topics.length && topics[topics.length - 1] === null) {\\n            topics.pop();\\n        }\\n        return topics;\\n    };\\n    Interface.prototype.encodeEventLog = function (eventFragment, values) {\\n        var _this = this;\\n        if (typeof (eventFragment) === \\\"string\\\") {\\n            eventFragment = this.getEvent(eventFragment);\\n        }\\n        var topics = [];\\n        var dataTypes = [];\\n        var dataValues = [];\\n        if (!eventFragment.anonymous) {\\n            topics.push(this.getEventTopic(eventFragment));\\n        }\\n        if (values.length !== eventFragment.inputs.length) {\\n            logger.throwArgumentError(\\\"event arguments/values mismatch\\\", \\\"values\\\", values);\\n        }\\n        eventFragment.inputs.forEach(function (param, index) {\\n            var value = values[index];\\n            if (param.indexed) {\\n                if (param.type === \\\"string\\\") {\\n                    topics.push((0, hash_1.id)(value));\\n                }\\n                else if (param.type === \\\"bytes\\\") {\\n                    topics.push((0, keccak256_1.keccak256)(value));\\n                }\\n                else if (param.baseType === \\\"tuple\\\" || param.baseType === \\\"array\\\") {\\n                    // @TODO\\n                    throw new Error(\\\"not implemented\\\");\\n                }\\n                else {\\n                    topics.push(_this._abiCoder.encode([param.type], [value]));\\n                }\\n            }\\n            else {\\n                dataTypes.push(param);\\n                dataValues.push(value);\\n            }\\n        });\\n        return {\\n            data: this._abiCoder.encode(dataTypes, dataValues),\\n            topics: topics\\n        };\\n    };\\n    // Decode a filter for the event and the search criteria\\n    Interface.prototype.decodeEventLog = function (eventFragment, data, topics) {\\n        if (typeof (eventFragment) === \\\"string\\\") {\\n            eventFragment = this.getEvent(eventFragment);\\n        }\\n        if (topics != null && !eventFragment.anonymous) {\\n            var topicHash = this.getEventTopic(eventFragment);\\n            if (!(0, bytes_1.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\\n                logger.throwError(\\\"fragment/topic mismatch\\\", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: \\\"topics[0]\\\", expected: topicHash, value: topics[0] });\\n            }\\n            topics = topics.slice(1);\\n        }\\n        var indexed = [];\\n        var nonIndexed = [];\\n        var dynamic = [];\\n        eventFragment.inputs.forEach(function (param, index) {\\n            if (param.indexed) {\\n                if (param.type === \\\"string\\\" || param.type === \\\"bytes\\\" || param.baseType === \\\"tuple\\\" || param.baseType === \\\"array\\\") {\\n                    indexed.push(fragments_1.ParamType.fromObject({ type: \\\"bytes32\\\", name: param.name }));\\n                    dynamic.push(true);\\n                }\\n                else {\\n                    indexed.push(param);\\n                    dynamic.push(false);\\n                }\\n            }\\n            else {\\n                nonIndexed.push(param);\\n                dynamic.push(false);\\n            }\\n        });\\n        var resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, (0, bytes_1.concat)(topics)) : null;\\n        var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\\n        var result = [];\\n        var nonIndexedIndex = 0, indexedIndex = 0;\\n        eventFragment.inputs.forEach(function (param, index) {\\n            if (param.indexed) {\\n                if (resultIndexed == null) {\\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\\n                }\\n                else if (dynamic[index]) {\\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\\n                }\\n                else {\\n                    try {\\n                        result[index] = resultIndexed[indexedIndex++];\\n                    }\\n                    catch (error) {\\n                        result[index] = error;\\n                    }\\n                }\\n            }\\n            else {\\n                try {\\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\\n                }\\n                catch (error) {\\n                    result[index] = error;\\n                }\\n            }\\n            // Add the keyword argument if named and safe\\n            if (param.name && result[param.name] == null) {\\n                var value_1 = result[index];\\n                // Make error named values throw on access\\n                if (value_1 instanceof Error) {\\n                    Object.defineProperty(result, param.name, {\\n                        enumerable: true,\\n                        get: function () { throw wrapAccessError(\\\"property \\\" + JSON.stringify(param.name), value_1); }\\n                    });\\n                }\\n                else {\\n                    result[param.name] = value_1;\\n                }\\n            }\\n        });\\n        var _loop_1 = function (i) {\\n            var value = result[i];\\n            if (value instanceof Error) {\\n                Object.defineProperty(result, i, {\\n                    enumerable: true,\\n                    get: function () { throw wrapAccessError(\\\"index \\\" + i, value); }\\n                });\\n            }\\n        };\\n        // Make all error indexed values throw on access\\n        for (var i = 0; i < result.length; i++) {\\n            _loop_1(i);\\n        }\\n        return Object.freeze(result);\\n    };\\n    // Given a transaction, find the matching function fragment (if any) and\\n    // determine all its properties and call parameters\\n    Interface.prototype.parseTransaction = function (tx) {\\n        var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\\n        if (!fragment) {\\n            return null;\\n        }\\n        return new TransactionDescription({\\n            args: this._abiCoder.decode(fragment.inputs, \\\"0x\\\" + tx.data.substring(10)),\\n            functionFragment: fragment,\\n            name: fragment.name,\\n            signature: fragment.format(),\\n            sighash: this.getSighash(fragment),\\n            value: bignumber_1.BigNumber.from(tx.value || \\\"0\\\"),\\n        });\\n    };\\n    // @TODO\\n    //parseCallResult(data: BytesLike): ??\\n    // Given an event log, find the matching event fragment (if any) and\\n    // determine all its properties and values\\n    Interface.prototype.parseLog = function (log) {\\n        var fragment = this.getEvent(log.topics[0]);\\n        if (!fragment || fragment.anonymous) {\\n            return null;\\n        }\\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\\n        //        Probably not, because just because it is the only event in the ABI does\\n        //        not mean we have the full ABI; maybe just a fragment?\\n        return new LogDescription({\\n            eventFragment: fragment,\\n            name: fragment.name,\\n            signature: fragment.format(),\\n            topic: this.getEventTopic(fragment),\\n            args: this.decodeEventLog(fragment, log.data, log.topics)\\n        });\\n    };\\n    Interface.prototype.parseError = function (data) {\\n        var hexData = (0, bytes_1.hexlify)(data);\\n        var fragment = this.getError(hexData.substring(0, 10).toLowerCase());\\n        if (!fragment) {\\n            return null;\\n        }\\n        return new ErrorDescription({\\n            args: this._abiCoder.decode(fragment.inputs, \\\"0x\\\" + hexData.substring(10)),\\n            errorFragment: fragment,\\n            name: fragment.name,\\n            signature: fragment.format(),\\n            sighash: this.getSighash(fragment),\\n        });\\n    };\\n    /*\\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\\n        if (Interface.isInterface(value)) {\\n            return value;\\n        }\\n        if (typeof(value) === \\\"string\\\") {\\n            return new Interface(JSON.parse(value));\\n        }\\n        return new Interface(value);\\n    }\\n    */\\n    Interface.isInterface = function (value) {\\n        return !!(value && value._isInterface);\\n    };\\n    return Interface;\\n}());\\nexports.Interface = Interface;\\n//# sourceMappingURL=interface.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"wrapAccessError\",\"property\",\"error\",\"wrap\",\"Error\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"Object\",\"setPrototypeOf\",\"__proto__\",\"Array\",\"p\",\"prototype\",\"hasOwnProperty\",\"call\",\"__\",\"constructor\",\"TypeError\",\"String\",\"create\",\"defineProperty\",\"value\",\"Interface\",\"Indexed\",\"ErrorDescription\",\"TransactionDescription\",\"LogDescription\",\"checkResultErrors\",\"address_1\",\"bignumber_1\",\"bytes_1\",\"hash_1\",\"keccak256_1\",\"properties_1\",\"abi_coder_1\",\"abstract_coder_1\",\"enumerable\",\"get\",\"fragments_1\",\"logger_1\",\"_version_1\",\"logger\",\"Logger\",\"version\",\"_super\",\"apply\",\"arguments\",\"Description\",\"isIndexed\",\"Indexed.isIndexed\",\"_isIndexed\",\"BuiltinErrors\",\"signature\",\"name\",\"inputs\",\"reason\",\"fragments\",\"_newTarget\",\"_this\",\"abi\",\"JSON\",\"parse\",\"defineReadOnly\",\"map\",\"fragment\",\"Fragment\",\"from\",\"filter\",\"getStatic\",\"forEach\",\"type\",\"deploy\",\"warn\",\"bucket\",\"functions\",\"events\",\"errors\",\"format\",\"ConstructorFragment\",\"payable\",\"Interface.prototype.format\",\"FormatTypes\",\"full\",\"sighash\",\"throwArgumentError\",\"json\",\"stringify\",\"j\",\"getAbiCoder\",\"Interface.getAbiCoder\",\"defaultAbiCoder\",\"getAddress\",\"Interface.getAddress\",\"address\",\"getSighash\",\"Interface.getSighash\",\"hexDataSlice\",\"id\",\"getEventTopic\",\"Interface.getEventTopic\",\"eventFragment\",\"getFunction\",\"Interface.prototype.getFunction\",\"nameOrSignatureOrSighash\",\"isHexString\",\"name_1\",\"indexOf\",\"name_2\",\"trim\",\"matching\",\"keys\",\"f\",\"split\",\"length\",\"result\",\"FunctionFragment\",\"fromString\",\"getEvent\",\"Interface.prototype.getEvent\",\"nameOrSignatureOrTopic\",\"topichash\",\"toLowerCase\",\"name_3\",\"name_4\",\"EventFragment\",\"getError\",\"Interface.prototype.getError\",\"name_5\",\"name_6\",\"Interface.prototype.getSighash\",\"_\",\"Interface.prototype.getEventTopic\",\"_decodeParams\",\"Interface.prototype._decodeParams\",\"params\",\"data\",\"_abiCoder\",\"decode\",\"_encodeParams\",\"Interface.prototype._encodeParams\",\"values\",\"encode\",\"encodeDeploy\",\"Interface.prototype.encodeDeploy\",\"decodeErrorResult\",\"Interface.prototype.decodeErrorResult\",\"bytes\",\"arrayify\",\"hexlify\",\"slice\",\"encodeErrorResult\",\"Interface.prototype.encodeErrorResult\",\"concat\",\"decodeFunctionData\",\"Interface.prototype.decodeFunctionData\",\"functionFragment\",\"encodeFunctionData\",\"Interface.prototype.encodeFunctionData\",\"decodeFunctionResult\",\"Interface.prototype.decodeFunctionResult\",\"message\",\"errorArgs\",\"errorName\",\"errorSignature\",\"_getWordSize\",\"outputs\",\"selector\",\"builtin\",\"throwError\",\"CALL_EXCEPTION\",\"method\",\"encodeFunctionResult\",\"Interface.prototype.encodeFunctionResult\",\"encodeFilterTopics\",\"Interface.prototype.encodeFilterTopics\",\"UNEXPECTED_ARGUMENT\",\"argument\",\"topics\",\"anonymous\",\"push\",\"encodeTopic\",\"param\",\"keccak256\",\"match\",\"BigNumber\",\"toHexString\",\"hexZeroPad\",\"index\",\"indexed\",\"baseType\",\"isArray\",\"pop\",\"encodeEventLog\",\"Interface.prototype.encodeEventLog\",\"dataTypes\",\"dataValues\",\"decodeEventLog\",\"Interface.prototype.decodeEventLog\",\"topicHash\",\"INVALID_ARGUMENT\",\"expected\",\"nonIndexed\",\"dynamic\",\"ParamType\",\"fromObject\",\"resultIndexed\",\"resultNonIndexed\",\"nonIndexedIndex\",\"indexedIndex\",\"hash\",\"value_1\",\"_loop_1\",\"i\",\"freeze\",\"parseTransaction\",\"Interface.prototype.parseTransaction\",\"tx\",\"substring\",\"args\",\"parseLog\",\"Interface.prototype.parseLog\",\"log\",\"topic\",\"parseError\",\"Interface.prototype.parseError\",\"hexData\",\"errorFragment\",\"isInterface\",\"Interface.isInterface\",\"_isInterface\"]\n}\n"]