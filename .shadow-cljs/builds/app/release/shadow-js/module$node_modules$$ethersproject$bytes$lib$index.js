["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/bytes/lib/index.js"],"~:js","shadow$provide[11]=function(S,A,V,q){function F(E){if(E.slice)return E;E.slice=function(){var H=Array.prototype.slice.call(arguments);return F(new Uint8Array(Array.prototype.slice.apply(E,H)))};return E}function G(E){return n(E)&&!(E.length%2)||y(E)}function r(E){return\"number\"===typeof E&&E==E&&0===E%1}function y(E){if(null==E)return!1;if(E.constructor===Uint8Array)return!0;if(\"string\"===typeof E||!r(E.length)||0>E.length)return!1;for(var H=0;H<E.length;H++){var D=E[H];if(!r(D)||0>D||256<=D)return!1}return!0}\nfunction e(E,H){H||(H={});if(\"number\"===typeof E){B.checkSafeUint53(E,\"invalid arrayify value\");for(H=[];E;)H.unshift(E&255),E=parseInt(String(E/256));0===H.length&&H.push(0);return F(new Uint8Array(H))}H.allowMissingPrefix&&\"string\"===typeof E&&\"0x\"!==E.substring(0,2)&&(E=\"0x\"+E);E.toHexString&&(E=E.toHexString());if(n(E)){var D=E.substring(2);D.length%2&&(\"left\"===H.hexPad?D=\"0\"+D:\"right\"===H.hexPad?D+=\"0\":B.throwArgumentError(\"hex data is odd-length\",\"value\",E));H=[];for(E=0;E<D.length;E+=2)H.push(parseInt(D.substring(E,\nE+2),16));return F(new Uint8Array(H))}return y(E)?F(new Uint8Array(E)):B.throwArgumentError(\"invalid arrayify value\",\"value\",E)}function u(E){E=E.map(function(C){return e(C)});var H=E.reduce(function(C,I){return C+I.length},0),D=new Uint8Array(H);E.reduce(function(C,I){D.set(I,C);return C+I.length},0);return F(D)}function p(E,H){E=e(E);E.length>H&&B.throwArgumentError(\"value out of range\",\"value\",E);var D=new Uint8Array(H);D.set(E,H-E.length);return F(D)}function n(E,H){return\"string\"!==typeof E||\n!E.match(/^0x[0-9A-Fa-f]*$/)||H&&E.length!==2+2*H?!1:!0}function l(E,H){H||(H={});if(\"number\"===typeof E){B.checkSafeUint53(E,\"invalid hexlify value\");for(H=\"\";E;)H=\"0123456789abcdef\"[E&15]+H,E=Math.floor(E/16);return H.length?(H.length%2&&(H=\"0\"+H),\"0x\"+H):\"0x00\"}if(\"bigint\"===typeof E)return E=E.toString(16),E.length%2?\"0x0\"+E:\"0x\"+E;H.allowMissingPrefix&&\"string\"===typeof E&&\"0x\"!==E.substring(0,2)&&(E=\"0x\"+E);if(E.toHexString)return E.toHexString();if(n(E))return E.length%2&&(\"left\"===H.hexPad?\nE=\"0x0\"+E.substring(2):\"right\"===H.hexPad?E+=\"0\":B.throwArgumentError(\"hex data is odd-length\",\"value\",E)),E.toLowerCase();if(y(E)){H=\"0x\";for(var D=0;D<E.length;D++){var C=E[D];H+=\"0123456789abcdef\"[(C&240)>>4]+\"0123456789abcdef\"[C&15]}return H}return B.throwArgumentError(\"invalid hexlify value\",\"value\",E)}function h(E){\"string\"!==typeof E&&(E=l(E));n(E)||B.throwArgumentError(\"invalid hex string\",\"value\",E);E=E.substring(2);for(var H=0;H<E.length&&\"0\"===E[H];)H++;return\"0x\"+E.substring(H)}function k(E,\nH){\"string\"!==typeof E?E=l(E):n(E)||B.throwArgumentError(\"invalid hex string\",\"value\",E);for(E.length>2*H+2&&B.throwArgumentError(\"value out of range\",\"value\",H);E.length<2*H+2;)E=\"0x0\"+E.substring(2);return E}function t(E){var H={r:\"0x\",s:\"0x\",_vs:\"0x\",recoveryParam:0,v:0,yParityAndS:\"0x\",compact:\"0x\"};if(G(E)){var D=e(E);64===D.length?(H.v=27+(D[32]>>7),D[32]&=127,H.r=l(D.slice(0,32)),H.s=l(D.slice(32,64))):65===D.length?(H.r=l(D.slice(0,32)),H.s=l(D.slice(32,64)),H.v=D[64]):B.throwArgumentError(\"invalid signature string\",\n\"signature\",E);27>H.v&&(0===H.v||1===H.v?H.v+=27:B.throwArgumentError(\"signature invalid v byte\",\"signature\",E));H.recoveryParam=1-H.v%2;H.recoveryParam&&(D[32]|=128);H._vs=l(D.slice(32,64))}else{H.r=E.r;H.s=E.s;H.v=E.v;H.recoveryParam=E.recoveryParam;H._vs=E._vs;if(null!=H._vs){D=p(e(H._vs),32);H._vs=l(D);var C=128<=D[0]?1:0;null==H.recoveryParam?H.recoveryParam=C:H.recoveryParam!==C&&B.throwArgumentError(\"signature recoveryParam mismatch _vs\",\"signature\",E);D[0]&=127;D=l(D);null==H.s?H.s=D:H.s!==\nD&&B.throwArgumentError(\"signature v mismatch _vs\",\"signature\",E)}null==H.recoveryParam?null==H.v?B.throwArgumentError(\"signature missing v and recoveryParam\",\"signature\",E):H.recoveryParam=0===H.v||1===H.v?H.v:1-H.v%2:null==H.v?H.v=27+H.recoveryParam:H.recoveryParam!==(0===H.v||1===H.v?H.v:1-H.v%2)&&B.throwArgumentError(\"signature recoveryParam mismatch v\",\"signature\",E);null!=H.r&&n(H.r)?H.r=k(H.r,32):B.throwArgumentError(\"signature missing or invalid r\",\"signature\",E);null!=H.s&&n(H.s)?H.s=k(H.s,\n32):B.throwArgumentError(\"signature missing or invalid s\",\"signature\",E);D=e(H.s);128<=D[0]&&B.throwArgumentError(\"signature s out of range\",\"signature\",E);H.recoveryParam&&(D[0]|=128);D=l(D);H._vs&&(n(H._vs)||B.throwArgumentError(\"signature invalid _vs\",\"signature\",E),H._vs=k(H._vs,32));null==H._vs?H._vs=D:H._vs!==D&&B.throwArgumentError(\"signature _vs mismatch v and s\",\"signature\",E)}H.yParityAndS=H._vs;H.compact=H.r+H.yParityAndS.substring(2);return H}Object.defineProperty(q,\"__esModule\",{value:!0});\nq.joinSignature=q.splitSignature=q.hexZeroPad=q.hexStripZeros=q.hexValue=q.hexConcat=q.hexDataSlice=q.hexDataLength=q.hexlify=q.isHexString=q.zeroPad=q.stripZeros=q.concat=q.arrayify=q.isBytes=q.isBytesLike=void 0;S=A(9);A=A(10);var B=new S.Logger(A.version);q.isBytesLike=G;q.isBytes=y;q.arrayify=e;q.concat=u;q.stripZeros=function(E){E=e(E);if(0===E.length)return E;for(var H=0;H<E.length&&0===E[H];)H++;H&&(E=E.slice(H));return E};q.zeroPad=p;q.isHexString=n;q.hexlify=l;q.hexDataLength=function(E){if(\"string\"!==\ntypeof E)E=l(E);else if(!n(E)||E.length%2)return null;return(E.length-2)/2};q.hexDataSlice=function(E,H,D){\"string\"!==typeof E?E=l(E):(!n(E)||E.length%2)&&B.throwArgumentError(\"invalid hexData\",\"value\",E);H=2+2*H;return null!=D?\"0x\"+E.substring(H,2+2*D):\"0x\"+E.substring(H)};q.hexConcat=function(E){var H=\"0x\";E.forEach(function(D){H+=l(D).substring(2)});return H};q.hexValue=function(E){E=h(l(E,{hexPad:\"left\"}));return\"0x\"===E?\"0x0\":E};q.hexStripZeros=h;q.hexZeroPad=k;q.splitSignature=t;q.joinSignature=\nfunction(E){E=t(E);return l(u([E.r,E.s,E.recoveryParam?\"0x1c\":\"0x1b\"]))}}","~:source","shadow$provide[11] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        var args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nexports.isBytesLike = isBytesLike;\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (var i = 0; i < value.length; i++) {\n        var v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isBytes = isBytes;\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        var result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        var hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        var result = [];\n        for (var i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nexports.arrayify = arrayify;\nfunction concat(items) {\n    var objects = items.map(function (item) { return arrayify(item); });\n    var length = objects.reduce(function (accum, item) { return (accum + item.length); }, 0);\n    var result = new Uint8Array(length);\n    objects.reduce(function (offset, object) {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nexports.concat = concat;\nfunction stripZeros(value) {\n    var result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    var start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nexports.stripZeros = stripZeros;\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    var result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nexports.zeroPad = zeroPad;\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\nvar HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        var hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        var result = \"0x\";\n        for (var i = 0; i < value.length; i++) {\n            var v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\nexports.hexlify = hexlify;\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nfunction hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nexports.hexDataLength = hexDataLength;\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nexports.hexDataSlice = hexDataSlice;\nfunction hexConcat(items) {\n    var result = \"0x\";\n    items.forEach(function (item) {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nexports.hexConcat = hexConcat;\nfunction hexValue(value) {\n    var trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nexports.hexValue = hexValue;\nfunction hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    var offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nexports.hexStripZeros = hexStripZeros;\nfunction hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nexports.hexZeroPad = hexZeroPad;\nfunction splitSignature(signature) {\n    var result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        var bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        }\n        else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        }\n        else {\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            var vs_1 = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs_1);\n            // Set or check the recid\n            var recoveryParam = ((vs_1[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs_1[0] &= 0x7f;\n            var s = hexlify(vs_1);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                var recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        var vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        var _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nexports.splitSignature = splitSignature;\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\nexports.joinSignature = joinSignature;\n//# sourceMappingURL=index.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$ethersproject$bytes$lib$_version","~$shadow.js","~$module$node_modules$$ethersproject$logger$lib$index"]],"~:properties",["^5",["zeroPad","isHexString","compact","hexZeroPad","s","hexDataSlice","hexValue","recoveryParam","hexPad","isBytes","__esModule","hexDataLength","v","hexStripZeros","value","splitSignature","stripZeros","concat","yParityAndS","joinSignature","r","arrayify","slice","hexlify","hexConcat","isBytesLike","_vs"]],"~:compiled-at",1695041440673,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$bytes$lib$index.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@ethersproject/bytes/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[11] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"./_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\n///////////////////////////////\\nfunction isHexable(value) {\\n    return !!(value.toHexString);\\n}\\nfunction addSlice(array) {\\n    if (array.slice) {\\n        return array;\\n    }\\n    array.slice = function () {\\n        var args = Array.prototype.slice.call(arguments);\\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\\n    };\\n    return array;\\n}\\nfunction isBytesLike(value) {\\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\\n}\\nexports.isBytesLike = isBytesLike;\\nfunction isInteger(value) {\\n    return (typeof (value) === \\\"number\\\" && value == value && (value % 1) === 0);\\n}\\nfunction isBytes(value) {\\n    if (value == null) {\\n        return false;\\n    }\\n    if (value.constructor === Uint8Array) {\\n        return true;\\n    }\\n    if (typeof (value) === \\\"string\\\") {\\n        return false;\\n    }\\n    if (!isInteger(value.length) || value.length < 0) {\\n        return false;\\n    }\\n    for (var i = 0; i < value.length; i++) {\\n        var v = value[i];\\n        if (!isInteger(v) || v < 0 || v >= 256) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nexports.isBytes = isBytes;\\nfunction arrayify(value, options) {\\n    if (!options) {\\n        options = {};\\n    }\\n    if (typeof (value) === \\\"number\\\") {\\n        logger.checkSafeUint53(value, \\\"invalid arrayify value\\\");\\n        var result = [];\\n        while (value) {\\n            result.unshift(value & 0xff);\\n            value = parseInt(String(value / 256));\\n        }\\n        if (result.length === 0) {\\n            result.push(0);\\n        }\\n        return addSlice(new Uint8Array(result));\\n    }\\n    if (options.allowMissingPrefix && typeof (value) === \\\"string\\\" && value.substring(0, 2) !== \\\"0x\\\") {\\n        value = \\\"0x\\\" + value;\\n    }\\n    if (isHexable(value)) {\\n        value = value.toHexString();\\n    }\\n    if (isHexString(value)) {\\n        var hex = value.substring(2);\\n        if (hex.length % 2) {\\n            if (options.hexPad === \\\"left\\\") {\\n                hex = \\\"0\\\" + hex;\\n            }\\n            else if (options.hexPad === \\\"right\\\") {\\n                hex += \\\"0\\\";\\n            }\\n            else {\\n                logger.throwArgumentError(\\\"hex data is odd-length\\\", \\\"value\\\", value);\\n            }\\n        }\\n        var result = [];\\n        for (var i = 0; i < hex.length; i += 2) {\\n            result.push(parseInt(hex.substring(i, i + 2), 16));\\n        }\\n        return addSlice(new Uint8Array(result));\\n    }\\n    if (isBytes(value)) {\\n        return addSlice(new Uint8Array(value));\\n    }\\n    return logger.throwArgumentError(\\\"invalid arrayify value\\\", \\\"value\\\", value);\\n}\\nexports.arrayify = arrayify;\\nfunction concat(items) {\\n    var objects = items.map(function (item) { return arrayify(item); });\\n    var length = objects.reduce(function (accum, item) { return (accum + item.length); }, 0);\\n    var result = new Uint8Array(length);\\n    objects.reduce(function (offset, object) {\\n        result.set(object, offset);\\n        return offset + object.length;\\n    }, 0);\\n    return addSlice(result);\\n}\\nexports.concat = concat;\\nfunction stripZeros(value) {\\n    var result = arrayify(value);\\n    if (result.length === 0) {\\n        return result;\\n    }\\n    // Find the first non-zero entry\\n    var start = 0;\\n    while (start < result.length && result[start] === 0) {\\n        start++;\\n    }\\n    // If we started with zeros, strip them\\n    if (start) {\\n        result = result.slice(start);\\n    }\\n    return result;\\n}\\nexports.stripZeros = stripZeros;\\nfunction zeroPad(value, length) {\\n    value = arrayify(value);\\n    if (value.length > length) {\\n        logger.throwArgumentError(\\\"value out of range\\\", \\\"value\\\", arguments[0]);\\n    }\\n    var result = new Uint8Array(length);\\n    result.set(value, length - value.length);\\n    return addSlice(result);\\n}\\nexports.zeroPad = zeroPad;\\nfunction isHexString(value, length) {\\n    if (typeof (value) !== \\\"string\\\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\\n        return false;\\n    }\\n    if (length && value.length !== 2 + 2 * length) {\\n        return false;\\n    }\\n    return true;\\n}\\nexports.isHexString = isHexString;\\nvar HexCharacters = \\\"0123456789abcdef\\\";\\nfunction hexlify(value, options) {\\n    if (!options) {\\n        options = {};\\n    }\\n    if (typeof (value) === \\\"number\\\") {\\n        logger.checkSafeUint53(value, \\\"invalid hexlify value\\\");\\n        var hex = \\\"\\\";\\n        while (value) {\\n            hex = HexCharacters[value & 0xf] + hex;\\n            value = Math.floor(value / 16);\\n        }\\n        if (hex.length) {\\n            if (hex.length % 2) {\\n                hex = \\\"0\\\" + hex;\\n            }\\n            return \\\"0x\\\" + hex;\\n        }\\n        return \\\"0x00\\\";\\n    }\\n    if (typeof (value) === \\\"bigint\\\") {\\n        value = value.toString(16);\\n        if (value.length % 2) {\\n            return (\\\"0x0\\\" + value);\\n        }\\n        return \\\"0x\\\" + value;\\n    }\\n    if (options.allowMissingPrefix && typeof (value) === \\\"string\\\" && value.substring(0, 2) !== \\\"0x\\\") {\\n        value = \\\"0x\\\" + value;\\n    }\\n    if (isHexable(value)) {\\n        return value.toHexString();\\n    }\\n    if (isHexString(value)) {\\n        if (value.length % 2) {\\n            if (options.hexPad === \\\"left\\\") {\\n                value = \\\"0x0\\\" + value.substring(2);\\n            }\\n            else if (options.hexPad === \\\"right\\\") {\\n                value += \\\"0\\\";\\n            }\\n            else {\\n                logger.throwArgumentError(\\\"hex data is odd-length\\\", \\\"value\\\", value);\\n            }\\n        }\\n        return value.toLowerCase();\\n    }\\n    if (isBytes(value)) {\\n        var result = \\\"0x\\\";\\n        for (var i = 0; i < value.length; i++) {\\n            var v = value[i];\\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\\n        }\\n        return result;\\n    }\\n    return logger.throwArgumentError(\\\"invalid hexlify value\\\", \\\"value\\\", value);\\n}\\nexports.hexlify = hexlify;\\n/*\\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\\n    if (typeof(value) === \\\"string\\\" && value.length % 2 && value.substring(0, 2) === \\\"0x\\\") {\\n        return \\\"0x0\\\" + value.substring(2);\\n    }\\n    return value;\\n}\\n*/\\nfunction hexDataLength(data) {\\n    if (typeof (data) !== \\\"string\\\") {\\n        data = hexlify(data);\\n    }\\n    else if (!isHexString(data) || (data.length % 2)) {\\n        return null;\\n    }\\n    return (data.length - 2) / 2;\\n}\\nexports.hexDataLength = hexDataLength;\\nfunction hexDataSlice(data, offset, endOffset) {\\n    if (typeof (data) !== \\\"string\\\") {\\n        data = hexlify(data);\\n    }\\n    else if (!isHexString(data) || (data.length % 2)) {\\n        logger.throwArgumentError(\\\"invalid hexData\\\", \\\"value\\\", data);\\n    }\\n    offset = 2 + 2 * offset;\\n    if (endOffset != null) {\\n        return \\\"0x\\\" + data.substring(offset, 2 + 2 * endOffset);\\n    }\\n    return \\\"0x\\\" + data.substring(offset);\\n}\\nexports.hexDataSlice = hexDataSlice;\\nfunction hexConcat(items) {\\n    var result = \\\"0x\\\";\\n    items.forEach(function (item) {\\n        result += hexlify(item).substring(2);\\n    });\\n    return result;\\n}\\nexports.hexConcat = hexConcat;\\nfunction hexValue(value) {\\n    var trimmed = hexStripZeros(hexlify(value, { hexPad: \\\"left\\\" }));\\n    if (trimmed === \\\"0x\\\") {\\n        return \\\"0x0\\\";\\n    }\\n    return trimmed;\\n}\\nexports.hexValue = hexValue;\\nfunction hexStripZeros(value) {\\n    if (typeof (value) !== \\\"string\\\") {\\n        value = hexlify(value);\\n    }\\n    if (!isHexString(value)) {\\n        logger.throwArgumentError(\\\"invalid hex string\\\", \\\"value\\\", value);\\n    }\\n    value = value.substring(2);\\n    var offset = 0;\\n    while (offset < value.length && value[offset] === \\\"0\\\") {\\n        offset++;\\n    }\\n    return \\\"0x\\\" + value.substring(offset);\\n}\\nexports.hexStripZeros = hexStripZeros;\\nfunction hexZeroPad(value, length) {\\n    if (typeof (value) !== \\\"string\\\") {\\n        value = hexlify(value);\\n    }\\n    else if (!isHexString(value)) {\\n        logger.throwArgumentError(\\\"invalid hex string\\\", \\\"value\\\", value);\\n    }\\n    if (value.length > 2 * length + 2) {\\n        logger.throwArgumentError(\\\"value out of range\\\", \\\"value\\\", arguments[1]);\\n    }\\n    while (value.length < 2 * length + 2) {\\n        value = \\\"0x0\\\" + value.substring(2);\\n    }\\n    return value;\\n}\\nexports.hexZeroPad = hexZeroPad;\\nfunction splitSignature(signature) {\\n    var result = {\\n        r: \\\"0x\\\",\\n        s: \\\"0x\\\",\\n        _vs: \\\"0x\\\",\\n        recoveryParam: 0,\\n        v: 0,\\n        yParityAndS: \\\"0x\\\",\\n        compact: \\\"0x\\\"\\n    };\\n    if (isBytesLike(signature)) {\\n        var bytes = arrayify(signature);\\n        // Get the r, s and v\\n        if (bytes.length === 64) {\\n            // EIP-2098; pull the v from the top bit of s and clear it\\n            result.v = 27 + (bytes[32] >> 7);\\n            bytes[32] &= 0x7f;\\n            result.r = hexlify(bytes.slice(0, 32));\\n            result.s = hexlify(bytes.slice(32, 64));\\n        }\\n        else if (bytes.length === 65) {\\n            result.r = hexlify(bytes.slice(0, 32));\\n            result.s = hexlify(bytes.slice(32, 64));\\n            result.v = bytes[64];\\n        }\\n        else {\\n            logger.throwArgumentError(\\\"invalid signature string\\\", \\\"signature\\\", signature);\\n        }\\n        // Allow a recid to be used as the v\\n        if (result.v < 27) {\\n            if (result.v === 0 || result.v === 1) {\\n                result.v += 27;\\n            }\\n            else {\\n                logger.throwArgumentError(\\\"signature invalid v byte\\\", \\\"signature\\\", signature);\\n            }\\n        }\\n        // Compute recoveryParam from v\\n        result.recoveryParam = 1 - (result.v % 2);\\n        // Compute _vs from recoveryParam and s\\n        if (result.recoveryParam) {\\n            bytes[32] |= 0x80;\\n        }\\n        result._vs = hexlify(bytes.slice(32, 64));\\n    }\\n    else {\\n        result.r = signature.r;\\n        result.s = signature.s;\\n        result.v = signature.v;\\n        result.recoveryParam = signature.recoveryParam;\\n        result._vs = signature._vs;\\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\\n        // and verify non-missing s, v and recoveryParam\\n        if (result._vs != null) {\\n            var vs_1 = zeroPad(arrayify(result._vs), 32);\\n            result._vs = hexlify(vs_1);\\n            // Set or check the recid\\n            var recoveryParam = ((vs_1[0] >= 128) ? 1 : 0);\\n            if (result.recoveryParam == null) {\\n                result.recoveryParam = recoveryParam;\\n            }\\n            else if (result.recoveryParam !== recoveryParam) {\\n                logger.throwArgumentError(\\\"signature recoveryParam mismatch _vs\\\", \\\"signature\\\", signature);\\n            }\\n            // Set or check the s\\n            vs_1[0] &= 0x7f;\\n            var s = hexlify(vs_1);\\n            if (result.s == null) {\\n                result.s = s;\\n            }\\n            else if (result.s !== s) {\\n                logger.throwArgumentError(\\\"signature v mismatch _vs\\\", \\\"signature\\\", signature);\\n            }\\n        }\\n        // Use recid and v to populate each other\\n        if (result.recoveryParam == null) {\\n            if (result.v == null) {\\n                logger.throwArgumentError(\\\"signature missing v and recoveryParam\\\", \\\"signature\\\", signature);\\n            }\\n            else if (result.v === 0 || result.v === 1) {\\n                result.recoveryParam = result.v;\\n            }\\n            else {\\n                result.recoveryParam = 1 - (result.v % 2);\\n            }\\n        }\\n        else {\\n            if (result.v == null) {\\n                result.v = 27 + result.recoveryParam;\\n            }\\n            else {\\n                var recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\\n                if (result.recoveryParam !== recId) {\\n                    logger.throwArgumentError(\\\"signature recoveryParam mismatch v\\\", \\\"signature\\\", signature);\\n                }\\n            }\\n        }\\n        if (result.r == null || !isHexString(result.r)) {\\n            logger.throwArgumentError(\\\"signature missing or invalid r\\\", \\\"signature\\\", signature);\\n        }\\n        else {\\n            result.r = hexZeroPad(result.r, 32);\\n        }\\n        if (result.s == null || !isHexString(result.s)) {\\n            logger.throwArgumentError(\\\"signature missing or invalid s\\\", \\\"signature\\\", signature);\\n        }\\n        else {\\n            result.s = hexZeroPad(result.s, 32);\\n        }\\n        var vs = arrayify(result.s);\\n        if (vs[0] >= 128) {\\n            logger.throwArgumentError(\\\"signature s out of range\\\", \\\"signature\\\", signature);\\n        }\\n        if (result.recoveryParam) {\\n            vs[0] |= 0x80;\\n        }\\n        var _vs = hexlify(vs);\\n        if (result._vs) {\\n            if (!isHexString(result._vs)) {\\n                logger.throwArgumentError(\\\"signature invalid _vs\\\", \\\"signature\\\", signature);\\n            }\\n            result._vs = hexZeroPad(result._vs, 32);\\n        }\\n        // Set or check the _vs\\n        if (result._vs == null) {\\n            result._vs = _vs;\\n        }\\n        else if (result._vs !== _vs) {\\n            logger.throwArgumentError(\\\"signature _vs mismatch v and s\\\", \\\"signature\\\", signature);\\n        }\\n    }\\n    result.yParityAndS = result._vs;\\n    result.compact = result.r + result.yParityAndS.substring(2);\\n    return result;\\n}\\nexports.splitSignature = splitSignature;\\nfunction joinSignature(signature) {\\n    signature = splitSignature(signature);\\n    return hexlify(concat([\\n        signature.r,\\n        signature.s,\\n        (signature.recoveryParam ? \\\"0x1c\\\" : \\\"0x1b\\\")\\n    ]));\\n}\\nexports.joinSignature = joinSignature;\\n//# sourceMappingURL=index.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"addSlice\",\"array\",\"slice\",\"array.slice\",\"args\",\"Array\",\"prototype\",\"call\",\"arguments\",\"Uint8Array\",\"apply\",\"isBytesLike\",\"value\",\"isHexString\",\"length\",\"isBytes\",\"isInteger\",\"constructor\",\"i\",\"v\",\"arrayify\",\"options\",\"logger\",\"checkSafeUint53\",\"result\",\"unshift\",\"parseInt\",\"String\",\"push\",\"allowMissingPrefix\",\"substring\",\"toHexString\",\"hex\",\"hexPad\",\"throwArgumentError\",\"concat\",\"items\",\"objects\",\"map\",\"item\",\"reduce\",\"accum\",\"offset\",\"object\",\"set\",\"zeroPad\",\"match\",\"hexlify\",\"HexCharacters\",\"Math\",\"floor\",\"toString\",\"toLowerCase\",\"hexStripZeros\",\"hexZeroPad\",\"splitSignature\",\"signature\",\"r\",\"s\",\"_vs\",\"recoveryParam\",\"yParityAndS\",\"compact\",\"bytes\",\"vs_1\",\"recId\",\"vs\",\"Object\",\"defineProperty\",\"joinSignature\",\"hexValue\",\"hexConcat\",\"hexDataSlice\",\"hexDataLength\",\"stripZeros\",\"logger_1\",\"_version_1\",\"Logger\",\"version\",\"start\",\"data\",\"endOffset\",\"forEach\",\"trimmed\"]\n}\n"]