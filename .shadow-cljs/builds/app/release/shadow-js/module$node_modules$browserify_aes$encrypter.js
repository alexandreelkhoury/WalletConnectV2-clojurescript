["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/browserify-aes/encrypter.js"],"~:js","shadow$provide[198]=function(S,A,V,q){function F(t,B,E){n.call(this);this._cache=new G;this._cipher=new l.AES(B);this._prev=u.from(E);this._mode=t;this._autopadding=!0}function G(){this.cache=u.allocUnsafe(0)}function r(t,B,E){t=y[t.toLowerCase()];if(!t)throw new TypeError(\"invalid suite type\");\"string\"===typeof B&&(B=u.from(B));if(B.length!==t.key/8)throw new TypeError(\"invalid key length \"+B.length);\"string\"===typeof E&&(E=u.from(E));if(\"GCM\"!==t.mode&&E.length!==t.iv)throw new TypeError(\"invalid iv length \"+\nE.length);return\"stream\"===t.type?new p(t.module,B,E):\"auth\"===t.type?new e(t.module,B,E):new F(t.module,B,E)}var y=A(192),e=A(195),u=A(111).Buffer,p=A(196),n=A(162),l=A(193),h=A(197);A(76)(F,n);F.prototype._update=function(t){this._cache.add(t);var B;for(t=[];B=this._cache.get();)B=this._mode.encrypt(this,B),t.push(B);return u.concat(t)};var k=u.alloc(16,16);F.prototype._final=function(){var t=this._cache.flush();if(this._autopadding)return t=this._mode.encrypt(this,t),this._cipher.scrub(),t;if(!t.equals(k))throw this._cipher.scrub(),\nError(\"data not multiple of block length\");};F.prototype.setAutoPadding=function(t){this._autopadding=!!t;return this};G.prototype.add=function(t){this.cache=u.concat([this.cache,t])};G.prototype.get=function(){if(15<this.cache.length){var t=this.cache.slice(0,16);this.cache=this.cache.slice(16);return t}return null};G.prototype.flush=function(){for(var t=16-this.cache.length,B=u.allocUnsafe(t),E=-1;++E<t;)B.writeUInt8(t,E);return u.concat([this.cache,B])};q.createCipheriv=r;q.createCipher=function(t,\nB){var E=y[t.toLowerCase()];if(!E)throw new TypeError(\"invalid suite type\");B=h(B,!1,E.key,E.iv);return r(t,B.key,B.iv)}}","~:source","shadow$provide[198] = function(global,require,module,exports) {\nvar MODES = require('./modes')\nvar AuthCipher = require('./authCipher')\nvar Buffer = require('safe-buffer').Buffer\nvar StreamCipher = require('./streamCipher')\nvar Transform = require('cipher-base')\nvar aes = require('./aes')\nvar ebtk = require('evp_bytestokey')\nvar inherits = require('inherits')\n\nfunction Cipher (mode, key, iv) {\n  Transform.call(this)\n\n  this._cache = new Splitter()\n  this._cipher = new aes.AES(key)\n  this._prev = Buffer.from(iv)\n  this._mode = mode\n  this._autopadding = true\n}\n\ninherits(Cipher, Transform)\n\nCipher.prototype._update = function (data) {\n  this._cache.add(data)\n  var chunk\n  var thing\n  var out = []\n\n  while ((chunk = this._cache.get())) {\n    thing = this._mode.encrypt(this, chunk)\n    out.push(thing)\n  }\n\n  return Buffer.concat(out)\n}\n\nvar PADDING = Buffer.alloc(16, 0x10)\n\nCipher.prototype._final = function () {\n  var chunk = this._cache.flush()\n  if (this._autopadding) {\n    chunk = this._mode.encrypt(this, chunk)\n    this._cipher.scrub()\n    return chunk\n  }\n\n  if (!chunk.equals(PADDING)) {\n    this._cipher.scrub()\n    throw new Error('data not multiple of block length')\n  }\n}\n\nCipher.prototype.setAutoPadding = function (setTo) {\n  this._autopadding = !!setTo\n  return this\n}\n\nfunction Splitter () {\n  this.cache = Buffer.allocUnsafe(0)\n}\n\nSplitter.prototype.add = function (data) {\n  this.cache = Buffer.concat([this.cache, data])\n}\n\nSplitter.prototype.get = function () {\n  if (this.cache.length > 15) {\n    var out = this.cache.slice(0, 16)\n    this.cache = this.cache.slice(16)\n    return out\n  }\n  return null\n}\n\nSplitter.prototype.flush = function () {\n  var len = 16 - this.cache.length\n  var padBuff = Buffer.allocUnsafe(len)\n\n  var i = -1\n  while (++i < len) {\n    padBuff.writeUInt8(len, i)\n  }\n\n  return Buffer.concat([this.cache, padBuff])\n}\n\nfunction createCipheriv (suite, password, iv) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  if (typeof password === 'string') password = Buffer.from(password)\n  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)\n\n  if (typeof iv === 'string') iv = Buffer.from(iv)\n  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)\n\n  if (config.type === 'stream') {\n    return new StreamCipher(config.module, password, iv)\n  } else if (config.type === 'auth') {\n    return new AuthCipher(config.module, password, iv)\n  }\n\n  return new Cipher(config.module, password, iv)\n}\n\nfunction createCipher (suite, password) {\n  var config = MODES[suite.toLowerCase()]\n  if (!config) throw new TypeError('invalid suite type')\n\n  var keys = ebtk(password, false, config.key, config.iv)\n  return createCipheriv(suite, keys.key, keys.iv)\n}\n\nexports.createCipheriv = createCipheriv\nexports.createCipher = createCipher\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$evp_bytestokey$index","~$module$node_modules$cipher_base$index","~$module$node_modules$browserify_aes$aes","~$shadow.js","~$module$node_modules$inherits$inherits_browser","~$module$node_modules$safe_buffer$index","~$module$node_modules$browserify_aes$authCipher","~$module$node_modules$browserify_aes$streamCipher","~$module$node_modules$browserify_aes$modes$index"]],"~:properties",["^5",["createCipheriv","_cipher","setAutoPadding","flush","createCipher","_prev","_cache","cache","_autopadding","add","_final","_update","get","_mode"]],"~:compiled-at",1695041440828,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$browserify_aes$encrypter.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/browserify-aes/encrypter.js\"],\n\"sourcesContent\":[\"shadow$provide[198] = function(global,require,module,exports) {\\nvar MODES = require('./modes')\\nvar AuthCipher = require('./authCipher')\\nvar Buffer = require('safe-buffer').Buffer\\nvar StreamCipher = require('./streamCipher')\\nvar Transform = require('cipher-base')\\nvar aes = require('./aes')\\nvar ebtk = require('evp_bytestokey')\\nvar inherits = require('inherits')\\n\\nfunction Cipher (mode, key, iv) {\\n  Transform.call(this)\\n\\n  this._cache = new Splitter()\\n  this._cipher = new aes.AES(key)\\n  this._prev = Buffer.from(iv)\\n  this._mode = mode\\n  this._autopadding = true\\n}\\n\\ninherits(Cipher, Transform)\\n\\nCipher.prototype._update = function (data) {\\n  this._cache.add(data)\\n  var chunk\\n  var thing\\n  var out = []\\n\\n  while ((chunk = this._cache.get())) {\\n    thing = this._mode.encrypt(this, chunk)\\n    out.push(thing)\\n  }\\n\\n  return Buffer.concat(out)\\n}\\n\\nvar PADDING = Buffer.alloc(16, 0x10)\\n\\nCipher.prototype._final = function () {\\n  var chunk = this._cache.flush()\\n  if (this._autopadding) {\\n    chunk = this._mode.encrypt(this, chunk)\\n    this._cipher.scrub()\\n    return chunk\\n  }\\n\\n  if (!chunk.equals(PADDING)) {\\n    this._cipher.scrub()\\n    throw new Error('data not multiple of block length')\\n  }\\n}\\n\\nCipher.prototype.setAutoPadding = function (setTo) {\\n  this._autopadding = !!setTo\\n  return this\\n}\\n\\nfunction Splitter () {\\n  this.cache = Buffer.allocUnsafe(0)\\n}\\n\\nSplitter.prototype.add = function (data) {\\n  this.cache = Buffer.concat([this.cache, data])\\n}\\n\\nSplitter.prototype.get = function () {\\n  if (this.cache.length > 15) {\\n    var out = this.cache.slice(0, 16)\\n    this.cache = this.cache.slice(16)\\n    return out\\n  }\\n  return null\\n}\\n\\nSplitter.prototype.flush = function () {\\n  var len = 16 - this.cache.length\\n  var padBuff = Buffer.allocUnsafe(len)\\n\\n  var i = -1\\n  while (++i < len) {\\n    padBuff.writeUInt8(len, i)\\n  }\\n\\n  return Buffer.concat([this.cache, padBuff])\\n}\\n\\nfunction createCipheriv (suite, password, iv) {\\n  var config = MODES[suite.toLowerCase()]\\n  if (!config) throw new TypeError('invalid suite type')\\n\\n  if (typeof password === 'string') password = Buffer.from(password)\\n  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)\\n\\n  if (typeof iv === 'string') iv = Buffer.from(iv)\\n  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)\\n\\n  if (config.type === 'stream') {\\n    return new StreamCipher(config.module, password, iv)\\n  } else if (config.type === 'auth') {\\n    return new AuthCipher(config.module, password, iv)\\n  }\\n\\n  return new Cipher(config.module, password, iv)\\n}\\n\\nfunction createCipher (suite, password) {\\n  var config = MODES[suite.toLowerCase()]\\n  if (!config) throw new TypeError('invalid suite type')\\n\\n  var keys = ebtk(password, false, config.key, config.iv)\\n  return createCipheriv(suite, keys.key, keys.iv)\\n}\\n\\nexports.createCipheriv = createCipheriv\\nexports.createCipher = createCipher\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Cipher\",\"mode\",\"key\",\"iv\",\"Transform\",\"call\",\"_cache\",\"Splitter\",\"_cipher\",\"aes\",\"AES\",\"_prev\",\"Buffer\",\"from\",\"_mode\",\"_autopadding\",\"cache\",\"allocUnsafe\",\"createCipheriv\",\"suite\",\"password\",\"config\",\"MODES\",\"toLowerCase\",\"TypeError\",\"length\",\"type\",\"StreamCipher\",\"AuthCipher\",\"ebtk\",\"inherits\",\"prototype\",\"_update\",\"Cipher.prototype._update\",\"data\",\"add\",\"chunk\",\"out\",\"get\",\"thing\",\"encrypt\",\"push\",\"concat\",\"PADDING\",\"alloc\",\"_final\",\"Cipher.prototype._final\",\"flush\",\"scrub\",\"equals\",\"Error\",\"setAutoPadding\",\"Cipher.prototype.setAutoPadding\",\"setTo\",\"Splitter.prototype.add\",\"Splitter.prototype.get\",\"slice\",\"Splitter.prototype.flush\",\"len\",\"padBuff\",\"i\",\"writeUInt8\",\"createCipher\",\"keys\"]\n}\n"]