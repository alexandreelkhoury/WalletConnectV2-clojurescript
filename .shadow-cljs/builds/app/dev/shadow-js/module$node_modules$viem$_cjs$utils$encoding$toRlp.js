["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/viem/_cjs/utils/encoding/toRlp.js"],"~:js","shadow$provide.module$node_modules$viem$_cjs$utils$encoding$toRlp=function(global,require,module,exports){function parse(hexOrBytes){return Array.isArray(hexOrBytes)?hexOrBytes.map(parse):\"string\"===typeof hexOrBytes?(0,toBytes_js_1.toBytes)(hexOrBytes):hexOrBytes}function format(bytes,type=\"bytes\"){return\"hex\"===type?(0,toHex_js_1.bytesToHex)(bytes):bytes}function bytesToRlp(bytes){return Array.isArray(bytes)?(bytes=(0,concat_js_1.concat)(bytes.map(bytesToRlp)),new Uint8Array([...encodeLength(bytes.length,\n192),...bytes])):1===bytes.length&&128>bytes[0]?bytes:new Uint8Array([...encodeLength(bytes.length,128),...bytes])}function encodeLength(length,offset){return 56>length?[offset+length]:[(0,toBytes_js_1.toBytes)(length).length+offset+55,...(0,toBytes_js_1.toBytes)(length)]}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.bytesToRlp=exports.toRlp=void 0;const concat_js_1=require(\"module$node_modules$viem$_cjs$utils$data$concat\"),toBytes_js_1=require(\"module$node_modules$viem$_cjs$utils$encoding$toBytes\"),\ntoHex_js_1=require(\"module$node_modules$viem$_cjs$utils$encoding$toHex\");exports.toRlp=function(hexOrBytes,to_){to_=to_||\"hex\";return format(bytesToRlp(parse(hexOrBytes)),to_)};exports.bytesToRlp=bytesToRlp}","~:source","shadow$provide[\"module$node_modules$viem$_cjs$utils$encoding$toRlp\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bytesToRlp = exports.toRlp = void 0;\nconst concat_js_1 = require(\"../data/concat.js\");\nconst toBytes_js_1 = require(\"./toBytes.js\");\nconst toHex_js_1 = require(\"./toHex.js\");\nfunction toRlp(hexOrBytes, to_) {\n    const to = to_ || 'hex';\n    return format(bytesToRlp(parse(hexOrBytes)), to);\n}\nexports.toRlp = toRlp;\nfunction parse(hexOrBytes) {\n    if (Array.isArray(hexOrBytes))\n        return hexOrBytes.map(parse);\n    return typeof hexOrBytes === 'string' ? (0, toBytes_js_1.toBytes)(hexOrBytes) : hexOrBytes;\n}\nfunction format(bytes, type = 'bytes') {\n    return type === 'hex' ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;\n}\nfunction bytesToRlp(bytes) {\n    if (Array.isArray(bytes)) {\n        const encoded = (0, concat_js_1.concat)(bytes.map(bytesToRlp));\n        return new Uint8Array([...encodeLength(encoded.length, 0xc0), ...encoded]);\n    }\n    if (bytes.length === 1 && bytes[0] < 0x80)\n        return bytes;\n    return new Uint8Array([...encodeLength(bytes.length, 0x80), ...bytes]);\n}\nexports.bytesToRlp = bytesToRlp;\nfunction encodeLength(length, offset) {\n    if (length < 56)\n        return [offset + length];\n    return [(0, toBytes_js_1.toBytes)(length).length + offset + 55, ...(0, toBytes_js_1.toBytes)(length)];\n}\n//# sourceMappingURL=toRlp.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$viem$_cjs$utils$data$concat","~$module$node_modules$viem$_cjs$utils$encoding$toBytes","~$shadow.js","~$module$node_modules$viem$_cjs$utils$encoding$toHex"]],"~:properties",["^5",["__esModule","value","toRlp","bytesToRlp"]],"~:compiled-at",1695064956403,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$viem$_cjs$utils$encoding$toRlp.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,kDAAA,CAAuE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAY/GC,QAASA,MAAK,CAACC,UAAD,CAAa,CACvB,MAAIC,MAAMC,CAAAA,OAAN,CAAcF,UAAd,CAAJ,CACWA,UAAWG,CAAAA,GAAX,CAAeJ,KAAf,CADX,CAE6B,QAAtB,GAAA,MAAOC,WAAP,CAAiC,GAAII,YAAaC,CAAAA,OAAjB,EAA0BL,UAA1B,CAAjC,CAAyEA,UAHzD,CAK3BM,QAASA,OAAM,CAACC,KAAD,CAAQC,IAAA,CAAO,OAAf,CAAwB,CACnC,MAAgB,KAAT,GAAAA,IAAA,CAAiB,GAAIC,UAAWC,CAAAA,UAAf,EAA2BH,KAA3B,CAAjB,CAAqDA,KADzB,CAGvCI,QAASA,WAAU,CAACJ,KAAD,CAAQ,CACvB,MAAIN,MAAMC,CAAAA,OAAN,CAAcK,KAAd,CAAJ,EACUK,KACC,CADS,GAAIC,WAAYC,CAAAA,MAAhB,EAAwBP,KAAMJ,CAAAA,GAAN,CAAUQ,UAAV,CAAxB,CACT,CAAA,IAAII,UAAJ,CAAe,CAAC,GAAGC,YAAA,CAAaJ,KAAQK,CAAAA,MAArB;AAA6B,GAA7B,CAAJ,CAAwC,GAAGL,KAA3C,CAAf,CAFX,EAIqB,CAArB,GAAIL,KAAMU,CAAAA,MAAV,EAAqC,GAArC,CAA0BV,KAAA,CAAM,CAAN,CAA1B,CACWA,KADX,CAEO,IAAIQ,UAAJ,CAAe,CAAC,GAAGC,YAAA,CAAaT,KAAMU,CAAAA,MAAnB,CAA2B,GAA3B,CAAJ,CAAsC,GAAGV,KAAzC,CAAf,CAPgB,CAU3BS,QAASA,aAAY,CAACC,MAAD,CAASC,MAAT,CAAiB,CAClC,MAAa,GAAb,CAAID,MAAJ,CACW,CAACC,MAAD,CAAUD,MAAV,CADX,CAEO,CAAC,GAAIb,YAAaC,CAAAA,OAAjB,EAA0BY,MAA1B,CAAkCA,CAAAA,MAAnC,CAA4CC,MAA5C,CAAqD,EAArD,CAAyD,GAAG,GAAId,YAAaC,CAAAA,OAAjB,EAA0BY,MAA1B,CAA5D,CAH2B,CA5BtCE,MAAOC,CAAAA,cAAP,CAAsBtB,OAAtB,CAA+B,YAA/B,CAA6C,CAAEuB,MAAO,CAAA,CAAT,CAA7C,CACAvB,QAAQa,CAAAA,UAAR,CAAqBb,OAAQwB,CAAAA,KAA7B,CAAqC,IAAK,EAC1C,OAAMT,YAAcjB,OAAA,CAAQ,iDAAR,CAApB,CACMQ,aAAeR,OAAA,CAAQ,sDAAR,CADrB;AAEMa,WAAab,OAAA,CAAQ,oDAAR,CAKnBE,QAAQwB,CAAAA,KAAR,CAJAA,QAAc,CAACtB,UAAD,CAAauB,GAAb,CAAkB,CACtBC,GAAAA,CAAKD,GAALC,EAAY,KAClB,OAAOlB,OAAA,CAAOK,UAAA,CAAWZ,KAAA,CAAMC,UAAN,CAAX,CAAP,CAAsCwB,GAAtC,CAFqB,CAsBhC1B,QAAQa,CAAAA,UAAR,CAAqBA,UA7B0F;\",\n\"sources\":[\"node_modules/viem/_cjs/utils/encoding/toRlp.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$viem$_cjs$utils$encoding$toRlp\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.bytesToRlp = exports.toRlp = void 0;\\nconst concat_js_1 = require(\\\"../data/concat.js\\\");\\nconst toBytes_js_1 = require(\\\"./toBytes.js\\\");\\nconst toHex_js_1 = require(\\\"./toHex.js\\\");\\nfunction toRlp(hexOrBytes, to_) {\\n    const to = to_ || 'hex';\\n    return format(bytesToRlp(parse(hexOrBytes)), to);\\n}\\nexports.toRlp = toRlp;\\nfunction parse(hexOrBytes) {\\n    if (Array.isArray(hexOrBytes))\\n        return hexOrBytes.map(parse);\\n    return typeof hexOrBytes === 'string' ? (0, toBytes_js_1.toBytes)(hexOrBytes) : hexOrBytes;\\n}\\nfunction format(bytes, type = 'bytes') {\\n    return type === 'hex' ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;\\n}\\nfunction bytesToRlp(bytes) {\\n    if (Array.isArray(bytes)) {\\n        const encoded = (0, concat_js_1.concat)(bytes.map(bytesToRlp));\\n        return new Uint8Array([...encodeLength(encoded.length, 0xc0), ...encoded]);\\n    }\\n    if (bytes.length === 1 && bytes[0] < 0x80)\\n        return bytes;\\n    return new Uint8Array([...encodeLength(bytes.length, 0x80), ...bytes]);\\n}\\nexports.bytesToRlp = bytesToRlp;\\nfunction encodeLength(length, offset) {\\n    if (length < 56)\\n        return [offset + length];\\n    return [(0, toBytes_js_1.toBytes)(length).length + offset + 55, ...(0, toBytes_js_1.toBytes)(length)];\\n}\\n//# sourceMappingURL=toRlp.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"parse\",\"hexOrBytes\",\"Array\",\"isArray\",\"map\",\"toBytes_js_1\",\"toBytes\",\"format\",\"bytes\",\"type\",\"toHex_js_1\",\"bytesToHex\",\"bytesToRlp\",\"encoded\",\"concat_js_1\",\"concat\",\"Uint8Array\",\"encodeLength\",\"length\",\"offset\",\"Object\",\"defineProperty\",\"value\",\"toRlp\",\"to_\",\"to\"]\n}\n"]