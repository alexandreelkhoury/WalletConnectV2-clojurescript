shadow$provide.module$node_modules$$noble$curves$abstract$modular=function(global,require,module,exports){function mod(a,b){a%=b;return a>=_0n?a:b+a}function pow(num,power,modulo){if(modulo<=_0n||power<_0n)throw Error("Expected power/modulo \x3e 0");if(modulo===_1n)return _0n;let res=_1n;for(;power>_0n;)power&_1n&&(res=res*num%modulo),num=num*num%modulo,power>>=_1n;return res}function invert(number,modulo){if(number===_0n||modulo<=_0n)throw Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
number=mod(number,modulo);let b=modulo,x=_0n,u=_1n;for(;number!==_0n;){const r=b%number,m=x-b/number*u;b=number;number=r;x=u;u=m}if(b!==_1n)throw Error("invert: does not exist");return mod(x,modulo)}function tonelliShanks(P){const legendreC=(P-_1n)/_2n;let Q,S,Z;Q=P-_1n;for(S=0;Q%_2n===_0n;Q/=_2n,S++);for(Z=_2n;Z<P&&pow(Z,legendreC,P)!==P-_1n;Z++);if(1===S){const p1div4=(P+_1n)/_4n;return function(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw Error("Cannot find square root");
return root}}const Q1div2=(Q+_1n)/_2n;return function(Fp,n){if(Fp.pow(n,legendreC)===Fp.neg(Fp.ONE))throw Error("Cannot find square root");var r=S;let g=Fp.pow(Fp.mul(Fp.ONE,Z),Q),x=Fp.pow(n,Q1div2);for(n=Fp.pow(n,Q);!Fp.eql(n,Fp.ONE);){if(Fp.eql(n,Fp.ZERO))return Fp.ZERO;let m=1;for(let t2=Fp.sqr(n);m<r&&!Fp.eql(t2,Fp.ONE);m++)t2=Fp.sqr(t2);r=Fp.pow(g,_1n<<BigInt(r-m-1));g=Fp.sqr(r);x=Fp.mul(x,r);n=Fp.mul(n,g);r=m}return x}}function FpSqrt(P){if(P%_4n===_3n){const p1div4=(P+_1n)/_4n;return function(Fp,
n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw Error("Cannot find square root");return root}}if(P%_8n===_5n){const c1=(P-_5n)/_8n;return function(Fp,n){var n2=Fp.mul(n,_2n),v=Fp.pow(n2,c1);n2=Fp.mul(n,v);v=Fp.mul(Fp.mul(n2,_2n),v);n2=Fp.mul(n2,Fp.sub(v,Fp.ONE));if(!Fp.eql(Fp.sqr(n2),n))throw Error("Cannot find square root");return n2}}return tonelliShanks(P)}function FpPow(f,num,power){if(power<_0n)throw Error("Expected power \x3e 0");if(power===_0n)return f.ONE;if(power===_1n)return num;
let p=f.ONE;for(;power>_0n;)power&_1n&&(p=f.mul(p,num)),num=f.sqr(num),power>>=_1n;return p}function FpInvertBatch(f,nums){const tmp=Array(nums.length);var lastMultiplied=nums.reduce((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=acc;return f.mul(acc,num)},f.ONE);lastMultiplied=f.inv(lastMultiplied);nums.reduceRight((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=f.mul(acc,tmp[i]);return f.mul(acc,num)},lastMultiplied);return tmp}function nLength(n,nBitLength){n=void 0!==nBitLength?nBitLength:n.toString(2).length;
return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function getFieldBytesLength(fieldOrder){if("bigint"!==typeof fieldOrder)throw Error("field order must be bigint");fieldOrder=fieldOrder.toString(2).length;return Math.ceil(fieldOrder/8)}function getMinHashLength(fieldOrder){fieldOrder=getFieldBytesLength(fieldOrder);return fieldOrder+Math.ceil(fieldOrder/2)}Object.defineProperty(exports,"__esModule",{value:!0});exports.mapHashToField=exports.getMinHashLength=exports.getFieldBytesLength=exports.hashToPrivateScalar=
exports.FpSqrtEven=exports.FpSqrtOdd=exports.Field=exports.nLength=exports.FpIsSquare=exports.FpDiv=exports.FpInvertBatch=exports.FpPow=exports.validateField=exports.isNegativeLE=exports.FpSqrt=exports.tonelliShanks=exports.invert=exports.pow2=exports.pow=exports.mod=void 0;const utils_js_1=require("module$node_modules$$noble$curves$abstract$utils"),_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);exports.mod=mod;exports.pow=pow;exports.pow2=function(x,
power,modulo){for(;power-- >_0n;)x*=x,x%=modulo;return x};exports.invert=invert;exports.tonelliShanks=tonelliShanks;exports.FpSqrt=FpSqrt;exports.isNegativeLE=(num,modulo)=>(mod(num,modulo)&_1n)===_1n;const FIELD_FIELDS="create isValid is0 neg inv sqrt sqr eql add sub mul pow div addN subN mulN sqrN".split(" ");exports.validateField=function(field){const opts=FIELD_FIELDS.reduce((map,val)=>{map[val]="function";return map},{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});
return(0,utils_js_1.validateObject)(field,opts)};exports.FpPow=FpPow;exports.FpInvertBatch=FpInvertBatch;exports.FpDiv=function(f,lhs,rhs){return f.mul(lhs,"bigint"===typeof rhs?invert(rhs,f.ORDER):f.inv(rhs))};exports.FpIsSquare=function(f){const legendreConst=(f.ORDER-_1n)/_2n;return x=>{x=f.pow(x,legendreConst);return f.eql(x,f.ZERO)||f.eql(x,f.ONE)}};exports.nLength=nLength;exports.Field=function(ORDER,bitLen,isLE=!1,redef={}){if(ORDER<=_0n)throw Error(`Expected Field ORDER > 0, got ${ORDER}`);
const {nBitLength:BITS,nByteLength:BYTES}=nLength(ORDER,bitLen);if(2048<BYTES)throw Error("Field lengths over 2048 bytes are not supported");const sqrtP=FpSqrt(ORDER),f=Object.freeze({ORDER,BITS,BYTES,MASK:(0,utils_js_1.bitMask)(BITS),ZERO:_0n,ONE:_1n,create:num=>mod(num,ORDER),isValid:num=>{if("bigint"!==typeof num)throw Error(`Invalid field element: expected bigint, got ${typeof num}`);return _0n<=num&&num<ORDER},is0:num=>num===_0n,isOdd:num=>(num&_1n)===_1n,neg:num=>mod(-num,ORDER),eql:(lhs,rhs)=>
lhs===rhs,sqr:num=>mod(num*num,ORDER),add:(lhs,rhs)=>mod(lhs+rhs,ORDER),sub:(lhs,rhs)=>mod(lhs-rhs,ORDER),mul:(lhs,rhs)=>mod(lhs*rhs,ORDER),pow:(num,power)=>FpPow(f,num,power),div:(lhs,rhs)=>mod(lhs*invert(rhs,ORDER),ORDER),sqrN:num=>num*num,addN:(lhs,rhs)=>lhs+rhs,subN:(lhs,rhs)=>lhs-rhs,mulN:(lhs,rhs)=>lhs*rhs,inv:num=>invert(num,ORDER),sqrt:redef.sqrt||(n=>sqrtP(f,n)),invertBatch:lst=>FpInvertBatch(f,lst),cmov:(a,b,c)=>c?b:a,toBytes:num=>isLE?(0,utils_js_1.numberToBytesLE)(num,BYTES):(0,utils_js_1.numberToBytesBE)(num,
BYTES),fromBytes:bytes=>{if(bytes.length!==BYTES)throw Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);return isLE?(0,utils_js_1.bytesToNumberLE)(bytes):(0,utils_js_1.bytesToNumberBE)(bytes)}});return Object.freeze(f)};exports.FpSqrtOdd=function(Fp,elm){if(!Fp.isOdd)throw Error("Field doesn't have isOdd");elm=Fp.sqrt(elm);return Fp.isOdd(elm)?elm:Fp.neg(elm)};exports.FpSqrtEven=function(Fp,elm){if(!Fp.isOdd)throw Error("Field doesn't have isOdd");elm=Fp.sqrt(elm);return Fp.isOdd(elm)?
Fp.neg(elm):elm};exports.hashToPrivateScalar=function(hash,groupOrder,isLE=!1){hash=(0,utils_js_1.ensureBytes)("privateHash",hash);const hashLen=hash.length,minLen=nLength(groupOrder).nByteLength+8;if(24>minLen||hashLen<minLen||1024<hashLen)throw Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);hash=isLE?(0,utils_js_1.bytesToNumberLE)(hash):(0,utils_js_1.bytesToNumberBE)(hash);return mod(hash,groupOrder-_1n)+_1n};exports.getFieldBytesLength=getFieldBytesLength;
exports.getMinHashLength=getMinHashLength;exports.mapHashToField=function(key,fieldOrder,isLE=!1){const len=key.length,fieldLen=getFieldBytesLength(fieldOrder),minLen=getMinHashLength(fieldOrder);if(16>len||len<minLen||1024<len)throw Error(`expected ${minLen}-1024 bytes of input, got ${len}`);key=isLE?(0,utils_js_1.bytesToNumberBE)(key):(0,utils_js_1.bytesToNumberLE)(key);fieldOrder=mod(key,fieldOrder-_1n)+_1n;return isLE?(0,utils_js_1.numberToBytesLE)(fieldOrder,fieldLen):(0,utils_js_1.numberToBytesBE)(fieldOrder,
fieldLen)}}
//# sourceMappingURL=module$node_modules$$noble$curves$abstract$modular.js.map
