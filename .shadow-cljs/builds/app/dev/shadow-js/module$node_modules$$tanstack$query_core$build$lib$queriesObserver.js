["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@tanstack/query-core/build/lib/queriesObserver.js"],"~:js","shadow$provide.module$node_modules$$tanstack$query_core$build$lib$queriesObserver=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});var utils=require(\"module$node_modules$$tanstack$query_core$build$lib$utils\"),notifyManager=require(\"module$node_modules$$tanstack$query_core$build$lib$notifyManager\"),queryObserver=require(\"module$node_modules$$tanstack$query_core$build$lib$queryObserver\");global=require(\"module$node_modules$$tanstack$query_core$build$lib$subscribable\");\nclass QueriesObserver extends global.Subscribable{constructor(client,queries){super();this.client=client;this.queries=[];this.result=[];this.observers=[];this.observersMap={};queries&&this.setQueries(queries)}onSubscribe(){1===this.listeners.size&&this.observers.forEach(observer=>{observer.subscribe(result=>{this.onUpdate(observer,result)})})}onUnsubscribe(){this.listeners.size||this.destroy()}destroy(){this.listeners=new Set;this.observers.forEach(observer=>{observer.destroy()})}setQueries(queries,\nnotifyOptions){this.queries=queries;notifyManager.notifyManager.batch(()=>{const prevObservers=this.observers;var newObserverMatches=this.findMatchingObservers(this.queries);newObserverMatches.forEach(match=>match.observer.setOptions(match.defaultedQueryOptions,notifyOptions));newObserverMatches=newObserverMatches.map(match=>match.observer);const newObserversMap=Object.fromEntries(newObserverMatches.map(observer=>[observer.options.queryHash,observer])),newResult=newObserverMatches.map(observer=>observer.getCurrentResult()),\nhasIndexChange=newObserverMatches.some((observer,index)=>observer!==prevObservers[index]);if(prevObservers.length!==newObserverMatches.length||hasIndexChange)this.observers=newObserverMatches,this.observersMap=newObserversMap,this.result=newResult,this.hasListeners()&&(utils.difference(prevObservers,newObserverMatches).forEach(observer=>{observer.destroy()}),utils.difference(newObserverMatches,prevObservers).forEach(observer=>{observer.subscribe(result=>{this.onUpdate(observer,result)})}),this.notify())})}getCurrentResult(){return this.result}getQueries(){return this.observers.map(observer=>\nobserver.getCurrentQuery())}getObservers(){return this.observers}getOptimisticResult(queries){return this.findMatchingObservers(queries).map(match=>match.observer.getOptimisticResult(match.defaultedQueryOptions))}findMatchingObservers(queries){var prevObservers=this.observers;const prevObserversMap=new Map(prevObservers.map(observer=>[observer.options.queryHash,observer])),defaultedQueryOptions=queries.map(options=>this.client.defaultQueryOptions(options));queries=defaultedQueryOptions.flatMap(defaultedOptions=>\n{const match=prevObserversMap.get(defaultedOptions.queryHash);return null!=match?[{defaultedQueryOptions:defaultedOptions,observer:match}]:[]});const matchedQueryHashes=new Set(queries.map(match=>match.defaultedQueryOptions.queryHash)),unmatchedQueries=defaultedQueryOptions.filter(defaultedOptions=>!matchedQueryHashes.has(defaultedOptions.queryHash)),matchingObserversSet=new Set(queries.map(match=>match.observer)),unmatchedObservers=prevObservers.filter(prevObserver=>!matchingObserversSet.has(prevObserver)),\ngetObserver=options=>{options=this.client.defaultQueryOptions(options);const currentObserver=this.observersMap[options.queryHash];return null!=currentObserver?currentObserver:new queryObserver.QueryObserver(this.client,options)};prevObservers=unmatchedQueries.map((options,index)=>options.keepPreviousData&&(index=unmatchedObservers[index],void 0!==index)?{defaultedQueryOptions:options,observer:index}:{defaultedQueryOptions:options,observer:getObserver(options)});return queries.concat(prevObservers).sort((a,\nb)=>defaultedQueryOptions.indexOf(a.defaultedQueryOptions)-defaultedQueryOptions.indexOf(b.defaultedQueryOptions))}onUpdate(observer,result){observer=this.observers.indexOf(observer);-1!==observer&&(this.result=utils.replaceAt(this.result,observer,result),this.notify())}notify(){notifyManager.notifyManager.batch(()=>{this.listeners.forEach(({listener})=>{listener(this.result)})})}}exports.QueriesObserver=QueriesObserver}","~:source","shadow$provide[\"module$node_modules$$tanstack$query_core$build$lib$queriesObserver\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('./utils.js');\nvar notifyManager = require('./notifyManager.js');\nvar queryObserver = require('./queryObserver.js');\nvar subscribable = require('./subscribable.js');\n\nclass QueriesObserver extends subscribable.Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      utils.difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      utils.difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getQueries() {\n    return this.observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getObservers() {\n    return this.observers;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\n    const matchingObserversSet = new Set(matchingObservers.map(match => match.observer));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObserversSet.has(prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new queryObserver.QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = utils.replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nexports.QueriesObserver = QueriesObserver;\n//# sourceMappingURL=queriesObserver.js.map\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$tanstack$query_core$build$lib$subscribable","~$module$node_modules$$tanstack$query_core$build$lib$utils","~$module$node_modules$$tanstack$query_core$build$lib$queryObserver","~$module$node_modules$$tanstack$query_core$build$lib$notifyManager"]],"~:properties",["^5",["queries","observer","observers","__esModule","QueriesObserver","observersMap","value","defaultedQueryOptions","client","listeners","result"]],"~:compiled-at",1695111489945,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$tanstack$query_core$build$lib$queriesObserver.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@tanstack/query-core/build/lib/queriesObserver.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$tanstack$query_core$build$lib$queriesObserver\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nvar utils = require('./utils.js');\\nvar notifyManager = require('./notifyManager.js');\\nvar queryObserver = require('./queryObserver.js');\\nvar subscribable = require('./subscribable.js');\\n\\nclass QueriesObserver extends subscribable.Subscribable {\\n  constructor(client, queries) {\\n    super();\\n    this.client = client;\\n    this.queries = [];\\n    this.result = [];\\n    this.observers = [];\\n    this.observersMap = {};\\n\\n    if (queries) {\\n      this.setQueries(queries);\\n    }\\n  }\\n\\n  onSubscribe() {\\n    if (this.listeners.size === 1) {\\n      this.observers.forEach(observer => {\\n        observer.subscribe(result => {\\n          this.onUpdate(observer, result);\\n        });\\n      });\\n    }\\n  }\\n\\n  onUnsubscribe() {\\n    if (!this.listeners.size) {\\n      this.destroy();\\n    }\\n  }\\n\\n  destroy() {\\n    this.listeners = new Set();\\n    this.observers.forEach(observer => {\\n      observer.destroy();\\n    });\\n  }\\n\\n  setQueries(queries, notifyOptions) {\\n    this.queries = queries;\\n    notifyManager.notifyManager.batch(() => {\\n      const prevObservers = this.observers;\\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\\n\\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\\n      const newObservers = newObserverMatches.map(match => match.observer);\\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\\n\\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\\n        return;\\n      }\\n\\n      this.observers = newObservers;\\n      this.observersMap = newObserversMap;\\n      this.result = newResult;\\n\\n      if (!this.hasListeners()) {\\n        return;\\n      }\\n\\n      utils.difference(prevObservers, newObservers).forEach(observer => {\\n        observer.destroy();\\n      });\\n      utils.difference(newObservers, prevObservers).forEach(observer => {\\n        observer.subscribe(result => {\\n          this.onUpdate(observer, result);\\n        });\\n      });\\n      this.notify();\\n    });\\n  }\\n\\n  getCurrentResult() {\\n    return this.result;\\n  }\\n\\n  getQueries() {\\n    return this.observers.map(observer => observer.getCurrentQuery());\\n  }\\n\\n  getObservers() {\\n    return this.observers;\\n  }\\n\\n  getOptimisticResult(queries) {\\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\\n  }\\n\\n  findMatchingObservers(queries) {\\n    const prevObservers = this.observers;\\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\\n\\n      if (match != null) {\\n        return [{\\n          defaultedQueryOptions: defaultedOptions,\\n          observer: match\\n        }];\\n      }\\n\\n      return [];\\n    });\\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\\n    const matchingObserversSet = new Set(matchingObservers.map(match => match.observer));\\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObserversSet.has(prevObserver));\\n\\n    const getObserver = options => {\\n      const defaultedOptions = this.client.defaultQueryOptions(options);\\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\\n      return currentObserver != null ? currentObserver : new queryObserver.QueryObserver(this.client, defaultedOptions);\\n    };\\n\\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\\n      if (options.keepPreviousData) {\\n        // return previous data from one of the observers that no longer match\\n        const previouslyUsedObserver = unmatchedObservers[index];\\n\\n        if (previouslyUsedObserver !== undefined) {\\n          return {\\n            defaultedQueryOptions: options,\\n            observer: previouslyUsedObserver\\n          };\\n        }\\n      }\\n\\n      return {\\n        defaultedQueryOptions: options,\\n        observer: getObserver(options)\\n      };\\n    });\\n\\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\\n\\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\\n  }\\n\\n  onUpdate(observer, result) {\\n    const index = this.observers.indexOf(observer);\\n\\n    if (index !== -1) {\\n      this.result = utils.replaceAt(this.result, index, result);\\n      this.notify();\\n    }\\n  }\\n\\n  notify() {\\n    notifyManager.notifyManager.batch(() => {\\n      this.listeners.forEach(({\\n        listener\\n      }) => {\\n        listener(this.result);\\n      });\\n    });\\n  }\\n\\n}\\n\\nexports.QueriesObserver = QueriesObserver;\\n//# sourceMappingURL=queriesObserver.js.map\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"utils\",\"notifyManager\",\"queryObserver\",\"subscribable\",\"QueriesObserver\",\"Subscribable\",\"constructor\",\"client\",\"queries\",\"result\",\"observers\",\"observersMap\",\"setQueries\",\"onSubscribe\",\"listeners\",\"size\",\"forEach\",\"observer\",\"subscribe\",\"onUpdate\",\"onUnsubscribe\",\"destroy\",\"Set\",\"notifyOptions\",\"batch\",\"prevObservers\",\"newObserverMatches\",\"findMatchingObservers\",\"match\",\"setOptions\",\"defaultedQueryOptions\",\"newObservers\",\"map\",\"newObserversMap\",\"fromEntries\",\"options\",\"queryHash\",\"newResult\",\"getCurrentResult\",\"hasIndexChange\",\"some\",\"index\",\"length\",\"hasListeners\",\"difference\",\"notify\",\"getQueries\",\"getCurrentQuery\",\"getObservers\",\"getOptimisticResult\",\"prevObserversMap\",\"Map\",\"defaultQueryOptions\",\"matchingObservers\",\"flatMap\",\"defaultedOptions\",\"get\",\"matchedQueryHashes\",\"unmatchedQueries\",\"filter\",\"has\",\"matchingObserversSet\",\"unmatchedObservers\",\"prevObserver\",\"getObserver\",\"currentObserver\",\"QueryObserver\",\"newOrReusedObservers\",\"keepPreviousData\",\"previouslyUsedObserver\",\"undefined\",\"concat\",\"sort\",\"a\",\"b\",\"sortMatchesByOrderOfQueries\",\"indexOf\",\"replaceAt\",\"listener\"]\n}\n"]