{
"version":3,
"file":"module$node_modules$viem$_cjs$utils$encoding$toHex.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/viem/_cjs/utils/encoding/toHex.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$viem$_cjs$utils$encoding$toHex\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toHex = void 0;\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst pad_js_1 = require(\"../data/pad.js\");\nconst fromHex_js_1 = require(\"./fromHex.js\");\nconst hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\nfunction toHex(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToHex(value, opts);\n    if (typeof value === 'string') {\n        return stringToHex(value, opts);\n    }\n    if (typeof value === 'boolean')\n        return boolToHex(value, opts);\n    return bytesToHex(value, opts);\n}\nexports.toHex = toHex;\nfunction boolToHex(value, opts = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof opts.size === 'number') {\n        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });\n        return (0, pad_js_1.pad)(hex, { size: opts.size });\n    }\n    return hex;\n}\nexports.boolToHex = boolToHex;\nfunction bytesToHex(value, opts = {}) {\n    let hexString = '';\n    for (let i = 0; i < value.length; i++) {\n        hexString += hexes[value[i]];\n    }\n    const hex = `0x${hexString}`;\n    if (typeof opts.size === 'number') {\n        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });\n        return (0, pad_js_1.pad)(hex, { dir: 'right', size: opts.size });\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHex(value_, opts = {}) {\n    const { signed, size } = opts;\n    const value = BigInt(value_);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value_ === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value > maxValue) || value < minValue) {\n        const suffix = typeof value_ === 'bigint' ? 'n' : '';\n        throw new encoding_js_1.IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value_}${suffix}`,\n        });\n    }\n    const hex = `0x${(signed && value < 0\n        ? (1n << BigInt(size * 8)) + BigInt(value)\n        : value).toString(16)}`;\n    if (size)\n        return (0, pad_js_1.pad)(hex, { size });\n    return hex;\n}\nexports.numberToHex = numberToHex;\nconst encoder = new TextEncoder();\nfunction stringToHex(value_, opts = {}) {\n    const value = encoder.encode(value_);\n    return bytesToHex(value, opts);\n}\nexports.stringToHex = stringToHex;\n//# sourceMappingURL=toHex.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","boolToHex","value","opts","hex","Number","size","fromHex_js_1","assertSize","pad_js_1","pad","bytesToHex","hexString","i","length","hexes","dir","numberToHex","value_","signed","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","encoding_js_1","IntegerOutOfRangeError","max","undefined","min","toString","stringToHex","encoder","encode","Object","defineProperty","toHex","Array","from","_v","padStart","TextEncoder"]
}
