["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/viem/_cjs/utils/typedData.js"],"~:js","shadow$provide.module$node_modules$viem$_cjs$utils$typedData=function(global,require,module,exports){function getTypesForEIP712Domain({domain}){return[\"string\"===typeof domain?.name&&{name:\"name\",type:\"string\"},domain?.version&&{name:\"version\",type:\"string\"},\"number\"===typeof domain?.chainId&&{name:\"chainId\",type:\"uint256\"},domain?.verifyingContract&&{name:\"verifyingContract\",type:\"address\"},domain?.salt&&{name:\"salt\",type:\"bytes32\"}].filter(Boolean)}Object.defineProperty(exports,\"__esModule\",{value:!0});\nexports.domainSeparator=exports.getTypesForEIP712Domain=exports.validateTypedData=void 0;const abi_js_1=require(\"module$node_modules$viem$_cjs$errors$abi\"),address_js_1=require(\"module$node_modules$viem$_cjs$errors$address\"),isAddress_js_1=require(\"module$node_modules$viem$_cjs$utils$address$isAddress\"),size_js_1=require(\"module$node_modules$viem$_cjs$utils$data$size\"),toHex_js_1=require(\"module$node_modules$viem$_cjs$utils$encoding$toHex\"),regex_js_1=require(\"module$node_modules$viem$_cjs$utils$regex\"),\nhashTypedData_js_1=require(\"module$node_modules$viem$_cjs$utils$signature$hashTypedData\");exports.validateTypedData=function({domain,message,primaryType,types:types_}){const validateData=(struct,value_)=>{for(const param of struct){const {name,type:type_}=param;var type=type_;struct=value_[name];var integerMatch=type.match(regex_js_1.integerRegex);if(integerMatch&&(\"number\"===typeof struct||\"bigint\"===typeof struct)){const [,base,size_]=integerMatch;(0,toHex_js_1.numberToHex)(struct,{signed:\"int\"===\nbase,size:parseInt(size_)/8})}if(\"address\"===type&&\"string\"===typeof struct&&!(0,isAddress_js_1.isAddress)(struct))throw new address_js_1.InvalidAddressError({address:struct});if(integerMatch=type.match(regex_js_1.bytesRegex))if([,integerMatch]=integerMatch,integerMatch&&(0,size_js_1.size)(struct)!==parseInt(integerMatch))throw new abi_js_1.BytesSizeMismatchError({expectedSize:parseInt(integerMatch),givenSize:(0,size_js_1.size)(struct)});(type=types_[type])&&validateData(type,struct)}};types_.EIP712Domain&&\ndomain&&validateData(types_.EIP712Domain,domain);\"EIP712Domain\"!==primaryType&&validateData(types_[primaryType],message)};exports.getTypesForEIP712Domain=getTypesForEIP712Domain;exports.domainSeparator=function({domain}){return(0,hashTypedData_js_1.hashDomain)({domain,types:{EIP712Domain:getTypesForEIP712Domain({domain})}})}}","~:source","shadow$provide[\"module$node_modules$viem$_cjs$utils$typedData\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.domainSeparator = exports.getTypesForEIP712Domain = exports.validateTypedData = void 0;\nconst abi_js_1 = require(\"../errors/abi.js\");\nconst address_js_1 = require(\"../errors/address.js\");\nconst isAddress_js_1 = require(\"./address/isAddress.js\");\nconst size_js_1 = require(\"./data/size.js\");\nconst toHex_js_1 = require(\"./encoding/toHex.js\");\nconst regex_js_1 = require(\"./regex.js\");\nconst hashTypedData_js_1 = require(\"./signature/hashTypedData.js\");\nfunction validateTypedData({ domain, message, primaryType, types: types_, }) {\n    const types = types_;\n    const validateData = (struct, value_) => {\n        for (const param of struct) {\n            const { name, type: type_ } = param;\n            const type = type_;\n            const value = value_[name];\n            const integerMatch = type.match(regex_js_1.integerRegex);\n            if (integerMatch &&\n                (typeof value === 'number' || typeof value === 'bigint')) {\n                const [_type, base, size_] = integerMatch;\n                (0, toHex_js_1.numberToHex)(value, {\n                    signed: base === 'int',\n                    size: parseInt(size_) / 8,\n                });\n            }\n            if (type === 'address' && typeof value === 'string' && !(0, isAddress_js_1.isAddress)(value))\n                throw new address_js_1.InvalidAddressError({ address: value });\n            const bytesMatch = type.match(regex_js_1.bytesRegex);\n            if (bytesMatch) {\n                const [_type, size_] = bytesMatch;\n                if (size_ && (0, size_js_1.size)(value) !== parseInt(size_))\n                    throw new abi_js_1.BytesSizeMismatchError({\n                        expectedSize: parseInt(size_),\n                        givenSize: (0, size_js_1.size)(value),\n                    });\n            }\n            const struct = types[type];\n            if (struct)\n                validateData(struct, value);\n        }\n    };\n    if (types.EIP712Domain && domain)\n        validateData(types.EIP712Domain, domain);\n    if (primaryType !== 'EIP712Domain') {\n        const type = types[primaryType];\n        validateData(type, message);\n    }\n}\nexports.validateTypedData = validateTypedData;\nfunction getTypesForEIP712Domain({ domain, }) {\n    return [\n        typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n        domain?.version && { name: 'version', type: 'string' },\n        typeof domain?.chainId === 'number' && {\n            name: 'chainId',\n            type: 'uint256',\n        },\n        domain?.verifyingContract && {\n            name: 'verifyingContract',\n            type: 'address',\n        },\n        domain?.salt && { name: 'salt', type: 'bytes32' },\n    ].filter(Boolean);\n}\nexports.getTypesForEIP712Domain = getTypesForEIP712Domain;\nfunction domainSeparator({ domain }) {\n    return (0, hashTypedData_js_1.hashDomain)({\n        domain,\n        types: {\n            EIP712Domain: getTypesForEIP712Domain({ domain }),\n        },\n    });\n}\nexports.domainSeparator = domainSeparator;\n//# sourceMappingURL=typedData.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$viem$_cjs$errors$address","~$shadow.js","~$module$node_modules$viem$_cjs$errors$abi","~$module$node_modules$viem$_cjs$utils$address$isAddress","~$module$node_modules$viem$_cjs$utils$regex","~$module$node_modules$viem$_cjs$utils$signature$hashTypedData","~$module$node_modules$viem$_cjs$utils$data$size","~$module$node_modules$viem$_cjs$utils$encoding$toHex"]],"~:properties",["^5",["validateTypedData","signed","givenSize","__esModule","types","name","value","getTypesForEIP712Domain","EIP712Domain","address","domain","type","expectedSize","domainSeparator","size"]],"~:compiled-at",1695111490304,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$viem$_cjs$utils$typedData.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/viem/_cjs/utils/typedData.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$viem$_cjs$utils$typedData\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.domainSeparator = exports.getTypesForEIP712Domain = exports.validateTypedData = void 0;\\nconst abi_js_1 = require(\\\"../errors/abi.js\\\");\\nconst address_js_1 = require(\\\"../errors/address.js\\\");\\nconst isAddress_js_1 = require(\\\"./address/isAddress.js\\\");\\nconst size_js_1 = require(\\\"./data/size.js\\\");\\nconst toHex_js_1 = require(\\\"./encoding/toHex.js\\\");\\nconst regex_js_1 = require(\\\"./regex.js\\\");\\nconst hashTypedData_js_1 = require(\\\"./signature/hashTypedData.js\\\");\\nfunction validateTypedData({ domain, message, primaryType, types: types_, }) {\\n    const types = types_;\\n    const validateData = (struct, value_) => {\\n        for (const param of struct) {\\n            const { name, type: type_ } = param;\\n            const type = type_;\\n            const value = value_[name];\\n            const integerMatch = type.match(regex_js_1.integerRegex);\\n            if (integerMatch &&\\n                (typeof value === 'number' || typeof value === 'bigint')) {\\n                const [_type, base, size_] = integerMatch;\\n                (0, toHex_js_1.numberToHex)(value, {\\n                    signed: base === 'int',\\n                    size: parseInt(size_) / 8,\\n                });\\n            }\\n            if (type === 'address' && typeof value === 'string' && !(0, isAddress_js_1.isAddress)(value))\\n                throw new address_js_1.InvalidAddressError({ address: value });\\n            const bytesMatch = type.match(regex_js_1.bytesRegex);\\n            if (bytesMatch) {\\n                const [_type, size_] = bytesMatch;\\n                if (size_ && (0, size_js_1.size)(value) !== parseInt(size_))\\n                    throw new abi_js_1.BytesSizeMismatchError({\\n                        expectedSize: parseInt(size_),\\n                        givenSize: (0, size_js_1.size)(value),\\n                    });\\n            }\\n            const struct = types[type];\\n            if (struct)\\n                validateData(struct, value);\\n        }\\n    };\\n    if (types.EIP712Domain && domain)\\n        validateData(types.EIP712Domain, domain);\\n    if (primaryType !== 'EIP712Domain') {\\n        const type = types[primaryType];\\n        validateData(type, message);\\n    }\\n}\\nexports.validateTypedData = validateTypedData;\\nfunction getTypesForEIP712Domain({ domain, }) {\\n    return [\\n        typeof domain?.name === 'string' && { name: 'name', type: 'string' },\\n        domain?.version && { name: 'version', type: 'string' },\\n        typeof domain?.chainId === 'number' && {\\n            name: 'chainId',\\n            type: 'uint256',\\n        },\\n        domain?.verifyingContract && {\\n            name: 'verifyingContract',\\n            type: 'address',\\n        },\\n        domain?.salt && { name: 'salt', type: 'bytes32' },\\n    ].filter(Boolean);\\n}\\nexports.getTypesForEIP712Domain = getTypesForEIP712Domain;\\nfunction domainSeparator({ domain }) {\\n    return (0, hashTypedData_js_1.hashDomain)({\\n        domain,\\n        types: {\\n            EIP712Domain: getTypesForEIP712Domain({ domain }),\\n        },\\n    });\\n}\\nexports.domainSeparator = domainSeparator;\\n//# sourceMappingURL=typedData.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getTypesForEIP712Domain\",\"domain\",\"name\",\"type\",\"version\",\"chainId\",\"verifyingContract\",\"salt\",\"filter\",\"Boolean\",\"Object\",\"defineProperty\",\"value\",\"domainSeparator\",\"validateTypedData\",\"abi_js_1\",\"address_js_1\",\"isAddress_js_1\",\"size_js_1\",\"toHex_js_1\",\"regex_js_1\",\"hashTypedData_js_1\",\"message\",\"primaryType\",\"types_\",\"validateData\",\"struct\",\"value_\",\"param\",\"type_\",\"integerMatch\",\"match\",\"integerRegex\",\"base\",\"size_\",\"numberToHex\",\"signed\",\"size\",\"parseInt\",\"isAddress\",\"InvalidAddressError\",\"address\",\"bytesMatch\",\"bytesRegex\",\"BytesSizeMismatchError\",\"expectedSize\",\"givenSize\",\"EIP712Domain\",\"hashDomain\",\"types\"]\n}\n"]