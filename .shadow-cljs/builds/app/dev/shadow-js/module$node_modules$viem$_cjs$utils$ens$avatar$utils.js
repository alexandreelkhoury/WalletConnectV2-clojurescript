["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/viem/_cjs/utils/ens/avatar/utils.js"],"~:js","shadow$provide.module$node_modules$viem$_cjs$utils$ens$avatar$utils=function(global,require,module,exports){async function isImageUri(uri){try{const res=await fetch(uri,{method:\"HEAD\"});return 200===res.status?res.headers.get(\"content-type\")?.startsWith(\"image/\"):!1}catch(error){return\"object\"===typeof error&&\"undefined\"!==typeof error.response||!globalThis.hasOwnProperty(\"Image\")?!1:new Promise(resolve=>{const img=new Image;img.onload=()=>{resolve(!0)};img.onerror=()=>{resolve(!1)};img.src=uri})}}\nfunction getGateway(custom,defaultGateway){return custom?custom.endsWith(\"/\")?custom.slice(0,-1):custom:defaultGateway}function resolveAvatarUri({uri,gatewayUrls}){var isEncoded=base64Regex.test(uri);if(isEncoded)return{uri,isOnChain:!0,isEncoded};isEncoded=getGateway(gatewayUrls?.ipfs,\"https://ipfs.io\");const arweaveGateway=getGateway(gatewayUrls?.arweave,\"https://arweave.net\");var networkRegexMatch=uri.match(networkRegex);const {protocol,subpath,target,subtarget=\"\"}=networkRegexMatch?.groups||{};\nnetworkRegexMatch=\"ipns:/\"===protocol||\"ipns/\"===subpath;const isIPFS=\"ipfs:/\"===protocol||\"ipfs/\"===subpath||ipfsHashRegex.test(uri);if(uri.startsWith(\"http\")&&!networkRegexMatch&&!isIPFS)return isEncoded=uri,gatewayUrls?.arweave&&(isEncoded=uri.replace(/https:\\/\\/arweave.net/g,gatewayUrls?.arweave)),{uri:isEncoded,isOnChain:!1,isEncoded:!1};if((networkRegexMatch||isIPFS)&&target)return{uri:`${isEncoded}/${networkRegexMatch?\"ipns\":\"ipfs\"}/${target}${subtarget}`,isOnChain:!1,isEncoded:!1};if(\"ar:/\"===\nprotocol&&target)return{uri:`${arweaveGateway}/${target}${subtarget||\"\"}`,isOnChain:!1,isEncoded:!1};gatewayUrls=uri.replace(dataURIRegex,\"\");gatewayUrls.startsWith(\"\\x3csvg\")&&(gatewayUrls=`data:image/svg+xml;base64,${btoa(gatewayUrls)}`);if(gatewayUrls.startsWith(\"data:\")||gatewayUrls.startsWith(\"{\"))return{uri:gatewayUrls,isOnChain:!0,isEncoded:!1};throw new ens_js_1.EnsAvatarUriResolutionError({uri});}function getJsonImage(data){if(\"object\"!==typeof data||!(\"image\"in data||\"image_url\"in data||\n\"image_data\"in data))throw new ens_js_1.EnsAvatarInvalidMetadataError({data});return data.image||data.image_url||data.image_data}async function parseAvatarUri({gatewayUrls,uri}){const {uri:resolvedURI,isOnChain}=resolveAvatarUri({uri,gatewayUrls});if(isOnChain||await isImageUri(resolvedURI))return resolvedURI;throw new ens_js_1.EnsAvatarUriResolutionError({uri});}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.getNftTokenUri=exports.parseNftUri=exports.parseAvatarUri=exports.getMetadataAvatarUri=\nexports.getJsonImage=exports.resolveAvatarUri=exports.getGateway=exports.isImageUri=void 0;const readContract_js_1=require(\"module$node_modules$viem$_cjs$actions$public$readContract\"),ens_js_1=require(\"module$node_modules$viem$_cjs$errors$ens\"),networkRegex=/(?<protocol>https?:\\/\\/[^\\/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/,ipfsHashRegex=/^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/,\nbase64Regex=/^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/,dataURIRegex=/^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;exports.isImageUri=isImageUri;exports.getGateway=getGateway;exports.resolveAvatarUri=resolveAvatarUri;exports.getJsonImage=getJsonImage;exports.getMetadataAvatarUri=async function({gatewayUrls,uri}){try{const res$jscomp$0=await fetch(uri).then(res=>res.json());return await parseAvatarUri({gatewayUrls,uri:getJsonImage(res$jscomp$0)})}catch{throw new ens_js_1.EnsAvatarUriResolutionError({uri});\n}};exports.parseAvatarUri=parseAvatarUri;exports.parseNftUri=function(uri_){uri_.startsWith(\"did:nft:\")&&(uri_=uri_.replace(\"did:nft:\",\"\").replace(/_/g,\"/\"));const [reference,asset_namespace,tokenID]=uri_.split(\"/\"),[eip_namespace,chainID]=reference.split(\":\"),[erc_namespace,contractAddress]=asset_namespace.split(\":\");if(!eip_namespace||\"eip155\"!==eip_namespace.toLowerCase())throw new ens_js_1.EnsAvatarInvalidNftUriError({reason:\"Only EIP-155 supported\"});if(!chainID)throw new ens_js_1.EnsAvatarInvalidNftUriError({reason:\"Chain ID not found\"});\nif(!contractAddress)throw new ens_js_1.EnsAvatarInvalidNftUriError({reason:\"Contract address not found\"});if(!tokenID)throw new ens_js_1.EnsAvatarInvalidNftUriError({reason:\"Token ID not found\"});if(!erc_namespace)throw new ens_js_1.EnsAvatarInvalidNftUriError({reason:\"ERC namespace not found\"});return{chainID:parseInt(chainID),namespace:erc_namespace.toLowerCase(),contractAddress,tokenID}};exports.getNftTokenUri=async function(client,{nft}){if(\"erc721\"===nft.namespace)return(0,readContract_js_1.readContract)(client,\n{address:nft.contractAddress,abi:[{name:\"tokenURI\",type:\"function\",stateMutability:\"view\",inputs:[{name:\"tokenId\",type:\"uint256\"}],outputs:[{name:\"\",type:\"string\"}]}],functionName:\"tokenURI\",args:[BigInt(nft.tokenID)]});if(\"erc1155\"===nft.namespace)return(0,readContract_js_1.readContract)(client,{address:nft.contractAddress,abi:[{name:\"uri\",type:\"function\",stateMutability:\"view\",inputs:[{name:\"_id\",type:\"uint256\"}],outputs:[{name:\"\",type:\"string\"}]}],functionName:\"uri\",args:[BigInt(nft.tokenID)]});\nthrow new ens_js_1.EnsAvatarUnsupportedNamespaceError({namespace:nft.namespace});}}","~:source","shadow$provide[\"module$node_modules$viem$_cjs$utils$ens$avatar$utils\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getNftTokenUri = exports.parseNftUri = exports.parseAvatarUri = exports.getMetadataAvatarUri = exports.getJsonImage = exports.resolveAvatarUri = exports.getGateway = exports.isImageUri = void 0;\nconst readContract_js_1 = require(\"../../../actions/public/readContract.js\");\nconst ens_js_1 = require(\"../../../errors/ens.js\");\nconst networkRegex = /(?<protocol>https?:\\/\\/[^\\/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/;\nconst ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/;\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/;\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;\nasync function isImageUri(uri) {\n    try {\n        const res = await fetch(uri, { method: 'HEAD' });\n        if (res.status === 200) {\n            const contentType = res.headers.get('content-type');\n            return contentType?.startsWith('image/');\n        }\n        return false;\n    }\n    catch (error) {\n        if (typeof error === 'object' && typeof error.response !== 'undefined') {\n            return false;\n        }\n        if (!globalThis.hasOwnProperty('Image'))\n            return false;\n        return new Promise((resolve) => {\n            const img = new Image();\n            img.onload = () => {\n                resolve(true);\n            };\n            img.onerror = () => {\n                resolve(false);\n            };\n            img.src = uri;\n        });\n    }\n}\nexports.isImageUri = isImageUri;\nfunction getGateway(custom, defaultGateway) {\n    if (!custom)\n        return defaultGateway;\n    if (custom.endsWith('/'))\n        return custom.slice(0, -1);\n    return custom;\n}\nexports.getGateway = getGateway;\nfunction resolveAvatarUri({ uri, gatewayUrls, }) {\n    const isEncoded = base64Regex.test(uri);\n    if (isEncoded)\n        return { uri, isOnChain: true, isEncoded };\n    const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');\n    const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');\n    const networkRegexMatch = uri.match(networkRegex);\n    const { protocol, subpath, target, subtarget = '', } = networkRegexMatch?.groups || {};\n    const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';\n    const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);\n    if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n        let replacedUri = uri;\n        if (gatewayUrls?.arweave)\n            replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls?.arweave);\n        return { uri: replacedUri, isOnChain: false, isEncoded: false };\n    }\n    if ((isIPNS || isIPFS) && target) {\n        return {\n            uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n            isOnChain: false,\n            isEncoded: false,\n        };\n    }\n    else if (protocol === 'ar:/' && target) {\n        return {\n            uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n            isOnChain: false,\n            isEncoded: false,\n        };\n    }\n    let parsedUri = uri.replace(dataURIRegex, '');\n    if (parsedUri.startsWith('<svg')) {\n        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;\n    }\n    if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n        return {\n            uri: parsedUri,\n            isOnChain: true,\n            isEncoded: false,\n        };\n    }\n    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });\n}\nexports.resolveAvatarUri = resolveAvatarUri;\nfunction getJsonImage(data) {\n    if (typeof data !== 'object' ||\n        (!('image' in data) && !('image_url' in data) && !('image_data' in data))) {\n        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });\n    }\n    return data.image || data.image_url || data.image_data;\n}\nexports.getJsonImage = getJsonImage;\nasync function getMetadataAvatarUri({ gatewayUrls, uri, }) {\n    try {\n        const res = await fetch(uri).then((res) => res.json());\n        const image = await parseAvatarUri({\n            gatewayUrls,\n            uri: getJsonImage(res),\n        });\n        return image;\n    }\n    catch {\n        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });\n    }\n}\nexports.getMetadataAvatarUri = getMetadataAvatarUri;\nasync function parseAvatarUri({ gatewayUrls, uri, }) {\n    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });\n    if (isOnChain)\n        return resolvedURI;\n    const isImage = await isImageUri(resolvedURI);\n    if (isImage)\n        return resolvedURI;\n    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });\n}\nexports.parseAvatarUri = parseAvatarUri;\nfunction parseNftUri(uri_) {\n    let uri = uri_;\n    if (uri.startsWith('did:nft:')) {\n        uri = uri.replace('did:nft:', '').replace(/_/g, '/');\n    }\n    const [reference, asset_namespace, tokenID] = uri.split('/');\n    const [eip_namespace, chainID] = reference.split(':');\n    const [erc_namespace, contractAddress] = asset_namespace.split(':');\n    if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' });\n    if (!chainID)\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' });\n    if (!contractAddress)\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({\n            reason: 'Contract address not found',\n        });\n    if (!tokenID)\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' });\n    if (!erc_namespace)\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' });\n    return {\n        chainID: parseInt(chainID),\n        namespace: erc_namespace.toLowerCase(),\n        contractAddress: contractAddress,\n        tokenID,\n    };\n}\nexports.parseNftUri = parseNftUri;\nasync function getNftTokenUri(client, { nft }) {\n    if (nft.namespace === 'erc721') {\n        return (0, readContract_js_1.readContract)(client, {\n            address: nft.contractAddress,\n            abi: [\n                {\n                    name: 'tokenURI',\n                    type: 'function',\n                    stateMutability: 'view',\n                    inputs: [{ name: 'tokenId', type: 'uint256' }],\n                    outputs: [{ name: '', type: 'string' }],\n                },\n            ],\n            functionName: 'tokenURI',\n            args: [BigInt(nft.tokenID)],\n        });\n    }\n    if (nft.namespace === 'erc1155') {\n        return (0, readContract_js_1.readContract)(client, {\n            address: nft.contractAddress,\n            abi: [\n                {\n                    name: 'uri',\n                    type: 'function',\n                    stateMutability: 'view',\n                    inputs: [{ name: '_id', type: 'uint256' }],\n                    outputs: [{ name: '', type: 'string' }],\n                },\n            ],\n            functionName: 'uri',\n            args: [BigInt(nft.tokenID)],\n        });\n    }\n    throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });\n}\nexports.getNftTokenUri = getNftTokenUri;\n//# sourceMappingURL=utils.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$viem$_cjs$errors$ens","~$module$node_modules$viem$_cjs$actions$public$readContract"]],"~:properties",["^5",["getMetadataAvatarUri","abi","isOnChain","onerror","chainID","getGateway","args","method","parseAvatarUri","uri","__esModule","tokenID","src","name","parseNftUri","isImageUri","stateMutability","value","outputs","address","onload","gatewayUrls","isEncoded","type","resolveAvatarUri","contractAddress","reason","inputs","getNftTokenUri","namespace","getJsonImage","functionName","data"]],"~:compiled-at",1695111490292,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$viem$_cjs$utils$ens$avatar$utils.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/viem/_cjs/utils/ens/avatar/utils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$viem$_cjs$utils$ens$avatar$utils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.getNftTokenUri = exports.parseNftUri = exports.parseAvatarUri = exports.getMetadataAvatarUri = exports.getJsonImage = exports.resolveAvatarUri = exports.getGateway = exports.isImageUri = void 0;\\nconst readContract_js_1 = require(\\\"../../../actions/public/readContract.js\\\");\\nconst ens_js_1 = require(\\\"../../../errors/ens.js\\\");\\nconst networkRegex = /(?<protocol>https?:\\\\/\\\\/[^\\\\/]*|ipfs:\\\\/|ipns:\\\\/|ar:\\\\/)?(?<root>\\\\/)?(?<subpath>ipfs\\\\/|ipns\\\\/)?(?<target>[\\\\w\\\\-.]+)(?<subtarget>\\\\/.*)?/;\\nconst ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\\\/(?<target>[\\\\w\\\\-.]+))?(?<subtarget>\\\\/.*)?$/;\\nconst base64Regex = /^data:([a-zA-Z\\\\-/+]*);base64,([^\\\"].*)/;\\nconst dataURIRegex = /^data:([a-zA-Z\\\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;\\nasync function isImageUri(uri) {\\n    try {\\n        const res = await fetch(uri, { method: 'HEAD' });\\n        if (res.status === 200) {\\n            const contentType = res.headers.get('content-type');\\n            return contentType?.startsWith('image/');\\n        }\\n        return false;\\n    }\\n    catch (error) {\\n        if (typeof error === 'object' && typeof error.response !== 'undefined') {\\n            return false;\\n        }\\n        if (!globalThis.hasOwnProperty('Image'))\\n            return false;\\n        return new Promise((resolve) => {\\n            const img = new Image();\\n            img.onload = () => {\\n                resolve(true);\\n            };\\n            img.onerror = () => {\\n                resolve(false);\\n            };\\n            img.src = uri;\\n        });\\n    }\\n}\\nexports.isImageUri = isImageUri;\\nfunction getGateway(custom, defaultGateway) {\\n    if (!custom)\\n        return defaultGateway;\\n    if (custom.endsWith('/'))\\n        return custom.slice(0, -1);\\n    return custom;\\n}\\nexports.getGateway = getGateway;\\nfunction resolveAvatarUri({ uri, gatewayUrls, }) {\\n    const isEncoded = base64Regex.test(uri);\\n    if (isEncoded)\\n        return { uri, isOnChain: true, isEncoded };\\n    const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');\\n    const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');\\n    const networkRegexMatch = uri.match(networkRegex);\\n    const { protocol, subpath, target, subtarget = '', } = networkRegexMatch?.groups || {};\\n    const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';\\n    const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);\\n    if (uri.startsWith('http') && !isIPNS && !isIPFS) {\\n        let replacedUri = uri;\\n        if (gatewayUrls?.arweave)\\n            replacedUri = uri.replace(/https:\\\\/\\\\/arweave.net/g, gatewayUrls?.arweave);\\n        return { uri: replacedUri, isOnChain: false, isEncoded: false };\\n    }\\n    if ((isIPNS || isIPFS) && target) {\\n        return {\\n            uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\\n            isOnChain: false,\\n            isEncoded: false,\\n        };\\n    }\\n    else if (protocol === 'ar:/' && target) {\\n        return {\\n            uri: `${arweaveGateway}/${target}${subtarget || ''}`,\\n            isOnChain: false,\\n            isEncoded: false,\\n        };\\n    }\\n    let parsedUri = uri.replace(dataURIRegex, '');\\n    if (parsedUri.startsWith('<svg')) {\\n        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;\\n    }\\n    if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\\n        return {\\n            uri: parsedUri,\\n            isOnChain: true,\\n            isEncoded: false,\\n        };\\n    }\\n    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });\\n}\\nexports.resolveAvatarUri = resolveAvatarUri;\\nfunction getJsonImage(data) {\\n    if (typeof data !== 'object' ||\\n        (!('image' in data) && !('image_url' in data) && !('image_data' in data))) {\\n        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });\\n    }\\n    return data.image || data.image_url || data.image_data;\\n}\\nexports.getJsonImage = getJsonImage;\\nasync function getMetadataAvatarUri({ gatewayUrls, uri, }) {\\n    try {\\n        const res = await fetch(uri).then((res) => res.json());\\n        const image = await parseAvatarUri({\\n            gatewayUrls,\\n            uri: getJsonImage(res),\\n        });\\n        return image;\\n    }\\n    catch {\\n        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });\\n    }\\n}\\nexports.getMetadataAvatarUri = getMetadataAvatarUri;\\nasync function parseAvatarUri({ gatewayUrls, uri, }) {\\n    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });\\n    if (isOnChain)\\n        return resolvedURI;\\n    const isImage = await isImageUri(resolvedURI);\\n    if (isImage)\\n        return resolvedURI;\\n    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });\\n}\\nexports.parseAvatarUri = parseAvatarUri;\\nfunction parseNftUri(uri_) {\\n    let uri = uri_;\\n    if (uri.startsWith('did:nft:')) {\\n        uri = uri.replace('did:nft:', '').replace(/_/g, '/');\\n    }\\n    const [reference, asset_namespace, tokenID] = uri.split('/');\\n    const [eip_namespace, chainID] = reference.split(':');\\n    const [erc_namespace, contractAddress] = asset_namespace.split(':');\\n    if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')\\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' });\\n    if (!chainID)\\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' });\\n    if (!contractAddress)\\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({\\n            reason: 'Contract address not found',\\n        });\\n    if (!tokenID)\\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' });\\n    if (!erc_namespace)\\n        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' });\\n    return {\\n        chainID: parseInt(chainID),\\n        namespace: erc_namespace.toLowerCase(),\\n        contractAddress: contractAddress,\\n        tokenID,\\n    };\\n}\\nexports.parseNftUri = parseNftUri;\\nasync function getNftTokenUri(client, { nft }) {\\n    if (nft.namespace === 'erc721') {\\n        return (0, readContract_js_1.readContract)(client, {\\n            address: nft.contractAddress,\\n            abi: [\\n                {\\n                    name: 'tokenURI',\\n                    type: 'function',\\n                    stateMutability: 'view',\\n                    inputs: [{ name: 'tokenId', type: 'uint256' }],\\n                    outputs: [{ name: '', type: 'string' }],\\n                },\\n            ],\\n            functionName: 'tokenURI',\\n            args: [BigInt(nft.tokenID)],\\n        });\\n    }\\n    if (nft.namespace === 'erc1155') {\\n        return (0, readContract_js_1.readContract)(client, {\\n            address: nft.contractAddress,\\n            abi: [\\n                {\\n                    name: 'uri',\\n                    type: 'function',\\n                    stateMutability: 'view',\\n                    inputs: [{ name: '_id', type: 'uint256' }],\\n                    outputs: [{ name: '', type: 'string' }],\\n                },\\n            ],\\n            functionName: 'uri',\\n            args: [BigInt(nft.tokenID)],\\n        });\\n    }\\n    throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });\\n}\\nexports.getNftTokenUri = getNftTokenUri;\\n//# sourceMappingURL=utils.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"isImageUri\",\"uri\",\"res\",\"fetch\",\"method\",\"status\",\"headers\",\"get\",\"contentType\",\"startsWith\",\"error\",\"response\",\"globalThis\",\"hasOwnProperty\",\"Promise\",\"resolve\",\"img\",\"Image\",\"onload\",\"img.onload\",\"onerror\",\"img.onerror\",\"src\",\"getGateway\",\"custom\",\"defaultGateway\",\"endsWith\",\"slice\",\"resolveAvatarUri\",\"gatewayUrls\",\"isEncoded\",\"base64Regex\",\"test\",\"isOnChain\",\"ipfsGateway\",\"ipfs\",\"arweaveGateway\",\"arweave\",\"networkRegexMatch\",\"match\",\"networkRegex\",\"protocol\",\"subpath\",\"target\",\"subtarget\",\"groups\",\"isIPNS\",\"isIPFS\",\"ipfsHashRegex\",\"replacedUri\",\"replace\",\"parsedUri\",\"dataURIRegex\",\"btoa\",\"ens_js_1\",\"EnsAvatarUriResolutionError\",\"getJsonImage\",\"data\",\"EnsAvatarInvalidMetadataError\",\"image\",\"image_url\",\"image_data\",\"parseAvatarUri\",\"resolvedURI\",\"isImage\",\"Object\",\"defineProperty\",\"value\",\"getNftTokenUri\",\"parseNftUri\",\"getMetadataAvatarUri\",\"readContract_js_1\",\"then\",\"json\",\"uri_\",\"reference\",\"asset_namespace\",\"tokenID\",\"split\",\"eip_namespace\",\"chainID\",\"erc_namespace\",\"contractAddress\",\"toLowerCase\",\"EnsAvatarInvalidNftUriError\",\"reason\",\"parseInt\",\"namespace\",\"client\",\"nft\",\"readContract\",\"address\",\"abi\",\"name\",\"type\",\"stateMutability\",\"inputs\",\"outputs\",\"functionName\",\"args\",\"BigInt\",\"EnsAvatarUnsupportedNamespaceError\"]\n}\n"]