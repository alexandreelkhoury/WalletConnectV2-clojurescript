["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/des_DOT_js/lib/des/cipher.js"],"~:js","shadow$provide[176]=function(S,A,V,q){function F(r){this.options=r;this.type=this.options.type;this.blockSize=8;this._init();this.buffer=Array(this.blockSize);this.bufferOff=0;this.padding=!1!==r.padding}var G=A(71);V.exports=F;F.prototype._init=function(){};F.prototype.update=function(r){return 0===r.length?[]:\"decrypt\"===this.type?this._updateDecrypt(r):this._updateEncrypt(r)};F.prototype._buffer=function(r,y){for(var e=Math.min(this.buffer.length-this.bufferOff,r.length-y),u=0;u<e;u++)this.buffer[this.bufferOff+\nu]=r[y+u];this.bufferOff+=e;return e};F.prototype._flushBuffer=function(r,y){this._update(this.buffer,0,r,y);this.bufferOff=0;return this.blockSize};F.prototype._updateEncrypt=function(r){var y=0,e=0,u=Array(((this.bufferOff+r.length)/this.blockSize|0)*this.blockSize);0!==this.bufferOff&&(y+=this._buffer(r,y),this.bufferOff===this.buffer.length&&(e+=this._flushBuffer(u,e)));for(var p=r.length-(r.length-y)%this.blockSize;y<p;y+=this.blockSize)this._update(r,y,u,e),e+=this.blockSize;for(;y<r.length;y++,\nthis.bufferOff++)this.buffer[this.bufferOff]=r[y];return u};F.prototype._updateDecrypt=function(r){for(var y=0,e=0,u=Math.ceil((this.bufferOff+r.length)/this.blockSize)-1,p=Array(u*this.blockSize);0<u;u--)y+=this._buffer(r,y),e+=this._flushBuffer(p,e);this._buffer(r,y);return p};F.prototype.final=function(r){var y;r&&(y=this.update(r));r=\"encrypt\"===this.type?this._finalEncrypt():this._finalDecrypt();return y?y.concat(r):r};F.prototype._pad=function(r,y){if(0===y)return!1;for(;y<r.length;)r[y++]=\n0;return!0};F.prototype._finalEncrypt=function(){if(!this._pad(this.buffer,this.bufferOff))return[];var r=Array(this.blockSize);this._update(this.buffer,0,r,0);return r};F.prototype._unpad=function(r){return r};F.prototype._finalDecrypt=function(){G.equal(this.bufferOff,this.blockSize,\"Not enough data to decrypt\");var r=Array(this.blockSize);this._flushBuffer(r,0);return this._unpad(r)}}","~:source","shadow$provide[176] = function(global,require,module,exports) {\n'use strict';\n\nvar assert = require('minimalistic-assert');\n\nfunction Cipher(options) {\n  this.options = options;\n\n  this.type = this.options.type;\n  this.blockSize = 8;\n  this._init();\n\n  this.buffer = new Array(this.blockSize);\n  this.bufferOff = 0;\n  this.padding = options.padding !== false\n}\nmodule.exports = Cipher;\n\nCipher.prototype._init = function _init() {\n  // Might be overrided\n};\n\nCipher.prototype.update = function update(data) {\n  if (data.length === 0)\n    return [];\n\n  if (this.type === 'decrypt')\n    return this._updateDecrypt(data);\n  else\n    return this._updateEncrypt(data);\n};\n\nCipher.prototype._buffer = function _buffer(data, off) {\n  // Append data to buffer\n  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\n  for (var i = 0; i < min; i++)\n    this.buffer[this.bufferOff + i] = data[off + i];\n  this.bufferOff += min;\n\n  // Shift next\n  return min;\n};\n\nCipher.prototype._flushBuffer = function _flushBuffer(out, off) {\n  this._update(this.buffer, 0, out, off);\n  this.bufferOff = 0;\n  return this.blockSize;\n};\n\nCipher.prototype._updateEncrypt = function _updateEncrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;\n  var out = new Array(count * this.blockSize);\n\n  if (this.bufferOff !== 0) {\n    inputOff += this._buffer(data, inputOff);\n\n    if (this.bufferOff === this.buffer.length)\n      outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Write blocks\n  var max = data.length - ((data.length - inputOff) % this.blockSize);\n  for (; inputOff < max; inputOff += this.blockSize) {\n    this._update(data, inputOff, out, outputOff);\n    outputOff += this.blockSize;\n  }\n\n  // Queue rest\n  for (; inputOff < data.length; inputOff++, this.bufferOff++)\n    this.buffer[this.bufferOff] = data[inputOff];\n\n  return out;\n};\n\nCipher.prototype._updateDecrypt = function _updateDecrypt(data) {\n  var inputOff = 0;\n  var outputOff = 0;\n\n  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\n  var out = new Array(count * this.blockSize);\n\n  // TODO(indutny): optimize it, this is far from optimal\n  for (; count > 0; count--) {\n    inputOff += this._buffer(data, inputOff);\n    outputOff += this._flushBuffer(out, outputOff);\n  }\n\n  // Buffer rest of the input\n  inputOff += this._buffer(data, inputOff);\n\n  return out;\n};\n\nCipher.prototype.final = function final(buffer) {\n  var first;\n  if (buffer)\n    first = this.update(buffer);\n\n  var last;\n  if (this.type === 'encrypt')\n    last = this._finalEncrypt();\n  else\n    last = this._finalDecrypt();\n\n  if (first)\n    return first.concat(last);\n  else\n    return last;\n};\n\nCipher.prototype._pad = function _pad(buffer, off) {\n  if (off === 0)\n    return false;\n\n  while (off < buffer.length)\n    buffer[off++] = 0;\n\n  return true;\n};\n\nCipher.prototype._finalEncrypt = function _finalEncrypt() {\n  if (!this._pad(this.buffer, this.bufferOff))\n    return [];\n\n  var out = new Array(this.blockSize);\n  this._update(this.buffer, 0, out, 0);\n  return out;\n};\n\nCipher.prototype._unpad = function _unpad(buffer) {\n  return buffer;\n};\n\nCipher.prototype._finalDecrypt = function _finalDecrypt() {\n  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\n  var out = new Array(this.blockSize);\n  this._flushBuffer(out, 0);\n\n  return this._unpad(out);\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$minimalistic_assert$index"]],"~:properties",["^5",["_finalEncrypt","_buffer","_finalDecrypt","padding","update","buffer","_unpad","_init","_flushBuffer","blockSize","bufferOff","_updateDecrypt","final","type","_updateEncrypt","options","_pad"]],"~:compiled-at",1695041440822,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$des_DOT_js$lib$des$cipher.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/des_DOT_js/lib/des/cipher.js\"],\n\"sourcesContent\":[\"shadow$provide[176] = function(global,require,module,exports) {\\n'use strict';\\n\\nvar assert = require('minimalistic-assert');\\n\\nfunction Cipher(options) {\\n  this.options = options;\\n\\n  this.type = this.options.type;\\n  this.blockSize = 8;\\n  this._init();\\n\\n  this.buffer = new Array(this.blockSize);\\n  this.bufferOff = 0;\\n  this.padding = options.padding !== false\\n}\\nmodule.exports = Cipher;\\n\\nCipher.prototype._init = function _init() {\\n  // Might be overrided\\n};\\n\\nCipher.prototype.update = function update(data) {\\n  if (data.length === 0)\\n    return [];\\n\\n  if (this.type === 'decrypt')\\n    return this._updateDecrypt(data);\\n  else\\n    return this._updateEncrypt(data);\\n};\\n\\nCipher.prototype._buffer = function _buffer(data, off) {\\n  // Append data to buffer\\n  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);\\n  for (var i = 0; i < min; i++)\\n    this.buffer[this.bufferOff + i] = data[off + i];\\n  this.bufferOff += min;\\n\\n  // Shift next\\n  return min;\\n};\\n\\nCipher.prototype._flushBuffer = function _flushBuffer(out, off) {\\n  this._update(this.buffer, 0, out, off);\\n  this.bufferOff = 0;\\n  return this.blockSize;\\n};\\n\\nCipher.prototype._updateEncrypt = function _updateEncrypt(data) {\\n  var inputOff = 0;\\n  var outputOff = 0;\\n\\n  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;\\n  var out = new Array(count * this.blockSize);\\n\\n  if (this.bufferOff !== 0) {\\n    inputOff += this._buffer(data, inputOff);\\n\\n    if (this.bufferOff === this.buffer.length)\\n      outputOff += this._flushBuffer(out, outputOff);\\n  }\\n\\n  // Write blocks\\n  var max = data.length - ((data.length - inputOff) % this.blockSize);\\n  for (; inputOff < max; inputOff += this.blockSize) {\\n    this._update(data, inputOff, out, outputOff);\\n    outputOff += this.blockSize;\\n  }\\n\\n  // Queue rest\\n  for (; inputOff < data.length; inputOff++, this.bufferOff++)\\n    this.buffer[this.bufferOff] = data[inputOff];\\n\\n  return out;\\n};\\n\\nCipher.prototype._updateDecrypt = function _updateDecrypt(data) {\\n  var inputOff = 0;\\n  var outputOff = 0;\\n\\n  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;\\n  var out = new Array(count * this.blockSize);\\n\\n  // TODO(indutny): optimize it, this is far from optimal\\n  for (; count > 0; count--) {\\n    inputOff += this._buffer(data, inputOff);\\n    outputOff += this._flushBuffer(out, outputOff);\\n  }\\n\\n  // Buffer rest of the input\\n  inputOff += this._buffer(data, inputOff);\\n\\n  return out;\\n};\\n\\nCipher.prototype.final = function final(buffer) {\\n  var first;\\n  if (buffer)\\n    first = this.update(buffer);\\n\\n  var last;\\n  if (this.type === 'encrypt')\\n    last = this._finalEncrypt();\\n  else\\n    last = this._finalDecrypt();\\n\\n  if (first)\\n    return first.concat(last);\\n  else\\n    return last;\\n};\\n\\nCipher.prototype._pad = function _pad(buffer, off) {\\n  if (off === 0)\\n    return false;\\n\\n  while (off < buffer.length)\\n    buffer[off++] = 0;\\n\\n  return true;\\n};\\n\\nCipher.prototype._finalEncrypt = function _finalEncrypt() {\\n  if (!this._pad(this.buffer, this.bufferOff))\\n    return [];\\n\\n  var out = new Array(this.blockSize);\\n  this._update(this.buffer, 0, out, 0);\\n  return out;\\n};\\n\\nCipher.prototype._unpad = function _unpad(buffer) {\\n  return buffer;\\n};\\n\\nCipher.prototype._finalDecrypt = function _finalDecrypt() {\\n  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');\\n  var out = new Array(this.blockSize);\\n  this._flushBuffer(out, 0);\\n\\n  return this._unpad(out);\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Cipher\",\"options\",\"type\",\"blockSize\",\"_init\",\"buffer\",\"Array\",\"bufferOff\",\"padding\",\"assert\",\"prototype\",\"Cipher.prototype._init\",\"update\",\"Cipher.prototype.update\",\"data\",\"length\",\"_updateDecrypt\",\"_updateEncrypt\",\"_buffer\",\"Cipher.prototype._buffer\",\"off\",\"min\",\"Math\",\"i\",\"_flushBuffer\",\"Cipher.prototype._flushBuffer\",\"out\",\"_update\",\"Cipher.prototype._updateEncrypt\",\"inputOff\",\"outputOff\",\"max\",\"Cipher.prototype._updateDecrypt\",\"count\",\"ceil\",\"final\",\"Cipher.prototype.final\",\"first\",\"last\",\"_finalEncrypt\",\"_finalDecrypt\",\"concat\",\"_pad\",\"Cipher.prototype._pad\",\"Cipher.prototype._finalEncrypt\",\"_unpad\",\"Cipher.prototype._unpad\",\"Cipher.prototype._finalDecrypt\",\"equal\"]\n}\n"]