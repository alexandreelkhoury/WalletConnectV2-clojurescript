["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/viem/_cjs/utils/encoding/toBytes.js"],"~:js","shadow$provide.module$node_modules$viem$_cjs$utils$encoding$toBytes=function(global,require,module,exports){function boolToBytes(value,opts={}){const bytes=new Uint8Array(1);bytes[0]=Number(value);return\"number\"===typeof opts.size?((0,fromHex_js_1.assertSize)(bytes,{size:opts.size}),(0,pad_js_1.pad)(bytes,{size:opts.size})):bytes}function hexToBytes(hex_,opts={}){opts.size&&((0,fromHex_js_1.assertSize)(hex_,{size:opts.size}),hex_=(0,pad_js_1.pad)(hex_,{dir:\"right\",size:opts.size}));opts=hex_.slice(2);\nopts.length%2&&(opts=`0${opts}`);hex_=new Uint8Array(opts.length/2);for(let index=0;index<hex_.length;index++){var start=2*index;start=opts.slice(start,start+2);const byte=Number.parseInt(start,16);if(Number.isNaN(byte)||0>byte)throw new base_js_1.BaseError(`Invalid byte sequence (\"${start}\" in \"${opts}\").`);hex_[index]=byte}return hex_}function numberToBytes(value,opts){value=(0,toHex_js_1.numberToHex)(value,opts);return hexToBytes(value)}function stringToBytes(value,opts={}){value=encoder.encode(value);\nreturn\"number\"===typeof opts.size?((0,fromHex_js_1.assertSize)(value,{size:opts.size}),(0,pad_js_1.pad)(value,{dir:\"right\",size:opts.size})):value}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.stringToBytes=exports.numberToBytes=exports.hexToBytes=exports.boolToBytes=exports.toBytes=void 0;const base_js_1=require(\"module$node_modules$viem$_cjs$errors$base\"),isHex_js_1=require(\"module$node_modules$viem$_cjs$utils$data$isHex\"),pad_js_1=require(\"module$node_modules$viem$_cjs$utils$data$pad\"),\nfromHex_js_1=require(\"module$node_modules$viem$_cjs$utils$encoding$fromHex\"),toHex_js_1=require(\"module$node_modules$viem$_cjs$utils$encoding$toHex\"),encoder=new TextEncoder;exports.toBytes=function(value,opts={}){return\"number\"===typeof value||\"bigint\"===typeof value?numberToBytes(value,opts):\"boolean\"===typeof value?boolToBytes(value,opts):(0,isHex_js_1.isHex)(value)?hexToBytes(value,opts):stringToBytes(value,opts)};exports.boolToBytes=boolToBytes;exports.hexToBytes=hexToBytes;exports.numberToBytes=\nnumberToBytes;exports.stringToBytes=stringToBytes}","~:source","shadow$provide[\"module$node_modules$viem$_cjs$utils$encoding$toBytes\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.toBytes = void 0;\nconst base_js_1 = require(\"../../errors/base.js\");\nconst isHex_js_1 = require(\"../data/isHex.js\");\nconst pad_js_1 = require(\"../data/pad.js\");\nconst fromHex_js_1 = require(\"./fromHex.js\");\nconst toHex_js_1 = require(\"./toHex.js\");\nconst encoder = new TextEncoder();\nfunction toBytes(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToBytes(value, opts);\n    if (typeof value === 'boolean')\n        return boolToBytes(value, opts);\n    if ((0, isHex_js_1.isHex)(value))\n        return hexToBytes(value, opts);\n    return stringToBytes(value, opts);\n}\nexports.toBytes = toBytes;\nfunction boolToBytes(value, opts = {}) {\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof opts.size === 'number') {\n        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });\n        return (0, pad_js_1.pad)(bytes, { size: opts.size });\n    }\n    return bytes;\n}\nexports.boolToBytes = boolToBytes;\nfunction hexToBytes(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });\n        hex = (0, pad_js_1.pad)(hex, { dir: 'right', size: opts.size });\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const bytes = new Uint8Array(hexString.length / 2);\n    for (let index = 0; index < bytes.length; index++) {\n        const start = index * 2;\n        const hexByte = hexString.slice(start, start + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new base_js_1.BaseError(`Invalid byte sequence (\"${hexByte}\" in \"${hexString}\").`);\n        bytes[index] = byte;\n    }\n    return bytes;\n}\nexports.hexToBytes = hexToBytes;\nfunction numberToBytes(value, opts) {\n    const hex = (0, toHex_js_1.numberToHex)(value, opts);\n    return hexToBytes(hex);\n}\nexports.numberToBytes = numberToBytes;\nfunction stringToBytes(value, opts = {}) {\n    const bytes = encoder.encode(value);\n    if (typeof opts.size === 'number') {\n        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });\n        return (0, pad_js_1.pad)(bytes, { dir: 'right', size: opts.size });\n    }\n    return bytes;\n}\nexports.stringToBytes = stringToBytes;\n//# sourceMappingURL=toBytes.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$viem$_cjs$utils$data$pad","~$module$node_modules$viem$_cjs$errors$base","~$shadow.js","~$module$node_modules$viem$_cjs$utils$encoding$fromHex","~$module$node_modules$viem$_cjs$utils$data$isHex","~$module$node_modules$viem$_cjs$utils$encoding$toHex"]],"~:properties",["^5",["numberToBytes","__esModule","hexToBytes","value","dir","toBytes","size","boolToBytes","stringToBytes"]],"~:compiled-at",1695064956369,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$viem$_cjs$utils$encoding$toBytes.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/viem/_cjs/utils/encoding/toBytes.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$viem$_cjs$utils$encoding$toBytes\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.toBytes = void 0;\\nconst base_js_1 = require(\\\"../../errors/base.js\\\");\\nconst isHex_js_1 = require(\\\"../data/isHex.js\\\");\\nconst pad_js_1 = require(\\\"../data/pad.js\\\");\\nconst fromHex_js_1 = require(\\\"./fromHex.js\\\");\\nconst toHex_js_1 = require(\\\"./toHex.js\\\");\\nconst encoder = new TextEncoder();\\nfunction toBytes(value, opts = {}) {\\n    if (typeof value === 'number' || typeof value === 'bigint')\\n        return numberToBytes(value, opts);\\n    if (typeof value === 'boolean')\\n        return boolToBytes(value, opts);\\n    if ((0, isHex_js_1.isHex)(value))\\n        return hexToBytes(value, opts);\\n    return stringToBytes(value, opts);\\n}\\nexports.toBytes = toBytes;\\nfunction boolToBytes(value, opts = {}) {\\n    const bytes = new Uint8Array(1);\\n    bytes[0] = Number(value);\\n    if (typeof opts.size === 'number') {\\n        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });\\n        return (0, pad_js_1.pad)(bytes, { size: opts.size });\\n    }\\n    return bytes;\\n}\\nexports.boolToBytes = boolToBytes;\\nfunction hexToBytes(hex_, opts = {}) {\\n    let hex = hex_;\\n    if (opts.size) {\\n        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });\\n        hex = (0, pad_js_1.pad)(hex, { dir: 'right', size: opts.size });\\n    }\\n    let hexString = hex.slice(2);\\n    if (hexString.length % 2)\\n        hexString = `0${hexString}`;\\n    const bytes = new Uint8Array(hexString.length / 2);\\n    for (let index = 0; index < bytes.length; index++) {\\n        const start = index * 2;\\n        const hexByte = hexString.slice(start, start + 2);\\n        const byte = Number.parseInt(hexByte, 16);\\n        if (Number.isNaN(byte) || byte < 0)\\n            throw new base_js_1.BaseError(`Invalid byte sequence (\\\"${hexByte}\\\" in \\\"${hexString}\\\").`);\\n        bytes[index] = byte;\\n    }\\n    return bytes;\\n}\\nexports.hexToBytes = hexToBytes;\\nfunction numberToBytes(value, opts) {\\n    const hex = (0, toHex_js_1.numberToHex)(value, opts);\\n    return hexToBytes(hex);\\n}\\nexports.numberToBytes = numberToBytes;\\nfunction stringToBytes(value, opts = {}) {\\n    const bytes = encoder.encode(value);\\n    if (typeof opts.size === 'number') {\\n        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });\\n        return (0, pad_js_1.pad)(bytes, { dir: 'right', size: opts.size });\\n    }\\n    return bytes;\\n}\\nexports.stringToBytes = stringToBytes;\\n//# sourceMappingURL=toBytes.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"boolToBytes\",\"value\",\"opts\",\"bytes\",\"Uint8Array\",\"Number\",\"size\",\"fromHex_js_1\",\"assertSize\",\"pad_js_1\",\"pad\",\"hexToBytes\",\"hex_\",\"hex\",\"dir\",\"hexString\",\"slice\",\"length\",\"index\",\"start\",\"hexByte\",\"byte\",\"parseInt\",\"isNaN\",\"base_js_1\",\"BaseError\",\"numberToBytes\",\"toHex_js_1\",\"numberToHex\",\"stringToBytes\",\"encoder\",\"encode\",\"Object\",\"defineProperty\",\"toBytes\",\"isHex_js_1\",\"TextEncoder\",\"isHex\"]\n}\n"]