{
"version":3,
"file":"module$node_modules$$noble$curves$abstract$curve.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/@noble/curves/abstract/curve.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$noble$curves$abstract$curve\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateBasic = exports.wNAF = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / \ud835\udc4a) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(\ud835\udc4a\u22121) * (Math.ceil(\ud835\udc5b / \ud835\udc4a) + 1), where:\n         * - \ud835\udc4a is the window size\n         * - \ud835\udc5b is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nexports.validateBasic = validateBasic;\n//# sourceMappingURL=curve.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","validateBasic","wNAF","modular_js_1","utils_js_1","_0n","BigInt","_1n","c","bits","constTimeNegate","condition","item","neg","negate","unsafeLadder","elm","n","p","ZERO","add","d","double","precomputeWindow","W","windows","windowSize","Math","ceil","points","base","window","push","i","precomputes","f","BASE","mask","maxNumber","shiftBy","offset","wbits","Number","offset1","offset2","abs","cond1","cond2","wNAFCached","P","precomputesMap","transform","_WINDOW_SIZE","comp","get","set","curve","validateField","Fp","validateObject","h","Gx","Gy","nBitLength","nByteLength","freeze","nLength","ORDER"]
}
