["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/string_decoder/lib/string_decoder.js"],"~:js","shadow$provide[122]=function(S,A,V,q){function F(E){if(!E)return\"utf8\";for(var H;;)switch(E){case \"utf8\":case \"utf-8\":return\"utf8\";case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":return\"utf16le\";case \"latin1\":case \"binary\":return\"latin1\";case \"base64\":case \"ascii\":case \"hex\":return E;default:if(H)return;E=(\"\"+E).toLowerCase();H=!0}}function G(E){var H=F(E);if(\"string\"!==typeof H&&(t.isEncoding===B||!B(E)))throw Error(\"Unknown encoding: \"+E);this.encoding=H||E;switch(this.encoding){case \"utf16le\":this.text=\nu;this.end=p;E=4;break;case \"utf8\":this.fillLast=e;E=4;break;case \"base64\":this.text=n;this.end=l;E=3;break;default:this.write=h;this.end=k;return}this.lastTotal=this.lastNeed=0;this.lastChar=t.allocUnsafe(E)}function r(E){return 127>=E?0:6===E>>5?2:14===E>>4?3:30===E>>3?4:2===E>>6?-1:-2}function y(E,H,D){var C=H.length-1;if(C<D)return 0;var I=r(H[C]);if(0<=I)return 0<I&&(E.lastNeed=I-1),I;if(--C<D||-2===I)return 0;I=r(H[C]);if(0<=I)return 0<I&&(E.lastNeed=I-2),I;if(--C<D||-2===I)return 0;I=r(H[C]);\nreturn 0<=I?(0<I&&(2===I?I=0:E.lastNeed=I-3),I):0}function e(E){var H=this.lastTotal-this.lastNeed;a:if(128!==(E[0]&192)){this.lastNeed=0;var D=\"�\"}else{if(1<this.lastNeed&&1<E.length){if(128!==(E[1]&192)){this.lastNeed=1;D=\"�\";break a}if(2<this.lastNeed&&2<E.length&&128!==(E[2]&192)){this.lastNeed=2;D=\"�\";break a}}D=void 0}if(void 0!==D)return D;if(this.lastNeed<=E.length)return E.copy(this.lastChar,H,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);E.copy(this.lastChar,H,\n0,E.length);this.lastNeed-=E.length}function u(E,H){if(0===(E.length-H)%2){if(H=E.toString(\"utf16le\",H)){var D=H.charCodeAt(H.length-1);if(55296<=D&&56319>=D)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=E[E.length-2],this.lastChar[1]=E[E.length-1],H.slice(0,-1)}return H}this.lastNeed=1;this.lastTotal=2;this.lastChar[0]=E[E.length-1];return E.toString(\"utf16le\",H,E.length-1)}function p(E){E=E&&E.length?this.write(E):\"\";return this.lastNeed?E+this.lastChar.toString(\"utf16le\",0,this.lastTotal-\nthis.lastNeed):E}function n(E,H){var D=(E.length-H)%3;if(0===D)return E.toString(\"base64\",H);this.lastNeed=3-D;this.lastTotal=3;1===D?this.lastChar[0]=E[E.length-1]:(this.lastChar[0]=E[E.length-2],this.lastChar[1]=E[E.length-1]);return E.toString(\"base64\",H,E.length-D)}function l(E){E=E&&E.length?this.write(E):\"\";return this.lastNeed?E+this.lastChar.toString(\"base64\",0,3-this.lastNeed):E}function h(E){return E.toString(this.encoding)}function k(E){return E&&E.length?this.write(E):\"\"}var t=A(111).Buffer,\nB=t.isEncoding||function(E){E=\"\"+E;switch(E&&E.toLowerCase()){case \"hex\":case \"utf8\":case \"utf-8\":case \"ascii\":case \"binary\":case \"base64\":case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":case \"raw\":return!0;default:return!1}};q.StringDecoder=G;G.prototype.write=function(E){if(0===E.length)return\"\";if(this.lastNeed){var H=this.fillLast(E);if(void 0===H)return\"\";var D=this.lastNeed;this.lastNeed=0}else D=0;return D<E.length?H?H+this.text(E,D):this.text(E,D):H||\"\"};G.prototype.end=function(E){E=\nE&&E.length?this.write(E):\"\";return this.lastNeed?E+\"�\":E};G.prototype.text=function(E,H){var D=y(this,E,H);if(!this.lastNeed)return E.toString(\"utf8\",H);this.lastTotal=D;D=E.length-(D-this.lastNeed);E.copy(this.lastChar,0,D);return E.toString(\"utf8\",H,D)};G.prototype.fillLast=function(E){if(this.lastNeed<=E.length)return E.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);E.copy(this.lastChar,this.lastTotal-this.lastNeed,0,E.length);\nthis.lastNeed-=E.length}}","~:source","shadow$provide[122] = function(global,require,module,exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$safe_buffer$index"]],"~:properties",["^5",["lastChar","StringDecoder","lastNeed","encoding","fillLast","lastTotal","text","write","end"]],"~:compiled-at",1695041440790,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$string_decoder$lib$string_decoder.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/string_decoder/lib/string_decoder.js\"],\n\"sourcesContent\":[\"shadow$provide[122] = function(global,require,module,exports) {\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n'use strict';\\n\\n/*<replacement>*/\\n\\nvar Buffer = require('safe-buffer').Buffer;\\n/*</replacement>*/\\n\\nvar isEncoding = Buffer.isEncoding || function (encoding) {\\n  encoding = '' + encoding;\\n  switch (encoding && encoding.toLowerCase()) {\\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\\n      return true;\\n    default:\\n      return false;\\n  }\\n};\\n\\nfunction _normalizeEncoding(enc) {\\n  if (!enc) return 'utf8';\\n  var retried;\\n  while (true) {\\n    switch (enc) {\\n      case 'utf8':\\n      case 'utf-8':\\n        return 'utf8';\\n      case 'ucs2':\\n      case 'ucs-2':\\n      case 'utf16le':\\n      case 'utf-16le':\\n        return 'utf16le';\\n      case 'latin1':\\n      case 'binary':\\n        return 'latin1';\\n      case 'base64':\\n      case 'ascii':\\n      case 'hex':\\n        return enc;\\n      default:\\n        if (retried) return; // undefined\\n        enc = ('' + enc).toLowerCase();\\n        retried = true;\\n    }\\n  }\\n};\\n\\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\\n// modules monkey-patch it to support additional encodings\\nfunction normalizeEncoding(enc) {\\n  var nenc = _normalizeEncoding(enc);\\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\\n  return nenc || enc;\\n}\\n\\n// StringDecoder provides an interface for efficiently splitting a series of\\n// buffers into a series of JS strings without breaking apart multi-byte\\n// characters.\\nexports.StringDecoder = StringDecoder;\\nfunction StringDecoder(encoding) {\\n  this.encoding = normalizeEncoding(encoding);\\n  var nb;\\n  switch (this.encoding) {\\n    case 'utf16le':\\n      this.text = utf16Text;\\n      this.end = utf16End;\\n      nb = 4;\\n      break;\\n    case 'utf8':\\n      this.fillLast = utf8FillLast;\\n      nb = 4;\\n      break;\\n    case 'base64':\\n      this.text = base64Text;\\n      this.end = base64End;\\n      nb = 3;\\n      break;\\n    default:\\n      this.write = simpleWrite;\\n      this.end = simpleEnd;\\n      return;\\n  }\\n  this.lastNeed = 0;\\n  this.lastTotal = 0;\\n  this.lastChar = Buffer.allocUnsafe(nb);\\n}\\n\\nStringDecoder.prototype.write = function (buf) {\\n  if (buf.length === 0) return '';\\n  var r;\\n  var i;\\n  if (this.lastNeed) {\\n    r = this.fillLast(buf);\\n    if (r === undefined) return '';\\n    i = this.lastNeed;\\n    this.lastNeed = 0;\\n  } else {\\n    i = 0;\\n  }\\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\\n  return r || '';\\n};\\n\\nStringDecoder.prototype.end = utf8End;\\n\\n// Returns only complete characters in a Buffer\\nStringDecoder.prototype.text = utf8Text;\\n\\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\\nStringDecoder.prototype.fillLast = function (buf) {\\n  if (this.lastNeed <= buf.length) {\\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\\n  }\\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\\n  this.lastNeed -= buf.length;\\n};\\n\\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\\n// continuation byte. If an invalid byte is detected, -2 is returned.\\nfunction utf8CheckByte(byte) {\\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\\n  return byte >> 6 === 0x02 ? -1 : -2;\\n}\\n\\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\\n// needed to complete the UTF-8 character (if applicable) are returned.\\nfunction utf8CheckIncomplete(self, buf, i) {\\n  var j = buf.length - 1;\\n  if (j < i) return 0;\\n  var nb = utf8CheckByte(buf[j]);\\n  if (nb >= 0) {\\n    if (nb > 0) self.lastNeed = nb - 1;\\n    return nb;\\n  }\\n  if (--j < i || nb === -2) return 0;\\n  nb = utf8CheckByte(buf[j]);\\n  if (nb >= 0) {\\n    if (nb > 0) self.lastNeed = nb - 2;\\n    return nb;\\n  }\\n  if (--j < i || nb === -2) return 0;\\n  nb = utf8CheckByte(buf[j]);\\n  if (nb >= 0) {\\n    if (nb > 0) {\\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\\n    }\\n    return nb;\\n  }\\n  return 0;\\n}\\n\\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\\n// needed or are available. If we see a non-continuation byte where we expect\\n// one, we \\\"replace\\\" the validated continuation bytes we've seen so far with\\n// a single UTF-8 replacement character ('\\\\ufffd'), to match v8's UTF-8 decoding\\n// behavior. The continuation byte check is included three times in the case\\n// where all of the continuation bytes for a character exist in the same buffer.\\n// It is also done this way as a slight performance increase instead of using a\\n// loop.\\nfunction utf8CheckExtraBytes(self, buf, p) {\\n  if ((buf[0] & 0xC0) !== 0x80) {\\n    self.lastNeed = 0;\\n    return '\\\\ufffd';\\n  }\\n  if (self.lastNeed > 1 && buf.length > 1) {\\n    if ((buf[1] & 0xC0) !== 0x80) {\\n      self.lastNeed = 1;\\n      return '\\\\ufffd';\\n    }\\n    if (self.lastNeed > 2 && buf.length > 2) {\\n      if ((buf[2] & 0xC0) !== 0x80) {\\n        self.lastNeed = 2;\\n        return '\\\\ufffd';\\n      }\\n    }\\n  }\\n}\\n\\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\\nfunction utf8FillLast(buf) {\\n  var p = this.lastTotal - this.lastNeed;\\n  var r = utf8CheckExtraBytes(this, buf, p);\\n  if (r !== undefined) return r;\\n  if (this.lastNeed <= buf.length) {\\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\\n  }\\n  buf.copy(this.lastChar, p, 0, buf.length);\\n  this.lastNeed -= buf.length;\\n}\\n\\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\\n// partial character, the character's bytes are buffered until the required\\n// number of bytes are available.\\nfunction utf8Text(buf, i) {\\n  var total = utf8CheckIncomplete(this, buf, i);\\n  if (!this.lastNeed) return buf.toString('utf8', i);\\n  this.lastTotal = total;\\n  var end = buf.length - (total - this.lastNeed);\\n  buf.copy(this.lastChar, 0, end);\\n  return buf.toString('utf8', i, end);\\n}\\n\\n// For UTF-8, a replacement character is added when ending on a partial\\n// character.\\nfunction utf8End(buf) {\\n  var r = buf && buf.length ? this.write(buf) : '';\\n  if (this.lastNeed) return r + '\\\\ufffd';\\n  return r;\\n}\\n\\n// UTF-16LE typically needs two bytes per character, but even if we have an even\\n// number of bytes available, we need to check if we end on a leading/high\\n// surrogate. In that case, we need to wait for the next two bytes in order to\\n// decode the last character properly.\\nfunction utf16Text(buf, i) {\\n  if ((buf.length - i) % 2 === 0) {\\n    var r = buf.toString('utf16le', i);\\n    if (r) {\\n      var c = r.charCodeAt(r.length - 1);\\n      if (c >= 0xD800 && c <= 0xDBFF) {\\n        this.lastNeed = 2;\\n        this.lastTotal = 4;\\n        this.lastChar[0] = buf[buf.length - 2];\\n        this.lastChar[1] = buf[buf.length - 1];\\n        return r.slice(0, -1);\\n      }\\n    }\\n    return r;\\n  }\\n  this.lastNeed = 1;\\n  this.lastTotal = 2;\\n  this.lastChar[0] = buf[buf.length - 1];\\n  return buf.toString('utf16le', i, buf.length - 1);\\n}\\n\\n// For UTF-16LE we do not explicitly append special replacement characters if we\\n// end on a partial character, we simply let v8 handle that.\\nfunction utf16End(buf) {\\n  var r = buf && buf.length ? this.write(buf) : '';\\n  if (this.lastNeed) {\\n    var end = this.lastTotal - this.lastNeed;\\n    return r + this.lastChar.toString('utf16le', 0, end);\\n  }\\n  return r;\\n}\\n\\nfunction base64Text(buf, i) {\\n  var n = (buf.length - i) % 3;\\n  if (n === 0) return buf.toString('base64', i);\\n  this.lastNeed = 3 - n;\\n  this.lastTotal = 3;\\n  if (n === 1) {\\n    this.lastChar[0] = buf[buf.length - 1];\\n  } else {\\n    this.lastChar[0] = buf[buf.length - 2];\\n    this.lastChar[1] = buf[buf.length - 1];\\n  }\\n  return buf.toString('base64', i, buf.length - n);\\n}\\n\\nfunction base64End(buf) {\\n  var r = buf && buf.length ? this.write(buf) : '';\\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\\n  return r;\\n}\\n\\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\\nfunction simpleWrite(buf) {\\n  return buf.toString(this.encoding);\\n}\\n\\nfunction simpleEnd(buf) {\\n  return buf && buf.length ? this.write(buf) : '';\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_normalizeEncoding\",\"enc\",\"retried\",\"toLowerCase\",\"StringDecoder\",\"encoding\",\"nenc\",\"Buffer\",\"isEncoding\",\"Error\",\"text\",\"utf16Text\",\"end\",\"utf16End\",\"nb\",\"fillLast\",\"utf8FillLast\",\"base64Text\",\"base64End\",\"write\",\"simpleWrite\",\"simpleEnd\",\"lastTotal\",\"lastNeed\",\"lastChar\",\"allocUnsafe\",\"utf8CheckByte\",\"byte\",\"utf8CheckIncomplete\",\"self\",\"buf\",\"i\",\"j\",\"length\",\"p\",\"undefined\",\"r\",\"copy\",\"toString\",\"c\",\"charCodeAt\",\"slice\",\"n\",\"prototype\",\"StringDecoder.prototype.write\",\"utf8End\",\"utf8Text\",\"total\",\"StringDecoder.prototype.fillLast\"]\n}\n"]