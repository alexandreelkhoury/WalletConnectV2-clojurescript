["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@noble/curves/secp256k1.js"],"~:js","shadow$provide.module$node_modules$$noble$curves$secp256k1=function(global,require,module,exports){function sqrtMod(y){var P=secp256k1P,_3n=BigInt(3),_6n=BigInt(6),_11n=BigInt(11),_22n=BigInt(22),_23n=BigInt(23),_44n=BigInt(44),_88n=BigInt(88);const b2=y*y*y%P,b3=b2*b2*y%P;var b6=(0,modular_js_1.pow2)(b3,_3n,P)*b3%P;b6=(0,modular_js_1.pow2)(b6,_3n,P)*b3%P;b6=(0,modular_js_1.pow2)(b6,_2n,P)*b2%P;_11n=(0,modular_js_1.pow2)(b6,_11n,P)*b6%P;_22n=(0,modular_js_1.pow2)(_11n,_22n,P)*_11n%P;b6=(0,modular_js_1.pow2)(_22n,\n_44n,P)*_22n%P;_88n=(0,modular_js_1.pow2)(b6,_88n,P)*b6%P;_44n=(0,modular_js_1.pow2)(_88n,_44n,P)*_22n%P;_3n=(0,modular_js_1.pow2)(_44n,_3n,P)*b3%P;_23n=(0,modular_js_1.pow2)(_3n,_23n,P)*_11n%P;_6n=(0,modular_js_1.pow2)(_23n,_6n,P)*b2%P;P=(0,modular_js_1.pow2)(_6n,_2n,P);if(!Fp.eql(Fp.sqr(P),y))throw Error(\"Cannot find square root\");return P}function taggedHash(tag,...messages){var tagP=TAGGED_HASH_PREFIXES[tag];void 0===tagP&&(tagP=(0,sha256_1.sha256)(Uint8Array.from(tag,c=>c.charCodeAt(0))),tagP=\n(0,utils_js_1.concatBytes)(tagP,tagP),TAGGED_HASH_PREFIXES[tag]=tagP);return(0,sha256_1.sha256)((0,utils_js_1.concatBytes)(tagP,...messages))}function schnorrGetExtPubKey(priv){priv=exports.secp256k1.utils.normPrivateKeyToScalar(priv);let p=Point.fromPrivateKey(priv);return{scalar:p.hasEvenY()?priv:(0,modular_js_1.mod)(-priv,secp256k1N),bytes:p.toRawBytes(!0).slice(1)}}function lift_x(x){if(!(\"bigint\"===typeof x&&_0n<x&&x<secp256k1P))throw Error(\"bad x: need 0 \\x3c x \\x3c p\");var xx=(0,modular_js_1.mod)(x*\nx,secp256k1P);xx=(0,modular_js_1.mod)(xx*x+BigInt(7),secp256k1P);xx=sqrtMod(xx);xx%_2n!==_0n&&(xx=(0,modular_js_1.mod)(-xx,secp256k1P));x=new Point(x,xx,_1n);x.assertValidity();return x}function challenge(...args){return(0,modular_js_1.mod)((0,utils_js_1.bytesToNumberBE)(taggedHash(\"BIP0340/challenge\",...args)),secp256k1N)}function schnorrVerify(signature,message,publicKey){signature=(0,utils_js_1.ensureBytes)(\"signature\",signature,64);message=(0,utils_js_1.ensureBytes)(\"message\",message);publicKey=\n(0,utils_js_1.ensureBytes)(\"publicKey\",publicKey,32);try{const P=lift_x((0,utils_js_1.bytesToNumberBE)(publicKey)),r=(0,utils_js_1.bytesToNumberBE)(signature.subarray(0,32));if(!(\"bigint\"===typeof r&&_0n<r&&r<secp256k1P))return!1;const s=(0,utils_js_1.bytesToNumberBE)(signature.subarray(32,64));if(!(\"bigint\"===typeof s&&_0n<s&&s<secp256k1N))return!1;const e=challenge((0,utils_js_1.numberToBytesBE)(r,32),P.toRawBytes(!0).slice(1),message);var JSCompiler_inline_result,b=(0,modular_js_1.mod)(-e,secp256k1N);\nreturn(JSCompiler_inline_result=Point.BASE.multiplyAndAddUnsafe(P,s,b))&&JSCompiler_inline_result.hasEvenY()&&JSCompiler_inline_result.toAffine().x===r?!0:!1}catch(error){return!1}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.encodeToCurve=exports.hashToCurve=exports.schnorr=exports.secp256k1=void 0;const sha256_1=require(\"module$node_modules$$noble$hashes$sha256\"),utils_1=require(\"module$node_modules$$noble$hashes$utils\"),modular_js_1=require(\"module$node_modules$$noble$curves$abstract$modular\");\nglobal=require(\"module$node_modules$$noble$curves$abstract$weierstrass\");const utils_js_1=require(\"module$node_modules$$noble$curves$abstract$utils\"),hash_to_curve_js_1=require(\"module$node_modules$$noble$curves$abstract$hash_to_curve\");require=require(\"module$node_modules$$noble$curves$_shortw_utils\");const secp256k1P=BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),secp256k1N=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),_1n=BigInt(1),_2n=\nBigInt(2),Fp=(0,modular_js_1.Field)(secp256k1P,void 0,void 0,{sqrt:sqrtMod});exports.secp256k1=(0,require.createCurve)({a:BigInt(0),b:BigInt(7),Fp,n:secp256k1N,Gx:BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),Gy:BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),h:BigInt(1),lowS:!0,endo:{beta:BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),splitScalar:k=>{const n=secp256k1N;var a1=BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"),\nb1=-_1n*BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");const POW_2_128=BigInt(\"0x100000000000000000000000000000000\");var c1=(a1*k+n/_2n)/n;const c2=(-b1*k+n/_2n)/n;let k1=(0,modular_js_1.mod)(k-c1*a1-c2*BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"),n);a1=(0,modular_js_1.mod)(-c1*b1-c2*a1,n);b1=k1>POW_2_128;c1=a1>POW_2_128;b1&&(k1=n-k1);c1&&(a1=n-a1);if(k1>POW_2_128||a1>POW_2_128)throw Error(\"splitScalar: Endomorphism failed, k\\x3d\"+k);return{k1neg:b1,k1,k2neg:c1,k2:a1}}}},sha256_1.sha256);const _0n=\nBigInt(0),TAGGED_HASH_PREFIXES={},Point=exports.secp256k1.ProjectivePoint;exports.schnorr={getPublicKey:function(privateKey){return schnorrGetExtPubKey(privateKey).bytes},sign:function(message,privateKey,auxRand=(0,utils_1.randomBytes)(32)){message=(0,utils_js_1.ensureBytes)(\"message\",message);const {bytes:px,scalar:d}=schnorrGetExtPubKey(privateKey);privateKey=(0,utils_js_1.ensureBytes)(\"auxRand\",auxRand,32);privateKey=(0,utils_js_1.numberToBytesBE)(d^(0,utils_js_1.bytesToNumberBE)(taggedHash(\"BIP0340/aux\",\nprivateKey)),32);privateKey=taggedHash(\"BIP0340/nonce\",privateKey,px,message);privateKey=(0,modular_js_1.mod)((0,utils_js_1.bytesToNumberBE)(privateKey),secp256k1N);if(privateKey===_0n)throw Error(\"sign failed: k is zero\");const {bytes:rx,scalar:k}=schnorrGetExtPubKey(privateKey);privateKey=challenge(rx,px,message);auxRand=new Uint8Array(64);auxRand.set(rx,0);auxRand.set((0,utils_js_1.numberToBytesBE)((0,modular_js_1.mod)(k+privateKey*d,secp256k1N),32),32);if(!schnorrVerify(auxRand,message,px))throw Error(\"sign: Invalid signature produced\");\nreturn auxRand},verify:schnorrVerify,utils:{randomPrivateKey:exports.secp256k1.utils.randomPrivateKey,lift_x,pointToBytes:point=>point.toRawBytes(!0).slice(1),numberToBytesBE:utils_js_1.numberToBytesBE,bytesToNumberBE:utils_js_1.bytesToNumberBE,taggedHash,mod:modular_js_1.mod}};const isoMap=(()=>(0,hash_to_curve_js_1.isogenyMap)(Fp,[[\"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n\"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"],[\"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\"0x0000000000000000000000000000000000000000000000000000000000000001\"],[\"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"],\n[\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\"0x0000000000000000000000000000000000000000000000000000000000000001\"]].map(i=>i.map(j=>BigInt(j)))))(),mapSWU=(0,global.mapToCurveSimpleSWU)(Fp,{A:BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),B:BigInt(\"1771\"),Z:Fp.create(BigInt(\"-11\"))});require=(()=>(0,hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint,\nscalars=>{const {x,y}=mapSWU(Fp.create(scalars[0]));return isoMap(x,y)},{DST:\"secp256k1_XMD:SHA-256_SSWU_RO_\",encodeDST:\"secp256k1_XMD:SHA-256_SSWU_NU_\",p:Fp.ORDER,m:1,k:128,expand:\"xmd\",hash:sha256_1.sha256}))();exports.hashToCurve=require.hashToCurve;exports.encodeToCurve=require.encodeToCurve}","~:source","shadow$provide[\"module$node_modules$$noble$curves$secp256k1\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst modular_js_1 = require(\"./abstract/modular.js\");\nconst weierstrass_js_1 = require(\"./abstract/weierstrass.js\");\nconst utils_js_1 = require(\"./abstract/utils.js\");\nconst hash_to_curve_js_1 = require(\"./abstract/hash-to-curve.js\");\nconst _shortw_utils_js_1 = require(\"./_shortw_utils.js\");\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);\nconst modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);\nconst modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexports.schnorr = (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: utils_js_1.numberToBytesBE,\n        bytesToNumberBE: utils_js_1.bytesToNumberBE,\n        taggedHash,\n        mod: modular_js_1.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256_1.sha256,\n}))();\nexports.hashToCurve = (() => htf.hashToCurve)();\nexports.encodeToCurve = (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$noble$curves$abstract$modular","~$module$node_modules$$noble$curves$abstract$hash_to_curve","~$module$node_modules$$noble$hashes$sha256","~$module$node_modules$$noble$curves$abstract$weierstrass","~$module$node_modules$$noble$curves$_shortw_utils","~$shadow.js","~$module$node_modules$$noble$hashes$utils","~$module$node_modules$$noble$curves$abstract$utils"]],"~:properties",["^5",["n","bytesToNumberBE","Gy","pointToBytes","scalar","schnorr","expand","p","hashToCurve","hash","__esModule","k1neg","secp256k1","Z","randomPrivateKey","k1","lift_x","value","lowS","verify","k2neg","B","a","k2","getPublicKey","bytes","sqrt","Gx","taggedHash","DST","mod","k","encodeToCurve","b","splitScalar","encodeDST","A","beta","numberToBytesBE","h","Fp","m","sign","utils","endo"]],"~:compiled-at",1695111490337,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$noble$curves$secp256k1.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@noble/curves/secp256k1.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$noble$curves$secp256k1\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\\nconst sha256_1 = require(\\\"@noble/hashes/sha256\\\");\\nconst utils_1 = require(\\\"@noble/hashes/utils\\\");\\nconst modular_js_1 = require(\\\"./abstract/modular.js\\\");\\nconst weierstrass_js_1 = require(\\\"./abstract/weierstrass.js\\\");\\nconst utils_js_1 = require(\\\"./abstract/utils.js\\\");\\nconst hash_to_curve_js_1 = require(\\\"./abstract/hash-to-curve.js\\\");\\nconst _shortw_utils_js_1 = require(\\\"./_shortw_utils.js\\\");\\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\\nconst _1n = BigInt(1);\\nconst _2n = BigInt(2);\\nconst divNearest = (a, b) => (a + b / _2n) / b;\\n/**\\n * \\u221an = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\\n */\\nfunction sqrtMod(y) {\\n    const P = secp256k1P;\\n    // prettier-ignore\\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\\n    // prettier-ignore\\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\\n    const b2 = (y * y * y) % P; // x^3, 11\\n    const b3 = (b2 * b2 * y) % P; // x^7\\n    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;\\n    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;\\n    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;\\n    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;\\n    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;\\n    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;\\n    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;\\n    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;\\n    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;\\n    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;\\n    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;\\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\\n    if (!Fp.eql(Fp.sqr(root), y))\\n        throw new Error('Cannot find square root');\\n    return root;\\n}\\nconst Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\\n    a: BigInt(0),\\n    b: BigInt(7),\\n    Fp,\\n    n: secp256k1N,\\n    // Base point (x, y) aka generator point\\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\\n    h: BigInt(1),\\n    lowS: true,\\n    /**\\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\\n     */\\n    endo: {\\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\\n        splitScalar: (k) => {\\n            const n = secp256k1N;\\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\\n            const b2 = a1;\\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\\n            const c1 = divNearest(b2 * k, n);\\n            const c2 = divNearest(-b1 * k, n);\\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\\n            const k1neg = k1 > POW_2_128;\\n            const k2neg = k2 > POW_2_128;\\n            if (k1neg)\\n                k1 = n - k1;\\n            if (k2neg)\\n                k2 = n - k2;\\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\\n            }\\n            return { k1neg, k1, k2neg, k2 };\\n        },\\n    },\\n}, sha256_1.sha256);\\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\\nconst _0n = BigInt(0);\\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\\nconst TAGGED_HASH_PREFIXES = {};\\nfunction taggedHash(tag, ...messages) {\\n    let tagP = TAGGED_HASH_PREFIXES[tag];\\n    if (tagP === undefined) {\\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\\n        TAGGED_HASH_PREFIXES[tag] = tagP;\\n    }\\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\\n}\\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\\nconst numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);\\nconst modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);\\nconst modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);\\nconst Point = exports.secp256k1.ProjectivePoint;\\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\\n// Calculate point, scalar and bytes\\nfunction schnorrGetExtPubKey(priv) {\\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\\n    let p = Point.fromPrivateKey(d_); // P = d'\\u22c5G; 0 < d' < n check is done inside\\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\\n    return { scalar: scalar, bytes: pointToBytes(p) };\\n}\\n/**\\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\\n * @returns valid point checked for being on-curve\\n */\\nfunction lift_x(x) {\\n    if (!fe(x))\\n        throw new Error('bad x: need 0 < x < p'); // Fail if x \\u2265 p.\\n    const xx = modP(x * x);\\n    const c = modP(xx * x + BigInt(7)); // Let c = x\\u00b3 + 7 mod p.\\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\\n    if (y % _2n !== _0n)\\n        y = modP(-y); // Return the unique point P such that x(P) = x and\\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\\n    p.assertValidity();\\n    return p;\\n}\\n/**\\n * Create tagged hash, convert it to bigint, reduce modulo-n.\\n */\\nfunction challenge(...args) {\\n    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\\n}\\n/**\\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\\n */\\nfunction schnorrGetPublicKey(privateKey) {\\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'\\u2265n. Ret bytes(d'\\u22c5G)\\n}\\n/**\\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\\n */\\nfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\\n    const m = (0, utils_js_1.ensureBytes)('message', message);\\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\\n    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\\n    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\\n    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\\n    if (k_ === _0n)\\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'\\u22c5G.\\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\\n    sig.set(rx, 0);\\n    sig.set(numTo32b(modN(k + e * d)), 32);\\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\\n    if (!schnorrVerify(sig, m, px))\\n        throw new Error('sign: Invalid signature produced');\\n    return sig;\\n}\\n/**\\n * Verifies Schnorr signature.\\n * Will swallow errors & return false except for initial type validation of arguments.\\n */\\nfunction schnorrVerify(signature, message, publicKey) {\\n    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);\\n    const m = (0, utils_js_1.ensureBytes)('message', message);\\n    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);\\n    try {\\n        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\\n        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r \\u2265 p.\\n        if (!fe(r))\\n            return false;\\n        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s \\u2265 n.\\n        if (!ge(s))\\n            return false;\\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\\n        const R = GmulAdd(P, s, modN(-e)); // R = s\\u22c5G - e\\u22c5P\\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\\n            return false; // -eP == (n-e)P\\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) \\u2260 r.\\n    }\\n    catch (error) {\\n        return false;\\n    }\\n}\\nexports.schnorr = (() => ({\\n    getPublicKey: schnorrGetPublicKey,\\n    sign: schnorrSign,\\n    verify: schnorrVerify,\\n    utils: {\\n        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\\n        lift_x,\\n        pointToBytes,\\n        numberToBytesBE: utils_js_1.numberToBytesBE,\\n        bytesToNumberBE: utils_js_1.bytesToNumberBE,\\n        taggedHash,\\n        mod: modular_js_1.mod,\\n    },\\n}))();\\nconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [\\n    // xNum\\n    [\\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\\n    ],\\n    // xDen\\n    [\\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\\n    ],\\n    // yNum\\n    [\\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\\n    ],\\n    // yDen\\n    [\\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\\n    ],\\n].map((i) => i.map((j) => BigInt(j)))))();\\nconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {\\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\\n    B: BigInt('1771'),\\n    Z: Fp.create(BigInt('-11')),\\n}))();\\nconst htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {\\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\\n    return isoMap(x, y);\\n}, {\\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\\n    p: Fp.ORDER,\\n    m: 1,\\n    k: 128,\\n    expand: 'xmd',\\n    hash: sha256_1.sha256,\\n}))();\\nexports.hashToCurve = (() => htf.hashToCurve)();\\nexports.encodeToCurve = (() => htf.encodeToCurve)();\\n//# sourceMappingURL=secp256k1.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"sqrtMod\",\"y\",\"P\",\"secp256k1P\",\"_3n\",\"BigInt\",\"_6n\",\"_11n\",\"_22n\",\"_23n\",\"_44n\",\"_88n\",\"b2\",\"b3\",\"b6\",\"modular_js_1\",\"pow2\",\"b9\",\"b11\",\"_2n\",\"b22\",\"b44\",\"b88\",\"b176\",\"b220\",\"b223\",\"t1\",\"t2\",\"root\",\"Fp\",\"eql\",\"sqr\",\"Error\",\"taggedHash\",\"tag\",\"messages\",\"tagP\",\"TAGGED_HASH_PREFIXES\",\"undefined\",\"tagH\",\"sha256_1\",\"sha256\",\"Uint8Array\",\"from\",\"c\",\"charCodeAt\",\"utils_js_1\",\"concatBytes\",\"schnorrGetExtPubKey\",\"priv\",\"d_\",\"secp256k1\",\"utils\",\"normPrivateKeyToScalar\",\"p\",\"Point\",\"fromPrivateKey\",\"scalar\",\"hasEvenY\",\"mod\",\"x\",\"secp256k1N\",\"bytes\",\"toRawBytes\",\"slice\",\"lift_x\",\"_0n\",\"xx\",\"_1n\",\"assertValidity\",\"challenge\",\"args\",\"bytesToNumberBE\",\"schnorrVerify\",\"signature\",\"message\",\"publicKey\",\"sig\",\"ensureBytes\",\"m\",\"pub\",\"r\",\"subarray\",\"s\",\"e\",\"numberToBytesBE\",\"BASE\",\"multiplyAndAddUnsafe\",\"b\",\"R\",\"toAffine\",\"error\",\"Object\",\"defineProperty\",\"value\",\"encodeToCurve\",\"hashToCurve\",\"schnorr\",\"utils_1\",\"weierstrass_js_1\",\"hash_to_curve_js_1\",\"_shortw_utils_js_1\",\"Field\",\"sqrt\",\"createCurve\",\"a\",\"n\",\"Gx\",\"Gy\",\"h\",\"lowS\",\"endo\",\"beta\",\"splitScalar\",\"k\",\"a1\",\"b1\",\"POW_2_128\",\"c1\",\"c2\",\"k1\",\"a2\",\"k2\",\"k1neg\",\"k2neg\",\"ProjectivePoint\",\"getPublicKey\",\"schnorrGetPublicKey\",\"privateKey\",\"sign\",\"schnorrSign\",\"auxRand\",\"randomBytes\",\"px\",\"d\",\"t\",\"rand\",\"k_\",\"rx\",\"set\",\"verify\",\"randomPrivateKey\",\"pointToBytes\",\"point\",\"isoMap\",\"isogenyMap\",\"map\",\"i\",\"j\",\"mapSWU\",\"mapToCurveSimpleSWU\",\"A\",\"B\",\"Z\",\"create\",\"htf\",\"createHasher\",\"scalars\",\"DST\",\"encodeDST\",\"ORDER\",\"expand\",\"hash\"]\n}\n"]