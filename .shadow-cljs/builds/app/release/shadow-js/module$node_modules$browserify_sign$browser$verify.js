["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/browserify-sign/browser/verify.js"],"~:js","shadow$provide[249]=function(S,A,V,q){function F(p,n){if(0>=p.cmpn(0))throw Error(\"invalid sig\");if(p.cmp(n)>=n)throw Error(\"invalid sig\");}var G=A(111).Buffer,r=A(7),y=A(102).ec,e=A(246),u=A(247);V.exports=function(p,n,l,h,k){l=e(l);if(\"ec\"===l.type){if(\"ecdsa\"!==h&&\"ecdsa/rsa\"!==h)throw Error(\"wrong public key type\");h=u[l.data.algorithm.curve.join(\".\")];if(!h)throw Error(\"unknown curve \"+l.data.algorithm.curve.join(\".\"));return(new y(h)).verify(n,p,l.data.subjectPrivateKey.data)}if(\"dsa\"===l.type){if(\"dsa\"!==\nh)throw Error(\"wrong public key type\");h=l.data.p;k=l.data.q;var t=l.data.g;l=l.data.pub_key;var B=e.signature.decode(p,\"der\");p=B.s;B=B.r;F(p,k);F(B,k);var E=r.mont(h);p=p.invm(k);return 0===t.toRed(E).redPow((new r(n)).mul(p).mod(k)).fromRed().mul(l.toRed(E).redPow(B.mul(p).mod(k)).fromRed()).mod(h).mod(k).cmp(B)}if(\"rsa\"!==h&&\"ecdsa/rsa\"!==h)throw Error(\"wrong public key type\");n=G.concat([k,n]);k=l.modulus.byteLength();h=[1];for(t=0;n.length+h.length+2<k;)h.push(255),t++;h.push(0);for(B=-1;++B<\nn.length;)h.push(n[B]);h=G.from(h);n=r.mont(l.modulus);p=(new r(p)).toRed(n);p=p.redPow(new r(l.publicExponent));p=G.from(p.fromRed().toArray());l=8>t?1:0;k=Math.min(p.length,h.length);p.length!==h.length&&(l=1);for(B=-1;++B<k;)l|=p[B]^h[B];return 0===l}}","~:source","shadow$provide[249] = function(global,require,module,exports) {\n// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\nvar Buffer = require('safe-buffer').Buffer\nvar BN = require('bn.js')\nvar EC = require('elliptic').ec\nvar parseKeys = require('parse-asn1')\nvar curves = require('./curves.json')\n\nfunction verify (sig, hash, key, signType, tag) {\n  var pub = parseKeys(key)\n  if (pub.type === 'ec') {\n    // rsa keys can be interpreted as ecdsa ones in openssl\n    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\n    return ecVerify(sig, hash, pub)\n  } else if (pub.type === 'dsa') {\n    if (signType !== 'dsa') throw new Error('wrong public key type')\n    return dsaVerify(sig, hash, pub)\n  } else {\n    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\n  }\n  hash = Buffer.concat([tag, hash])\n  var len = pub.modulus.byteLength()\n  var pad = [1]\n  var padNum = 0\n  while (hash.length + pad.length + 2 < len) {\n    pad.push(0xff)\n    padNum++\n  }\n  pad.push(0x00)\n  var i = -1\n  while (++i < hash.length) {\n    pad.push(hash[i])\n  }\n  pad = Buffer.from(pad)\n  var red = BN.mont(pub.modulus)\n  sig = new BN(sig).toRed(red)\n\n  sig = sig.redPow(new BN(pub.publicExponent))\n  sig = Buffer.from(sig.fromRed().toArray())\n  var out = padNum < 8 ? 1 : 0\n  len = Math.min(sig.length, pad.length)\n  if (sig.length !== pad.length) out = 1\n\n  i = -1\n  while (++i < len) out |= sig[i] ^ pad[i]\n  return out === 0\n}\n\nfunction ecVerify (sig, hash, pub) {\n  var curveId = curves[pub.data.algorithm.curve.join('.')]\n  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))\n\n  var curve = new EC(curveId)\n  var pubkey = pub.data.subjectPrivateKey.data\n\n  return curve.verify(hash, sig, pubkey)\n}\n\nfunction dsaVerify (sig, hash, pub) {\n  var p = pub.data.p\n  var q = pub.data.q\n  var g = pub.data.g\n  var y = pub.data.pub_key\n  var unpacked = parseKeys.signature.decode(sig, 'der')\n  var s = unpacked.s\n  var r = unpacked.r\n  checkValue(s, q)\n  checkValue(r, q)\n  var montp = BN.mont(p)\n  var w = s.invm(q)\n  var v = g.toRed(montp)\n    .redPow(new BN(hash).mul(w).mod(q))\n    .fromRed()\n    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())\n    .mod(p)\n    .mod(q)\n  return v.cmp(r) === 0\n}\n\nfunction checkValue (b, q) {\n  if (b.cmpn(0) <= 0) throw new Error('invalid sig')\n  if (b.cmp(q) >= q) throw new Error('invalid sig')\n}\n\nmodule.exports = verify\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$browserify_sign$browser$curves_json","~$module$node_modules$elliptic$lib$elliptic","~$shadow.js","~$module$node_modules$safe_buffer$index","~$module$node_modules$parse_asn1$index","~$module$node_modules$bn_DOT_js$lib$bn"]],"~:properties",["^5",[]],"~:compiled-at",1695041440861,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$browserify_sign$browser$verify.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CA+E9DC,QAASA,EAAW,CAACC,CAAD,CAAIC,CAAJ,CAAO,CACzB,GAAiB,CAAjB,EAAID,CAAEE,CAAAA,IAAF,CAAO,CAAP,CAAJ,CAAoB,KAAUC,MAAJ,CAAU,aAAV,CAAN,CACpB,GAAIH,CAAEI,CAAAA,GAAF,CAAMH,CAAN,CAAJ,EAAgBA,CAAhB,CAAmB,KAAUE,MAAJ,CAAU,aAAV,CAAN,CAFM,CA7E3B,IAAIE,EAAST,CAAA,CAAQ,GAAR,CAAuBS,CAAAA,MAApC,CACIC,EAAKV,CAAA,CAAQ,CAAR,CADT,CAEIW,EAAKX,CAAA,CAAQ,GAAR,CAAoBY,CAAAA,EAF7B,CAGIC,EAAYb,CAAA,CAAQ,GAAR,CAHhB,CAIIc,EAASd,CAAA,CAAQ,GAAR,CA8EbC,EAAOC,CAAAA,OAAP,CA5EAa,QAAgB,CAACC,CAAD,CAAMC,CAAN,CAAYC,CAAZ,CAAiBC,CAAjB,CAA2BC,CAA3B,CAAgC,CAC1CC,CAAAA,CAAMR,CAAA,CAAUK,CAAV,CACV,IAAiB,IAAjB,GAAIG,CAAIC,CAAAA,IAAR,CAAuB,CAErB,GAAiB,OAAjB,GAAIH,CAAJ,EAAyC,WAAzC,GAA4BA,CAA5B,CAAsD,KAAUZ,MAAJ,CAAU,uBAAV,CAAN,CAqCpDgB,CAAAA,CAAUT,CAAA,CApCeO,CAoCJG,CAAAA,IAAKC,CAAAA,SAAUC,CAAAA,KAAMC,CAAAA,IAAzB,CAA8B,GAA9B,CAAP,CACd,IAAI,CAACJ,CAAL,CAAc,KAAUhB,MAAJ,CAAU,gBAAV,CArCSc,CAqCwBG,CAAAA,IAAKC,CAAAA,SAAUC,CAAAA,KAAMC,CAAAA,IAAzB,CAA8B,GAA9B,CAA7B,CAAN,CArCZ,MA0CWZ,CAHDW,IAAIf,CAAJe,CAAOH,CAAPG,CAGCX,EAAAA,MAAN,CAAaE,CAAb,CAAmBD,CAAnB,CA1CsBK,CAwCZG,CAAAA,IAAKI,CAAAA,iBAAkBJ,CAAAA,IAEjC,CA7CgB,CAIhB,GAAiB,KAAjB,GAAIH,CAAIC,CAAAA,IAAR,CAAwB,CAC7B,GAAiB,KAAjB;AAAIH,CAAJ,CAAwB,KAAUZ,MAAJ,CAAU,uBAAV,CAAN,CA4CtBsB,CAAAA,CA3C0BR,CA2ClBG,CAAAA,IAAKK,CAAAA,CACbxB,EAAAA,CA5C0BgB,CA4ClBG,CAAAA,IAAKnB,CAAAA,CACjB,KAAIyB,EA7C0BT,CA6ClBG,CAAAA,IAAKM,CAAAA,CACbC,EAAAA,CA9C0BV,CA8ClBG,CAAAA,IAAKQ,CAAAA,OACjB,KAAIC,EAAWpB,CAAUqB,CAAAA,SAAUC,CAAAA,MAApB,CA/CInB,CA+CJ,CAAgC,KAAhC,CACXoB,EAAAA,CAAIH,CAASG,CAAAA,CACbC,EAAAA,CAAIJ,CAASI,CAAAA,CACjBlC,EAAA,CAAWiC,CAAX,CAAc/B,CAAd,CACAF,EAAA,CAAWkC,CAAX,CAAchC,CAAd,CACA,KAAIiC,EAAQ5B,CAAG6B,CAAAA,IAAH,CAAQV,CAAR,CACRW,EAAAA,CAAIJ,CAAEK,CAAAA,IAAF,CAAOpC,CAAP,CArDN,OA4DkB,EA5DlB,GAsDMyB,CAAEY,CAAAA,KAAF,CAAQJ,CAAR,CACLK,CAAAA,MADK,CACeC,CAAb,IAAIlC,CAAJ,CAAOO,CAAP,CAAa2B,EAAAA,GAAb,CAAiBJ,CAAjB,CAAoBK,CAAAA,GAApB,CAAwBxC,CAAxB,CADF,CAELyC,CAAAA,OAFK,EAGLF,CAAAA,GAHK,CAGDb,CAAEW,CAAAA,KAAF,CAAQJ,CAAR,CAAeK,CAAAA,MAAf,CAAsBN,CAAEO,CAAAA,GAAF,CAAMJ,CAAN,CAASK,CAAAA,GAAT,CAAaxC,CAAb,CAAtB,CAAuCyC,CAAAA,OAAvC,EAHC,CAILD,CAAAA,GAJK,CAIDhB,CAJC,CAKLgB,CAAAA,GALKE,CAKD1C,CALC0C,CAMCvC,CAAAA,GAAF,CAAM6B,CAAN,CA9DwB,CAI7B,GAAiB,KAAjB,GAAIlB,CAAJ,EAAuC,WAAvC,GAA0BA,CAA1B,CAAoD,KAAUZ,MAAJ,CAAU,uBAAV,CAAN,CAEtDU,CAAA,CAAOR,CAAOuC,CAAAA,MAAP,CAAc,CAAC5B,CAAD,CAAMH,CAAN,CAAd,CACHgC,EAAAA,CAAM5B,CAAI6B,CAAAA,OAAQC,CAAAA,UAAZ,EACNC,EAAAA,CAAM,CAAC,CAAD,CAEV,KADIC,CACJ,CADa,CACb,CAAOpC,CAAKqC,CAAAA,MAAZ,CAAqBF,CAAIE,CAAAA,MAAzB,CAAkC,CAAlC,CAAsCL,CAAtC,CAAA,CACEG,CAAIG,CAAAA,IAAJ,CAAS,GAAT,CACA,CAAAF,CAAA,EAEFD,EAAIG,CAAAA,IAAJ,CAAS,CAAT,CAEA,KADIC,CACJ,CADQ,CAAC,CACT,CAAO,EAAEA,CAAT;AAAavC,CAAKqC,CAAAA,MAAlB,CAAA,CACEF,CAAIG,CAAAA,IAAJ,CAAStC,CAAA,CAAKuC,CAAL,CAAT,CAEFJ,EAAA,CAAM3C,CAAOgD,CAAAA,IAAP,CAAYL,CAAZ,CACFM,EAAAA,CAAMhD,CAAG6B,CAAAA,IAAH,CAAQlB,CAAI6B,CAAAA,OAAZ,CACVlC,EAAA,CAAkB0B,CAAZ,IAAIhC,CAAJ,CAAOM,CAAP,CAAY0B,EAAAA,KAAZ,CAAkBgB,CAAlB,CAEN1C,EAAA,CAAMA,CAAI2B,CAAAA,MAAJ,CAAW,IAAIjC,CAAJ,CAAOW,CAAIsC,CAAAA,cAAX,CAAX,CACN3C,EAAA,CAAMP,CAAOgD,CAAAA,IAAP,CAAYzC,CAAI8B,CAAAA,OAAJ,EAAcc,CAAAA,OAAd,EAAZ,CACFC,EAAAA,CAAe,CAAT,CAAAR,CAAA,CAAa,CAAb,CAAiB,CAC3BJ,EAAA,CAAMa,IAAKC,CAAAA,GAAL,CAAS/C,CAAIsC,CAAAA,MAAb,CAAqBF,CAAIE,CAAAA,MAAzB,CACFtC,EAAIsC,CAAAA,MAAR,GAAmBF,CAAIE,CAAAA,MAAvB,GAA+BO,CAA/B,CAAqC,CAArC,CAGA,KADAL,CACA,CADI,CAAC,CACL,CAAO,EAAEA,CAAT,CAAaP,CAAb,CAAA,CAAkBY,CAAA,EAAO7C,CAAA,CAAIwC,CAAJ,CAAP,CAAgBJ,CAAA,CAAII,CAAJ,CAClC,OAAe,EAAf,GAAOK,CArCuC,CARc;\",\n\"sources\":[\"node_modules/browserify-sign/browser/verify.js\"],\n\"sourcesContent\":[\"shadow$provide[249] = function(global,require,module,exports) {\\n// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js\\nvar Buffer = require('safe-buffer').Buffer\\nvar BN = require('bn.js')\\nvar EC = require('elliptic').ec\\nvar parseKeys = require('parse-asn1')\\nvar curves = require('./curves.json')\\n\\nfunction verify (sig, hash, key, signType, tag) {\\n  var pub = parseKeys(key)\\n  if (pub.type === 'ec') {\\n    // rsa keys can be interpreted as ecdsa ones in openssl\\n    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\\n    return ecVerify(sig, hash, pub)\\n  } else if (pub.type === 'dsa') {\\n    if (signType !== 'dsa') throw new Error('wrong public key type')\\n    return dsaVerify(sig, hash, pub)\\n  } else {\\n    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')\\n  }\\n  hash = Buffer.concat([tag, hash])\\n  var len = pub.modulus.byteLength()\\n  var pad = [1]\\n  var padNum = 0\\n  while (hash.length + pad.length + 2 < len) {\\n    pad.push(0xff)\\n    padNum++\\n  }\\n  pad.push(0x00)\\n  var i = -1\\n  while (++i < hash.length) {\\n    pad.push(hash[i])\\n  }\\n  pad = Buffer.from(pad)\\n  var red = BN.mont(pub.modulus)\\n  sig = new BN(sig).toRed(red)\\n\\n  sig = sig.redPow(new BN(pub.publicExponent))\\n  sig = Buffer.from(sig.fromRed().toArray())\\n  var out = padNum < 8 ? 1 : 0\\n  len = Math.min(sig.length, pad.length)\\n  if (sig.length !== pad.length) out = 1\\n\\n  i = -1\\n  while (++i < len) out |= sig[i] ^ pad[i]\\n  return out === 0\\n}\\n\\nfunction ecVerify (sig, hash, pub) {\\n  var curveId = curves[pub.data.algorithm.curve.join('.')]\\n  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))\\n\\n  var curve = new EC(curveId)\\n  var pubkey = pub.data.subjectPrivateKey.data\\n\\n  return curve.verify(hash, sig, pubkey)\\n}\\n\\nfunction dsaVerify (sig, hash, pub) {\\n  var p = pub.data.p\\n  var q = pub.data.q\\n  var g = pub.data.g\\n  var y = pub.data.pub_key\\n  var unpacked = parseKeys.signature.decode(sig, 'der')\\n  var s = unpacked.s\\n  var r = unpacked.r\\n  checkValue(s, q)\\n  checkValue(r, q)\\n  var montp = BN.mont(p)\\n  var w = s.invm(q)\\n  var v = g.toRed(montp)\\n    .redPow(new BN(hash).mul(w).mod(q))\\n    .fromRed()\\n    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())\\n    .mod(p)\\n    .mod(q)\\n  return v.cmp(r) === 0\\n}\\n\\nfunction checkValue (b, q) {\\n  if (b.cmpn(0) <= 0) throw new Error('invalid sig')\\n  if (b.cmp(q) >= q) throw new Error('invalid sig')\\n}\\n\\nmodule.exports = verify\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"checkValue\",\"b\",\"q\",\"cmpn\",\"Error\",\"cmp\",\"Buffer\",\"BN\",\"EC\",\"ec\",\"parseKeys\",\"curves\",\"verify\",\"sig\",\"hash\",\"key\",\"signType\",\"tag\",\"pub\",\"type\",\"curveId\",\"data\",\"algorithm\",\"curve\",\"join\",\"subjectPrivateKey\",\"p\",\"g\",\"y\",\"pub_key\",\"unpacked\",\"signature\",\"decode\",\"s\",\"r\",\"montp\",\"mont\",\"w\",\"invm\",\"toRed\",\"redPow\",\"mul\",\"mod\",\"fromRed\",\"v\",\"concat\",\"len\",\"modulus\",\"byteLength\",\"pad\",\"padNum\",\"length\",\"push\",\"i\",\"from\",\"red\",\"publicExponent\",\"toArray\",\"out\",\"Math\",\"min\"]\n}\n"]