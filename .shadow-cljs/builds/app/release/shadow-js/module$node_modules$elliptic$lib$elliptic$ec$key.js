["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/elliptic/lib/elliptic/ec/key.js"],"~:js","shadow$provide[96]=function(S,A,V,q){function F(y,e){this.ec=y;this.pub=this.priv=null;e.priv&&this._importPrivate(e.priv,e.privEnc);e.pub&&this._importPublic(e.pub,e.pubEnc)}var G=A(70),r=A(73).assert;V.exports=F;F.fromPublic=function(y,e,u){return e instanceof F?e:new F(y,{pub:e,pubEnc:u})};F.fromPrivate=function(y,e,u){return e instanceof F?e:new F(y,{priv:e,privEnc:u})};F.prototype.validate=function(){var y=this.getPublic();return y.isInfinity()?{result:!1,reason:\"Invalid public key\"}:y.validate()?\ny.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:\"Public key * N !\\x3d O\"}:{result:!1,reason:\"Public key is not a point\"}};F.prototype.getPublic=function(y,e){\"string\"===typeof y&&(e=y,y=null);this.pub||(this.pub=this.ec.g.mul(this.priv));return e?this.pub.encode(e,y):this.pub};F.prototype.getPrivate=function(y){return\"hex\"===y?this.priv.toString(16,2):this.priv};F.prototype._importPrivate=function(y,e){this.priv=new G(y,e||16);this.priv=this.priv.umod(this.ec.curve.n)};\nF.prototype._importPublic=function(y,e){y.x||y.y?(\"mont\"===this.ec.curve.type?r(y.x,\"Need x coordinate\"):(\"short\"===this.ec.curve.type||\"edwards\"===this.ec.curve.type)&&r(y.x&&y.y,\"Need both x and y coordinate\"),this.pub=this.ec.curve.point(y.x,y.y)):this.pub=this.ec.curve.decodePoint(y,e)};F.prototype.derive=function(y){y.validate()||r(y.validate(),\"public point not validated\");return y.mul(this.priv).getX()};F.prototype.sign=function(y,e,u){return this.ec.sign(y,this,e,u)};F.prototype.verify=function(y,\ne){return this.ec.verify(y,e,this)};F.prototype.inspect=function(){return\"\\x3cKey priv: \"+(this.priv&&this.priv.toString(16,2))+\" pub: \"+(this.pub&&this.pub.inspect())+\" \\x3e\"}}","~:source","shadow$provide[96] = function(global,require,module,exports) {\n'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$elliptic$node_modules$bn_js$lib$bn","~$module$node_modules$elliptic$lib$elliptic$utils"]],"~:properties",["^5",["ec","fromPublic","getPrivate","validate","inspect","derive","priv","verify","fromPrivate","pub","_importPublic","privEnc","reason","_importPrivate","sign","pubEnc","result","getPublic"]],"~:compiled-at",1695041440753,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$elliptic$lib$elliptic$ec$key.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAe,EAAf,CAAA,CAAqB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAO7DC,QAASA,EAAO,CAACC,CAAD,CAAKC,CAAL,CAAc,CAC5B,IAAKD,CAAAA,EAAL,CAAUA,CAEV,KAAKE,CAAAA,GAAL,CADA,IAAKC,CAAAA,IACL,CADY,IAIRF,EAAQE,CAAAA,IAAZ,EACE,IAAKC,CAAAA,cAAL,CAAoBH,CAAQE,CAAAA,IAA5B,CAAkCF,CAAQI,CAAAA,OAA1C,CACEJ,EAAQC,CAAAA,GAAZ,EACE,IAAKI,CAAAA,aAAL,CAAmBL,CAAQC,CAAAA,GAA3B,CAAgCD,CAAQM,CAAAA,MAAxC,CAT0B,CAJ9B,IAAIC,EAAKZ,CAAA,CAAQ,EAAR,CAAT,CAEIa,EADQb,CAAAc,CAAQ,EAARA,CACOD,CAAAA,MAanBZ,EAAOC,CAAAA,OAAP,CAAiBC,CAEjBA,EAAQY,CAAAA,UAAR,CAAqBC,QAAmB,CAACZ,CAAD,CAAKE,CAAL,CAAUW,CAAV,CAAe,CACrD,MAAIX,EAAJ,WAAmBH,EAAnB,CACSG,CADT,CAGO,IAAIH,CAAJ,CAAYC,CAAZ,CAAgB,CACrBE,IAAKA,CADgB,CAErBK,OAAQM,CAFa,CAAhB,CAJ8C,CAUvDd,EAAQe,CAAAA,WAAR,CAAsBC,QAAoB,CAACf,CAAD,CAAKG,CAAL,CAAWU,CAAX,CAAgB,CACxD,MAAIV,EAAJ,WAAoBJ,EAApB,CACSI,CADT,CAGO,IAAIJ,CAAJ,CAAYC,CAAZ,CAAgB,CACrBG,KAAMA,CADe,CAErBE,QAASQ,CAFY,CAAhB,CAJiD,CAU1Dd,EAAQiB,CAAAA,SAAUC,CAAAA,QAAlB,CAA6BC,QAAiB,EAAG,CAC/C,IAAIhB,EAAM,IAAKiB,CAAAA,SAAL,EAEV,OAAIjB,EAAIkB,CAAAA,UAAJ,EAAJ,CACS,CAAEC,OAAQ,CAAA,CAAV,CAAiBC,OAAQ,oBAAzB,CADT,CAEKpB,CAAIe,CAAAA,QAAJ,EAAL;AAEKf,CAAIqB,CAAAA,GAAJ,CAAQ,IAAKvB,CAAAA,EAAGwB,CAAAA,KAAMC,CAAAA,CAAtB,CAAyBL,CAAAA,UAAzB,EAAL,CAGO,CAAEC,OAAQ,CAAA,CAAV,CAAgBC,OAAQ,IAAxB,CAHP,CACS,CAAED,OAAQ,CAAA,CAAV,CAAiBC,OAAQ,wBAAzB,CAHT,CACS,CAAED,OAAQ,CAAA,CAAV,CAAiBC,OAAQ,2BAAzB,CANsC,CAajDvB,EAAQiB,CAAAA,SAAUG,CAAAA,SAAlB,CAA8BO,QAAkB,CAACC,CAAD,CAAUd,CAAV,CAAe,CAEtC,QAAvB,GAAI,MAAOc,EAAX,GACEd,CACA,CADMc,CACN,CAAAA,CAAA,CAAU,IAFZ,CAKK,KAAKzB,CAAAA,GAAV,GACE,IAAKA,CAAAA,GADP,CACa,IAAKF,CAAAA,EAAG4B,CAAAA,CAAEL,CAAAA,GAAV,CAAc,IAAKpB,CAAAA,IAAnB,CADb,CAGA,OAAKU,EAAL,CAGO,IAAKX,CAAAA,GAAI2B,CAAAA,MAAT,CAAgBhB,CAAhB,CAAqBc,CAArB,CAHP,CACS,IAAKzB,CAAAA,GAX+C,CAgB/DH,EAAQiB,CAAAA,SAAUc,CAAAA,UAAlB,CAA+BC,QAAmB,CAAClB,CAAD,CAAM,CACtD,MAAY,KAAZ,GAAIA,CAAJ,CACS,IAAKV,CAAAA,IAAK6B,CAAAA,QAAV,CAAmB,EAAnB,CAAuB,CAAvB,CADT,CAGS,IAAK7B,CAAAA,IAJwC,CAOxDJ,EAAQiB,CAAAA,SAAUZ,CAAAA,cAAlB,CAAmC6B,QAAuB,CAACC,CAAD,CAAMrB,CAAN,CAAW,CACnE,IAAKV,CAAAA,IAAL,CAAY,IAAIK,CAAJ,CAAO0B,CAAP,CAAYrB,CAAZ,EAAmB,EAAnB,CAIZ,KAAKV,CAAAA,IAAL,CAAY,IAAKA,CAAAA,IAAKgC,CAAAA,IAAV,CAAe,IAAKnC,CAAAA,EAAGwB,CAAAA,KAAMC,CAAAA,CAA7B,CALuD,CAQrE1B;CAAQiB,CAAAA,SAAUV,CAAAA,aAAlB,CAAkC8B,QAAsB,CAACF,CAAD,CAAMrB,CAAN,CAAW,CAC7DqB,CAAIG,CAAAA,CAAR,EAAaH,CAAII,CAAAA,CAAjB,EAI6B,MAA3B,GAAI,IAAKtC,CAAAA,EAAGwB,CAAAA,KAAMe,CAAAA,IAAlB,CACE9B,CAAA,CAAOyB,CAAIG,CAAAA,CAAX,CAAc,mBAAd,CADF,EAEkC,OAFlC,GAEW,IAAKrC,CAAAA,EAAGwB,CAAAA,KAAMe,CAAAA,IAFzB,EAGkC,SAHlC,GAGW,IAAKvC,CAAAA,EAAGwB,CAAAA,KAAMe,CAAAA,IAHzB,GAIE9B,CAAA,CAAOyB,CAAIG,CAAAA,CAAX,EAAgBH,CAAII,CAAAA,CAApB,CAAuB,8BAAvB,CAEF,CAAA,IAAKpC,CAAAA,GAAL,CAAW,IAAKF,CAAAA,EAAGwB,CAAAA,KAAMgB,CAAAA,KAAd,CAAoBN,CAAIG,CAAAA,CAAxB,CAA2BH,CAAII,CAAAA,CAA/B,CAVb,EAaA,IAAKpC,CAAAA,GAbL,CAaW,IAAKF,CAAAA,EAAGwB,CAAAA,KAAMiB,CAAAA,WAAd,CAA0BP,CAA1B,CAA+BrB,CAA/B,CAdsD,CAkBnEd,EAAQiB,CAAAA,SAAU0B,CAAAA,MAAlB,CAA2BC,QAAe,CAACzC,CAAD,CAAM,CAC1CA,CAAIe,CAAAA,QAAJ,EAAJ,EACER,CAAA,CAAOP,CAAIe,CAAAA,QAAJ,EAAP,CAAuB,4BAAvB,CAEF,OAAOf,EAAIqB,CAAAA,GAAJ,CAAQ,IAAKpB,CAAAA,IAAb,CAAmByC,CAAAA,IAAnB,EAJuC,CAQhD7C,EAAQiB,CAAAA,SAAU6B,CAAAA,IAAlB,CAAyBC,QAAa,CAACC,CAAD,CAAMlC,CAAN,CAAWZ,CAAX,CAAoB,CACxD,MAAO,KAAKD,CAAAA,EAAG6C,CAAAA,IAAR,CAAaE,CAAb,CAAkB,IAAlB,CAAwBlC,CAAxB,CAA6BZ,CAA7B,CADiD,CAI1DF,EAAQiB,CAAAA,SAAUgC,CAAAA,MAAlB,CAA2BC,QAAe,CAACF,CAAD;AAAMG,CAAN,CAAiB,CACzD,MAAO,KAAKlD,CAAAA,EAAGgD,CAAAA,MAAR,CAAeD,CAAf,CAAoBG,CAApB,CAA+B,IAA/B,CADkD,CAI3DnD,EAAQiB,CAAAA,SAAUmC,CAAAA,OAAlB,CAA4BC,QAAgB,EAAG,CAC7C,MAAO,gBAAP,EAAwB,IAAKjD,CAAAA,IAA7B,EAAqC,IAAKA,CAAAA,IAAK6B,CAAAA,QAAV,CAAmB,EAAnB,CAAuB,CAAvB,CAArC,EACO,QADP,EACmB,IAAK9B,CAAAA,GADxB,EAC+B,IAAKA,CAAAA,GAAIiD,CAAAA,OAAT,EAD/B,EACqD,OAFR,CAtHc;\",\n\"sources\":[\"node_modules/elliptic/lib/elliptic/ec/key.js\"],\n\"sourcesContent\":[\"shadow$provide[96] = function(global,require,module,exports) {\\n'use strict';\\n\\nvar BN = require('bn.js');\\nvar utils = require('../utils');\\nvar assert = utils.assert;\\n\\nfunction KeyPair(ec, options) {\\n  this.ec = ec;\\n  this.priv = null;\\n  this.pub = null;\\n\\n  // KeyPair(ec, { priv: ..., pub: ... })\\n  if (options.priv)\\n    this._importPrivate(options.priv, options.privEnc);\\n  if (options.pub)\\n    this._importPublic(options.pub, options.pubEnc);\\n}\\nmodule.exports = KeyPair;\\n\\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\\n  if (pub instanceof KeyPair)\\n    return pub;\\n\\n  return new KeyPair(ec, {\\n    pub: pub,\\n    pubEnc: enc,\\n  });\\n};\\n\\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\\n  if (priv instanceof KeyPair)\\n    return priv;\\n\\n  return new KeyPair(ec, {\\n    priv: priv,\\n    privEnc: enc,\\n  });\\n};\\n\\nKeyPair.prototype.validate = function validate() {\\n  var pub = this.getPublic();\\n\\n  if (pub.isInfinity())\\n    return { result: false, reason: 'Invalid public key' };\\n  if (!pub.validate())\\n    return { result: false, reason: 'Public key is not a point' };\\n  if (!pub.mul(this.ec.curve.n).isInfinity())\\n    return { result: false, reason: 'Public key * N != O' };\\n\\n  return { result: true, reason: null };\\n};\\n\\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\\n  // compact is optional argument\\n  if (typeof compact === 'string') {\\n    enc = compact;\\n    compact = null;\\n  }\\n\\n  if (!this.pub)\\n    this.pub = this.ec.g.mul(this.priv);\\n\\n  if (!enc)\\n    return this.pub;\\n\\n  return this.pub.encode(enc, compact);\\n};\\n\\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\\n  if (enc === 'hex')\\n    return this.priv.toString(16, 2);\\n  else\\n    return this.priv;\\n};\\n\\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\\n  this.priv = new BN(key, enc || 16);\\n\\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\\n  // in fixed multiplication method\\n  this.priv = this.priv.umod(this.ec.curve.n);\\n};\\n\\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\\n  if (key.x || key.y) {\\n    // Montgomery points only have an `x` coordinate.\\n    // Weierstrass/Edwards points on the other hand have both `x` and\\n    // `y` coordinates.\\n    if (this.ec.curve.type === 'mont') {\\n      assert(key.x, 'Need x coordinate');\\n    } else if (this.ec.curve.type === 'short' ||\\n               this.ec.curve.type === 'edwards') {\\n      assert(key.x && key.y, 'Need both x and y coordinate');\\n    }\\n    this.pub = this.ec.curve.point(key.x, key.y);\\n    return;\\n  }\\n  this.pub = this.ec.curve.decodePoint(key, enc);\\n};\\n\\n// ECDH\\nKeyPair.prototype.derive = function derive(pub) {\\n  if(!pub.validate()) {\\n    assert(pub.validate(), 'public point not validated');\\n  }\\n  return pub.mul(this.priv).getX();\\n};\\n\\n// ECDSA\\nKeyPair.prototype.sign = function sign(msg, enc, options) {\\n  return this.ec.sign(msg, this, enc, options);\\n};\\n\\nKeyPair.prototype.verify = function verify(msg, signature) {\\n  return this.ec.verify(msg, signature, this);\\n};\\n\\nKeyPair.prototype.inspect = function inspect() {\\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"KeyPair\",\"ec\",\"options\",\"pub\",\"priv\",\"_importPrivate\",\"privEnc\",\"_importPublic\",\"pubEnc\",\"BN\",\"assert\",\"utils\",\"fromPublic\",\"KeyPair.fromPublic\",\"enc\",\"fromPrivate\",\"KeyPair.fromPrivate\",\"prototype\",\"validate\",\"KeyPair.prototype.validate\",\"getPublic\",\"isInfinity\",\"result\",\"reason\",\"mul\",\"curve\",\"n\",\"KeyPair.prototype.getPublic\",\"compact\",\"g\",\"encode\",\"getPrivate\",\"KeyPair.prototype.getPrivate\",\"toString\",\"KeyPair.prototype._importPrivate\",\"key\",\"umod\",\"KeyPair.prototype._importPublic\",\"x\",\"y\",\"type\",\"point\",\"decodePoint\",\"derive\",\"KeyPair.prototype.derive\",\"getX\",\"sign\",\"KeyPair.prototype.sign\",\"msg\",\"verify\",\"KeyPair.prototype.verify\",\"signature\",\"inspect\",\"KeyPair.prototype.inspect\"]\n}\n"]