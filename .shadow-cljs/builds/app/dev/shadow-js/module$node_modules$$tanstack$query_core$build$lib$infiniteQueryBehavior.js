["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.js"],"~:js","shadow$provide.module$node_modules$$tanstack$query_core$build$lib$infiniteQueryBehavior=function(global,require,module,exports){function getNextPageParam(options,pages){return null==options.getNextPageParam?void 0:options.getNextPageParam(pages[pages.length-1],pages)}function getPreviousPageParam(options,pages){return null==options.getPreviousPageParam?void 0:options.getPreviousPageParam(pages[0],pages)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.getNextPageParam=getNextPageParam;\nexports.getPreviousPageParam=getPreviousPageParam;exports.hasNextPage=function(options,pages){if(options.getNextPageParam&&Array.isArray(pages))return options=getNextPageParam(options,pages),\"undefined\"!==typeof options&&null!==options&&!1!==options};exports.hasPreviousPage=function(options,pages){if(options.getPreviousPageParam&&Array.isArray(pages))return options=getPreviousPageParam(options,pages),\"undefined\"!==typeof options&&null!==options&&!1!==options};exports.infiniteQueryBehavior=function(){return{onFetch:context=>\n{context.fetchFn=()=>{var _context$fetchOptions,_context$fetchOptions2,_context$fetchOptions3,_context$fetchOptions4,_context$state$data,_context$state$data2;const refetchPage=null==(_context$fetchOptions=context.fetchOptions)?void 0:null==(_context$fetchOptions2=_context$fetchOptions.meta)?void 0:_context$fetchOptions2.refetchPage;_context$fetchOptions=null==(_context$fetchOptions3=context.fetchOptions)?void 0:null==(_context$fetchOptions4=_context$fetchOptions3.meta)?void 0:_context$fetchOptions4.fetchMore;\n_context$fetchOptions3=null==_context$fetchOptions?void 0:_context$fetchOptions.pageParam;_context$fetchOptions4=\"forward\"===(null==_context$fetchOptions?void 0:_context$fetchOptions.direction);_context$fetchOptions=\"backward\"===(null==_context$fetchOptions?void 0:_context$fetchOptions.direction);const oldPages=(null==(_context$state$data=context.state.data)?void 0:_context$state$data.pages)||[],oldPageParams=(null==(_context$state$data2=context.state.data)?void 0:_context$state$data2.pageParams)||\n[];let newPageParams=oldPageParams,cancelled=!1;const addSignalProperty=object=>{Object.defineProperty(object,\"signal\",{enumerable:!0,get:()=>{var _context$signal;if(null!=(_context$signal=context.signal)&&_context$signal.aborted)cancelled=!0;else{var _context$signal2;null==(_context$signal2=context.signal)?void 0:_context$signal2.addEventListener(\"abort\",()=>{cancelled=!0})}return context.signal}})},queryFn=context.options.queryFn||(()=>Promise.reject(\"Missing queryFn for queryKey '\"+context.options.queryHash+\n\"'\")),buildNewPages=(pages,param,page,previous)=>{newPageParams=previous?[param,...newPageParams]:[...newPageParams,param];return previous?[page,...pages]:[...pages,page]},fetchPage=(pages,manual,param,previous)=>{if(cancelled)return Promise.reject(\"Cancelled\");if(\"undefined\"===typeof param&&!manual&&pages.length)return Promise.resolve(pages);manual={queryKey:context.queryKey,pageParam:param,meta:context.options.meta};addSignalProperty(manual);manual=queryFn(manual);return Promise.resolve(manual).then(page=>\nbuildNewPages(pages,param,page,previous))};if(oldPages.length)if(_context$fetchOptions4)_context$state$data2=(_context$state$data=\"undefined\"!==typeof _context$fetchOptions3)?_context$fetchOptions3:getNextPageParam(context.options,oldPages),_context$state$data=fetchPage(oldPages,_context$state$data,_context$state$data2);else if(_context$fetchOptions)_context$state$data2=(_context$state$data=\"undefined\"!==typeof _context$fetchOptions3)?_context$fetchOptions3:getPreviousPageParam(context.options,oldPages),\n_context$state$data=fetchPage(oldPages,_context$state$data,_context$state$data2,!0);else{newPageParams=[];const manual=\"undefined\"===typeof context.options.getNextPageParam;_context$state$data=(refetchPage&&oldPages[0]?refetchPage(oldPages[0],0,oldPages):1)?fetchPage([],manual,oldPageParams[0]):Promise.resolve(buildNewPages([],oldPageParams[0],oldPages[0]));for(let i=1;i<oldPages.length;i++)_context$state$data=_context$state$data.then(pages=>{if(refetchPage&&oldPages[i]?refetchPage(oldPages[i],i,\noldPages):1){const param=manual?oldPageParams[i]:getNextPageParam(context.options,pages);return fetchPage(pages,manual,param)}return Promise.resolve(buildNewPages(pages,oldPageParams[i],oldPages[i]))})}else _context$state$data=fetchPage([]);return _context$state$data.then(pages=>({pages,pageParams:newPageParams}))}}}}}","~:source","shadow$provide[\"module$node_modules$$tanstack$query_core$build$lib$infiniteQueryBehavior\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject(\"Missing queryFn for queryKey '\" + context.options.queryHash + \"'\"));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\nexports.getNextPageParam = getNextPageParam;\nexports.getPreviousPageParam = getPreviousPageParam;\nexports.hasNextPage = hasNextPage;\nexports.hasPreviousPage = hasPreviousPage;\nexports.infiniteQueryBehavior = infiniteQueryBehavior;\n//# sourceMappingURL=infiniteQueryBehavior.js.map\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["queryKey","getNextPageParam","pages","__esModule","onFetch","signal","value","enumerable","pageParams","fetchFn","getPreviousPageParam","meta","hasPreviousPage","pageParam","hasNextPage","get","infiniteQueryBehavior"]],"~:compiled-at",1695111489932,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$tanstack$query_core$build$lib$infiniteQueryBehavior.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$tanstack$query_core$build$lib$infiniteQueryBehavior\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nfunction infiniteQueryBehavior() {\\n  return {\\n    onFetch: context => {\\n      context.fetchFn = () => {\\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\\n\\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\\n        let newPageParams = oldPageParams;\\n        let cancelled = false;\\n\\n        const addSignalProperty = object => {\\n          Object.defineProperty(object, 'signal', {\\n            enumerable: true,\\n            get: () => {\\n              var _context$signal;\\n\\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\\n                cancelled = true;\\n              } else {\\n                var _context$signal2;\\n\\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\\n                  cancelled = true;\\n                });\\n              }\\n\\n              return context.signal;\\n            }\\n          });\\n        }; // Get query function\\n\\n\\n        const queryFn = context.options.queryFn || (() => Promise.reject(\\\"Missing queryFn for queryKey '\\\" + context.options.queryHash + \\\"'\\\"));\\n\\n        const buildNewPages = (pages, param, page, previous) => {\\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\\n          return previous ? [page, ...pages] : [...pages, page];\\n        }; // Create function to fetch a page\\n\\n\\n        const fetchPage = (pages, manual, param, previous) => {\\n          if (cancelled) {\\n            return Promise.reject('Cancelled');\\n          }\\n\\n          if (typeof param === 'undefined' && !manual && pages.length) {\\n            return Promise.resolve(pages);\\n          }\\n\\n          const queryFnContext = {\\n            queryKey: context.queryKey,\\n            pageParam: param,\\n            meta: context.options.meta\\n          };\\n          addSignalProperty(queryFnContext);\\n          const queryFnResult = queryFn(queryFnContext);\\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\\n          return promise;\\n        };\\n\\n        let promise; // Fetch first page?\\n\\n        if (!oldPages.length) {\\n          promise = fetchPage([]);\\n        } // Fetch next page?\\n        else if (isFetchingNextPage) {\\n          const manual = typeof pageParam !== 'undefined';\\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\\n          promise = fetchPage(oldPages, manual, param);\\n        } // Fetch previous page?\\n        else if (isFetchingPreviousPage) {\\n          const manual = typeof pageParam !== 'undefined';\\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\\n          promise = fetchPage(oldPages, manual, param, true);\\n        } // Refetch pages\\n        else {\\n          newPageParams = [];\\n          const manual = typeof context.options.getNextPageParam === 'undefined';\\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\\n\\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\\n\\n          for (let i = 1; i < oldPages.length; i++) {\\n            promise = promise.then(pages => {\\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\\n\\n              if (shouldFetchNextPage) {\\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\\n                return fetchPage(pages, manual, param);\\n              }\\n\\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\\n            });\\n          }\\n        }\\n\\n        const finalPromise = promise.then(pages => ({\\n          pages,\\n          pageParams: newPageParams\\n        }));\\n        return finalPromise;\\n      };\\n    }\\n  };\\n}\\nfunction getNextPageParam(options, pages) {\\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\\n}\\nfunction getPreviousPageParam(options, pages) {\\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\\n}\\n/**\\n * Checks if there is a next page.\\n * Returns `undefined` if it cannot be determined.\\n */\\n\\nfunction hasNextPage(options, pages) {\\n  if (options.getNextPageParam && Array.isArray(pages)) {\\n    const nextPageParam = getNextPageParam(options, pages);\\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\\n  }\\n\\n  return;\\n}\\n/**\\n * Checks if there is a previous page.\\n * Returns `undefined` if it cannot be determined.\\n */\\n\\nfunction hasPreviousPage(options, pages) {\\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\\n    const previousPageParam = getPreviousPageParam(options, pages);\\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\\n  }\\n\\n  return;\\n}\\n\\nexports.getNextPageParam = getNextPageParam;\\nexports.getPreviousPageParam = getPreviousPageParam;\\nexports.hasNextPage = hasNextPage;\\nexports.hasPreviousPage = hasPreviousPage;\\nexports.infiniteQueryBehavior = infiniteQueryBehavior;\\n//# sourceMappingURL=infiniteQueryBehavior.js.map\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getNextPageParam\",\"options\",\"pages\",\"length\",\"getPreviousPageParam\",\"Object\",\"defineProperty\",\"value\",\"hasNextPage\",\"Array\",\"isArray\",\"nextPageParam\",\"hasPreviousPage\",\"previousPageParam\",\"infiniteQueryBehavior\",\"onFetch\",\"context\",\"fetchFn\",\"context.fetchFn\",\"_context$fetchOptions\",\"_context$fetchOptions2\",\"_context$fetchOptions3\",\"_context$fetchOptions4\",\"_context$state$data\",\"_context$state$data2\",\"refetchPage\",\"fetchOptions\",\"meta\",\"fetchMore\",\"pageParam\",\"isFetchingNextPage\",\"direction\",\"isFetchingPreviousPage\",\"oldPages\",\"state\",\"data\",\"oldPageParams\",\"pageParams\",\"newPageParams\",\"cancelled\",\"addSignalProperty\",\"object\",\"enumerable\",\"get\",\"_context$signal\",\"signal\",\"aborted\",\"_context$signal2\",\"addEventListener\",\"queryFn\",\"Promise\",\"reject\",\"queryHash\",\"buildNewPages\",\"param\",\"page\",\"previous\",\"fetchPage\",\"manual\",\"resolve\",\"queryFnContext\",\"queryKey\",\"queryFnResult\",\"then\",\"promise\",\"shouldFetchFirstPage\",\"i\",\"shouldFetchNextPage\",\"finalPromise\"]\n}\n"]