["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/elliptic/lib/elliptic/ec/index.js"],"~:js","shadow$provide[98]=function(S,A,V,q){function F(l){if(!(this instanceof F))return new F(l);\"string\"===typeof l&&(u(Object.prototype.hasOwnProperty.call(y,l),\"Unknown curve \"+l),l=y[l]);l instanceof y.PresetCurve&&(l={curve:l});this.curve=l.curve.curve;this.n=this.curve.n;this.nh=this.n.ushrn(1);this.g=this.curve.g;this.g=l.curve.g;this.g.precompute(l.curve.n.bitLength()+1);this.hash=l.hash||l.curve.hash}var G=A(70),r=A(95);S=A(73);var y=A(94),e=A(74),u=S.assert,p=A(96),n=A(97);V.exports=F;F.prototype.keyPair=\nfunction(l){return new p(this,l)};F.prototype.keyFromPrivate=function(l,h){return p.fromPrivate(this,l,h)};F.prototype.keyFromPublic=function(l,h){return p.fromPublic(this,l,h)};F.prototype.genKeyPair=function(l){l||(l={});l=new r({hash:this.hash,pers:l.pers,persEnc:l.persEnc||\"utf8\",entropy:l.entropy||e(this.hash.hmacStrength),entropyEnc:l.entropy&&l.entropyEnc||\"utf8\",nonce:this.n.toArray()});for(var h=this.n.byteLength(),k=this.n.sub(new G(2));;){var t=new G(l.generate(h));if(!(0<t.cmp(k)))return t.iaddn(1),\nthis.keyFromPrivate(t)}};F.prototype._truncateToN=function(l,h){var k=8*l.byteLength()-this.n.bitLength();0<k&&(l=l.ushrn(k));return!h&&0<=l.cmp(this.n)?l.sub(this.n):l};F.prototype.sign=function(l,h,k,t){\"object\"===typeof k&&(t=k,k=null);t||(t={});h=this.keyFromPrivate(h,k);l=this._truncateToN(new G(l,16));var B=this.n.byteLength();k=h.getPrivate().toArray(\"be\",B);B=l.toArray(\"be\",B);B=new r({hash:this.hash,entropy:k,nonce:B,pers:t.pers,persEnc:t.persEnc||\"utf8\"});for(var E=this.n.sub(new G(1)),\nH=0;;H++){var D=t.k?t.k(H):new G(B.generate(this.n.byteLength()));D=this._truncateToN(D,!0);if(!(0>=D.cmpn(1)||0<=D.cmp(E))){var C=this.g.mul(D);if(!C.isInfinity()){var I=C.getX();k=I.umod(this.n);if(0!==k.cmpn(0)&&(D=D.invm(this.n).mul(k.mul(h.getPrivate()).iadd(l)),D=D.umod(this.n),0!==D.cmpn(0)))return l=(C.getY().isOdd()?1:0)|(0!==I.cmp(k)?2:0),t.canonical&&0<D.cmp(this.nh)&&(D=this.n.sub(D),l^=1),new n({r:k,s:D,recoveryParam:l})}}}};F.prototype.verify=function(l,h,k,t){l=this._truncateToN(new G(l,\n16));k=this.keyFromPublic(k,t);h=new n(h,\"hex\");t=h.r;h=h.s;if(0>t.cmpn(1)||0<=t.cmp(this.n)||0>h.cmpn(1)||0<=h.cmp(this.n))return!1;h=h.invm(this.n);l=h.mul(l).umod(this.n);h=h.mul(t).umod(this.n);if(!this.curve._maxwellTrick)return k=this.g.mulAdd(l,k.getPublic(),h),k.isInfinity()?!1:0===k.getX().umod(this.n).cmp(t);k=this.g.jmulAdd(l,k.getPublic(),h);return k.isInfinity()?!1:k.eqXToP(t)};F.prototype.recoverPubKey=function(l,h,k,t){u((3&k)===k,\"The recovery param is more than two bits\");h=new n(h,\nt);t=this.n;var B=new G(l);l=h.r;var E=h.s,H=k&1;k>>=1;if(0<=l.cmp(this.curve.p.umod(this.curve.n))&&k)throw Error(\"Unable to find sencond key candinate\");l=k?this.curve.pointFromX(l.add(this.curve.n),H):this.curve.pointFromX(l,H);h=h.r.invm(t);k=t.sub(B).mul(h).umod(t);t=E.mul(h).umod(t);return this.g.mulAdd(k,l,t)};F.prototype.getKeyRecoveryParam=function(l,h,k,t){h=new n(h,t);if(null!==h.recoveryParam)return h.recoveryParam;for(t=0;4>t;t++){try{var B=this.recoverPubKey(l,h,t)}catch(E){continue}if(B.eq(k))return t}throw Error(\"Unable to find valid recovery factor\");\n}}","~:source","shadow$provide[98] = function(global,require,module,exports) {\n'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$elliptic$lib$elliptic$ec$key","~$shadow.js","~$module$node_modules$elliptic$node_modules$bn_js$lib$bn","~$module$node_modules$brorand$index","~$module$node_modules$hmac_drbg$lib$hmac_drbg","~$module$node_modules$elliptic$lib$elliptic$curves","~$module$node_modules$elliptic$lib$elliptic$ec$signature","~$module$node_modules$elliptic$lib$elliptic$utils"]],"~:properties",["^5",["n","keyPair","nh","s","pers","curve","recoverPubKey","recoveryParam","getKeyRecoveryParam","hash","entropyEnc","keyFromPublic","keyFromPrivate","verify","persEnc","entropy","r","g","nonce","genKeyPair","sign","_truncateToN"]],"~:compiled-at",1695041440755,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$elliptic$lib$elliptic$ec$index.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/elliptic/lib/elliptic/ec/index.js\"],\n\"sourcesContent\":[\"shadow$provide[98] = function(global,require,module,exports) {\\n'use strict';\\n\\nvar BN = require('bn.js');\\nvar HmacDRBG = require('hmac-drbg');\\nvar utils = require('../utils');\\nvar curves = require('../curves');\\nvar rand = require('brorand');\\nvar assert = utils.assert;\\n\\nvar KeyPair = require('./key');\\nvar Signature = require('./signature');\\n\\nfunction EC(options) {\\n  if (!(this instanceof EC))\\n    return new EC(options);\\n\\n  // Shortcut `elliptic.ec(curve-name)`\\n  if (typeof options === 'string') {\\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\\n      'Unknown curve ' + options);\\n\\n    options = curves[options];\\n  }\\n\\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\\n  if (options instanceof curves.PresetCurve)\\n    options = { curve: options };\\n\\n  this.curve = options.curve.curve;\\n  this.n = this.curve.n;\\n  this.nh = this.n.ushrn(1);\\n  this.g = this.curve.g;\\n\\n  // Point on curve\\n  this.g = options.curve.g;\\n  this.g.precompute(options.curve.n.bitLength() + 1);\\n\\n  // Hash for function for DRBG\\n  this.hash = options.hash || options.curve.hash;\\n}\\nmodule.exports = EC;\\n\\nEC.prototype.keyPair = function keyPair(options) {\\n  return new KeyPair(this, options);\\n};\\n\\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\\n  return KeyPair.fromPrivate(this, priv, enc);\\n};\\n\\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\\n  return KeyPair.fromPublic(this, pub, enc);\\n};\\n\\nEC.prototype.genKeyPair = function genKeyPair(options) {\\n  if (!options)\\n    options = {};\\n\\n  // Instantiate Hmac_DRBG\\n  var drbg = new HmacDRBG({\\n    hash: this.hash,\\n    pers: options.pers,\\n    persEnc: options.persEnc || 'utf8',\\n    entropy: options.entropy || rand(this.hash.hmacStrength),\\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\\n    nonce: this.n.toArray(),\\n  });\\n\\n  var bytes = this.n.byteLength();\\n  var ns2 = this.n.sub(new BN(2));\\n  for (;;) {\\n    var priv = new BN(drbg.generate(bytes));\\n    if (priv.cmp(ns2) > 0)\\n      continue;\\n\\n    priv.iaddn(1);\\n    return this.keyFromPrivate(priv);\\n  }\\n};\\n\\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\\n  if (delta > 0)\\n    msg = msg.ushrn(delta);\\n  if (!truncOnly && msg.cmp(this.n) >= 0)\\n    return msg.sub(this.n);\\n  else\\n    return msg;\\n};\\n\\nEC.prototype.sign = function sign(msg, key, enc, options) {\\n  if (typeof enc === 'object') {\\n    options = enc;\\n    enc = null;\\n  }\\n  if (!options)\\n    options = {};\\n\\n  key = this.keyFromPrivate(key, enc);\\n  msg = this._truncateToN(new BN(msg, 16));\\n\\n  // Zero-extend key to provide enough entropy\\n  var bytes = this.n.byteLength();\\n  var bkey = key.getPrivate().toArray('be', bytes);\\n\\n  // Zero-extend nonce to have the same byte size as N\\n  var nonce = msg.toArray('be', bytes);\\n\\n  // Instantiate Hmac_DRBG\\n  var drbg = new HmacDRBG({\\n    hash: this.hash,\\n    entropy: bkey,\\n    nonce: nonce,\\n    pers: options.pers,\\n    persEnc: options.persEnc || 'utf8',\\n  });\\n\\n  // Number of bytes to generate\\n  var ns1 = this.n.sub(new BN(1));\\n\\n  for (var iter = 0; ; iter++) {\\n    var k = options.k ?\\n      options.k(iter) :\\n      new BN(drbg.generate(this.n.byteLength()));\\n    k = this._truncateToN(k, true);\\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\\n      continue;\\n\\n    var kp = this.g.mul(k);\\n    if (kp.isInfinity())\\n      continue;\\n\\n    var kpX = kp.getX();\\n    var r = kpX.umod(this.n);\\n    if (r.cmpn(0) === 0)\\n      continue;\\n\\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\\n    s = s.umod(this.n);\\n    if (s.cmpn(0) === 0)\\n      continue;\\n\\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\\n\\n    // Use complement of `s`, if it is > `n / 2`\\n    if (options.canonical && s.cmp(this.nh) > 0) {\\n      s = this.n.sub(s);\\n      recoveryParam ^= 1;\\n    }\\n\\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\\n  }\\n};\\n\\nEC.prototype.verify = function verify(msg, signature, key, enc) {\\n  msg = this._truncateToN(new BN(msg, 16));\\n  key = this.keyFromPublic(key, enc);\\n  signature = new Signature(signature, 'hex');\\n\\n  // Perform primitive values validation\\n  var r = signature.r;\\n  var s = signature.s;\\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\\n    return false;\\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\\n    return false;\\n\\n  // Validate signature\\n  var sinv = s.invm(this.n);\\n  var u1 = sinv.mul(msg).umod(this.n);\\n  var u2 = sinv.mul(r).umod(this.n);\\n  var p;\\n\\n  if (!this.curve._maxwellTrick) {\\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\\n    if (p.isInfinity())\\n      return false;\\n\\n    return p.getX().umod(this.n).cmp(r) === 0;\\n  }\\n\\n  // NOTE: Greg Maxwell's trick, inspired by:\\n  // https://git.io/vad3K\\n\\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\\n  if (p.isInfinity())\\n    return false;\\n\\n  // Compare `p.x` of Jacobian point with `r`,\\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\\n  // inverse of `p.z^2`\\n  return p.eqXToP(r);\\n};\\n\\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\\n  assert((3 & j) === j, 'The recovery param is more than two bits');\\n  signature = new Signature(signature, enc);\\n\\n  var n = this.n;\\n  var e = new BN(msg);\\n  var r = signature.r;\\n  var s = signature.s;\\n\\n  // A set LSB signifies that the y-coordinate is odd\\n  var isYOdd = j & 1;\\n  var isSecondKey = j >> 1;\\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\\n    throw new Error('Unable to find sencond key candinate');\\n\\n  // 1.1. Let x = r + jn.\\n  if (isSecondKey)\\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\\n  else\\n    r = this.curve.pointFromX(r, isYOdd);\\n\\n  var rInv = signature.r.invm(n);\\n  var s1 = n.sub(e).mul(rInv).umod(n);\\n  var s2 = s.mul(rInv).umod(n);\\n\\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\\n  //               Q = r^-1 (sR + -eG)\\n  return this.g.mulAdd(s1, r, s2);\\n};\\n\\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\\n  signature = new Signature(signature, enc);\\n  if (signature.recoveryParam !== null)\\n    return signature.recoveryParam;\\n\\n  for (var i = 0; i < 4; i++) {\\n    var Qprime;\\n    try {\\n      Qprime = this.recoverPubKey(e, signature, i);\\n    } catch (e) {\\n      continue;\\n    }\\n\\n    if (Qprime.eq(Q))\\n      return i;\\n  }\\n  throw new Error('Unable to find valid recovery factor');\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"EC\",\"options\",\"assert\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"curves\",\"PresetCurve\",\"curve\",\"n\",\"nh\",\"ushrn\",\"g\",\"precompute\",\"bitLength\",\"hash\",\"BN\",\"HmacDRBG\",\"utils\",\"rand\",\"KeyPair\",\"Signature\",\"keyPair\",\"EC.prototype.keyPair\",\"keyFromPrivate\",\"EC.prototype.keyFromPrivate\",\"priv\",\"enc\",\"fromPrivate\",\"keyFromPublic\",\"EC.prototype.keyFromPublic\",\"pub\",\"fromPublic\",\"genKeyPair\",\"EC.prototype.genKeyPair\",\"drbg\",\"pers\",\"persEnc\",\"entropy\",\"hmacStrength\",\"entropyEnc\",\"nonce\",\"toArray\",\"bytes\",\"byteLength\",\"ns2\",\"sub\",\"generate\",\"cmp\",\"iaddn\",\"_truncateToN\",\"EC.prototype._truncateToN\",\"msg\",\"truncOnly\",\"delta\",\"sign\",\"EC.prototype.sign\",\"key\",\"bkey\",\"getPrivate\",\"ns1\",\"iter\",\"k\",\"cmpn\",\"kp\",\"mul\",\"isInfinity\",\"kpX\",\"getX\",\"r\",\"umod\",\"s\",\"invm\",\"iadd\",\"recoveryParam\",\"getY\",\"isOdd\",\"canonical\",\"verify\",\"EC.prototype.verify\",\"signature\",\"sinv\",\"u1\",\"u2\",\"_maxwellTrick\",\"p\",\"mulAdd\",\"getPublic\",\"jmulAdd\",\"eqXToP\",\"recoverPubKey\",\"EC.prototype.recoverPubKey\",\"j\",\"e\",\"isYOdd\",\"isSecondKey\",\"Error\",\"pointFromX\",\"add\",\"rInv\",\"s1\",\"s2\",\"getKeyRecoveryParam\",\"EC.prototype.getKeyRecoveryParam\",\"Q\",\"i\",\"Qprime\",\"eq\"]\n}\n"]