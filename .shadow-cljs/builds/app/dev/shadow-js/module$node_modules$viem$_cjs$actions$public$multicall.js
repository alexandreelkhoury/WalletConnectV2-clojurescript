["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/viem/_cjs/actions/public/multicall.js"],"~:js","shadow$provide.module$node_modules$viem$_cjs$actions$public$multicall=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.multicall=void 0;const abis_js_1=require(\"module$node_modules$viem$_cjs$constants$abis\"),abi_js_1=require(\"module$node_modules$viem$_cjs$errors$abi\"),base_js_1=require(\"module$node_modules$viem$_cjs$errors$base\"),contract_js_1=require(\"module$node_modules$viem$_cjs$errors$contract\"),decodeFunctionResult_js_1=require(\"module$node_modules$viem$_cjs$utils$abi$decodeFunctionResult\"),\nencodeFunctionData_js_1=require(\"module$node_modules$viem$_cjs$utils$abi$encodeFunctionData\"),chain_js_1=require(\"module$node_modules$viem$_cjs$utils$chain\"),getContractError_js_1=require(\"module$node_modules$viem$_cjs$utils$errors$getContractError\"),readContract_js_1=require(\"module$node_modules$viem$_cjs$actions$public$readContract\");exports.multicall=async function(client,args$jscomp$0){const {allowFailure=!0,batchSize:batchSize_,blockNumber,blockTag,contracts,multicallAddress:multicallAddress_}=\nargs$jscomp$0;var batchSize=batchSize_??(\"object\"===typeof client.batch?.multicall&&client.batch.multicall.batchSize||1024);let multicallAddress=multicallAddress_;if(!multicallAddress){if(!client.chain)throw Error(\"client chain not configured. multicallAddress is required.\");multicallAddress=(0,chain_js_1.getChainContractAddress)({blockNumber,chain:client.chain,contract:\"multicall3\"})}args$jscomp$0=[[]];var currentChunk=0,currentChunkSize=0;for(var i=0;i<contracts.length;i++){const {abi,address,args,\nfunctionName}=contracts[i];try{var callData=(0,encodeFunctionData_js_1.encodeFunctionData)({abi,args,functionName});currentChunkSize+=(callData.length-2)/2;0<batchSize&&currentChunkSize>batchSize&&0<args$jscomp$0[currentChunk].length&&(currentChunk++,currentChunkSize=(callData.length-2)/2,args$jscomp$0[currentChunk]=[]);args$jscomp$0[currentChunk]=[...args$jscomp$0[currentChunk],{allowFailure:!0,callData,target:address}]}catch(err){var error=(0,getContractError_js_1.getContractError)(err,{abi,address,\nargs,docsPath:\"/docs/contract/multicall\",functionName});if(!allowFailure)throw error;args$jscomp$0[currentChunk]=[...args$jscomp$0[currentChunk],{allowFailure:!0,callData:\"0x\",target:address}]}}callData=await Promise.allSettled(args$jscomp$0.map(calls=>(0,readContract_js_1.readContract)(client,{abi:abis_js_1.multicall3Abi,address:multicallAddress,args:[calls],blockNumber,blockTag,functionName:\"aggregate3\"})));batchSize=[];for(currentChunk=0;currentChunk<callData.length;currentChunk++)if(currentChunkSize=\ncallData[currentChunk],\"rejected\"===currentChunkSize.status){if(!allowFailure)throw currentChunkSize.reason;for(i=0;i<args$jscomp$0[currentChunk].length;i++)batchSize.push({status:\"failure\",error:currentChunkSize.reason,result:void 0})}else for(currentChunkSize=currentChunkSize.value,i=0;i<currentChunkSize.length;i++){const {returnData,success}=currentChunkSize[i];({callData:error}=args$jscomp$0[currentChunk][i]);const {abi,address,functionName,args}=contracts[batchSize.length];try{if(\"0x\"===error)throw new abi_js_1.AbiDecodingZeroDataError;\nif(!success)throw new contract_js_1.RawContractError({data:returnData});const result=(0,decodeFunctionResult_js_1.decodeFunctionResult)({abi,args,data:returnData,functionName});batchSize.push(allowFailure?{result,status:\"success\"}:result)}catch(err){error=(0,getContractError_js_1.getContractError)(err,{abi,address,args,docsPath:\"/docs/contract/multicall\",functionName});if(!allowFailure)throw error;batchSize.push({error,result:void 0,status:\"failure\"})}}if(batchSize.length!==contracts.length)throw new base_js_1.BaseError(\"multicall results mismatch\");\nreturn batchSize}}","~:source","shadow$provide[\"module$node_modules$viem$_cjs$actions$public$multicall\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.multicall = void 0;\nconst abis_js_1 = require(\"../../constants/abis.js\");\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst base_js_1 = require(\"../../errors/base.js\");\nconst contract_js_1 = require(\"../../errors/contract.js\");\nconst decodeFunctionResult_js_1 = require(\"../../utils/abi/decodeFunctionResult.js\");\nconst encodeFunctionData_js_1 = require(\"../../utils/abi/encodeFunctionData.js\");\nconst chain_js_1 = require(\"../../utils/chain.js\");\nconst getContractError_js_1 = require(\"../../utils/errors/getContractError.js\");\nconst readContract_js_1 = require(\"./readContract.js\");\nasync function multicall(client, args) {\n    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts, multicallAddress: multicallAddress_, } = args;\n    const batchSize = batchSize_ ??\n        ((typeof client.batch?.multicall === 'object' &&\n            client.batch.multicall.batchSize) ||\n            1024);\n    let multicallAddress = multicallAddress_;\n    if (!multicallAddress) {\n        if (!client.chain)\n            throw new Error('client chain not configured. multicallAddress is required.');\n        multicallAddress = (0, chain_js_1.getChainContractAddress)({\n            blockNumber,\n            chain: client.chain,\n            contract: 'multicall3',\n        });\n    }\n    const chunkedCalls = [[]];\n    let currentChunk = 0;\n    let currentChunkSize = 0;\n    for (let i = 0; i < contracts.length; i++) {\n        const { abi, address, args, functionName } = contracts[i];\n        try {\n            const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({\n                abi,\n                args,\n                functionName,\n            });\n            currentChunkSize += (callData.length - 2) / 2;\n            if (batchSize > 0 &&\n                currentChunkSize > batchSize &&\n                chunkedCalls[currentChunk].length > 0) {\n                currentChunk++;\n                currentChunkSize = (callData.length - 2) / 2;\n                chunkedCalls[currentChunk] = [];\n            }\n            chunkedCalls[currentChunk] = [\n                ...chunkedCalls[currentChunk],\n                {\n                    allowFailure: true,\n                    callData,\n                    target: address,\n                },\n            ];\n        }\n        catch (err) {\n            const error = (0, getContractError_js_1.getContractError)(err, {\n                abi,\n                address,\n                args,\n                docsPath: '/docs/contract/multicall',\n                functionName,\n            });\n            if (!allowFailure)\n                throw error;\n            chunkedCalls[currentChunk] = [\n                ...chunkedCalls[currentChunk],\n                {\n                    allowFailure: true,\n                    callData: '0x',\n                    target: address,\n                },\n            ];\n        }\n    }\n    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, readContract_js_1.readContract)(client, {\n        abi: abis_js_1.multicall3Abi,\n        address: multicallAddress,\n        args: [calls],\n        blockNumber,\n        blockTag,\n        functionName: 'aggregate3',\n    })));\n    const results = [];\n    for (let i = 0; i < aggregate3Results.length; i++) {\n        const result = aggregate3Results[i];\n        if (result.status === 'rejected') {\n            if (!allowFailure)\n                throw result.reason;\n            for (let j = 0; j < chunkedCalls[i].length; j++) {\n                results.push({\n                    status: 'failure',\n                    error: result.reason,\n                    result: undefined,\n                });\n            }\n            continue;\n        }\n        const aggregate3Result = result.value;\n        for (let j = 0; j < aggregate3Result.length; j++) {\n            const { returnData, success } = aggregate3Result[j];\n            const { callData } = chunkedCalls[i][j];\n            const { abi, address, functionName, args } = contracts[results.length];\n            try {\n                if (callData === '0x')\n                    throw new abi_js_1.AbiDecodingZeroDataError();\n                if (!success)\n                    throw new contract_js_1.RawContractError({ data: returnData });\n                const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({\n                    abi,\n                    args,\n                    data: returnData,\n                    functionName,\n                });\n                results.push(allowFailure ? { result, status: 'success' } : result);\n            }\n            catch (err) {\n                const error = (0, getContractError_js_1.getContractError)(err, {\n                    abi,\n                    address,\n                    args,\n                    docsPath: '/docs/contract/multicall',\n                    functionName,\n                });\n                if (!allowFailure)\n                    throw error;\n                results.push({ error, result: undefined, status: 'failure' });\n            }\n        }\n    }\n    if (results.length !== contracts.length)\n        throw new base_js_1.BaseError('multicall results mismatch');\n    return results;\n}\nexports.multicall = multicall;\n//# sourceMappingURL=multicall.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$viem$_cjs$constants$abis","~$module$node_modules$viem$_cjs$utils$abi$decodeFunctionResult","~$module$node_modules$viem$_cjs$errors$base","~$module$node_modules$viem$_cjs$errors$contract","~$module$node_modules$viem$_cjs$utils$abi$encodeFunctionData","~$module$node_modules$viem$_cjs$utils$errors$getContractError","~$shadow.js","~$module$node_modules$viem$_cjs$errors$abi","~$module$node_modules$viem$_cjs$utils$chain","~$module$node_modules$viem$_cjs$actions$public$readContract"]],"~:properties",["^5",["abi","args","__esModule","error","blockNumber","allowFailure","value","address","status","multicall","callData","contract","docsPath","target","blockTag","functionName","data","chain","result"]],"~:compiled-at",1695111490301,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$viem$_cjs$actions$public$multicall.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/viem/_cjs/actions/public/multicall.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$viem$_cjs$actions$public$multicall\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.multicall = void 0;\\nconst abis_js_1 = require(\\\"../../constants/abis.js\\\");\\nconst abi_js_1 = require(\\\"../../errors/abi.js\\\");\\nconst base_js_1 = require(\\\"../../errors/base.js\\\");\\nconst contract_js_1 = require(\\\"../../errors/contract.js\\\");\\nconst decodeFunctionResult_js_1 = require(\\\"../../utils/abi/decodeFunctionResult.js\\\");\\nconst encodeFunctionData_js_1 = require(\\\"../../utils/abi/encodeFunctionData.js\\\");\\nconst chain_js_1 = require(\\\"../../utils/chain.js\\\");\\nconst getContractError_js_1 = require(\\\"../../utils/errors/getContractError.js\\\");\\nconst readContract_js_1 = require(\\\"./readContract.js\\\");\\nasync function multicall(client, args) {\\n    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts, multicallAddress: multicallAddress_, } = args;\\n    const batchSize = batchSize_ ??\\n        ((typeof client.batch?.multicall === 'object' &&\\n            client.batch.multicall.batchSize) ||\\n            1024);\\n    let multicallAddress = multicallAddress_;\\n    if (!multicallAddress) {\\n        if (!client.chain)\\n            throw new Error('client chain not configured. multicallAddress is required.');\\n        multicallAddress = (0, chain_js_1.getChainContractAddress)({\\n            blockNumber,\\n            chain: client.chain,\\n            contract: 'multicall3',\\n        });\\n    }\\n    const chunkedCalls = [[]];\\n    let currentChunk = 0;\\n    let currentChunkSize = 0;\\n    for (let i = 0; i < contracts.length; i++) {\\n        const { abi, address, args, functionName } = contracts[i];\\n        try {\\n            const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({\\n                abi,\\n                args,\\n                functionName,\\n            });\\n            currentChunkSize += (callData.length - 2) / 2;\\n            if (batchSize > 0 &&\\n                currentChunkSize > batchSize &&\\n                chunkedCalls[currentChunk].length > 0) {\\n                currentChunk++;\\n                currentChunkSize = (callData.length - 2) / 2;\\n                chunkedCalls[currentChunk] = [];\\n            }\\n            chunkedCalls[currentChunk] = [\\n                ...chunkedCalls[currentChunk],\\n                {\\n                    allowFailure: true,\\n                    callData,\\n                    target: address,\\n                },\\n            ];\\n        }\\n        catch (err) {\\n            const error = (0, getContractError_js_1.getContractError)(err, {\\n                abi,\\n                address,\\n                args,\\n                docsPath: '/docs/contract/multicall',\\n                functionName,\\n            });\\n            if (!allowFailure)\\n                throw error;\\n            chunkedCalls[currentChunk] = [\\n                ...chunkedCalls[currentChunk],\\n                {\\n                    allowFailure: true,\\n                    callData: '0x',\\n                    target: address,\\n                },\\n            ];\\n        }\\n    }\\n    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, readContract_js_1.readContract)(client, {\\n        abi: abis_js_1.multicall3Abi,\\n        address: multicallAddress,\\n        args: [calls],\\n        blockNumber,\\n        blockTag,\\n        functionName: 'aggregate3',\\n    })));\\n    const results = [];\\n    for (let i = 0; i < aggregate3Results.length; i++) {\\n        const result = aggregate3Results[i];\\n        if (result.status === 'rejected') {\\n            if (!allowFailure)\\n                throw result.reason;\\n            for (let j = 0; j < chunkedCalls[i].length; j++) {\\n                results.push({\\n                    status: 'failure',\\n                    error: result.reason,\\n                    result: undefined,\\n                });\\n            }\\n            continue;\\n        }\\n        const aggregate3Result = result.value;\\n        for (let j = 0; j < aggregate3Result.length; j++) {\\n            const { returnData, success } = aggregate3Result[j];\\n            const { callData } = chunkedCalls[i][j];\\n            const { abi, address, functionName, args } = contracts[results.length];\\n            try {\\n                if (callData === '0x')\\n                    throw new abi_js_1.AbiDecodingZeroDataError();\\n                if (!success)\\n                    throw new contract_js_1.RawContractError({ data: returnData });\\n                const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({\\n                    abi,\\n                    args,\\n                    data: returnData,\\n                    functionName,\\n                });\\n                results.push(allowFailure ? { result, status: 'success' } : result);\\n            }\\n            catch (err) {\\n                const error = (0, getContractError_js_1.getContractError)(err, {\\n                    abi,\\n                    address,\\n                    args,\\n                    docsPath: '/docs/contract/multicall',\\n                    functionName,\\n                });\\n                if (!allowFailure)\\n                    throw error;\\n                results.push({ error, result: undefined, status: 'failure' });\\n            }\\n        }\\n    }\\n    if (results.length !== contracts.length)\\n        throw new base_js_1.BaseError('multicall results mismatch');\\n    return results;\\n}\\nexports.multicall = multicall;\\n//# sourceMappingURL=multicall.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"multicall\",\"abis_js_1\",\"abi_js_1\",\"base_js_1\",\"contract_js_1\",\"decodeFunctionResult_js_1\",\"encodeFunctionData_js_1\",\"chain_js_1\",\"getContractError_js_1\",\"readContract_js_1\",\"client\",\"args\",\"allowFailure\",\"batchSize_\",\"blockNumber\",\"blockTag\",\"contracts\",\"multicallAddress_\",\"batchSize\",\"batch\",\"multicallAddress\",\"chain\",\"Error\",\"getChainContractAddress\",\"contract\",\"chunkedCalls\",\"currentChunk\",\"currentChunkSize\",\"i\",\"length\",\"abi\",\"address\",\"functionName\",\"callData\",\"encodeFunctionData\",\"target\",\"err\",\"error\",\"getContractError\",\"docsPath\",\"aggregate3Results\",\"Promise\",\"allSettled\",\"map\",\"calls\",\"readContract\",\"multicall3Abi\",\"results\",\"result\",\"status\",\"reason\",\"j\",\"push\",\"undefined\",\"aggregate3Result\",\"returnData\",\"success\",\"AbiDecodingZeroDataError\",\"RawContractError\",\"data\",\"decodeFunctionResult\",\"BaseError\"]\n}\n"]