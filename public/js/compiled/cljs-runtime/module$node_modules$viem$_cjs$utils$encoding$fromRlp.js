shadow$provide.module$node_modules$viem$_cjs$utils$encoding$fromRlp=function(global,require,module,exports){function format(bytes,to){return Array.isArray(bytes)?bytes.map(b=>format(b,to)):"hex"===to?(0,toHex_js_1.bytesToHex)(bytes):bytes}function rlpToBytes(bytes,offset=0){if(0===bytes.length)return[new Uint8Array([]),0];var prefix=bytes[offset];if(127>=prefix)return[new Uint8Array([bytes[offset]]),1];if(183>=prefix){prefix-=128;offset+=1;if(offset+prefix>bytes.length)throw new encoding_js_1.DataLengthTooShortError({length:offset+
prefix,dataLength:bytes.length});return[bytes.slice(offset,offset+prefix),1+prefix]}if(191>=prefix){prefix-=183;offset+=1;var length=(0,fromBytes_js_1.bytesToNumber)(bytes.slice(offset,offset+prefix));if(offset+prefix+length>bytes.length)throw new encoding_js_1.DataLengthTooShortError({length:prefix+length,dataLength:bytes.length-prefix});return[bytes.slice(offset+prefix,offset+prefix+length),1+prefix+length]}length=0;var length$jscomp$0=prefix-192;247<prefix&&(length=prefix-247,length$jscomp$0=(0,fromBytes_js_1.bytesToNumber)(bytes.slice(offset+
1,offset+1+length)));prefix=offset+1+length;if(prefix>bytes.length)throw new encoding_js_1.DataLengthTooShortError({length:prefix,dataLength:bytes.length});length=1+length+length$jscomp$0;for(length$jscomp$0=[];prefix<offset+length;){const decoded=rlpToBytes(bytes,prefix);length$jscomp$0.push(decoded[0]);prefix+=decoded[1];if(prefix>offset+length)throw new encoding_js_1.OffsetOutOfBoundsError({nextOffset:prefix,offset:offset+length});}return[length$jscomp$0,length]}Object.defineProperty(exports,"__esModule",
{value:!0});exports.fromRlp=void 0;const encoding_js_1=require("module$node_modules$viem$_cjs$errors$encoding"),fromBytes_js_1=require("module$node_modules$viem$_cjs$utils$encoding$fromBytes"),toBytes_js_1=require("module$node_modules$viem$_cjs$utils$encoding$toBytes"),toHex_js_1=require("module$node_modules$viem$_cjs$utils$encoding$toHex");exports.fromRlp=function(value,to){if("string"===typeof value){if(3<value.length&&0!==value.length%2)throw new encoding_js_1.InvalidHexValueError(value);value=
(0,toBytes_js_1.hexToBytes)(value)}const [data,consumed]=rlpToBytes(value);if(consumed<value.length)throw new encoding_js_1.DataLengthTooLongError({consumed,length:value.length});return format(data,to)}}
//# sourceMappingURL=module$node_modules$viem$_cjs$utils$encoding$fromRlp.js.map
