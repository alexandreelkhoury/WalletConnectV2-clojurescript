["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js"],"~:js","shadow$provide.module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$utils=function(global,require,module,exports){function parseAbiParameter(param,options){const parameterCacheKey=(0,cache_js_1.getParameterCacheKey)(param,options?.type);if(cache_js_1.parameterCache.has(parameterCacheKey))return cache_js_1.parameterCache.get(parameterCacheKey);var isTuple=regex_js_1.isTupleRegex.test(param);const match=(0,regex_js_1.execTyped)(isTuple?abiParameterWithTupleRegex:abiParameterWithoutTupleRegex,\nparam);if(!match)throw new abiParameter_js_1.InvalidParameterError({param});if(match.name&&isSolidityKeyword(match.name))throw new abiParameter_js_1.SolidityProtectedKeywordError({param,name:match.name});const name=match.name?{name:match.name}:{},indexed=\"indexed\"===match.modifier?{indexed:!0}:{},structs=options?.structs??{};var components={};if(isTuple){isTuple=\"tuple\";components=splitParameters(match.type);const components_=[],length=components.length;for(let i=0;i<length;i++)components_.push(parseAbiParameter(components[i],\n{structs}));components={components:components_}}else if(match.type in structs)isTuple=\"tuple\",components={components:structs[match.type]};else if(dynamicIntegerRegex.test(match.type))isTuple=`${match.type}256`;else if(isTuple=match.type,\"struct\"!==options?.type&&!isSolidityType(isTuple))throw new abiItem_js_1.UnknownSolidityTypeError({type:isTuple});if(match.modifier){if(!options?.modifiers?.has?.(match.modifier))throw new abiParameter_js_1.InvalidModifierError({param,type:options?.type,modifier:match.modifier});\nif(signatures_js_1.functionModifiers.has(match.modifier)&&!isValidDataLocation(isTuple,!!match.array))throw new abiParameter_js_1.InvalidFunctionModifierError({param,type:options?.type,modifier:match.modifier});}param={type:`${isTuple}${match.array??\"\"}`,...name,...indexed,...components};cache_js_1.parameterCache.set(parameterCacheKey,param);return param}function splitParameters(params,result=[],current=\"\",depth=0){if(\"\"===params){if(\"\"===current)return result;if(0!==depth)throw new splitParameters_js_1.InvalidParenthesisError({current,\ndepth});result.push(current.trim());return result}var length=params.length;for(let i=0;i<length;)switch(length=params[i],params=params.slice(i+1),length){case \",\":return 0===depth?splitParameters(params,[...result,current.trim()]):splitParameters(params,result,`${current}${length}`,depth);case \"(\":return splitParameters(params,result,`${current}${length}`,depth+1);case \")\":return splitParameters(params,result,`${current}${length}`,depth-1);default:return splitParameters(params,result,`${current}${length}`,\ndepth)}return[]}function isSolidityType(type){return\"address\"===type||\"bool\"===type||\"function\"===type||\"string\"===type||regex_js_1.bytesRegex.test(type)||regex_js_1.integerRegex.test(type)}function isSolidityKeyword(name){return\"address\"===name||\"bool\"===name||\"function\"===name||\"string\"===name||\"tuple\"===name||regex_js_1.bytesRegex.test(name)||regex_js_1.integerRegex.test(name)||protectedKeywordsRegex.test(name)}function isValidDataLocation(type,isArray){return isArray||\"bytes\"===type||\"string\"===\ntype||\"tuple\"===type}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.isValidDataLocation=exports.isSolidityKeyword=exports.isSolidityType=exports.splitParameters=exports.parseAbiParameter=exports.parseSignature=void 0;const regex_js_1=require(\"module$node_modules$viem$node_modules$abitype$dist$cjs$regex\"),abiItem_js_1=require(\"module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$abiItem\"),abiParameter_js_1=require(\"module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$abiParameter\"),\nsignature_js_1=require(\"module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$signature\"),splitParameters_js_1=require(\"module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$splitParameters\"),cache_js_1=require(\"module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$cache\"),signatures_js_1=require(\"module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$signatures\");exports.parseSignature=function(signature,\nstructs={}){if((0,signatures_js_1.isFunctionSignature)(signature)){var match=(0,signatures_js_1.execFunctionSignature)(signature);if(!match)throw new signature_js_1.InvalidSignatureError({signature,type:\"function\"});var inputParams=splitParameters(match.parameters);signature=[];var inputLength=inputParams.length;for(var i$jscomp$0=0;i$jscomp$0<inputLength;i$jscomp$0++)signature.push(parseAbiParameter(inputParams[i$jscomp$0],{modifiers:signatures_js_1.functionModifiers,structs,type:\"function\"}));inputParams=\n[];if(match.returns){inputLength=splitParameters(match.returns);i$jscomp$0=inputLength.length;for(let i=0;i<i$jscomp$0;i++)inputParams.push(parseAbiParameter(inputLength[i],{modifiers:signatures_js_1.functionModifiers,structs,type:\"function\"}))}return{name:match.name,type:\"function\",stateMutability:match.stateMutability??\"nonpayable\",inputs:signature,outputs:inputParams}}if((0,signatures_js_1.isEventSignature)(signature)){match=(0,signatures_js_1.execEventSignature)(signature);if(!match)throw new signature_js_1.InvalidSignatureError({signature,\ntype:\"event\"});signature=splitParameters(match.parameters);inputParams=[];inputLength=signature.length;for(i$jscomp$0=0;i$jscomp$0<inputLength;i$jscomp$0++)inputParams.push(parseAbiParameter(signature[i$jscomp$0],{modifiers:signatures_js_1.eventModifiers,structs,type:\"event\"}));return{name:match.name,type:\"event\",inputs:inputParams}}if((0,signatures_js_1.isErrorSignature)(signature)){match=(0,signatures_js_1.execErrorSignature)(signature);if(!match)throw new signature_js_1.InvalidSignatureError({signature,\ntype:\"error\"});signature=splitParameters(match.parameters);inputParams=[];inputLength=signature.length;for(i$jscomp$0=0;i$jscomp$0<inputLength;i$jscomp$0++)inputParams.push(parseAbiParameter(signature[i$jscomp$0],{structs,type:\"error\"}));return{name:match.name,type:\"error\",inputs:inputParams}}if((0,signatures_js_1.isConstructorSignature)(signature)){match=(0,signatures_js_1.execConstructorSignature)(signature);if(!match)throw new signature_js_1.InvalidSignatureError({signature,type:\"constructor\"});\nsignature=splitParameters(match.parameters);inputParams=[];inputLength=signature.length;for(i$jscomp$0=0;i$jscomp$0<inputLength;i$jscomp$0++)inputParams.push(parseAbiParameter(signature[i$jscomp$0],{structs,type:\"constructor\"}));return{type:\"constructor\",stateMutability:match.stateMutability??\"nonpayable\",inputs:inputParams}}if((0,signatures_js_1.isFallbackSignature)(signature))return{type:\"fallback\"};if((0,signatures_js_1.isReceiveSignature)(signature))return{type:\"receive\",stateMutability:\"payable\"};\nthrow new signature_js_1.UnknownSignatureError({signature});};const abiParameterWithoutTupleRegex=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,abiParameterWithTupleRegex=/^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,dynamicIntegerRegex=/^u?int$/;exports.parseAbiParameter=parseAbiParameter;exports.splitParameters=\nsplitParameters;exports.isSolidityType=isSolidityType;const protectedKeywordsRegex=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;exports.isSolidityKeyword=\nisSolidityKeyword;exports.isValidDataLocation=isValidDataLocation}","~:source","shadow$provide[\"module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$utils\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidDataLocation = exports.isSolidityKeyword = exports.isSolidityType = exports.splitParameters = exports.parseAbiParameter = exports.parseSignature = void 0;\nconst regex_js_1 = require(\"../../regex.js\");\nconst abiItem_js_1 = require(\"../errors/abiItem.js\");\nconst abiParameter_js_1 = require(\"../errors/abiParameter.js\");\nconst signature_js_1 = require(\"../errors/signature.js\");\nconst splitParameters_js_1 = require(\"../errors/splitParameters.js\");\nconst cache_js_1 = require(\"./cache.js\");\nconst signatures_js_1 = require(\"./signatures.js\");\nfunction parseSignature(signature, structs = {}) {\n    if ((0, signatures_js_1.isFunctionSignature)(signature)) {\n        const match = (0, signatures_js_1.execFunctionSignature)(signature);\n        if (!match)\n            throw new signature_js_1.InvalidSignatureError({ signature, type: 'function' });\n        const inputParams = splitParameters(match.parameters);\n        const inputs = [];\n        const inputLength = inputParams.length;\n        for (let i = 0; i < inputLength; i++) {\n            inputs.push(parseAbiParameter(inputParams[i], {\n                modifiers: signatures_js_1.functionModifiers,\n                structs,\n                type: 'function',\n            }));\n        }\n        const outputs = [];\n        if (match.returns) {\n            const outputParams = splitParameters(match.returns);\n            const outputLength = outputParams.length;\n            for (let i = 0; i < outputLength; i++) {\n                outputs.push(parseAbiParameter(outputParams[i], {\n                    modifiers: signatures_js_1.functionModifiers,\n                    structs,\n                    type: 'function',\n                }));\n            }\n        }\n        return {\n            name: match.name,\n            type: 'function',\n            stateMutability: match.stateMutability ?? 'nonpayable',\n            inputs,\n            outputs,\n        };\n    }\n    if ((0, signatures_js_1.isEventSignature)(signature)) {\n        const match = (0, signatures_js_1.execEventSignature)(signature);\n        if (!match)\n            throw new signature_js_1.InvalidSignatureError({ signature, type: 'event' });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter(params[i], {\n                modifiers: signatures_js_1.eventModifiers,\n                structs,\n                type: 'event',\n            }));\n        }\n        return { name: match.name, type: 'event', inputs: abiParameters };\n    }\n    if ((0, signatures_js_1.isErrorSignature)(signature)) {\n        const match = (0, signatures_js_1.execErrorSignature)(signature);\n        if (!match)\n            throw new signature_js_1.InvalidSignatureError({ signature, type: 'error' });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));\n        }\n        return { name: match.name, type: 'error', inputs: abiParameters };\n    }\n    if ((0, signatures_js_1.isConstructorSignature)(signature)) {\n        const match = (0, signatures_js_1.execConstructorSignature)(signature);\n        if (!match)\n            throw new signature_js_1.InvalidSignatureError({ signature, type: 'constructor' });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));\n        }\n        return {\n            type: 'constructor',\n            stateMutability: match.stateMutability ?? 'nonpayable',\n            inputs: abiParameters,\n        };\n    }\n    if ((0, signatures_js_1.isFallbackSignature)(signature))\n        return { type: 'fallback' };\n    if ((0, signatures_js_1.isReceiveSignature)(signature))\n        return {\n            type: 'receive',\n            stateMutability: 'payable',\n        };\n    throw new signature_js_1.UnknownSignatureError({ signature });\n}\nexports.parseSignature = parseSignature;\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n    const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);\n    if (cache_js_1.parameterCache.has(parameterCacheKey))\n        return cache_js_1.parameterCache.get(parameterCacheKey);\n    const isTuple = regex_js_1.isTupleRegex.test(param);\n    const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n    if (!match)\n        throw new abiParameter_js_1.InvalidParameterError({ param });\n    if (match.name && isSolidityKeyword(match.name))\n        throw new abiParameter_js_1.SolidityProtectedKeywordError({ param, name: match.name });\n    const name = match.name ? { name: match.name } : {};\n    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};\n    const structs = options?.structs ?? {};\n    let type;\n    let components = {};\n    if (isTuple) {\n        type = 'tuple';\n        const params = splitParameters(match.type);\n        const components_ = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            components_.push(parseAbiParameter(params[i], { structs }));\n        }\n        components = { components: components_ };\n    }\n    else if (match.type in structs) {\n        type = 'tuple';\n        components = { components: structs[match.type] };\n    }\n    else if (dynamicIntegerRegex.test(match.type)) {\n        type = `${match.type}256`;\n    }\n    else {\n        type = match.type;\n        if (!(options?.type === 'struct') && !isSolidityType(type))\n            throw new abiItem_js_1.UnknownSolidityTypeError({ type });\n    }\n    if (match.modifier) {\n        if (!options?.modifiers?.has?.(match.modifier))\n            throw new abiParameter_js_1.InvalidModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n        if (signatures_js_1.functionModifiers.has(match.modifier) &&\n            !isValidDataLocation(type, !!match.array))\n            throw new abiParameter_js_1.InvalidFunctionModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n    }\n    const abiParameter = {\n        type: `${type}${match.array ?? ''}`,\n        ...name,\n        ...indexed,\n        ...components,\n    };\n    cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);\n    return abiParameter;\n}\nexports.parseAbiParameter = parseAbiParameter;\nfunction splitParameters(params, result = [], current = '', depth = 0) {\n    if (params === '') {\n        if (current === '')\n            return result;\n        if (depth !== 0)\n            throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });\n        result.push(current.trim());\n        return result;\n    }\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n        const char = params[i];\n        const tail = params.slice(i + 1);\n        switch (char) {\n            case ',':\n                return depth === 0\n                    ? splitParameters(tail, [...result, current.trim()])\n                    : splitParameters(tail, result, `${current}${char}`, depth);\n            case '(':\n                return splitParameters(tail, result, `${current}${char}`, depth + 1);\n            case ')':\n                return splitParameters(tail, result, `${current}${char}`, depth - 1);\n            default:\n                return splitParameters(tail, result, `${current}${char}`, depth);\n        }\n    }\n    return [];\n}\nexports.splitParameters = splitParameters;\nfunction isSolidityType(type) {\n    return (type === 'address' ||\n        type === 'bool' ||\n        type === 'function' ||\n        type === 'string' ||\n        regex_js_1.bytesRegex.test(type) ||\n        regex_js_1.integerRegex.test(type));\n}\nexports.isSolidityType = isSolidityType;\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name) {\n    return (name === 'address' ||\n        name === 'bool' ||\n        name === 'function' ||\n        name === 'string' ||\n        name === 'tuple' ||\n        regex_js_1.bytesRegex.test(name) ||\n        regex_js_1.integerRegex.test(name) ||\n        protectedKeywordsRegex.test(name));\n}\nexports.isSolidityKeyword = isSolidityKeyword;\nfunction isValidDataLocation(type, isArray) {\n    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}\nexports.isValidDataLocation = isValidDataLocation;\n//# sourceMappingURL=utils.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$signature","~$shadow.js","~$module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$splitParameters","~$module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$cache","~$module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$abiItem","~$module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$abiParameter","~$module$node_modules$viem$node_modules$abitype$dist$cjs$regex","~$module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$signatures"]],"~:properties",["^5",["indexed","parseSignature","splitParameters","__esModule","isSolidityKeyword","isValidDataLocation","name","stateMutability","value","outputs","param","modifier","signature","current","modifiers","isSolidityType","type","depth","structs","inputs","components","parseAbiParameter"]],"~:compiled-at",1695111490213,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$utils.js\",\n\"lineCount\":16,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$utils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.isValidDataLocation = exports.isSolidityKeyword = exports.isSolidityType = exports.splitParameters = exports.parseAbiParameter = exports.parseSignature = void 0;\\nconst regex_js_1 = require(\\\"../../regex.js\\\");\\nconst abiItem_js_1 = require(\\\"../errors/abiItem.js\\\");\\nconst abiParameter_js_1 = require(\\\"../errors/abiParameter.js\\\");\\nconst signature_js_1 = require(\\\"../errors/signature.js\\\");\\nconst splitParameters_js_1 = require(\\\"../errors/splitParameters.js\\\");\\nconst cache_js_1 = require(\\\"./cache.js\\\");\\nconst signatures_js_1 = require(\\\"./signatures.js\\\");\\nfunction parseSignature(signature, structs = {}) {\\n    if ((0, signatures_js_1.isFunctionSignature)(signature)) {\\n        const match = (0, signatures_js_1.execFunctionSignature)(signature);\\n        if (!match)\\n            throw new signature_js_1.InvalidSignatureError({ signature, type: 'function' });\\n        const inputParams = splitParameters(match.parameters);\\n        const inputs = [];\\n        const inputLength = inputParams.length;\\n        for (let i = 0; i < inputLength; i++) {\\n            inputs.push(parseAbiParameter(inputParams[i], {\\n                modifiers: signatures_js_1.functionModifiers,\\n                structs,\\n                type: 'function',\\n            }));\\n        }\\n        const outputs = [];\\n        if (match.returns) {\\n            const outputParams = splitParameters(match.returns);\\n            const outputLength = outputParams.length;\\n            for (let i = 0; i < outputLength; i++) {\\n                outputs.push(parseAbiParameter(outputParams[i], {\\n                    modifiers: signatures_js_1.functionModifiers,\\n                    structs,\\n                    type: 'function',\\n                }));\\n            }\\n        }\\n        return {\\n            name: match.name,\\n            type: 'function',\\n            stateMutability: match.stateMutability ?? 'nonpayable',\\n            inputs,\\n            outputs,\\n        };\\n    }\\n    if ((0, signatures_js_1.isEventSignature)(signature)) {\\n        const match = (0, signatures_js_1.execEventSignature)(signature);\\n        if (!match)\\n            throw new signature_js_1.InvalidSignatureError({ signature, type: 'event' });\\n        const params = splitParameters(match.parameters);\\n        const abiParameters = [];\\n        const length = params.length;\\n        for (let i = 0; i < length; i++) {\\n            abiParameters.push(parseAbiParameter(params[i], {\\n                modifiers: signatures_js_1.eventModifiers,\\n                structs,\\n                type: 'event',\\n            }));\\n        }\\n        return { name: match.name, type: 'event', inputs: abiParameters };\\n    }\\n    if ((0, signatures_js_1.isErrorSignature)(signature)) {\\n        const match = (0, signatures_js_1.execErrorSignature)(signature);\\n        if (!match)\\n            throw new signature_js_1.InvalidSignatureError({ signature, type: 'error' });\\n        const params = splitParameters(match.parameters);\\n        const abiParameters = [];\\n        const length = params.length;\\n        for (let i = 0; i < length; i++) {\\n            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));\\n        }\\n        return { name: match.name, type: 'error', inputs: abiParameters };\\n    }\\n    if ((0, signatures_js_1.isConstructorSignature)(signature)) {\\n        const match = (0, signatures_js_1.execConstructorSignature)(signature);\\n        if (!match)\\n            throw new signature_js_1.InvalidSignatureError({ signature, type: 'constructor' });\\n        const params = splitParameters(match.parameters);\\n        const abiParameters = [];\\n        const length = params.length;\\n        for (let i = 0; i < length; i++) {\\n            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));\\n        }\\n        return {\\n            type: 'constructor',\\n            stateMutability: match.stateMutability ?? 'nonpayable',\\n            inputs: abiParameters,\\n        };\\n    }\\n    if ((0, signatures_js_1.isFallbackSignature)(signature))\\n        return { type: 'fallback' };\\n    if ((0, signatures_js_1.isReceiveSignature)(signature))\\n        return {\\n            type: 'receive',\\n            stateMutability: 'payable',\\n        };\\n    throw new signature_js_1.UnknownSignatureError({ signature });\\n}\\nexports.parseSignature = parseSignature;\\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\\\[\\\\d*?\\\\])+?)?(?:\\\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\\nconst abiParameterWithTupleRegex = /^\\\\((?<type>.+?)\\\\)(?<array>(?:\\\\[\\\\d*?\\\\])+?)?(?:\\\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\\nconst dynamicIntegerRegex = /^u?int$/;\\nfunction parseAbiParameter(param, options) {\\n    const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);\\n    if (cache_js_1.parameterCache.has(parameterCacheKey))\\n        return cache_js_1.parameterCache.get(parameterCacheKey);\\n    const isTuple = regex_js_1.isTupleRegex.test(param);\\n    const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\\n    if (!match)\\n        throw new abiParameter_js_1.InvalidParameterError({ param });\\n    if (match.name && isSolidityKeyword(match.name))\\n        throw new abiParameter_js_1.SolidityProtectedKeywordError({ param, name: match.name });\\n    const name = match.name ? { name: match.name } : {};\\n    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};\\n    const structs = options?.structs ?? {};\\n    let type;\\n    let components = {};\\n    if (isTuple) {\\n        type = 'tuple';\\n        const params = splitParameters(match.type);\\n        const components_ = [];\\n        const length = params.length;\\n        for (let i = 0; i < length; i++) {\\n            components_.push(parseAbiParameter(params[i], { structs }));\\n        }\\n        components = { components: components_ };\\n    }\\n    else if (match.type in structs) {\\n        type = 'tuple';\\n        components = { components: structs[match.type] };\\n    }\\n    else if (dynamicIntegerRegex.test(match.type)) {\\n        type = `${match.type}256`;\\n    }\\n    else {\\n        type = match.type;\\n        if (!(options?.type === 'struct') && !isSolidityType(type))\\n            throw new abiItem_js_1.UnknownSolidityTypeError({ type });\\n    }\\n    if (match.modifier) {\\n        if (!options?.modifiers?.has?.(match.modifier))\\n            throw new abiParameter_js_1.InvalidModifierError({\\n                param,\\n                type: options?.type,\\n                modifier: match.modifier,\\n            });\\n        if (signatures_js_1.functionModifiers.has(match.modifier) &&\\n            !isValidDataLocation(type, !!match.array))\\n            throw new abiParameter_js_1.InvalidFunctionModifierError({\\n                param,\\n                type: options?.type,\\n                modifier: match.modifier,\\n            });\\n    }\\n    const abiParameter = {\\n        type: `${type}${match.array ?? ''}`,\\n        ...name,\\n        ...indexed,\\n        ...components,\\n    };\\n    cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);\\n    return abiParameter;\\n}\\nexports.parseAbiParameter = parseAbiParameter;\\nfunction splitParameters(params, result = [], current = '', depth = 0) {\\n    if (params === '') {\\n        if (current === '')\\n            return result;\\n        if (depth !== 0)\\n            throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });\\n        result.push(current.trim());\\n        return result;\\n    }\\n    const length = params.length;\\n    for (let i = 0; i < length; i++) {\\n        const char = params[i];\\n        const tail = params.slice(i + 1);\\n        switch (char) {\\n            case ',':\\n                return depth === 0\\n                    ? splitParameters(tail, [...result, current.trim()])\\n                    : splitParameters(tail, result, `${current}${char}`, depth);\\n            case '(':\\n                return splitParameters(tail, result, `${current}${char}`, depth + 1);\\n            case ')':\\n                return splitParameters(tail, result, `${current}${char}`, depth - 1);\\n            default:\\n                return splitParameters(tail, result, `${current}${char}`, depth);\\n        }\\n    }\\n    return [];\\n}\\nexports.splitParameters = splitParameters;\\nfunction isSolidityType(type) {\\n    return (type === 'address' ||\\n        type === 'bool' ||\\n        type === 'function' ||\\n        type === 'string' ||\\n        regex_js_1.bytesRegex.test(type) ||\\n        regex_js_1.integerRegex.test(type));\\n}\\nexports.isSolidityType = isSolidityType;\\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\\nfunction isSolidityKeyword(name) {\\n    return (name === 'address' ||\\n        name === 'bool' ||\\n        name === 'function' ||\\n        name === 'string' ||\\n        name === 'tuple' ||\\n        regex_js_1.bytesRegex.test(name) ||\\n        regex_js_1.integerRegex.test(name) ||\\n        protectedKeywordsRegex.test(name));\\n}\\nexports.isSolidityKeyword = isSolidityKeyword;\\nfunction isValidDataLocation(type, isArray) {\\n    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\\n}\\nexports.isValidDataLocation = isValidDataLocation;\\n//# sourceMappingURL=utils.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"parseAbiParameter\",\"param\",\"options\",\"parameterCacheKey\",\"cache_js_1\",\"getParameterCacheKey\",\"type\",\"parameterCache\",\"has\",\"get\",\"isTuple\",\"regex_js_1\",\"isTupleRegex\",\"test\",\"match\",\"execTyped\",\"abiParameterWithTupleRegex\",\"abiParameterWithoutTupleRegex\",\"abiParameter_js_1\",\"InvalidParameterError\",\"name\",\"isSolidityKeyword\",\"SolidityProtectedKeywordError\",\"indexed\",\"modifier\",\"structs\",\"components\",\"params\",\"splitParameters\",\"components_\",\"length\",\"i\",\"push\",\"dynamicIntegerRegex\",\"isSolidityType\",\"abiItem_js_1\",\"UnknownSolidityTypeError\",\"modifiers\",\"InvalidModifierError\",\"signatures_js_1\",\"functionModifiers\",\"isValidDataLocation\",\"array\",\"InvalidFunctionModifierError\",\"abiParameter\",\"set\",\"result\",\"current\",\"depth\",\"splitParameters_js_1\",\"InvalidParenthesisError\",\"trim\",\"char\",\"tail\",\"slice\",\"bytesRegex\",\"integerRegex\",\"protectedKeywordsRegex\",\"isArray\",\"Object\",\"defineProperty\",\"value\",\"parseSignature\",\"signature_js_1\",\"signature\",\"isFunctionSignature\",\"execFunctionSignature\",\"InvalidSignatureError\",\"inputParams\",\"parameters\",\"inputs\",\"inputLength\",\"outputs\",\"returns\",\"outputParams\",\"outputLength\",\"stateMutability\",\"isEventSignature\",\"execEventSignature\",\"abiParameters\",\"eventModifiers\",\"isErrorSignature\",\"execErrorSignature\",\"isConstructorSignature\",\"execConstructorSignature\",\"isFallbackSignature\",\"isReceiveSignature\",\"UnknownSignatureError\"]\n}\n"]