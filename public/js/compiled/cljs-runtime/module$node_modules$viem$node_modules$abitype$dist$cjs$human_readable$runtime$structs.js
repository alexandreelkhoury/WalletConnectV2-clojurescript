shadow$provide.module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$structs=function(global,require,module,exports){function resolveStructs(abiParameters,structs,ancestors=new Set){const components=[],length=abiParameters.length;for(let i=0;i<length;i++){const abiParameter=abiParameters[i];if(regex_js_1.isTupleRegex.test(abiParameter.type))components.push(abiParameter);else{const match=(0,regex_js_1.execTyped)(typeWithoutTupleRegex,abiParameter.type);if(!match?.type)throw new abiParameter_js_1.InvalidAbiTypeParameterError({abiParameter});
const {array,type}=match;if(type in structs){if(ancestors.has(type))throw new struct_js_1.CircularReferenceError({type});components.push({...abiParameter,type:`tuple${array??""}`,components:resolveStructs(structs[type]??[],structs,new Set([...ancestors,type]))})}else if((0,utils_js_1.isSolidityType)(type))components.push(abiParameter);else throw new abiItem_js_1.UnknownTypeError({type});}}return components}Object.defineProperty(exports,"__esModule",{value:!0});exports.parseStructs=void 0;const regex_js_1=
require("module$node_modules$viem$node_modules$abitype$dist$cjs$regex"),abiItem_js_1=require("module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$abiItem"),abiParameter_js_1=require("module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$abiParameter"),signature_js_1=require("module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$signature"),struct_js_1=require("module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$errors$struct"),
signatures_js_1=require("module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$signatures"),utils_js_1=require("module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$utils");exports.parseStructs=function(signatures){const shallowStructs={};var signaturesLength=signatures.length;for(var i=0;i<signaturesLength;i++){var signature=signatures[i];if(!(0,signatures_js_1.isStructSignature)(signature))continue;const match=(0,signatures_js_1.execStructSignature)(signature);
if(!match)throw new signature_js_1.InvalidSignatureError({signature,type:"struct"});const properties=match.properties.split(";"),components=[],propertiesLength=properties.length;for(let k=0;k<propertiesLength;k++){var trimmed=properties[k].trim();trimmed&&(trimmed=(0,utils_js_1.parseAbiParameter)(trimmed,{type:"struct"}),components.push(trimmed))}if(!components.length)throw new signature_js_1.InvalidStructSignatureError({signature});shallowStructs[match.name]=components}signatures={};signaturesLength=
Object.entries(shallowStructs);i=signaturesLength.length;for(signature=0;signature<i;signature++){const [name,parameters]=signaturesLength[signature];signatures[name]=resolveStructs(parameters,shallowStructs)}return signatures};const typeWithoutTupleRegex=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/}
//# sourceMappingURL=module$node_modules$viem$node_modules$abitype$dist$cjs$human_readable$runtime$structs.js.map
