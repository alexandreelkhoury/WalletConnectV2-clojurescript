["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/pako/lib/zlib/trees.js"],"~:js","shadow$provide[319]=function(S,A,V,q){function F(v){for(var R=v.length;0<=--R;)v[R]=0}function G(v,R,O,L,Q){this.static_tree=v;this.extra_bits=R;this.extra_base=O;this.elems=L;this.max_length=Q;this.has_stree=v&&v.length}function r(v,R){this.dyn_tree=v;this.max_code=0;this.stat_desc=R}function y(v,R){v.pending_buf[v.pending++]=R&255;v.pending_buf[v.pending++]=R>>>8&255}function e(v,R,O){v.bi_valid>16-O?(v.bi_buf|=R<<v.bi_valid&65535,y(v,v.bi_buf),v.bi_buf=R>>16-v.bi_valid,v.bi_valid+=O-16):(v.bi_buf|=\nR<<v.bi_valid&65535,v.bi_valid+=O)}function u(v,R,O){e(v,O[2*R],O[2*R+1])}function p(v,R){var O=0;do O|=v&1,v>>>=1,O<<=1;while(0<--R);return O>>>1}function n(v,R,O){var L=Array(16),Q=0,W;for(W=1;15>=W;W++)L[W]=Q=Q+O[W-1]<<1;for(O=0;O<=R;O++)Q=v[2*O+1],0!==Q&&(v[2*O]=p(L[Q]++,Q))}function l(v){var R;for(R=0;286>R;R++)v.dyn_ltree[2*R]=0;for(R=0;30>R;R++)v.dyn_dtree[2*R]=0;for(R=0;19>R;R++)v.bl_tree[2*R]=0;v.dyn_ltree[512]=1;v.opt_len=v.static_len=0;v.last_lit=v.matches=0}function h(v){8<v.bi_valid?\ny(v,v.bi_buf):0<v.bi_valid&&(v.pending_buf[v.pending++]=v.bi_buf);v.bi_buf=0;v.bi_valid=0}function k(v,R,O,L){var Q=2*R,W=2*O;return v[Q]<v[W]||v[Q]===v[W]&&L[R]<=L[O]}function t(v,R,O){for(var L=v.heap[O],Q=O<<1;Q<=v.heap_len;){Q<v.heap_len&&k(R,v.heap[Q+1],v.heap[Q],v.depth)&&Q++;if(k(R,L,v.heap[Q],v.depth))break;v.heap[O]=v.heap[Q];O=Q;Q<<=1}v.heap[O]=L}function B(v,R,O){var L=0;if(0!==v.last_lit){do{var Q=v.pending_buf[v.d_buf+2*L]<<8|v.pending_buf[v.d_buf+2*L+1];var W=v.pending_buf[v.l_buf+L];\nL++;if(0===Q)u(v,W,R);else{var Z=d[W];u(v,Z+256+1,R);var da=P[Z];0!==da&&(W-=f[Z],e(v,W,da));Q--;Z=256>Q?c[Q]:c[256+(Q>>>7)];u(v,Z,O);da=J[Z];0!==da&&(Q-=g[Z],e(v,Q,da))}}while(L<v.last_lit)}u(v,256,R)}function E(v,R){var O=R.dyn_tree,L=R.stat_desc.static_tree,Q=R.stat_desc.has_stree,W=R.stat_desc.elems,Z,da=-1;v.heap_len=0;v.heap_max=573;for(Z=0;Z<W;Z++)0!==O[2*Z]?(v.heap[++v.heap_len]=da=Z,v.depth[Z]=0):O[2*Z+1]=0;for(;2>v.heap_len;){var X=v.heap[++v.heap_len]=2>da?++da:0;O[2*X]=1;v.depth[X]=0;\nv.opt_len--;Q&&(v.static_len-=L[2*X+1])}R.max_code=da;for(Z=v.heap_len>>1;1<=Z;Z--)t(v,O,Z);X=W;do Z=v.heap[1],v.heap[1]=v.heap[v.heap_len--],t(v,O,1),L=v.heap[1],v.heap[--v.heap_max]=Z,v.heap[--v.heap_max]=L,O[2*X]=O[2*Z]+O[2*L],v.depth[X]=(v.depth[Z]>=v.depth[L]?v.depth[Z]:v.depth[L])+1,O[2*Z+1]=O[2*L+1]=X,v.heap[1]=X++,t(v,O,1);while(2<=v.heap_len);v.heap[--v.heap_max]=v.heap[1];Z=R.dyn_tree;X=R.max_code;L=R.stat_desc.static_tree;Q=R.stat_desc.has_stree;W=R.stat_desc.extra_bits;var Y=R.stat_desc.extra_base,\naa=R.stat_desc.max_length,ca,ea=0;for(ca=0;15>=ca;ca++)v.bl_count[ca]=0;Z[2*v.heap[v.heap_max]+1]=0;for(R=v.heap_max+1;573>R;R++){var ja=v.heap[R];ca=Z[2*Z[2*ja+1]+1]+1;ca>aa&&(ca=aa,ea++);Z[2*ja+1]=ca;if(!(ja>X)){v.bl_count[ca]++;var ka=0;ja>=Y&&(ka=W[ja-Y]);var la=Z[2*ja];v.opt_len+=la*(ca+ka);Q&&(v.static_len+=la*(L[2*ja+1]+ka))}}if(0!==ea){do{for(ca=aa-1;0===v.bl_count[ca];)ca--;v.bl_count[ca]--;v.bl_count[ca+1]+=2;v.bl_count[aa]--;ea-=2}while(0<ea);for(ca=aa;0!==ca;ca--)for(ja=v.bl_count[ca];0!==\nja;)L=v.heap[--R],L>X||(Z[2*L+1]!==ca&&(v.opt_len+=(ca-Z[2*L+1])*Z[2*L],Z[2*L+1]=ca),ja--)}n(O,da,v.bl_count)}function H(v,R,O){var L,Q=-1,W=R[1],Z=0,da=7,X=4;0===W&&(da=138,X=3);R[2*(O+1)+1]=65535;for(L=0;L<=O;L++){var Y=W;W=R[2*(L+1)+1];++Z<da&&Y===W||(Z<X?v.bl_tree[2*Y]+=Z:0!==Y?(Y!==Q&&v.bl_tree[2*Y]++,v.bl_tree[32]++):10>=Z?v.bl_tree[34]++:v.bl_tree[36]++,Z=0,Q=Y,0===W?(da=138,X=3):Y===W?(da=6,X=3):(da=7,X=4))}}function D(v,R,O){var L,Q=-1,W=R[1],Z=0,da=7,X=4;0===W&&(da=138,X=3);for(L=0;L<=O;L++){var Y=\nW;W=R[2*(L+1)+1];if(!(++Z<da&&Y===W)){if(Z<X){do u(v,Y,v.bl_tree);while(0!==--Z)}else 0!==Y?(Y!==Q&&(u(v,Y,v.bl_tree),Z--),u(v,16,v.bl_tree),e(v,Z-3,2)):10>=Z?(u(v,17,v.bl_tree),e(v,Z-3,3)):(u(v,18,v.bl_tree),e(v,Z-11,7));Z=0;Q=Y;0===W?(da=138,X=3):Y===W?(da=6,X=3):(da=7,X=4)}}}function C(v){var R=4093624447,O;for(O=0;31>=O;O++,R>>>=1)if(R&1&&0!==v.dyn_ltree[2*O])return 0;if(0!==v.dyn_ltree[18]||0!==v.dyn_ltree[20]||0!==v.dyn_ltree[26])return 1;for(O=32;256>O;O++)if(0!==v.dyn_ltree[2*O])return 1;\nreturn 0}function I(v,R,O,L){e(v,L?1:0,3);h(v);y(v,O);y(v,~O);M.arraySet(v.pending_buf,v.window,R,O,v.pending);v.pending+=O}var M=A(318),P=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],J=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],T=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],N=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],a=Array(576);F(a);var b=Array(60);F(b);var c=Array(512);F(c);var d=Array(256);F(d);var f=Array(29);F(f);var g=Array(30);F(g);var m,w,x,z=\n!1;q._tr_init=function(v){if(!z){var R,O,L,Q=Array(16);for(L=O=0;28>L;L++)for(f[L]=O,R=0;R<1<<P[L];R++)d[O++]=L;d[O-1]=L;for(L=O=0;16>L;L++)for(g[L]=O,R=0;R<1<<J[L];R++)c[O++]=L;for(O>>=7;30>L;L++)for(g[L]=O<<7,R=0;R<1<<J[L]-7;R++)c[256+O++]=L;for(R=0;15>=R;R++)Q[R]=0;for(R=0;143>=R;)a[2*R+1]=8,R++,Q[8]++;for(;255>=R;)a[2*R+1]=9,R++,Q[9]++;for(;279>=R;)a[2*R+1]=7,R++,Q[7]++;for(;287>=R;)a[2*R+1]=8,R++,Q[8]++;n(a,287,Q);for(R=0;30>R;R++)b[2*R+1]=5,b[2*R]=p(R,5);m=new G(a,P,257,286,15);w=new G(b,J,\n0,30,15);x=new G([],T,0,19,7);z=!0}v.l_desc=new r(v.dyn_ltree,m);v.d_desc=new r(v.dyn_dtree,w);v.bl_desc=new r(v.bl_tree,x);v.bi_buf=0;v.bi_valid=0;l(v)};q._tr_stored_block=I;q._tr_flush_block=function(v,R,O,L){var Q=0;if(0<v.level){2===v.strm.data_type&&(v.strm.data_type=C(v));E(v,v.l_desc);E(v,v.d_desc);H(v,v.dyn_ltree,v.l_desc.max_code);H(v,v.dyn_dtree,v.d_desc.max_code);E(v,v.bl_desc);for(Q=18;3<=Q&&0===v.bl_tree[2*N[Q]+1];Q--);v.opt_len+=3*(Q+1)+14;var W=v.opt_len+3+7>>>3;var Z=v.static_len+\n3+7>>>3;Z<=W&&(W=Z)}else W=Z=O+5;if(O+4<=W&&-1!==R)I(v,R,O,L);else if(4===v.strategy||Z===W)e(v,2+(L?1:0),3),B(v,a,b);else{e(v,4+(L?1:0),3);R=v.l_desc.max_code+1;O=v.d_desc.max_code+1;Q+=1;e(v,R-257,5);e(v,O-1,5);e(v,Q-4,4);for(W=0;W<Q;W++)e(v,v.bl_tree[2*N[W]+1],3);D(v,v.dyn_ltree,R-1);D(v,v.dyn_dtree,O-1);B(v,v.dyn_ltree,v.dyn_dtree)}l(v);L&&h(v)};q._tr_tally=function(v,R,O){v.pending_buf[v.d_buf+2*v.last_lit]=R>>>8&255;v.pending_buf[v.d_buf+2*v.last_lit+1]=R&255;v.pending_buf[v.l_buf+v.last_lit]=\nO&255;v.last_lit++;0===R?v.dyn_ltree[2*O]++:(v.matches++,R--,v.dyn_ltree[2*(d[O]+256+1)]++,v.dyn_dtree[2*(256>R?c[R]:c[256+(R>>>7)])]++);return v.last_lit===v.lit_bufsize-1};q._tr_align=function(v){e(v,2,3);u(v,256,a);16===v.bi_valid?(y(v,v.bi_buf),v.bi_buf=0,v.bi_valid=0):8<=v.bi_valid&&(v.pending_buf[v.pending++]=v.bi_buf&255,v.bi_buf>>=8,v.bi_valid-=8)}}","~:source","shadow$provide[319] = function(global,require,module,exports) {\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$pako$lib$utils$common"]],"~:properties",["^5",["static_tree","heap_len","data_type","opt_len","d_desc","extra_base","max_code","bl_desc","extra_bits","elems","bi_buf","has_stree","_tr_flush_block","_tr_stored_block","max_length","_tr_init","matches","stat_desc","static_len","l_desc","heap_max","last_lit","pending","_tr_align","_tr_tally","dyn_tree","bi_valid"]],"~:compiled-at",1695041440899,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$pako$lib$zlib$trees.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/pako/lib/zlib/trees.js\"],\n\"sourcesContent\":[\"shadow$provide[319] = function(global,require,module,exports) {\\n'use strict';\\n\\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\\n//\\n// This software is provided 'as-is', without any express or implied\\n// warranty. In no event will the authors be held liable for any damages\\n// arising from the use of this software.\\n//\\n// Permission is granted to anyone to use this software for any purpose,\\n// including commercial applications, and to alter it and redistribute it\\n// freely, subject to the following restrictions:\\n//\\n// 1. The origin of this software must not be misrepresented; you must not\\n//   claim that you wrote the original software. If you use this software\\n//   in a product, an acknowledgment in the product documentation would be\\n//   appreciated but is not required.\\n// 2. Altered source versions must be plainly marked as such, and must not be\\n//   misrepresented as being the original software.\\n// 3. This notice may not be removed or altered from any source distribution.\\n\\n/* eslint-disable space-unary-ops */\\n\\nvar utils = require('../utils/common');\\n\\n/* Public constants ==========================================================*/\\n/* ===========================================================================*/\\n\\n\\n//var Z_FILTERED          = 1;\\n//var Z_HUFFMAN_ONLY      = 2;\\n//var Z_RLE               = 3;\\nvar Z_FIXED               = 4;\\n//var Z_DEFAULT_STRATEGY  = 0;\\n\\n/* Possible values of the data_type field (though see inflate()) */\\nvar Z_BINARY              = 0;\\nvar Z_TEXT                = 1;\\n//var Z_ASCII             = 1; // = Z_TEXT\\nvar Z_UNKNOWN             = 2;\\n\\n/*============================================================================*/\\n\\n\\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\\n\\n// From zutil.h\\n\\nvar STORED_BLOCK = 0;\\nvar STATIC_TREES = 1;\\nvar DYN_TREES    = 2;\\n/* The three kinds of block type */\\n\\nvar MIN_MATCH    = 3;\\nvar MAX_MATCH    = 258;\\n/* The minimum and maximum match lengths */\\n\\n// From deflate.h\\n/* ===========================================================================\\n * Internal compression state.\\n */\\n\\nvar LENGTH_CODES  = 29;\\n/* number of length codes, not counting the special END_BLOCK code */\\n\\nvar LITERALS      = 256;\\n/* number of literal bytes 0..255 */\\n\\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\\n/* number of Literal or Length codes, including the END_BLOCK code */\\n\\nvar D_CODES       = 30;\\n/* number of distance codes */\\n\\nvar BL_CODES      = 19;\\n/* number of codes used to transfer the bit lengths */\\n\\nvar HEAP_SIZE     = 2 * L_CODES + 1;\\n/* maximum heap size */\\n\\nvar MAX_BITS      = 15;\\n/* All codes must not exceed MAX_BITS bits */\\n\\nvar Buf_size      = 16;\\n/* size of bit buffer in bi_buf */\\n\\n\\n/* ===========================================================================\\n * Constants\\n */\\n\\nvar MAX_BL_BITS = 7;\\n/* Bit length codes must not exceed MAX_BL_BITS bits */\\n\\nvar END_BLOCK   = 256;\\n/* end of block literal code */\\n\\nvar REP_3_6     = 16;\\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\\n\\nvar REPZ_3_10   = 17;\\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\\n\\nvar REPZ_11_138 = 18;\\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\\n\\n/* eslint-disable comma-spacing,array-bracket-spacing */\\nvar extra_lbits =   /* extra bits for each length code */\\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\\n\\nvar extra_dbits =   /* extra bits for each distance code */\\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\\n\\nvar extra_blbits =  /* extra bits for each bit length code */\\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\\n\\nvar bl_order =\\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\\n/* eslint-enable comma-spacing,array-bracket-spacing */\\n\\n/* The lengths of the bit length codes are sent in order of decreasing\\n * probability, to avoid transmitting the lengths for unused bit length codes.\\n */\\n\\n/* ===========================================================================\\n * Local data. These are initialized only once.\\n */\\n\\n// We pre-fill arrays with 0 to avoid uninitialized gaps\\n\\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\\n\\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\\nvar static_ltree  = new Array((L_CODES + 2) * 2);\\nzero(static_ltree);\\n/* The static literal tree. Since the bit lengths are imposed, there is no\\n * need for the L_CODES extra codes used during heap construction. However\\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\\n * below).\\n */\\n\\nvar static_dtree  = new Array(D_CODES * 2);\\nzero(static_dtree);\\n/* The static distance tree. (Actually a trivial tree since all codes use\\n * 5 bits.)\\n */\\n\\nvar _dist_code    = new Array(DIST_CODE_LEN);\\nzero(_dist_code);\\n/* Distance codes. The first 256 values correspond to the distances\\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\\n * the 15 bit distances.\\n */\\n\\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\\nzero(_length_code);\\n/* length code for each normalized match length (0 == MIN_MATCH) */\\n\\nvar base_length   = new Array(LENGTH_CODES);\\nzero(base_length);\\n/* First normalized length for each code (0 = MIN_MATCH) */\\n\\nvar base_dist     = new Array(D_CODES);\\nzero(base_dist);\\n/* First normalized distance for each code (0 = distance of 1) */\\n\\n\\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\\n\\n  this.static_tree  = static_tree;  /* static tree or NULL */\\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\\n  this.extra_base   = extra_base;   /* base index for extra_bits */\\n  this.elems        = elems;        /* max number of elements in the tree */\\n  this.max_length   = max_length;   /* max bit length for the codes */\\n\\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\\n  this.has_stree    = static_tree && static_tree.length;\\n}\\n\\n\\nvar static_l_desc;\\nvar static_d_desc;\\nvar static_bl_desc;\\n\\n\\nfunction TreeDesc(dyn_tree, stat_desc) {\\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\\n  this.max_code = 0;            /* largest code with non zero frequency */\\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\\n}\\n\\n\\n\\nfunction d_code(dist) {\\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\\n}\\n\\n\\n/* ===========================================================================\\n * Output a short LSB first on the stream.\\n * IN assertion: there is enough room in pendingBuf.\\n */\\nfunction put_short(s, w) {\\n//    put_byte(s, (uch)((w) & 0xff));\\n//    put_byte(s, (uch)((ush)(w) >> 8));\\n  s.pending_buf[s.pending++] = (w) & 0xff;\\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\\n}\\n\\n\\n/* ===========================================================================\\n * Send a value on a given number of bits.\\n * IN assertion: length <= 16 and value fits in length bits.\\n */\\nfunction send_bits(s, value, length) {\\n  if (s.bi_valid > (Buf_size - length)) {\\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\\n    put_short(s, s.bi_buf);\\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\\n    s.bi_valid += length - Buf_size;\\n  } else {\\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\\n    s.bi_valid += length;\\n  }\\n}\\n\\n\\nfunction send_code(s, c, tree) {\\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\\n}\\n\\n\\n/* ===========================================================================\\n * Reverse the first len bits of a code, using straightforward code (a faster\\n * method would use a table)\\n * IN assertion: 1 <= len <= 15\\n */\\nfunction bi_reverse(code, len) {\\n  var res = 0;\\n  do {\\n    res |= code & 1;\\n    code >>>= 1;\\n    res <<= 1;\\n  } while (--len > 0);\\n  return res >>> 1;\\n}\\n\\n\\n/* ===========================================================================\\n * Flush the bit buffer, keeping at most 7 bits in it.\\n */\\nfunction bi_flush(s) {\\n  if (s.bi_valid === 16) {\\n    put_short(s, s.bi_buf);\\n    s.bi_buf = 0;\\n    s.bi_valid = 0;\\n\\n  } else if (s.bi_valid >= 8) {\\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\\n    s.bi_buf >>= 8;\\n    s.bi_valid -= 8;\\n  }\\n}\\n\\n\\n/* ===========================================================================\\n * Compute the optimal bit lengths for a tree and update the total bit length\\n * for the current block.\\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\\n *    above are the tree nodes sorted by increasing frequency.\\n * OUT assertions: the field len is set to the optimal bit length, the\\n *     array bl_count contains the frequencies for each bit length.\\n *     The length opt_len is updated; static_len is also updated if stree is\\n *     not null.\\n */\\nfunction gen_bitlen(s, desc)\\n//    deflate_state *s;\\n//    tree_desc *desc;    /* the tree descriptor */\\n{\\n  var tree            = desc.dyn_tree;\\n  var max_code        = desc.max_code;\\n  var stree           = desc.stat_desc.static_tree;\\n  var has_stree       = desc.stat_desc.has_stree;\\n  var extra           = desc.stat_desc.extra_bits;\\n  var base            = desc.stat_desc.extra_base;\\n  var max_length      = desc.stat_desc.max_length;\\n  var h;              /* heap index */\\n  var n, m;           /* iterate over the tree elements */\\n  var bits;           /* bit length */\\n  var xbits;          /* extra bits */\\n  var f;              /* frequency */\\n  var overflow = 0;   /* number of elements with bit length too large */\\n\\n  for (bits = 0; bits <= MAX_BITS; bits++) {\\n    s.bl_count[bits] = 0;\\n  }\\n\\n  /* In a first pass, compute the optimal bit lengths (which may\\n   * overflow in the case of the bit length tree).\\n   */\\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\\n\\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\\n    n = s.heap[h];\\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\\n    if (bits > max_length) {\\n      bits = max_length;\\n      overflow++;\\n    }\\n    tree[n * 2 + 1]/*.Len*/ = bits;\\n    /* We overwrite tree[n].Dad which is no longer needed */\\n\\n    if (n > max_code) { continue; } /* not a leaf node */\\n\\n    s.bl_count[bits]++;\\n    xbits = 0;\\n    if (n >= base) {\\n      xbits = extra[n - base];\\n    }\\n    f = tree[n * 2]/*.Freq*/;\\n    s.opt_len += f * (bits + xbits);\\n    if (has_stree) {\\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\\n    }\\n  }\\n  if (overflow === 0) { return; }\\n\\n  // Trace((stderr,\\\"\\\\nbit length overflow\\\\n\\\"));\\n  /* This happens for example on obj2 and pic of the Calgary corpus */\\n\\n  /* Find the first bit length which could increase: */\\n  do {\\n    bits = max_length - 1;\\n    while (s.bl_count[bits] === 0) { bits--; }\\n    s.bl_count[bits]--;      /* move one leaf down the tree */\\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\\n    s.bl_count[max_length]--;\\n    /* The brother of the overflow item also moves one step up,\\n     * but this does not affect bl_count[max_length]\\n     */\\n    overflow -= 2;\\n  } while (overflow > 0);\\n\\n  /* Now recompute all bit lengths, scanning in increasing frequency.\\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\\n   * lengths instead of fixing only the wrong ones. This idea is taken\\n   * from 'ar' written by Haruhiko Okumura.)\\n   */\\n  for (bits = max_length; bits !== 0; bits--) {\\n    n = s.bl_count[bits];\\n    while (n !== 0) {\\n      m = s.heap[--h];\\n      if (m > max_code) { continue; }\\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\\n        // Trace((stderr,\\\"code %d bits %d->%d\\\\n\\\", m, tree[m].Len, bits));\\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\\n        tree[m * 2 + 1]/*.Len*/ = bits;\\n      }\\n      n--;\\n    }\\n  }\\n}\\n\\n\\n/* ===========================================================================\\n * Generate the codes for a given tree and bit counts (which need not be\\n * optimal).\\n * IN assertion: the array bl_count contains the bit length statistics for\\n * the given tree and the field len is set for all tree elements.\\n * OUT assertion: the field code is set for all tree elements of non\\n *     zero code length.\\n */\\nfunction gen_codes(tree, max_code, bl_count)\\n//    ct_data *tree;             /* the tree to decorate */\\n//    int max_code;              /* largest code with non zero frequency */\\n//    ushf *bl_count;            /* number of codes at each bit length */\\n{\\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\\n  var code = 0;              /* running code value */\\n  var bits;                  /* bit index */\\n  var n;                     /* code index */\\n\\n  /* The distribution counts are first used to generate the code values\\n   * without bit reversal.\\n   */\\n  for (bits = 1; bits <= MAX_BITS; bits++) {\\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\\n  }\\n  /* Check that the bit counts in bl_count are consistent. The last code\\n   * must be all ones.\\n   */\\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\\n  //        \\\"inconsistent bit counts\\\");\\n  //Tracev((stderr,\\\"\\\\ngen_codes: max_code %d \\\", max_code));\\n\\n  for (n = 0;  n <= max_code; n++) {\\n    var len = tree[n * 2 + 1]/*.Len*/;\\n    if (len === 0) { continue; }\\n    /* Now reverse the bits */\\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\\n\\n    //Tracecv(tree != static_ltree, (stderr,\\\"\\\\nn %3d %c l %2d c %4x (%x) \\\",\\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\\n  }\\n}\\n\\n\\n/* ===========================================================================\\n * Initialize the various 'constant' tables.\\n */\\nfunction tr_static_init() {\\n  var n;        /* iterates over tree elements */\\n  var bits;     /* bit counter */\\n  var length;   /* length value */\\n  var code;     /* code value */\\n  var dist;     /* distance index */\\n  var bl_count = new Array(MAX_BITS + 1);\\n  /* number of codes at each bit length for an optimal tree */\\n\\n  // do check in _tr_init()\\n  //if (static_init_done) return;\\n\\n  /* For some embedded targets, global variables are not initialized: */\\n/*#ifdef NO_INIT_GLOBAL_POINTERS\\n  static_l_desc.static_tree = static_ltree;\\n  static_l_desc.extra_bits = extra_lbits;\\n  static_d_desc.static_tree = static_dtree;\\n  static_d_desc.extra_bits = extra_dbits;\\n  static_bl_desc.extra_bits = extra_blbits;\\n#endif*/\\n\\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\\n  length = 0;\\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\\n    base_length[code] = length;\\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\\n      _length_code[length++] = code;\\n    }\\n  }\\n  //Assert (length == 256, \\\"tr_static_init: length != 256\\\");\\n  /* Note that the length 255 (match length 258) can be represented\\n   * in two different ways: code 284 + 5 bits or code 285, so we\\n   * overwrite length_code[255] to use the best encoding:\\n   */\\n  _length_code[length - 1] = code;\\n\\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\\n  dist = 0;\\n  for (code = 0; code < 16; code++) {\\n    base_dist[code] = dist;\\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\\n      _dist_code[dist++] = code;\\n    }\\n  }\\n  //Assert (dist == 256, \\\"tr_static_init: dist != 256\\\");\\n  dist >>= 7; /* from now on, all distances are divided by 128 */\\n  for (; code < D_CODES; code++) {\\n    base_dist[code] = dist << 7;\\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\\n      _dist_code[256 + dist++] = code;\\n    }\\n  }\\n  //Assert (dist == 256, \\\"tr_static_init: 256+dist != 512\\\");\\n\\n  /* Construct the codes of the static literal tree */\\n  for (bits = 0; bits <= MAX_BITS; bits++) {\\n    bl_count[bits] = 0;\\n  }\\n\\n  n = 0;\\n  while (n <= 143) {\\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\\n    n++;\\n    bl_count[8]++;\\n  }\\n  while (n <= 255) {\\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\\n    n++;\\n    bl_count[9]++;\\n  }\\n  while (n <= 279) {\\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\\n    n++;\\n    bl_count[7]++;\\n  }\\n  while (n <= 287) {\\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\\n    n++;\\n    bl_count[8]++;\\n  }\\n  /* Codes 286 and 287 do not exist, but we must include them in the\\n   * tree construction to get a canonical Huffman tree (longest code\\n   * all ones)\\n   */\\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\\n\\n  /* The static distance tree is trivial: */\\n  for (n = 0; n < D_CODES; n++) {\\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\\n  }\\n\\n  // Now data ready and we can init static trees\\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\\n\\n  //static_init_done = true;\\n}\\n\\n\\n/* ===========================================================================\\n * Initialize a new block.\\n */\\nfunction init_block(s) {\\n  var n; /* iterates over tree elements */\\n\\n  /* Initialize the trees. */\\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\\n\\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\\n  s.opt_len = s.static_len = 0;\\n  s.last_lit = s.matches = 0;\\n}\\n\\n\\n/* ===========================================================================\\n * Flush the bit buffer and align the output on a byte boundary\\n */\\nfunction bi_windup(s)\\n{\\n  if (s.bi_valid > 8) {\\n    put_short(s, s.bi_buf);\\n  } else if (s.bi_valid > 0) {\\n    //put_byte(s, (Byte)s->bi_buf);\\n    s.pending_buf[s.pending++] = s.bi_buf;\\n  }\\n  s.bi_buf = 0;\\n  s.bi_valid = 0;\\n}\\n\\n/* ===========================================================================\\n * Copy a stored block, storing first the length and its\\n * one's complement if requested.\\n */\\nfunction copy_block(s, buf, len, header)\\n//DeflateState *s;\\n//charf    *buf;    /* the input data */\\n//unsigned len;     /* its length */\\n//int      header;  /* true if block header must be written */\\n{\\n  bi_windup(s);        /* align on byte boundary */\\n\\n  if (header) {\\n    put_short(s, len);\\n    put_short(s, ~len);\\n  }\\n//  while (len--) {\\n//    put_byte(s, *buf++);\\n//  }\\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\\n  s.pending += len;\\n}\\n\\n/* ===========================================================================\\n * Compares to subtrees, using the tree depth as tie breaker when\\n * the subtrees have equal frequency. This minimizes the worst case length.\\n */\\nfunction smaller(tree, n, m, depth) {\\n  var _n2 = n * 2;\\n  var _m2 = m * 2;\\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\\n}\\n\\n/* ===========================================================================\\n * Restore the heap property by moving down the tree starting at node k,\\n * exchanging a node with the smallest of its two sons if necessary, stopping\\n * when the heap property is re-established (each father smaller than its\\n * two sons).\\n */\\nfunction pqdownheap(s, tree, k)\\n//    deflate_state *s;\\n//    ct_data *tree;  /* the tree to restore */\\n//    int k;               /* node to move down */\\n{\\n  var v = s.heap[k];\\n  var j = k << 1;  /* left son of k */\\n  while (j <= s.heap_len) {\\n    /* Set j to the smallest of the two sons: */\\n    if (j < s.heap_len &&\\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\\n      j++;\\n    }\\n    /* Exit if v is smaller than both sons */\\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\\n\\n    /* Exchange v with the smallest son */\\n    s.heap[k] = s.heap[j];\\n    k = j;\\n\\n    /* And continue down the tree, setting j to the left son of k */\\n    j <<= 1;\\n  }\\n  s.heap[k] = v;\\n}\\n\\n\\n// inlined manually\\n// var SMALLEST = 1;\\n\\n/* ===========================================================================\\n * Send the block data compressed using the given Huffman trees\\n */\\nfunction compress_block(s, ltree, dtree)\\n//    deflate_state *s;\\n//    const ct_data *ltree; /* literal tree */\\n//    const ct_data *dtree; /* distance tree */\\n{\\n  var dist;           /* distance of matched string */\\n  var lc;             /* match length or unmatched char (if dist == 0) */\\n  var lx = 0;         /* running index in l_buf */\\n  var code;           /* the code to send */\\n  var extra;          /* number of extra bits to send */\\n\\n  if (s.last_lit !== 0) {\\n    do {\\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\\n      lc = s.pending_buf[s.l_buf + lx];\\n      lx++;\\n\\n      if (dist === 0) {\\n        send_code(s, lc, ltree); /* send a literal byte */\\n        //Tracecv(isgraph(lc), (stderr,\\\" '%c' \\\", lc));\\n      } else {\\n        /* Here, lc is the match length - MIN_MATCH */\\n        code = _length_code[lc];\\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\\n        extra = extra_lbits[code];\\n        if (extra !== 0) {\\n          lc -= base_length[code];\\n          send_bits(s, lc, extra);       /* send the extra length bits */\\n        }\\n        dist--; /* dist is now the match distance - 1 */\\n        code = d_code(dist);\\n        //Assert (code < D_CODES, \\\"bad d_code\\\");\\n\\n        send_code(s, code, dtree);       /* send the distance code */\\n        extra = extra_dbits[code];\\n        if (extra !== 0) {\\n          dist -= base_dist[code];\\n          send_bits(s, dist, extra);   /* send the extra distance bits */\\n        }\\n      } /* literal or match pair ? */\\n\\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\\n      //       \\\"pendingBuf overflow\\\");\\n\\n    } while (lx < s.last_lit);\\n  }\\n\\n  send_code(s, END_BLOCK, ltree);\\n}\\n\\n\\n/* ===========================================================================\\n * Construct one Huffman tree and assigns the code bit strings and lengths.\\n * Update the total bit length for the current block.\\n * IN assertion: the field freq is set for all tree elements.\\n * OUT assertions: the fields len and code are set to the optimal bit length\\n *     and corresponding code. The length opt_len is updated; static_len is\\n *     also updated if stree is not null. The field max_code is set.\\n */\\nfunction build_tree(s, desc)\\n//    deflate_state *s;\\n//    tree_desc *desc; /* the tree descriptor */\\n{\\n  var tree     = desc.dyn_tree;\\n  var stree    = desc.stat_desc.static_tree;\\n  var has_stree = desc.stat_desc.has_stree;\\n  var elems    = desc.stat_desc.elems;\\n  var n, m;          /* iterate over heap elements */\\n  var max_code = -1; /* largest code with non zero frequency */\\n  var node;          /* new node being created */\\n\\n  /* Construct the initial heap, with least frequent element in\\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\\n   * heap[0] is not used.\\n   */\\n  s.heap_len = 0;\\n  s.heap_max = HEAP_SIZE;\\n\\n  for (n = 0; n < elems; n++) {\\n    if (tree[n * 2]/*.Freq*/ !== 0) {\\n      s.heap[++s.heap_len] = max_code = n;\\n      s.depth[n] = 0;\\n\\n    } else {\\n      tree[n * 2 + 1]/*.Len*/ = 0;\\n    }\\n  }\\n\\n  /* The pkzip format requires that at least one distance code exists,\\n   * and that at least one bit should be sent even if there is only one\\n   * possible code. So to avoid special checks later on we force at least\\n   * two codes of non zero frequency.\\n   */\\n  while (s.heap_len < 2) {\\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\\n    tree[node * 2]/*.Freq*/ = 1;\\n    s.depth[node] = 0;\\n    s.opt_len--;\\n\\n    if (has_stree) {\\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\\n    }\\n    /* node is 0 or 1 so it does not have extra bits */\\n  }\\n  desc.max_code = max_code;\\n\\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\\n   * establish sub-heaps of increasing lengths:\\n   */\\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\\n\\n  /* Construct the Huffman tree by repeatedly combining the least two\\n   * frequent nodes.\\n   */\\n  node = elems;              /* next internal node of the tree */\\n  do {\\n    //pqremove(s, tree, n);  /* n = node of least frequency */\\n    /*** pqremove ***/\\n    n = s.heap[1/*SMALLEST*/];\\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\\n    pqdownheap(s, tree, 1/*SMALLEST*/);\\n    /***/\\n\\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\\n\\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\\n    s.heap[--s.heap_max] = m;\\n\\n    /* Create a new node father of n and m */\\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\\n\\n    /* and insert the new node in the heap */\\n    s.heap[1/*SMALLEST*/] = node++;\\n    pqdownheap(s, tree, 1/*SMALLEST*/);\\n\\n  } while (s.heap_len >= 2);\\n\\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\\n\\n  /* At this point, the fields freq and dad are set. We can now\\n   * generate the bit lengths.\\n   */\\n  gen_bitlen(s, desc);\\n\\n  /* The field len is now set, we can generate the bit codes */\\n  gen_codes(tree, max_code, s.bl_count);\\n}\\n\\n\\n/* ===========================================================================\\n * Scan a literal or distance tree to determine the frequencies of the codes\\n * in the bit length tree.\\n */\\nfunction scan_tree(s, tree, max_code)\\n//    deflate_state *s;\\n//    ct_data *tree;   /* the tree to be scanned */\\n//    int max_code;    /* and its largest code of non zero frequency */\\n{\\n  var n;                     /* iterates over all tree elements */\\n  var prevlen = -1;          /* last emitted length */\\n  var curlen;                /* length of current code */\\n\\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\\n\\n  var count = 0;             /* repeat count of the current code */\\n  var max_count = 7;         /* max repeat count */\\n  var min_count = 4;         /* min repeat count */\\n\\n  if (nextlen === 0) {\\n    max_count = 138;\\n    min_count = 3;\\n  }\\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\\n\\n  for (n = 0; n <= max_code; n++) {\\n    curlen = nextlen;\\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\\n\\n    if (++count < max_count && curlen === nextlen) {\\n      continue;\\n\\n    } else if (count < min_count) {\\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\\n\\n    } else if (curlen !== 0) {\\n\\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\\n\\n    } else if (count <= 10) {\\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\\n\\n    } else {\\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\\n    }\\n\\n    count = 0;\\n    prevlen = curlen;\\n\\n    if (nextlen === 0) {\\n      max_count = 138;\\n      min_count = 3;\\n\\n    } else if (curlen === nextlen) {\\n      max_count = 6;\\n      min_count = 3;\\n\\n    } else {\\n      max_count = 7;\\n      min_count = 4;\\n    }\\n  }\\n}\\n\\n\\n/* ===========================================================================\\n * Send a literal or distance tree in compressed form, using the codes in\\n * bl_tree.\\n */\\nfunction send_tree(s, tree, max_code)\\n//    deflate_state *s;\\n//    ct_data *tree; /* the tree to be scanned */\\n//    int max_code;       /* and its largest code of non zero frequency */\\n{\\n  var n;                     /* iterates over all tree elements */\\n  var prevlen = -1;          /* last emitted length */\\n  var curlen;                /* length of current code */\\n\\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\\n\\n  var count = 0;             /* repeat count of the current code */\\n  var max_count = 7;         /* max repeat count */\\n  var min_count = 4;         /* min repeat count */\\n\\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\\n  if (nextlen === 0) {\\n    max_count = 138;\\n    min_count = 3;\\n  }\\n\\n  for (n = 0; n <= max_code; n++) {\\n    curlen = nextlen;\\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\\n\\n    if (++count < max_count && curlen === nextlen) {\\n      continue;\\n\\n    } else if (count < min_count) {\\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\\n\\n    } else if (curlen !== 0) {\\n      if (curlen !== prevlen) {\\n        send_code(s, curlen, s.bl_tree);\\n        count--;\\n      }\\n      //Assert(count >= 3 && count <= 6, \\\" 3_6?\\\");\\n      send_code(s, REP_3_6, s.bl_tree);\\n      send_bits(s, count - 3, 2);\\n\\n    } else if (count <= 10) {\\n      send_code(s, REPZ_3_10, s.bl_tree);\\n      send_bits(s, count - 3, 3);\\n\\n    } else {\\n      send_code(s, REPZ_11_138, s.bl_tree);\\n      send_bits(s, count - 11, 7);\\n    }\\n\\n    count = 0;\\n    prevlen = curlen;\\n    if (nextlen === 0) {\\n      max_count = 138;\\n      min_count = 3;\\n\\n    } else if (curlen === nextlen) {\\n      max_count = 6;\\n      min_count = 3;\\n\\n    } else {\\n      max_count = 7;\\n      min_count = 4;\\n    }\\n  }\\n}\\n\\n\\n/* ===========================================================================\\n * Construct the Huffman tree for the bit lengths and return the index in\\n * bl_order of the last bit length code to send.\\n */\\nfunction build_bl_tree(s) {\\n  var max_blindex;  /* index of last bit length code of non zero freq */\\n\\n  /* Determine the bit length frequencies for literal and distance trees */\\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\\n\\n  /* Build the bit length tree: */\\n  build_tree(s, s.bl_desc);\\n  /* opt_len now includes the length of the tree representations, except\\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\\n   */\\n\\n  /* Determine the number of bit length codes to send. The pkzip format\\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\\n   * 3 but the actual value used is 4.)\\n   */\\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\\n      break;\\n    }\\n  }\\n  /* Update opt_len to include the bit length tree and counts */\\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\\n  //Tracev((stderr, \\\"\\\\ndyn trees: dyn %ld, stat %ld\\\",\\n  //        s->opt_len, s->static_len));\\n\\n  return max_blindex;\\n}\\n\\n\\n/* ===========================================================================\\n * Send the header for a block using dynamic Huffman trees: the counts, the\\n * lengths of the bit length codes, the literal tree and the distance tree.\\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\\n */\\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\\n//    deflate_state *s;\\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\\n{\\n  var rank;                    /* index in bl_order */\\n\\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \\\"not enough codes\\\");\\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\\n  //        \\\"too many codes\\\");\\n  //Tracev((stderr, \\\"\\\\nbl counts: \\\"));\\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\\n  send_bits(s, dcodes - 1,   5);\\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\\n  for (rank = 0; rank < blcodes; rank++) {\\n    //Tracev((stderr, \\\"\\\\nbl code %2d \\\", bl_order[rank]));\\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\\n  }\\n  //Tracev((stderr, \\\"\\\\nbl tree: sent %ld\\\", s->bits_sent));\\n\\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\\n  //Tracev((stderr, \\\"\\\\nlit tree: sent %ld\\\", s->bits_sent));\\n\\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\\n  //Tracev((stderr, \\\"\\\\ndist tree: sent %ld\\\", s->bits_sent));\\n}\\n\\n\\n/* ===========================================================================\\n * Check if the data type is TEXT or BINARY, using the following algorithm:\\n * - TEXT if the two conditions below are satisfied:\\n *    a) There are no non-portable control characters belonging to the\\n *       \\\"black list\\\" (0..6, 14..25, 28..31).\\n *    b) There is at least one printable character belonging to the\\n *       \\\"white list\\\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\\n * - BINARY otherwise.\\n * - The following partially-portable control characters form a\\n *   \\\"gray list\\\" that is ignored in this detection algorithm:\\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\\n * IN assertion: the fields Freq of dyn_ltree are set.\\n */\\nfunction detect_data_type(s) {\\n  /* black_mask is the bit mask of black-listed bytes\\n   * set bits 0..6, 14..25, and 28..31\\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\\n   */\\n  var black_mask = 0xf3ffc07f;\\n  var n;\\n\\n  /* Check for non-textual (\\\"black-listed\\\") bytes. */\\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\\n      return Z_BINARY;\\n    }\\n  }\\n\\n  /* Check for textual (\\\"white-listed\\\") bytes. */\\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\\n    return Z_TEXT;\\n  }\\n  for (n = 32; n < LITERALS; n++) {\\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\\n      return Z_TEXT;\\n    }\\n  }\\n\\n  /* There are no \\\"black-listed\\\" or \\\"white-listed\\\" bytes:\\n   * this stream either is empty or has tolerated (\\\"gray-listed\\\") bytes only.\\n   */\\n  return Z_BINARY;\\n}\\n\\n\\nvar static_init_done = false;\\n\\n/* ===========================================================================\\n * Initialize the tree data structures for a new zlib stream.\\n */\\nfunction _tr_init(s)\\n{\\n\\n  if (!static_init_done) {\\n    tr_static_init();\\n    static_init_done = true;\\n  }\\n\\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\\n\\n  s.bi_buf = 0;\\n  s.bi_valid = 0;\\n\\n  /* Initialize the first block of the first file: */\\n  init_block(s);\\n}\\n\\n\\n/* ===========================================================================\\n * Send a stored block\\n */\\nfunction _tr_stored_block(s, buf, stored_len, last)\\n//DeflateState *s;\\n//charf *buf;       /* input block */\\n//ulg stored_len;   /* length of input block */\\n//int last;         /* one if this is the last block for a file */\\n{\\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\\n  copy_block(s, buf, stored_len, true); /* with header */\\n}\\n\\n\\n/* ===========================================================================\\n * Send one empty static block to give enough lookahead for inflate.\\n * This takes 10 bits, of which 7 may remain in the bit buffer.\\n */\\nfunction _tr_align(s) {\\n  send_bits(s, STATIC_TREES << 1, 3);\\n  send_code(s, END_BLOCK, static_ltree);\\n  bi_flush(s);\\n}\\n\\n\\n/* ===========================================================================\\n * Determine the best encoding for the current block: dynamic trees, static\\n * trees or store, and output the encoded block to the zip file.\\n */\\nfunction _tr_flush_block(s, buf, stored_len, last)\\n//DeflateState *s;\\n//charf *buf;       /* input block, or NULL if too old */\\n//ulg stored_len;   /* length of input block */\\n//int last;         /* one if this is the last block for a file */\\n{\\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\\n\\n  /* Build the Huffman trees unless a stored block is forced */\\n  if (s.level > 0) {\\n\\n    /* Check if the file is binary or text */\\n    if (s.strm.data_type === Z_UNKNOWN) {\\n      s.strm.data_type = detect_data_type(s);\\n    }\\n\\n    /* Construct the literal and distance trees */\\n    build_tree(s, s.l_desc);\\n    // Tracev((stderr, \\\"\\\\nlit data: dyn %ld, stat %ld\\\", s->opt_len,\\n    //        s->static_len));\\n\\n    build_tree(s, s.d_desc);\\n    // Tracev((stderr, \\\"\\\\ndist data: dyn %ld, stat %ld\\\", s->opt_len,\\n    //        s->static_len));\\n    /* At this point, opt_len and static_len are the total bit lengths of\\n     * the compressed block data, excluding the tree representations.\\n     */\\n\\n    /* Build the bit length tree for the above two trees, and get the index\\n     * in bl_order of the last bit length code to send.\\n     */\\n    max_blindex = build_bl_tree(s);\\n\\n    /* Determine the best encoding. Compute the block lengths in bytes. */\\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\\n\\n    // Tracev((stderr, \\\"\\\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \\\",\\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\\n    //        s->last_lit));\\n\\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\\n\\n  } else {\\n    // Assert(buf != (char*)0, \\\"lost buf\\\");\\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\\n  }\\n\\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\\n    /* 4: two words for the lengths */\\n\\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\\n     * Otherwise we can't have processed more than WSIZE input bytes since\\n     * the last block flush, because compression would have been\\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\\n     * transform a block into a stored block.\\n     */\\n    _tr_stored_block(s, buf, stored_len, last);\\n\\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\\n\\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\\n    compress_block(s, static_ltree, static_dtree);\\n\\n  } else {\\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\\n  }\\n  // Assert (s->compressed_len == s->bits_sent, \\\"bad compressed size\\\");\\n  /* The above check is made mod 2^32, for files larger than 512 MB\\n   * and uLong implemented on 32 bits.\\n   */\\n  init_block(s);\\n\\n  if (last) {\\n    bi_windup(s);\\n  }\\n  // Tracev((stderr,\\\"\\\\ncomprlen %lu(%lu) \\\", s->compressed_len>>3,\\n  //       s->compressed_len-7*last));\\n}\\n\\n/* ===========================================================================\\n * Save the match info and tally the frequency counts. Return true if\\n * the current block must be flushed.\\n */\\nfunction _tr_tally(s, dist, lc)\\n//    deflate_state *s;\\n//    unsigned dist;  /* distance of matched string */\\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\\n{\\n  //var out_length, in_length, dcode;\\n\\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\\n\\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\\n  s.last_lit++;\\n\\n  if (dist === 0) {\\n    /* lc is the unmatched char */\\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\\n  } else {\\n    s.matches++;\\n    /* Here, lc is the match length - MIN_MATCH */\\n    dist--;             /* dist = match distance - 1 */\\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\\n    //       (ush)d_code(dist) < (ush)D_CODES,  \\\"_tr_tally: bad match\\\");\\n\\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\\n  }\\n\\n// (!) This block is disabled in zlib defaults,\\n// don't enable it for binary compatibility\\n\\n//#ifdef TRUNCATE_BLOCK\\n//  /* Try to guess if it is profitable to stop the current block here */\\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\\n//    /* Compute an upper bound for the compressed length */\\n//    out_length = s.last_lit*8;\\n//    in_length = s.strstart - s.block_start;\\n//\\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\\n//    }\\n//    out_length >>>= 3;\\n//    //Tracev((stderr,\\\"\\\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \\\",\\n//    //       s->last_lit, in_length, out_length,\\n//    //       100L - out_length*100L/in_length));\\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\\n//      return true;\\n//    }\\n//  }\\n//#endif\\n\\n  return (s.last_lit === s.lit_bufsize - 1);\\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\\n   * on 16 bit machines and because stored blocks are restricted to\\n   * 64K-1 bytes.\\n   */\\n}\\n\\nexports._tr_init  = _tr_init;\\nexports._tr_stored_block = _tr_stored_block;\\nexports._tr_flush_block  = _tr_flush_block;\\nexports._tr_tally = _tr_tally;\\nexports._tr_align = _tr_align;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"zero\",\"buf\",\"len\",\"length\",\"StaticTreeDesc\",\"static_tree\",\"extra_bits\",\"extra_base\",\"elems\",\"max_length\",\"has_stree\",\"TreeDesc\",\"dyn_tree\",\"stat_desc\",\"max_code\",\"put_short\",\"s\",\"w\",\"pending_buf\",\"pending\",\"send_bits\",\"value\",\"bi_valid\",\"Buf_size\",\"bi_buf\",\"send_code\",\"c\",\"tree\",\"bi_reverse\",\"code\",\"res\",\"gen_codes\",\"bl_count\",\"next_code\",\"Array\",\"bits\",\"MAX_BITS\",\"n\",\"init_block\",\"L_CODES\",\"dyn_ltree\",\"D_CODES\",\"dyn_dtree\",\"BL_CODES\",\"bl_tree\",\"opt_len\",\"static_len\",\"last_lit\",\"matches\",\"bi_windup\",\"smaller\",\"m\",\"depth\",\"_n2\",\"_m2\",\"pqdownheap\",\"k\",\"v\",\"heap\",\"j\",\"heap_len\",\"compress_block\",\"ltree\",\"dtree\",\"lx\",\"dist\",\"d_buf\",\"lc\",\"l_buf\",\"_length_code\",\"LITERALS\",\"extra\",\"extra_lbits\",\"base_length\",\"_dist_code\",\"extra_dbits\",\"base_dist\",\"END_BLOCK\",\"build_tree\",\"desc\",\"stree\",\"heap_max\",\"HEAP_SIZE\",\"node\",\"base\",\"overflow\",\"h\",\"xbits\",\"f\",\"scan_tree\",\"prevlen\",\"nextlen\",\"count\",\"max_count\",\"min_count\",\"curlen\",\"send_tree\",\"REP_3_6\",\"REPZ_3_10\",\"REPZ_11_138\",\"detect_data_type\",\"black_mask\",\"Z_BINARY\",\"Z_TEXT\",\"_tr_stored_block\",\"stored_len\",\"last\",\"utils\",\"arraySet\",\"window\",\"extra_blbits\",\"bl_order\",\"static_ltree\",\"static_dtree\",\"DIST_CODE_LEN\",\"LENGTH_CODES\",\"static_l_desc\",\"static_d_desc\",\"static_bl_desc\",\"static_init_done\",\"_tr_init\",\"MAX_BL_BITS\",\"l_desc\",\"d_desc\",\"bl_desc\",\"_tr_flush_block\",\"max_blindex\",\"level\",\"Z_UNKNOWN\",\"strm\",\"data_type\",\"opt_lenb\",\"static_lenb\",\"Z_FIXED\",\"strategy\",\"lcodes\",\"dcodes\",\"blcodes\",\"rank\",\"_tr_tally\",\"lit_bufsize\",\"_tr_align\"]\n}\n"]