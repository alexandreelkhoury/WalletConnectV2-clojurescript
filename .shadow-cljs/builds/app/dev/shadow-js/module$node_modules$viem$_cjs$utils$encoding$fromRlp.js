["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/viem/_cjs/utils/encoding/fromRlp.js"],"~:js","shadow$provide.module$node_modules$viem$_cjs$utils$encoding$fromRlp=function(global,require,module,exports){function format(bytes,to){return Array.isArray(bytes)?bytes.map(b=>format(b,to)):\"hex\"===to?(0,toHex_js_1.bytesToHex)(bytes):bytes}function rlpToBytes(bytes,offset=0){if(0===bytes.length)return[new Uint8Array([]),0];var prefix=bytes[offset];if(127>=prefix)return[new Uint8Array([bytes[offset]]),1];if(183>=prefix){prefix-=128;offset+=1;if(offset+prefix>bytes.length)throw new encoding_js_1.DataLengthTooShortError({length:offset+\nprefix,dataLength:bytes.length});return[bytes.slice(offset,offset+prefix),1+prefix]}if(191>=prefix){prefix-=183;offset+=1;var length=(0,fromBytes_js_1.bytesToNumber)(bytes.slice(offset,offset+prefix));if(offset+prefix+length>bytes.length)throw new encoding_js_1.DataLengthTooShortError({length:prefix+length,dataLength:bytes.length-prefix});return[bytes.slice(offset+prefix,offset+prefix+length),1+prefix+length]}length=0;var length$jscomp$0=prefix-192;247<prefix&&(length=prefix-247,length$jscomp$0=(0,fromBytes_js_1.bytesToNumber)(bytes.slice(offset+\n1,offset+1+length)));prefix=offset+1+length;if(prefix>bytes.length)throw new encoding_js_1.DataLengthTooShortError({length:prefix,dataLength:bytes.length});length=1+length+length$jscomp$0;for(length$jscomp$0=[];prefix<offset+length;){const decoded=rlpToBytes(bytes,prefix);length$jscomp$0.push(decoded[0]);prefix+=decoded[1];if(prefix>offset+length)throw new encoding_js_1.OffsetOutOfBoundsError({nextOffset:prefix,offset:offset+length});}return[length$jscomp$0,length]}Object.defineProperty(exports,\"__esModule\",\n{value:!0});exports.fromRlp=void 0;const encoding_js_1=require(\"module$node_modules$viem$_cjs$errors$encoding\"),fromBytes_js_1=require(\"module$node_modules$viem$_cjs$utils$encoding$fromBytes\"),toBytes_js_1=require(\"module$node_modules$viem$_cjs$utils$encoding$toBytes\"),toHex_js_1=require(\"module$node_modules$viem$_cjs$utils$encoding$toHex\");exports.fromRlp=function(value,to){if(\"string\"===typeof value){if(3<value.length&&0!==value.length%2)throw new encoding_js_1.InvalidHexValueError(value);value=\n(0,toBytes_js_1.hexToBytes)(value)}const [data,consumed]=rlpToBytes(value);if(consumed<value.length)throw new encoding_js_1.DataLengthTooLongError({consumed,length:value.length});return format(data,to)}}","~:source","shadow$provide[\"module$node_modules$viem$_cjs$utils$encoding$fromRlp\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromRlp = void 0;\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst fromBytes_js_1 = require(\"./fromBytes.js\");\nconst toBytes_js_1 = require(\"./toBytes.js\");\nconst toHex_js_1 = require(\"./toHex.js\");\nfunction fromRlp(value, to) {\n    const bytes = parse(value);\n    const [data, consumed] = rlpToBytes(bytes);\n    if (consumed < bytes.length)\n        throw new encoding_js_1.DataLengthTooLongError({\n            consumed,\n            length: bytes.length,\n        });\n    return format(data, to);\n}\nexports.fromRlp = fromRlp;\nfunction parse(value) {\n    if (typeof value === 'string') {\n        if (value.length > 3 && value.length % 2 !== 0)\n            throw new encoding_js_1.InvalidHexValueError(value);\n        return (0, toBytes_js_1.hexToBytes)(value);\n    }\n    return value;\n}\nfunction format(bytes, to) {\n    if (Array.isArray(bytes))\n        return bytes.map((b) => format(b, to));\n    return (to === 'hex' ? (0, toHex_js_1.bytesToHex)(bytes) : bytes);\n}\nfunction rlpToBytes(bytes, offset = 0) {\n    if (bytes.length === 0)\n        return [new Uint8Array([]), 0];\n    const prefix = bytes[offset];\n    if (prefix <= 0x7f)\n        return [new Uint8Array([bytes[offset]]), 1];\n    if (prefix <= 0xb7) {\n        const length = prefix - 0x80;\n        const offset_ = offset + 1;\n        if (offset_ + length > bytes.length)\n            throw new encoding_js_1.DataLengthTooShortError({\n                length: offset_ + length,\n                dataLength: bytes.length,\n            });\n        return [bytes.slice(offset_, offset_ + length), 1 + length];\n    }\n    if (prefix <= 0xbf) {\n        const lengthOfLength = prefix - 0xb7;\n        const offset_ = offset + 1;\n        const length = (0, fromBytes_js_1.bytesToNumber)(bytes.slice(offset_, offset_ + lengthOfLength));\n        if (offset_ + lengthOfLength + length > bytes.length)\n            throw new encoding_js_1.DataLengthTooShortError({\n                length: lengthOfLength + length,\n                dataLength: bytes.length - lengthOfLength,\n            });\n        return [\n            bytes.slice(offset_ + lengthOfLength, offset_ + lengthOfLength + length),\n            1 + lengthOfLength + length,\n        ];\n    }\n    let lengthOfLength = 0;\n    let length = prefix - 0xc0;\n    if (prefix > 0xf7) {\n        lengthOfLength = prefix - 0xf7;\n        length = (0, fromBytes_js_1.bytesToNumber)(bytes.slice(offset + 1, offset + 1 + lengthOfLength));\n    }\n    let nextOffset = offset + 1 + lengthOfLength;\n    if (nextOffset > bytes.length)\n        throw new encoding_js_1.DataLengthTooShortError({\n            length: nextOffset,\n            dataLength: bytes.length,\n        });\n    const consumed = 1 + lengthOfLength + length;\n    const result = [];\n    while (nextOffset < offset + consumed) {\n        const decoded = rlpToBytes(bytes, nextOffset);\n        result.push(decoded[0]);\n        nextOffset += decoded[1];\n        if (nextOffset > offset + consumed)\n            throw new encoding_js_1.OffsetOutOfBoundsError({\n                nextOffset: nextOffset,\n                offset: offset + consumed,\n            });\n    }\n    return [result, consumed];\n}\n//# sourceMappingURL=fromRlp.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$viem$_cjs$utils$encoding$toBytes","~$shadow.js","~$module$node_modules$viem$_cjs$utils$encoding$fromBytes","~$module$node_modules$viem$_cjs$errors$encoding","~$module$node_modules$viem$_cjs$utils$encoding$toHex"]],"~:properties",["^5",["consumed","offset","nextOffset","fromRlp","__esModule","value","length","dataLength"]],"~:compiled-at",1695111490310,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$viem$_cjs$utils$encoding$fromRlp.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/viem/_cjs/utils/encoding/fromRlp.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$viem$_cjs$utils$encoding$fromRlp\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.fromRlp = void 0;\\nconst encoding_js_1 = require(\\\"../../errors/encoding.js\\\");\\nconst fromBytes_js_1 = require(\\\"./fromBytes.js\\\");\\nconst toBytes_js_1 = require(\\\"./toBytes.js\\\");\\nconst toHex_js_1 = require(\\\"./toHex.js\\\");\\nfunction fromRlp(value, to) {\\n    const bytes = parse(value);\\n    const [data, consumed] = rlpToBytes(bytes);\\n    if (consumed < bytes.length)\\n        throw new encoding_js_1.DataLengthTooLongError({\\n            consumed,\\n            length: bytes.length,\\n        });\\n    return format(data, to);\\n}\\nexports.fromRlp = fromRlp;\\nfunction parse(value) {\\n    if (typeof value === 'string') {\\n        if (value.length > 3 && value.length % 2 !== 0)\\n            throw new encoding_js_1.InvalidHexValueError(value);\\n        return (0, toBytes_js_1.hexToBytes)(value);\\n    }\\n    return value;\\n}\\nfunction format(bytes, to) {\\n    if (Array.isArray(bytes))\\n        return bytes.map((b) => format(b, to));\\n    return (to === 'hex' ? (0, toHex_js_1.bytesToHex)(bytes) : bytes);\\n}\\nfunction rlpToBytes(bytes, offset = 0) {\\n    if (bytes.length === 0)\\n        return [new Uint8Array([]), 0];\\n    const prefix = bytes[offset];\\n    if (prefix <= 0x7f)\\n        return [new Uint8Array([bytes[offset]]), 1];\\n    if (prefix <= 0xb7) {\\n        const length = prefix - 0x80;\\n        const offset_ = offset + 1;\\n        if (offset_ + length > bytes.length)\\n            throw new encoding_js_1.DataLengthTooShortError({\\n                length: offset_ + length,\\n                dataLength: bytes.length,\\n            });\\n        return [bytes.slice(offset_, offset_ + length), 1 + length];\\n    }\\n    if (prefix <= 0xbf) {\\n        const lengthOfLength = prefix - 0xb7;\\n        const offset_ = offset + 1;\\n        const length = (0, fromBytes_js_1.bytesToNumber)(bytes.slice(offset_, offset_ + lengthOfLength));\\n        if (offset_ + lengthOfLength + length > bytes.length)\\n            throw new encoding_js_1.DataLengthTooShortError({\\n                length: lengthOfLength + length,\\n                dataLength: bytes.length - lengthOfLength,\\n            });\\n        return [\\n            bytes.slice(offset_ + lengthOfLength, offset_ + lengthOfLength + length),\\n            1 + lengthOfLength + length,\\n        ];\\n    }\\n    let lengthOfLength = 0;\\n    let length = prefix - 0xc0;\\n    if (prefix > 0xf7) {\\n        lengthOfLength = prefix - 0xf7;\\n        length = (0, fromBytes_js_1.bytesToNumber)(bytes.slice(offset + 1, offset + 1 + lengthOfLength));\\n    }\\n    let nextOffset = offset + 1 + lengthOfLength;\\n    if (nextOffset > bytes.length)\\n        throw new encoding_js_1.DataLengthTooShortError({\\n            length: nextOffset,\\n            dataLength: bytes.length,\\n        });\\n    const consumed = 1 + lengthOfLength + length;\\n    const result = [];\\n    while (nextOffset < offset + consumed) {\\n        const decoded = rlpToBytes(bytes, nextOffset);\\n        result.push(decoded[0]);\\n        nextOffset += decoded[1];\\n        if (nextOffset > offset + consumed)\\n            throw new encoding_js_1.OffsetOutOfBoundsError({\\n                nextOffset: nextOffset,\\n                offset: offset + consumed,\\n            });\\n    }\\n    return [result, consumed];\\n}\\n//# sourceMappingURL=fromRlp.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"format\",\"bytes\",\"to\",\"Array\",\"isArray\",\"map\",\"b\",\"toHex_js_1\",\"bytesToHex\",\"rlpToBytes\",\"offset\",\"length\",\"Uint8Array\",\"prefix\",\"offset_\",\"encoding_js_1\",\"DataLengthTooShortError\",\"dataLength\",\"slice\",\"lengthOfLength\",\"fromBytes_js_1\",\"bytesToNumber\",\"nextOffset\",\"consumed\",\"result\",\"decoded\",\"push\",\"OffsetOutOfBoundsError\",\"Object\",\"defineProperty\",\"value\",\"fromRlp\",\"toBytes_js_1\",\"InvalidHexValueError\",\"hexToBytes\",\"data\",\"DataLengthTooLongError\"]\n}\n"]