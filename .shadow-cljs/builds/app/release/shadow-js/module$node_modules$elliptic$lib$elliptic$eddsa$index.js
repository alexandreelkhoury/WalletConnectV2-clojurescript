["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/elliptic/lib/elliptic/eddsa/index.js"],"~:js","shadow$provide[101]=function(S,A,V,q){function F(l){e(\"ed25519\"===l,\"only tested with ed25519 so far\");if(!(this instanceof F))return new F(l);this.curve=l=r[l].curve;this.g=l.g;this.g.precompute(l.n.bitLength()+1);this.pointClass=l.point().constructor;this.encodingLength=Math.ceil(l.n.bitLength()/8);this.hash=G.sha512}var G=A(92),r=A(94),y=A(73),e=y.assert,u=y.parseBytes,p=A(99),n=A(100);V.exports=F;F.prototype.sign=function(l,h){l=u(l);var k=this.keyFromSecret(h),t=this.hashInt(k.messagePrefix(),\nl);h=this.g.mul(t);var B=this.encodePoint(h);l=this.hashInt(B,k.pubBytes(),l).mul(k.priv());l=t.add(l).umod(this.curve.n);return this.makeSignature({R:h,S:l,Rencoded:B})};F.prototype.verify=function(l,h,k){l=u(l);h=this.makeSignature(h);k=this.keyFromPublic(k);l=this.hashInt(h.Rencoded(),k.pubBytes(),l);var t=this.g.mul(h.S());return h.R().add(k.pub().mul(l)).eq(t)};F.prototype.hashInt=function(){for(var l=this.hash(),h=0;h<arguments.length;h++)l.update(arguments[h]);return y.intFromLE(l.digest()).umod(this.curve.n)};\nF.prototype.keyFromPublic=function(l){return p.fromPublic(this,l)};F.prototype.keyFromSecret=function(l){return p.fromSecret(this,l)};F.prototype.makeSignature=function(l){return l instanceof n?l:new n(this,l)};F.prototype.encodePoint=function(l){var h=l.getY().toArray(\"le\",this.encodingLength);h[this.encodingLength-1]|=l.getX().isOdd()?128:0;return h};F.prototype.decodePoint=function(l){l=y.parseBytes(l);var h=l.length-1,k=l.slice(0,h).concat(l[h]&-129);l=0!==(l[h]&128);k=y.intFromLE(k);return this.curve.pointFromY(k,\nl)};F.prototype.encodeInt=function(l){return l.toArray(\"le\",this.encodingLength)};F.prototype.decodeInt=function(l){return y.intFromLE(l)};F.prototype.isPoint=function(l){return l instanceof this.pointClass}}","~:source","shadow$provide[101] = function(global,require,module,exports) {\n'use strict';\n\nvar hash = require('hash.js');\nvar curves = require('../curves');\nvar utils = require('../utils');\nvar assert = utils.assert;\nvar parseBytes = utils.parseBytes;\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EDDSA(curve) {\n  assert(curve === 'ed25519', 'only tested with ed25519 so far');\n\n  if (!(this instanceof EDDSA))\n    return new EDDSA(curve);\n\n  curve = curves[curve].curve;\n  this.curve = curve;\n  this.g = curve.g;\n  this.g.precompute(curve.n.bitLength() + 1);\n\n  this.pointClass = curve.point().constructor;\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\n  this.hash = hash.sha512;\n}\n\nmodule.exports = EDDSA;\n\n/**\n* @param {Array|String} message - message bytes\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\n* @returns {Signature} - signature\n*/\nEDDSA.prototype.sign = function sign(message, secret) {\n  message = parseBytes(message);\n  var key = this.keyFromSecret(secret);\n  var r = this.hashInt(key.messagePrefix(), message);\n  var R = this.g.mul(r);\n  var Rencoded = this.encodePoint(R);\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)\n    .mul(key.priv());\n  var S = r.add(s_).umod(this.curve.n);\n  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });\n};\n\n/**\n* @param {Array} message - message bytes\n* @param {Array|String|Signature} sig - sig bytes\n* @param {Array|String|Point|KeyPair} pub - public key\n* @returns {Boolean} - true if public key matches sig of message\n*/\nEDDSA.prototype.verify = function verify(message, sig, pub) {\n  message = parseBytes(message);\n  sig = this.makeSignature(sig);\n  var key = this.keyFromPublic(pub);\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\n  var SG = this.g.mul(sig.S());\n  var RplusAh = sig.R().add(key.pub().mul(h));\n  return RplusAh.eq(SG);\n};\n\nEDDSA.prototype.hashInt = function hashInt() {\n  var hash = this.hash();\n  for (var i = 0; i < arguments.length; i++)\n    hash.update(arguments[i]);\n  return utils.intFromLE(hash.digest()).umod(this.curve.n);\n};\n\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\n  return KeyPair.fromPublic(this, pub);\n};\n\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\n  return KeyPair.fromSecret(this, secret);\n};\n\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\n  if (sig instanceof Signature)\n    return sig;\n  return new Signature(this, sig);\n};\n\n/**\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\n*\n* EDDSA defines methods for encoding and decoding points and integers. These are\n* helper convenience methods, that pass along to utility functions implied\n* parameters.\n*\n*/\nEDDSA.prototype.encodePoint = function encodePoint(point) {\n  var enc = point.getY().toArray('le', this.encodingLength);\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n};\n\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\n  bytes = utils.parseBytes(bytes);\n\n  var lastIx = bytes.length - 1;\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\n\n  var y = utils.intFromLE(normed);\n  return this.curve.pointFromY(y, xIsOdd);\n};\n\nEDDSA.prototype.encodeInt = function encodeInt(num) {\n  return num.toArray('le', this.encodingLength);\n};\n\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\n  return utils.intFromLE(bytes);\n};\n\nEDDSA.prototype.isPoint = function isPoint(val) {\n  return val instanceof this.pointClass;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$elliptic$lib$elliptic$eddsa$key","~$module$node_modules$hash_DOT_js$lib$hash","~$module$node_modules$elliptic$lib$elliptic$eddsa$signature","~$module$node_modules$elliptic$lib$elliptic$curves","~$module$node_modules$elliptic$lib$elliptic$utils"]],"~:properties",["^5",["pointClass","makeSignature","curve","encodingLength","hash","encodePoint","S","keyFromPublic","decodePoint","verify","R","Rencoded","encodeInt","keyFromSecret","g","isPoint","sign","hashInt","decodeInt"]],"~:compiled-at",1695041440756,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$elliptic$lib$elliptic$eddsa$index.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/elliptic/lib/elliptic/eddsa/index.js\"],\n\"sourcesContent\":[\"shadow$provide[101] = function(global,require,module,exports) {\\n'use strict';\\n\\nvar hash = require('hash.js');\\nvar curves = require('../curves');\\nvar utils = require('../utils');\\nvar assert = utils.assert;\\nvar parseBytes = utils.parseBytes;\\nvar KeyPair = require('./key');\\nvar Signature = require('./signature');\\n\\nfunction EDDSA(curve) {\\n  assert(curve === 'ed25519', 'only tested with ed25519 so far');\\n\\n  if (!(this instanceof EDDSA))\\n    return new EDDSA(curve);\\n\\n  curve = curves[curve].curve;\\n  this.curve = curve;\\n  this.g = curve.g;\\n  this.g.precompute(curve.n.bitLength() + 1);\\n\\n  this.pointClass = curve.point().constructor;\\n  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);\\n  this.hash = hash.sha512;\\n}\\n\\nmodule.exports = EDDSA;\\n\\n/**\\n* @param {Array|String} message - message bytes\\n* @param {Array|String|KeyPair} secret - secret bytes or a keypair\\n* @returns {Signature} - signature\\n*/\\nEDDSA.prototype.sign = function sign(message, secret) {\\n  message = parseBytes(message);\\n  var key = this.keyFromSecret(secret);\\n  var r = this.hashInt(key.messagePrefix(), message);\\n  var R = this.g.mul(r);\\n  var Rencoded = this.encodePoint(R);\\n  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)\\n    .mul(key.priv());\\n  var S = r.add(s_).umod(this.curve.n);\\n  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });\\n};\\n\\n/**\\n* @param {Array} message - message bytes\\n* @param {Array|String|Signature} sig - sig bytes\\n* @param {Array|String|Point|KeyPair} pub - public key\\n* @returns {Boolean} - true if public key matches sig of message\\n*/\\nEDDSA.prototype.verify = function verify(message, sig, pub) {\\n  message = parseBytes(message);\\n  sig = this.makeSignature(sig);\\n  var key = this.keyFromPublic(pub);\\n  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);\\n  var SG = this.g.mul(sig.S());\\n  var RplusAh = sig.R().add(key.pub().mul(h));\\n  return RplusAh.eq(SG);\\n};\\n\\nEDDSA.prototype.hashInt = function hashInt() {\\n  var hash = this.hash();\\n  for (var i = 0; i < arguments.length; i++)\\n    hash.update(arguments[i]);\\n  return utils.intFromLE(hash.digest()).umod(this.curve.n);\\n};\\n\\nEDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {\\n  return KeyPair.fromPublic(this, pub);\\n};\\n\\nEDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {\\n  return KeyPair.fromSecret(this, secret);\\n};\\n\\nEDDSA.prototype.makeSignature = function makeSignature(sig) {\\n  if (sig instanceof Signature)\\n    return sig;\\n  return new Signature(this, sig);\\n};\\n\\n/**\\n* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2\\n*\\n* EDDSA defines methods for encoding and decoding points and integers. These are\\n* helper convenience methods, that pass along to utility functions implied\\n* parameters.\\n*\\n*/\\nEDDSA.prototype.encodePoint = function encodePoint(point) {\\n  var enc = point.getY().toArray('le', this.encodingLength);\\n  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\\n  return enc;\\n};\\n\\nEDDSA.prototype.decodePoint = function decodePoint(bytes) {\\n  bytes = utils.parseBytes(bytes);\\n\\n  var lastIx = bytes.length - 1;\\n  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);\\n  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;\\n\\n  var y = utils.intFromLE(normed);\\n  return this.curve.pointFromY(y, xIsOdd);\\n};\\n\\nEDDSA.prototype.encodeInt = function encodeInt(num) {\\n  return num.toArray('le', this.encodingLength);\\n};\\n\\nEDDSA.prototype.decodeInt = function decodeInt(bytes) {\\n  return utils.intFromLE(bytes);\\n};\\n\\nEDDSA.prototype.isPoint = function isPoint(val) {\\n  return val instanceof this.pointClass;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"EDDSA\",\"curve\",\"assert\",\"curves\",\"g\",\"precompute\",\"n\",\"bitLength\",\"pointClass\",\"point\",\"constructor\",\"encodingLength\",\"Math\",\"ceil\",\"hash\",\"sha512\",\"utils\",\"parseBytes\",\"KeyPair\",\"Signature\",\"prototype\",\"sign\",\"EDDSA.prototype.sign\",\"message\",\"secret\",\"key\",\"keyFromSecret\",\"r\",\"hashInt\",\"messagePrefix\",\"R\",\"mul\",\"Rencoded\",\"encodePoint\",\"s_\",\"pubBytes\",\"priv\",\"S\",\"add\",\"umod\",\"makeSignature\",\"verify\",\"EDDSA.prototype.verify\",\"sig\",\"pub\",\"keyFromPublic\",\"h\",\"SG\",\"RplusAh\",\"eq\",\"EDDSA.prototype.hashInt\",\"i\",\"arguments\",\"length\",\"update\",\"intFromLE\",\"digest\",\"EDDSA.prototype.keyFromPublic\",\"fromPublic\",\"EDDSA.prototype.keyFromSecret\",\"fromSecret\",\"EDDSA.prototype.makeSignature\",\"EDDSA.prototype.encodePoint\",\"enc\",\"getY\",\"toArray\",\"getX\",\"isOdd\",\"decodePoint\",\"EDDSA.prototype.decodePoint\",\"bytes\",\"lastIx\",\"normed\",\"slice\",\"concat\",\"xIsOdd\",\"y\",\"pointFromY\",\"encodeInt\",\"EDDSA.prototype.encodeInt\",\"num\",\"decodeInt\",\"EDDSA.prototype.decodeInt\",\"isPoint\",\"EDDSA.prototype.isPoint\",\"val\"]\n}\n"]