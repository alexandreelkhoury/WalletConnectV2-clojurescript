shadow$provide.module$node_modules$$noble$curves$abstract$utils=function(global,require,module,exports){function bytesToHex(bytes){if(!(bytes instanceof Uint8Array))throw Error("Uint8Array expected");let hex="";for(let i=0;i<bytes.length;i++)hex+=hexes[bytes[i]];return hex}function numberToHexUnpadded(num){num=num.toString(16);return num.length&1?`0${num}`:num}function hexToNumber(hex){if("string"!==typeof hex)throw Error("hex string expected, got "+typeof hex);return BigInt(""===hex?"0":`0x${hex}`)}
function hexToBytes(hex){if("string"!==typeof hex)throw Error("hex string expected, got "+typeof hex);var len=hex.length;if(len%2)throw Error("padded hex string expected, got unpadded hex of length "+len);len=new Uint8Array(len/2);for(let i=0;i<len.length;i++){var j=2*i;j=hex.slice(j,j+2);j=Number.parseInt(j,16);if(Number.isNaN(j)||0>j)throw Error("Invalid byte sequence");len[i]=j}return len}function numberToBytesBE(n,len){return hexToBytes(n.toString(16).padStart(2*len,"0"))}function concatBytes(...arrays){const r=
new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!(a instanceof Uint8Array))throw Error("Uint8Array expected");r.set(a,pad);pad+=a.length});return r}Object.defineProperty(exports,"__esModule",{value:!0});exports.validateObject=exports.createHmacDrbg=exports.bitMask=exports.bitSet=exports.bitGet=exports.bitLen=exports.utf8ToBytes=exports.equalBytes=exports.concatBytes=exports.ensureBytes=exports.numberToVarBytesBE=exports.numberToBytesLE=exports.numberToBytesBE=
exports.bytesToNumberLE=exports.bytesToNumberBE=exports.hexToBytes=exports.hexToNumber=exports.numberToHexUnpadded=exports.bytesToHex=void 0;const _0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),hexes=Array.from({length:256},(_,i)=>i.toString(16).padStart(2,"0"));exports.bytesToHex=bytesToHex;exports.numberToHexUnpadded=numberToHexUnpadded;exports.hexToNumber=hexToNumber;exports.hexToBytes=hexToBytes;exports.bytesToNumberBE=function(bytes){return hexToNumber(bytesToHex(bytes))};exports.bytesToNumberLE=
function(bytes){if(!(bytes instanceof Uint8Array))throw Error("Uint8Array expected");return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()))};exports.numberToBytesBE=numberToBytesBE;exports.numberToBytesLE=function(n,len){return numberToBytesBE(n,len).reverse()};exports.numberToVarBytesBE=function(n){return hexToBytes(numberToHexUnpadded(n))};exports.ensureBytes=function(title,hex,expectedLength){let res;if("string"===typeof hex)try{res=hexToBytes(hex)}catch(e){throw Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
}else if(hex instanceof Uint8Array)res=Uint8Array.from(hex);else throw Error(`${title} must be hex string or Uint8Array`);hex=res.length;if("number"===typeof expectedLength&&hex!==expectedLength)throw Error(`${title} expected ${expectedLength} bytes, got ${hex}`);return res};exports.concatBytes=concatBytes;exports.equalBytes=function(b1,b2){if(b1.length!==b2.length)return!1;for(let i=0;i<b1.length;i++)if(b1[i]!==b2[i])return!1;return!0};exports.utf8ToBytes=function(str){if("string"!==typeof str)throw Error(`utf8ToBytes expected string, got ${typeof str}`);
return new Uint8Array((new TextEncoder).encode(str))};exports.bitLen=function(n){let len;for(len=0;n>_0n;n>>=_1n,len+=1);return len};exports.bitGet=function(n,pos){return n>>BigInt(pos)&_1n};exports.bitSet=(n,pos,value)=>n|(value?_1n:_0n)<<BigInt(pos);exports.bitMask=n=>(_2n<<BigInt(n-1))-_1n;exports.createHmacDrbg=function(hashLen,qByteLen,hmacFn){if("number"!==typeof hashLen||2>hashLen)throw Error("hashLen must be a number");if("number"!==typeof qByteLen||2>qByteLen)throw Error("qByteLen must be a number");
if("function"!==typeof hmacFn)throw Error("hmacFn must be a function");let v=new Uint8Array(hashLen),k=new Uint8Array(hashLen),i=0;const reseed=(seed=new Uint8Array(void 0))=>{k=hmacFn(k,v,...[Uint8Array.from([0]),seed]);v=hmacFn(k,v,...[]);0!==seed.length&&(k=hmacFn(k,v,...[Uint8Array.from([1]),seed]),v=hmacFn(k,v,...[]))},gen=()=>{if(1E3<=i++)throw Error("drbg: tried 1000 values");let len=0;const out=[];for(;len<qByteLen;){v=hmacFn(k,v,...[]);const sl=v.slice();out.push(sl);len+=v.length}return concatBytes(...out)};
return(seed,pred)=>{v.fill(1);k.fill(0);i=0;for(reseed(seed);!(seed=pred(gen()));)reseed();v.fill(1);k.fill(0);i=0;return seed}};const validatorFns={bigint:val=>"bigint"===typeof val,function:val=>"function"===typeof val,boolean:val=>"boolean"===typeof val,string:val=>"string"===typeof val,stringOrUint8Array:val=>"string"===typeof val||val instanceof Uint8Array,isSafeInteger:val=>Number.isSafeInteger(val),array:val=>Array.isArray(val),field:(val,object)=>object.Fp.isValid(val),hash:val=>"function"===
typeof val&&Number.isSafeInteger(val.outputLen)};exports.validateObject=function(object,validators,optValidators={}){const checkField=(fieldName,type,isOptional)=>{const checkVal=validatorFns[type];if("function"!==typeof checkVal)throw Error(`Invalid validator "${type}", expected function`);const val=object[fieldName];if(!(isOptional&&void 0===val||checkVal(val,object)))throw Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);};for(const [fieldName,type]of Object.entries(validators))checkField(fieldName,
type,!1);for(const [fieldName,type]of Object.entries(optValidators))checkField(fieldName,type,!0);return object}}
//# sourceMappingURL=module$node_modules$$noble$curves$abstract$utils.js.map
