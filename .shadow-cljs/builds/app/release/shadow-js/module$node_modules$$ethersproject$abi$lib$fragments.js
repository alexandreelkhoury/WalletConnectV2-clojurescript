["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/abi/lib/fragments.js"],"~:js","shadow$provide[19]=function(S,A,V,q){function F(f,g){if(\"bytes\"===f||\"string\"===f){if(I[g])return!0}else if(\"address\"===f){if(\"payable\"===g)return!0}else if((0<=f.indexOf(\"[\")||\"tuple\"===f)&&M[g])return!0;(I[g]||\"payable\"===g)&&D.throwArgumentError(\"invalid modifier\",\"name\",g);return!1}function G(f,g){function m(L){D.throwArgumentError(\"unexpected character at position \"+L,\"param\",f)}function w(L){L={type:\"\",name:\"\",parent:L,state:{allowType:!0}};g&&(L.indexed=!1);return L}var x=f;f=f.replace(/\\s/g,\n\" \");for(var z={type:\"\",name:\"\",state:{allowType:!0}},v=z,R=0;R<f.length;R++){var O=f[R];switch(O){case \"(\":v.state.allowType&&\"\"===v.type?v.type=\"tuple\":v.state.allowParams||m(R);v.state.allowType=!1;v.type=l(v.type);v.components=[w(v)];v=v.components[0];break;case \")\":delete v.state;\"indexed\"===v.name&&(g||m(R),v.indexed=!0,v.name=\"\");F(v.type,v.name)&&(v.name=\"\");v.type=l(v.type);O=v;(v=v.parent)||m(R);delete O.parent;v.state.allowParams=!1;v.state.allowName=!0;v.state.allowArray=!0;break;case \",\":delete v.state;\n\"indexed\"===v.name&&(g||m(R),v.indexed=!0,v.name=\"\");F(v.type,v.name)&&(v.name=\"\");v.type=l(v.type);O=w(v.parent);v.parent.components.push(O);delete v.parent;v=O;break;case \" \":v.state.allowType&&\"\"!==v.type&&(v.type=l(v.type),delete v.state.allowType,v.state.allowName=!0,v.state.allowParams=!0);v.state.allowName&&\"\"!==v.name&&(\"indexed\"===v.name?(g||m(R),v.indexed&&m(R),v.indexed=!0,v.name=\"\"):F(v.type,v.name)?v.name=\"\":v.state.allowName=!1);break;case \"[\":v.state.allowArray||m(R);v.type+=O;v.state.allowArray=\n!1;v.state.allowName=!1;v.state.readArray=!0;break;case \"]\":v.state.readArray||m(R);v.type+=O;v.state.readArray=!1;v.state.allowArray=!0;v.state.allowName=!0;break;default:v.state.allowType?(v.type+=O,v.state.allowParams=!0,v.state.allowArray=!0):v.state.allowName?(v.name+=O,delete v.state.allowArray):v.state.readArray?v.type+=O:m(R)}}v.parent&&D.throwArgumentError(\"unexpected eof\",\"param\",f);delete z.state;\"indexed\"===v.name?(g||m(x.length-7),v.indexed&&m(x.length-7),v.indexed=!0,v.name=\"\"):F(v.type,\nv.name)&&(v.name=\"\");z.type=l(z.type);return z}function r(f,g){for(var m in g)(0,E.defineReadOnly)(f,m,g[m])}function y(f,g){return k(f).map(function(m){return J.fromString(m,g)})}function e(f,g){g.gas=null;var m=f.split(\"@\");return 1!==m.length?(2<m.length&&D.throwArgumentError(\"invalid human-readable ABI signature\",\"value\",f),m[1].match(/^[0-9]+$/)||D.throwArgumentError(\"invalid human-readable ABI signature gas\",\"value\",f),g.gas=B.BigNumber.from(m[1]),m[0]):f}function u(f,g){g.constant=!1;g.payable=\n!1;g.stateMutability=\"nonpayable\";f.split(\" \").forEach(function(m){switch(m.trim()){case \"constant\":g.constant=!0;break;case \"payable\":g.payable=!0;g.stateMutability=\"payable\";break;case \"nonpayable\":g.payable=!1;g.stateMutability=\"nonpayable\";break;case \"pure\":g.constant=!0;g.stateMutability=\"pure\";break;case \"view\":g.constant=!0;g.stateMutability=\"view\";break;case \"external\":case \"public\":case \"\":break;default:console.log(\"unknown modifier: \"+m)}})}function p(f){var g={constant:!1,payable:!0,stateMutability:\"payable\"};\nnull!=f.stateMutability?(g.stateMutability=f.stateMutability,g.constant=\"view\"===g.stateMutability||\"pure\"===g.stateMutability,null!=f.constant&&!!f.constant!==g.constant&&D.throwArgumentError(\"cannot have constant function with mutability \"+g.stateMutability,\"value\",f),g.payable=\"payable\"===g.stateMutability,null!=f.payable&&!!f.payable!==g.payable&&D.throwArgumentError(\"cannot have payable function with mutability \"+g.stateMutability,\"value\",f)):null!=f.payable?(g.payable=!!f.payable,null!=f.constant||\ng.payable||\"constructor\"===f.type||D.throwArgumentError(\"unable to determine stateMutability\",\"value\",f),g.constant=!!f.constant,g.stateMutability=g.constant?\"view\":g.payable?\"payable\":\"nonpayable\",g.payable&&g.constant&&D.throwArgumentError(\"cannot have constant payable function\",\"value\",f)):null!=f.constant?(g.constant=!!f.constant,g.payable=!g.constant,g.stateMutability=g.constant?\"view\":\"payable\"):\"constructor\"!==f.type&&D.throwArgumentError(\"unable to determine stateMutability\",\"value\",f);return g}\nfunction n(f){var g=f.format();\"Error(string)\"!==g&&\"Panic(uint256)\"!==g||D.throwArgumentError(\"cannot specify user defined \"+g+\" error\",\"fragment\",f);return f}function l(f){f.match(/^uint($|[^1-9])/)?f=\"uint256\"+f.substring(4):f.match(/^int($|[^1-9])/)&&(f=\"int256\"+f.substring(3));return f}function h(f){f&&f.match(c)||D.throwArgumentError('invalid identifier \"'+f+'\"',\"value\",f);return f}function k(f){f=f.trim();for(var g=[],m=\"\",w=0,x=0;x<f.length;x++){var z=f[x];\",\"===z&&0===w?(g.push(m),m=\"\"):\n(m+=z,\"(\"===z?w++:\")\"===z&&(w--,-1===w&&D.throwArgumentError(\"unbalanced parenthesis\",\"value\",f)))}m&&g.push(m);return g}var t=this&&this.__extends||function(){var f=function(g,m){f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(w,x){w.__proto__=x}||function(w,x){for(var z in x)Object.prototype.hasOwnProperty.call(x,z)&&(w[z]=x[z])};return f(g,m)};return function(g,m){function w(){this.constructor=g}if(\"function\"!==typeof m&&null!==m)throw new TypeError(\"Class extends value \"+String(m)+\n\" is not a constructor or null\");f(g,m);g.prototype=null===m?Object.create(m):(w.prototype=m.prototype,new w)}}();Object.defineProperty(q,\"__esModule\",{value:!0});q.ErrorFragment=q.FunctionFragment=q.ConstructorFragment=q.EventFragment=q.Fragment=q.ParamType=q.FormatTypes=void 0;var B=A(15),E=A(17),H=A(9);S=A(18);var D=new H.Logger(S.version),C={},I={calldata:!0,memory:!0,storage:!0},M={calldata:!0,memory:!0};q.FormatTypes=Object.freeze({sighash:\"sighash\",minimal:\"minimal\",full:\"full\",json:\"json\"});\nvar P=new RegExp(/^(.*)\\[([0-9]*)\\]$/),J=function(){function f(g,m){g!==C&&D.throwError(\"use fromString\",H.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"new ParamType()\"});r(this,m);(g=this.type.match(P))?r(this,{arrayLength:parseInt(g[2]||\"-1\"),arrayChildren:f.fromObject({type:g[1],components:this.components}),baseType:\"array\"}):r(this,{arrayLength:null,arrayChildren:null,baseType:null!=this.components?\"tuple\":this.type});this._isParamType=!0;Object.freeze(this)}f.prototype.format=function(g){g||\n(g=q.FormatTypes.sighash);q.FormatTypes[g]||D.throwArgumentError(\"invalid format type\",\"format\",g);if(g===q.FormatTypes.json){var m={type:\"tuple\"===this.baseType?\"tuple\":this.type,name:this.name||void 0};\"boolean\"===typeof this.indexed&&(m.indexed=this.indexed);this.components&&(m.components=this.components.map(function(w){return JSON.parse(w.format(g))}));return JSON.stringify(m)}m=\"\";\"array\"===this.baseType?(m+=this.arrayChildren.format(g),m+=\"[\"+(0>this.arrayLength?\"\":String(this.arrayLength))+\n\"]\"):\"tuple\"===this.baseType?(g!==q.FormatTypes.sighash&&(m+=this.type),m+=\"(\"+this.components.map(function(w){return w.format(g)}).join(g===q.FormatTypes.full?\", \":\",\")+\")\"):m+=this.type;g!==q.FormatTypes.sighash&&(!0===this.indexed&&(m+=\" indexed\"),g===q.FormatTypes.full&&this.name&&(m+=\" \"+this.name));return m};f.from=function(g,m){return\"string\"===typeof g?f.fromString(g,m):f.fromObject(g)};f.fromObject=function(g){return f.isParamType(g)?g:new f(C,{name:g.name||null,type:l(g.type),indexed:null==\ng.indexed?null:!!g.indexed,components:g.components?g.components.map(f.fromObject):null})};f.fromString=function(g,m){g=G(g,!!m);return f.fromObject({name:g.name,type:g.type,indexed:g.indexed,components:g.components})};f.isParamType=function(g){return!(null==g||!g._isParamType)};return f}();q.ParamType=J;S=function(){function f(g,m){g!==C&&D.throwError(\"use a static from method\",H.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"new Fragment()\"});r(this,m);this._isFragment=!0;Object.freeze(this)}f.from=\nfunction(g){return f.isFragment(g)?g:\"string\"===typeof g?f.fromString(g):f.fromObject(g)};f.fromObject=function(g){if(f.isFragment(g))return g;switch(g.type){case \"function\":return a.fromObject(g);case \"event\":return T.fromObject(g);case \"constructor\":return N.fromObject(g);case \"error\":return b.fromObject(g);case \"fallback\":case \"receive\":return null}return D.throwArgumentError(\"invalid fragment object\",\"value\",g)};f.fromString=function(g){g=g.replace(/\\s/g,\" \");g=g.replace(/\\(/g,\" (\").replace(/\\)/g,\n\") \").replace(/\\s+/g,\" \");g=g.trim();return\"event\"===g.split(\" \")[0]?T.fromString(g.substring(5).trim()):\"function\"===g.split(\" \")[0]?a.fromString(g.substring(8).trim()):\"constructor\"===g.split(\"(\")[0].trim()?N.fromString(g.trim()):\"error\"===g.split(\" \")[0]?b.fromString(g.substring(5).trim()):D.throwArgumentError(\"unsupported fragment\",\"value\",g)};f.isFragment=function(g){return!(!g||!g._isFragment)};return f}();q.Fragment=S;var T=function(f){function g(){return null!==f&&f.apply(this,arguments)||\nthis}t(g,f);g.prototype.format=function(m){m||(m=q.FormatTypes.sighash);q.FormatTypes[m]||D.throwArgumentError(\"invalid format type\",\"format\",m);if(m===q.FormatTypes.json)return JSON.stringify({type:\"event\",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map(function(x){return JSON.parse(x.format(m))})});var w=\"\";m!==q.FormatTypes.sighash&&(w+=\"event \");w+=this.name+\"(\"+this.inputs.map(function(x){return x.format(m)}).join(m===q.FormatTypes.full?\", \":\",\")+\") \";m!==q.FormatTypes.sighash&&\nthis.anonymous&&(w+=\"anonymous \");return w.trim()};g.from=function(m){return\"string\"===typeof m?g.fromString(m):g.fromObject(m)};g.fromObject=function(m){if(g.isEventFragment(m))return m;\"event\"!==m.type&&D.throwArgumentError(\"invalid event object\",\"value\",m);m={name:h(m.name),anonymous:m.anonymous,inputs:m.inputs?m.inputs.map(J.fromObject):[],type:\"event\"};return new g(C,m)};g.fromString=function(m){var w=m.match(d);w||D.throwArgumentError(\"invalid event string\",\"value\",m);var x=!1;w[3].split(\" \").forEach(function(z){switch(z.trim()){case \"anonymous\":x=\n!0;break;case \"\":break;default:D.warn(\"unknown modifier: \"+z)}});return g.fromObject({name:w[1].trim(),anonymous:x,inputs:y(w[2],!0),type:\"event\"})};g.isEventFragment=function(m){return m&&m._isFragment&&\"event\"===m.type};return g}(S);q.EventFragment=T;var N=function(f){function g(){return null!==f&&f.apply(this,arguments)||this}t(g,f);g.prototype.format=function(m){m||(m=q.FormatTypes.sighash);q.FormatTypes[m]||D.throwArgumentError(\"invalid format type\",\"format\",m);if(m===q.FormatTypes.json)return JSON.stringify({type:\"constructor\",\nstateMutability:\"nonpayable\"!==this.stateMutability?this.stateMutability:void 0,payable:this.payable,gas:this.gas?this.gas.toNumber():void 0,inputs:this.inputs.map(function(x){return JSON.parse(x.format(m))})});m===q.FormatTypes.sighash&&D.throwError(\"cannot format a constructor for sighash\",H.Logger.errors.UNSUPPORTED_OPERATION,{operation:\"format(sighash)\"});var w=\"constructor(\"+this.inputs.map(function(x){return x.format(m)}).join(m===q.FormatTypes.full?\", \":\",\")+\") \";this.stateMutability&&\"nonpayable\"!==\nthis.stateMutability&&(w+=this.stateMutability+\" \");return w.trim()};g.from=function(m){return\"string\"===typeof m?g.fromString(m):g.fromObject(m)};g.fromObject=function(m){if(g.isConstructorFragment(m))return m;\"constructor\"!==m.type&&D.throwArgumentError(\"invalid constructor object\",\"value\",m);var w=p(m);w.constant&&D.throwArgumentError(\"constructor cannot be constant\",\"value\",m);m={name:null,type:m.type,inputs:m.inputs?m.inputs.map(J.fromObject):[],payable:w.payable,stateMutability:w.stateMutability,\ngas:m.gas?B.BigNumber.from(m.gas):null};return new g(C,m)};g.fromString=function(m){var w={type:\"constructor\"};m=e(m,w);var x=m.match(d);x&&\"constructor\"===x[1].trim()||D.throwArgumentError(\"invalid constructor string\",\"value\",m);w.inputs=y(x[2].trim(),!1);u(x[3].trim(),w);return g.fromObject(w)};g.isConstructorFragment=function(m){return m&&m._isFragment&&\"constructor\"===m.type};return g}(S);q.ConstructorFragment=N;var a=function(f){function g(){return null!==f&&f.apply(this,arguments)||this}t(g,\nf);g.prototype.format=function(m){m||(m=q.FormatTypes.sighash);q.FormatTypes[m]||D.throwArgumentError(\"invalid format type\",\"format\",m);if(m===q.FormatTypes.json)return JSON.stringify({type:\"function\",name:this.name,constant:this.constant,stateMutability:\"nonpayable\"!==this.stateMutability?this.stateMutability:void 0,payable:this.payable,gas:this.gas?this.gas.toNumber():void 0,inputs:this.inputs.map(function(x){return JSON.parse(x.format(m))}),outputs:this.outputs.map(function(x){return JSON.parse(x.format(m))})});\nvar w=\"\";m!==q.FormatTypes.sighash&&(w+=\"function \");w+=this.name+\"(\"+this.inputs.map(function(x){return x.format(m)}).join(m===q.FormatTypes.full?\", \":\",\")+\") \";m!==q.FormatTypes.sighash&&(this.stateMutability?\"nonpayable\"!==this.stateMutability&&(w+=this.stateMutability+\" \"):this.constant&&(w+=\"view \"),this.outputs&&this.outputs.length&&(w+=\"returns (\"+this.outputs.map(function(x){return x.format(m)}).join(\", \")+\") \"),null!=this.gas&&(w+=\"@\"+this.gas.toString()+\" \"));return w.trim()};g.from=function(m){return\"string\"===\ntypeof m?g.fromString(m):g.fromObject(m)};g.fromObject=function(m){if(g.isFunctionFragment(m))return m;\"function\"!==m.type&&D.throwArgumentError(\"invalid function object\",\"value\",m);var w=p(m);m={type:m.type,name:h(m.name),constant:w.constant,inputs:m.inputs?m.inputs.map(J.fromObject):[],outputs:m.outputs?m.outputs.map(J.fromObject):[],payable:w.payable,stateMutability:w.stateMutability,gas:m.gas?B.BigNumber.from(m.gas):null};return new g(C,m)};g.fromString=function(m){var w={type:\"function\"};m=e(m,\nw);var x=m.split(\" returns \");2<x.length&&D.throwArgumentError(\"invalid function string\",\"value\",m);var z=x[0].match(d);z||D.throwArgumentError(\"invalid function signature\",\"value\",m);w.name=z[1].trim();w.name&&h(w.name);w.inputs=y(z[2],!1);u(z[3].trim(),w);1<x.length?(x=x[1].match(d),\"\"==x[1].trim()&&\"\"==x[3].trim()||D.throwArgumentError(\"unexpected tokens\",\"value\",m),w.outputs=y(x[2],!1)):w.outputs=[];return g.fromObject(w)};g.isFunctionFragment=function(m){return m&&m._isFragment&&\"function\"===\nm.type};return g}(N);q.FunctionFragment=a;var b=function(f){function g(){return null!==f&&f.apply(this,arguments)||this}t(g,f);g.prototype.format=function(m){m||(m=q.FormatTypes.sighash);q.FormatTypes[m]||D.throwArgumentError(\"invalid format type\",\"format\",m);if(m===q.FormatTypes.json)return JSON.stringify({type:\"error\",name:this.name,inputs:this.inputs.map(function(x){return JSON.parse(x.format(m))})});var w=\"\";m!==q.FormatTypes.sighash&&(w+=\"error \");w+=this.name+\"(\"+this.inputs.map(function(x){return x.format(m)}).join(m===\nq.FormatTypes.full?\", \":\",\")+\") \";return w.trim()};g.from=function(m){return\"string\"===typeof m?g.fromString(m):g.fromObject(m)};g.fromObject=function(m){if(g.isErrorFragment(m))return m;\"error\"!==m.type&&D.throwArgumentError(\"invalid error object\",\"value\",m);m={type:m.type,name:h(m.name),inputs:m.inputs?m.inputs.map(J.fromObject):[]};return n(new g(C,m))};g.fromString=function(m){var w={type:\"error\"},x=m.match(d);x||D.throwArgumentError(\"invalid error signature\",\"value\",m);w.name=x[1].trim();w.name&&\nh(w.name);w.inputs=y(x[2],!1);return n(g.fromObject(w))};g.isErrorFragment=function(m){return m&&m._isFragment&&\"error\"===m.type};return g}(S);q.ErrorFragment=b;var c=RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\"),d=RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\")}","~:source","shadow$provide[19] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ErrorFragment = exports.FunctionFragment = exports.ConstructorFragment = exports.EventFragment = exports.Fragment = exports.ParamType = exports.FormatTypes = void 0;\nvar bignumber_1 = require(\"@ethersproject/bignumber\");\nvar properties_1 = require(\"@ethersproject/properties\");\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\n;\nvar _constructorGuard = {};\nvar ModifiersBytes = { calldata: true, memory: true, storage: true };\nvar ModifiersNest = { calldata: true, memory: true };\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    }\n    else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    }\n    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    var originalParam = param;\n    function throwError(i) {\n        logger.throwArgumentError(\"unexpected character at position \" + i, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        var node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    var parent = { type: \"\", name: \"\", state: { allowType: true } };\n    var node = parent;\n    for (var i = 0; i < param.length; i++) {\n        var c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                }\n                else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [newNode(node)];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                var child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                var sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        }\n                        else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    }\n    else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for (var key in params) {\n        (0, properties_1.defineReadOnly)(object, key, params[key]);\n    }\n}\nexports.FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nvar ParamType = /** @class */ (function () {\n    function ParamType(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use fromString\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new ParamType()\"\n            });\n        }\n        populate(this, params);\n        var match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        }\n        else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    ParamType.prototype.format = function (format) {\n        if (!format) {\n            format = exports.FormatTypes.sighash;\n        }\n        if (!exports.FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === exports.FormatTypes.json) {\n            var result_1 = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result_1.indexed = this.indexed;\n            }\n            if (this.components) {\n                result_1.components = this.components.map(function (comp) { return JSON.parse(comp.format(format)); });\n            }\n            return JSON.stringify(result_1);\n        }\n        var result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        }\n        else {\n            if (this.baseType === \"tuple\") {\n                if (format !== exports.FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(function (comp) { return comp.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== exports.FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === exports.FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    };\n    ParamType.from = function (value, allowIndexed) {\n        if (typeof (value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    };\n    ParamType.fromObject = function (value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n        });\n    };\n    ParamType.fromString = function (value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    };\n    ParamType.isParamType = function (value) {\n        return !!(value != null && value._isParamType);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map(function (param) { return ParamType.fromString(param, allowIndex); });\n}\nvar Fragment = /** @class */ (function () {\n    function Fragment(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    Fragment.from = function (value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    };\n    Fragment.fromObject = function (value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    };\n    Fragment.fromString = function (value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        }\n        else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        }\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        }\n        else if (value.split(\" \")[0] === \"error\") {\n            return ErrorFragment.fromString(value.substring(5).trim());\n        }\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    };\n    Fragment.isFragment = function (value) {\n        return !!(value && value._isFragment);\n    };\n    return Fragment;\n}());\nexports.Fragment = Fragment;\nvar EventFragment = /** @class */ (function (_super) {\n    __extends(EventFragment, _super);\n    function EventFragment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    EventFragment.prototype.format = function (format) {\n        if (!format) {\n            format = exports.FormatTypes.sighash;\n        }\n        if (!exports.FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === exports.FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\n            });\n        }\n        var result = \"\";\n        if (format !== exports.FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== exports.FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    };\n    EventFragment.from = function (value) {\n        if (typeof (value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    };\n    EventFragment.fromObject = function (value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n        var params = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n        return new EventFragment(_constructorGuard, params);\n    };\n    EventFragment.fromString = function (value) {\n        var match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n        var anonymous = false;\n        match[3].split(\" \").forEach(function (modifier) {\n            switch (modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    };\n    EventFragment.isEventFragment = function (value) {\n        return (value && value._isFragment && value.type === \"event\");\n    };\n    return EventFragment;\n}(Fragment));\nexports.EventFragment = EventFragment;\nfunction parseGas(value, params) {\n    params.gas = null;\n    var comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = bignumber_1.BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach(function (modifier) {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    var result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n    }\n    else if (value.payable != null) {\n        result.payable = !!value.payable;\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n        result.constant = !!value.constant;\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        }\n        else {\n            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n        }\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n    }\n    else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n    }\n    else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    return result;\n}\nvar ConstructorFragment = /** @class */ (function (_super) {\n    __extends(ConstructorFragment, _super);\n    function ConstructorFragment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ConstructorFragment.prototype.format = function (format) {\n        if (!format) {\n            format = exports.FormatTypes.sighash;\n        }\n        if (!exports.FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === exports.FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\n            });\n        }\n        if (format === exports.FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        var result = \"constructor(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    };\n    ConstructorFragment.from = function (value) {\n        if (typeof (value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    };\n    ConstructorFragment.fromObject = function (value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n        var state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n        var params = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? bignumber_1.BigNumber.from(value.gas) : null)\n        };\n        return new ConstructorFragment(_constructorGuard, params);\n    };\n    ConstructorFragment.fromString = function (value) {\n        var params = { type: \"constructor\" };\n        value = parseGas(value, params);\n        var parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    };\n    ConstructorFragment.isConstructorFragment = function (value) {\n        return (value && value._isFragment && value.type === \"constructor\");\n    };\n    return ConstructorFragment;\n}(Fragment));\nexports.ConstructorFragment = ConstructorFragment;\nvar FunctionFragment = /** @class */ (function (_super) {\n    __extends(FunctionFragment, _super);\n    function FunctionFragment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    FunctionFragment.prototype.format = function (format) {\n        if (!format) {\n            format = exports.FormatTypes.sighash;\n        }\n        if (!exports.FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === exports.FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),\n                outputs: this.outputs.map(function (output) { return JSON.parse(output.format(format)); }),\n            });\n        }\n        var result = \"\";\n        if (format !== exports.FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== exports.FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            }\n            else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(function (output) { return output.format(format); }).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    };\n    FunctionFragment.from = function (value) {\n        if (typeof (value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    };\n    FunctionFragment.fromObject = function (value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n        var state = verifyState(value);\n        var params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? bignumber_1.BigNumber.from(value.gas) : null)\n        };\n        return new FunctionFragment(_constructorGuard, params);\n    };\n    FunctionFragment.fromString = function (value) {\n        var params = { type: \"function\" };\n        value = parseGas(value, params);\n        var comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n        var parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            var returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        }\n        else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    };\n    FunctionFragment.isFunctionFragment = function (value) {\n        return (value && value._isFragment && value.type === \"function\");\n    };\n    return FunctionFragment;\n}(ConstructorFragment));\nexports.FunctionFragment = FunctionFragment;\n//export class StructFragment extends Fragment {\n//}\nfunction checkForbidden(fragment) {\n    var sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(\"cannot specify user defined \" + sig + \" error\", \"fragment\", fragment);\n    }\n    return fragment;\n}\nvar ErrorFragment = /** @class */ (function (_super) {\n    __extends(ErrorFragment, _super);\n    function ErrorFragment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ErrorFragment.prototype.format = function (format) {\n        if (!format) {\n            format = exports.FormatTypes.sighash;\n        }\n        if (!exports.FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === exports.FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),\n            });\n        }\n        var result = \"\";\n        if (format !== exports.FormatTypes.sighash) {\n            result += \"error \";\n        }\n        result += this.name + \"(\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \", \" : \",\") + \") \";\n        return result.trim();\n    };\n    ErrorFragment.from = function (value) {\n        if (typeof (value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    };\n    ErrorFragment.fromObject = function (value) {\n        if (ErrorFragment.isErrorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n        var params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])\n        };\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    };\n    ErrorFragment.fromString = function (value) {\n        var params = { type: \"error\" };\n        var parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        return checkForbidden(ErrorFragment.fromObject(params));\n    };\n    ErrorFragment.isErrorFragment = function (value) {\n        return (value && value._isFragment && value.type === \"error\");\n    };\n    return ErrorFragment;\n}(Fragment));\nexports.ErrorFragment = ErrorFragment;\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nvar regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(\"invalid identifier \\\"\" + value + \"\\\"\", \"value\", value);\n    }\n    return value;\n}\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    var result = [];\n    var accum = \"\";\n    var depth = 0;\n    for (var offset = 0; offset < value.length; offset++) {\n        var c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        }\n        else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            }\n            else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n//# sourceMappingURL=fragments.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$$ethersproject$bignumber$lib$index","~$module$node_modules$$ethersproject$logger$lib$index","~$module$node_modules$$ethersproject$properties$lib$index","~$module$node_modules$$ethersproject$abi$lib$_version"]],"~:properties",["^5",["json","isFunctionFragment","arrayLength","allowParams","anonymous","prototype","FunctionFragment","fromString","constant","EventFragment","indexed","allowType","baseType","parent","__esModule","storage","minimal","Fragment","allowName","isEventFragment","ConstructorFragment","gas","_isParamType","allowArray","name","stateMutability","value","outputs","full","operation","payable","FormatTypes","memory","arrayChildren","fromObject","type","state","__proto__","from","isParamType","inputs","calldata","components","_isFragment","isConstructorFragment","readArray","ErrorFragment","isErrorFragment","sighash","ParamType","isFragment","format","constructor"]],"~:compiled-at",1695041440682,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$abi$lib$fragments.js\",\n\"lineCount\":30,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@ethersproject/abi/lib/fragments.js\"],\n\"sourcesContent\":[\"shadow$provide[19] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        if (typeof b !== \\\"function\\\" && b !== null)\\n            throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.ErrorFragment = exports.FunctionFragment = exports.ConstructorFragment = exports.EventFragment = exports.Fragment = exports.ParamType = exports.FormatTypes = void 0;\\nvar bignumber_1 = require(\\\"@ethersproject/bignumber\\\");\\nvar properties_1 = require(\\\"@ethersproject/properties\\\");\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"./_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\n;\\nvar _constructorGuard = {};\\nvar ModifiersBytes = { calldata: true, memory: true, storage: true };\\nvar ModifiersNest = { calldata: true, memory: true };\\nfunction checkModifier(type, name) {\\n    if (type === \\\"bytes\\\" || type === \\\"string\\\") {\\n        if (ModifiersBytes[name]) {\\n            return true;\\n        }\\n    }\\n    else if (type === \\\"address\\\") {\\n        if (name === \\\"payable\\\") {\\n            return true;\\n        }\\n    }\\n    else if (type.indexOf(\\\"[\\\") >= 0 || type === \\\"tuple\\\") {\\n        if (ModifiersNest[name]) {\\n            return true;\\n        }\\n    }\\n    if (ModifiersBytes[name] || name === \\\"payable\\\") {\\n        logger.throwArgumentError(\\\"invalid modifier\\\", \\\"name\\\", name);\\n    }\\n    return false;\\n}\\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\\nfunction parseParamType(param, allowIndexed) {\\n    var originalParam = param;\\n    function throwError(i) {\\n        logger.throwArgumentError(\\\"unexpected character at position \\\" + i, \\\"param\\\", param);\\n    }\\n    param = param.replace(/\\\\s/g, \\\" \\\");\\n    function newNode(parent) {\\n        var node = { type: \\\"\\\", name: \\\"\\\", parent: parent, state: { allowType: true } };\\n        if (allowIndexed) {\\n            node.indexed = false;\\n        }\\n        return node;\\n    }\\n    var parent = { type: \\\"\\\", name: \\\"\\\", state: { allowType: true } };\\n    var node = parent;\\n    for (var i = 0; i < param.length; i++) {\\n        var c = param[i];\\n        switch (c) {\\n            case \\\"(\\\":\\n                if (node.state.allowType && node.type === \\\"\\\") {\\n                    node.type = \\\"tuple\\\";\\n                }\\n                else if (!node.state.allowParams) {\\n                    throwError(i);\\n                }\\n                node.state.allowType = false;\\n                node.type = verifyType(node.type);\\n                node.components = [newNode(node)];\\n                node = node.components[0];\\n                break;\\n            case \\\")\\\":\\n                delete node.state;\\n                if (node.name === \\\"indexed\\\") {\\n                    if (!allowIndexed) {\\n                        throwError(i);\\n                    }\\n                    node.indexed = true;\\n                    node.name = \\\"\\\";\\n                }\\n                if (checkModifier(node.type, node.name)) {\\n                    node.name = \\\"\\\";\\n                }\\n                node.type = verifyType(node.type);\\n                var child = node;\\n                node = node.parent;\\n                if (!node) {\\n                    throwError(i);\\n                }\\n                delete child.parent;\\n                node.state.allowParams = false;\\n                node.state.allowName = true;\\n                node.state.allowArray = true;\\n                break;\\n            case \\\",\\\":\\n                delete node.state;\\n                if (node.name === \\\"indexed\\\") {\\n                    if (!allowIndexed) {\\n                        throwError(i);\\n                    }\\n                    node.indexed = true;\\n                    node.name = \\\"\\\";\\n                }\\n                if (checkModifier(node.type, node.name)) {\\n                    node.name = \\\"\\\";\\n                }\\n                node.type = verifyType(node.type);\\n                var sibling = newNode(node.parent);\\n                //{ type: \\\"\\\", name: \\\"\\\", parent: node.parent, state: { allowType: true } };\\n                node.parent.components.push(sibling);\\n                delete node.parent;\\n                node = sibling;\\n                break;\\n            // Hit a space...\\n            case \\\" \\\":\\n                // If reading type, the type is done and may read a param or name\\n                if (node.state.allowType) {\\n                    if (node.type !== \\\"\\\") {\\n                        node.type = verifyType(node.type);\\n                        delete node.state.allowType;\\n                        node.state.allowName = true;\\n                        node.state.allowParams = true;\\n                    }\\n                }\\n                // If reading name, the name is done\\n                if (node.state.allowName) {\\n                    if (node.name !== \\\"\\\") {\\n                        if (node.name === \\\"indexed\\\") {\\n                            if (!allowIndexed) {\\n                                throwError(i);\\n                            }\\n                            if (node.indexed) {\\n                                throwError(i);\\n                            }\\n                            node.indexed = true;\\n                            node.name = \\\"\\\";\\n                        }\\n                        else if (checkModifier(node.type, node.name)) {\\n                            node.name = \\\"\\\";\\n                        }\\n                        else {\\n                            node.state.allowName = false;\\n                        }\\n                    }\\n                }\\n                break;\\n            case \\\"[\\\":\\n                if (!node.state.allowArray) {\\n                    throwError(i);\\n                }\\n                node.type += c;\\n                node.state.allowArray = false;\\n                node.state.allowName = false;\\n                node.state.readArray = true;\\n                break;\\n            case \\\"]\\\":\\n                if (!node.state.readArray) {\\n                    throwError(i);\\n                }\\n                node.type += c;\\n                node.state.readArray = false;\\n                node.state.allowArray = true;\\n                node.state.allowName = true;\\n                break;\\n            default:\\n                if (node.state.allowType) {\\n                    node.type += c;\\n                    node.state.allowParams = true;\\n                    node.state.allowArray = true;\\n                }\\n                else if (node.state.allowName) {\\n                    node.name += c;\\n                    delete node.state.allowArray;\\n                }\\n                else if (node.state.readArray) {\\n                    node.type += c;\\n                }\\n                else {\\n                    throwError(i);\\n                }\\n        }\\n    }\\n    if (node.parent) {\\n        logger.throwArgumentError(\\\"unexpected eof\\\", \\\"param\\\", param);\\n    }\\n    delete parent.state;\\n    if (node.name === \\\"indexed\\\") {\\n        if (!allowIndexed) {\\n            throwError(originalParam.length - 7);\\n        }\\n        if (node.indexed) {\\n            throwError(originalParam.length - 7);\\n        }\\n        node.indexed = true;\\n        node.name = \\\"\\\";\\n    }\\n    else if (checkModifier(node.type, node.name)) {\\n        node.name = \\\"\\\";\\n    }\\n    parent.type = verifyType(parent.type);\\n    return parent;\\n}\\nfunction populate(object, params) {\\n    for (var key in params) {\\n        (0, properties_1.defineReadOnly)(object, key, params[key]);\\n    }\\n}\\nexports.FormatTypes = Object.freeze({\\n    // Bare formatting, as is needed for computing a sighash of an event or function\\n    sighash: \\\"sighash\\\",\\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\\n    minimal: \\\"minimal\\\",\\n    // Human-Readable with nice spacing, including all names\\n    full: \\\"full\\\",\\n    // JSON-format a la Solidity\\n    json: \\\"json\\\"\\n});\\nvar paramTypeArray = new RegExp(/^(.*)\\\\[([0-9]*)\\\\]$/);\\nvar ParamType = /** @class */ (function () {\\n    function ParamType(constructorGuard, params) {\\n        if (constructorGuard !== _constructorGuard) {\\n            logger.throwError(\\\"use fromString\\\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\\n                operation: \\\"new ParamType()\\\"\\n            });\\n        }\\n        populate(this, params);\\n        var match = this.type.match(paramTypeArray);\\n        if (match) {\\n            populate(this, {\\n                arrayLength: parseInt(match[2] || \\\"-1\\\"),\\n                arrayChildren: ParamType.fromObject({\\n                    type: match[1],\\n                    components: this.components\\n                }),\\n                baseType: \\\"array\\\"\\n            });\\n        }\\n        else {\\n            populate(this, {\\n                arrayLength: null,\\n                arrayChildren: null,\\n                baseType: ((this.components != null) ? \\\"tuple\\\" : this.type)\\n            });\\n        }\\n        this._isParamType = true;\\n        Object.freeze(this);\\n    }\\n    // Format the parameter fragment\\n    //   - sighash: \\\"(uint256,address)\\\"\\n    //   - minimal: \\\"tuple(uint256,address) indexed\\\"\\n    //   - full:    \\\"tuple(uint256 foo, address bar) indexed baz\\\"\\n    ParamType.prototype.format = function (format) {\\n        if (!format) {\\n            format = exports.FormatTypes.sighash;\\n        }\\n        if (!exports.FormatTypes[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === exports.FormatTypes.json) {\\n            var result_1 = {\\n                type: ((this.baseType === \\\"tuple\\\") ? \\\"tuple\\\" : this.type),\\n                name: (this.name || undefined)\\n            };\\n            if (typeof (this.indexed) === \\\"boolean\\\") {\\n                result_1.indexed = this.indexed;\\n            }\\n            if (this.components) {\\n                result_1.components = this.components.map(function (comp) { return JSON.parse(comp.format(format)); });\\n            }\\n            return JSON.stringify(result_1);\\n        }\\n        var result = \\\"\\\";\\n        // Array\\n        if (this.baseType === \\\"array\\\") {\\n            result += this.arrayChildren.format(format);\\n            result += \\\"[\\\" + (this.arrayLength < 0 ? \\\"\\\" : String(this.arrayLength)) + \\\"]\\\";\\n        }\\n        else {\\n            if (this.baseType === \\\"tuple\\\") {\\n                if (format !== exports.FormatTypes.sighash) {\\n                    result += this.type;\\n                }\\n                result += \\\"(\\\" + this.components.map(function (comp) { return comp.format(format); }).join((format === exports.FormatTypes.full) ? \\\", \\\" : \\\",\\\") + \\\")\\\";\\n            }\\n            else {\\n                result += this.type;\\n            }\\n        }\\n        if (format !== exports.FormatTypes.sighash) {\\n            if (this.indexed === true) {\\n                result += \\\" indexed\\\";\\n            }\\n            if (format === exports.FormatTypes.full && this.name) {\\n                result += \\\" \\\" + this.name;\\n            }\\n        }\\n        return result;\\n    };\\n    ParamType.from = function (value, allowIndexed) {\\n        if (typeof (value) === \\\"string\\\") {\\n            return ParamType.fromString(value, allowIndexed);\\n        }\\n        return ParamType.fromObject(value);\\n    };\\n    ParamType.fromObject = function (value) {\\n        if (ParamType.isParamType(value)) {\\n            return value;\\n        }\\n        return new ParamType(_constructorGuard, {\\n            name: (value.name || null),\\n            type: verifyType(value.type),\\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\\n        });\\n    };\\n    ParamType.fromString = function (value, allowIndexed) {\\n        function ParamTypify(node) {\\n            return ParamType.fromObject({\\n                name: node.name,\\n                type: node.type,\\n                indexed: node.indexed,\\n                components: node.components\\n            });\\n        }\\n        return ParamTypify(parseParamType(value, !!allowIndexed));\\n    };\\n    ParamType.isParamType = function (value) {\\n        return !!(value != null && value._isParamType);\\n    };\\n    return ParamType;\\n}());\\nexports.ParamType = ParamType;\\n;\\nfunction parseParams(value, allowIndex) {\\n    return splitNesting(value).map(function (param) { return ParamType.fromString(param, allowIndex); });\\n}\\nvar Fragment = /** @class */ (function () {\\n    function Fragment(constructorGuard, params) {\\n        if (constructorGuard !== _constructorGuard) {\\n            logger.throwError(\\\"use a static from method\\\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\\n                operation: \\\"new Fragment()\\\"\\n            });\\n        }\\n        populate(this, params);\\n        this._isFragment = true;\\n        Object.freeze(this);\\n    }\\n    Fragment.from = function (value) {\\n        if (Fragment.isFragment(value)) {\\n            return value;\\n        }\\n        if (typeof (value) === \\\"string\\\") {\\n            return Fragment.fromString(value);\\n        }\\n        return Fragment.fromObject(value);\\n    };\\n    Fragment.fromObject = function (value) {\\n        if (Fragment.isFragment(value)) {\\n            return value;\\n        }\\n        switch (value.type) {\\n            case \\\"function\\\":\\n                return FunctionFragment.fromObject(value);\\n            case \\\"event\\\":\\n                return EventFragment.fromObject(value);\\n            case \\\"constructor\\\":\\n                return ConstructorFragment.fromObject(value);\\n            case \\\"error\\\":\\n                return ErrorFragment.fromObject(value);\\n            case \\\"fallback\\\":\\n            case \\\"receive\\\":\\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\\n                return null;\\n        }\\n        return logger.throwArgumentError(\\\"invalid fragment object\\\", \\\"value\\\", value);\\n    };\\n    Fragment.fromString = function (value) {\\n        // Make sure the \\\"returns\\\" is surrounded by a space and all whitespace is exactly one space\\n        value = value.replace(/\\\\s/g, \\\" \\\");\\n        value = value.replace(/\\\\(/g, \\\" (\\\").replace(/\\\\)/g, \\\") \\\").replace(/\\\\s+/g, \\\" \\\");\\n        value = value.trim();\\n        if (value.split(\\\" \\\")[0] === \\\"event\\\") {\\n            return EventFragment.fromString(value.substring(5).trim());\\n        }\\n        else if (value.split(\\\" \\\")[0] === \\\"function\\\") {\\n            return FunctionFragment.fromString(value.substring(8).trim());\\n        }\\n        else if (value.split(\\\"(\\\")[0].trim() === \\\"constructor\\\") {\\n            return ConstructorFragment.fromString(value.trim());\\n        }\\n        else if (value.split(\\\" \\\")[0] === \\\"error\\\") {\\n            return ErrorFragment.fromString(value.substring(5).trim());\\n        }\\n        return logger.throwArgumentError(\\\"unsupported fragment\\\", \\\"value\\\", value);\\n    };\\n    Fragment.isFragment = function (value) {\\n        return !!(value && value._isFragment);\\n    };\\n    return Fragment;\\n}());\\nexports.Fragment = Fragment;\\nvar EventFragment = /** @class */ (function (_super) {\\n    __extends(EventFragment, _super);\\n    function EventFragment() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    EventFragment.prototype.format = function (format) {\\n        if (!format) {\\n            format = exports.FormatTypes.sighash;\\n        }\\n        if (!exports.FormatTypes[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === exports.FormatTypes.json) {\\n            return JSON.stringify({\\n                type: \\\"event\\\",\\n                anonymous: this.anonymous,\\n                name: this.name,\\n                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\\n            });\\n        }\\n        var result = \\\"\\\";\\n        if (format !== exports.FormatTypes.sighash) {\\n            result += \\\"event \\\";\\n        }\\n        result += this.name + \\\"(\\\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \\\", \\\" : \\\",\\\") + \\\") \\\";\\n        if (format !== exports.FormatTypes.sighash) {\\n            if (this.anonymous) {\\n                result += \\\"anonymous \\\";\\n            }\\n        }\\n        return result.trim();\\n    };\\n    EventFragment.from = function (value) {\\n        if (typeof (value) === \\\"string\\\") {\\n            return EventFragment.fromString(value);\\n        }\\n        return EventFragment.fromObject(value);\\n    };\\n    EventFragment.fromObject = function (value) {\\n        if (EventFragment.isEventFragment(value)) {\\n            return value;\\n        }\\n        if (value.type !== \\\"event\\\") {\\n            logger.throwArgumentError(\\\"invalid event object\\\", \\\"value\\\", value);\\n        }\\n        var params = {\\n            name: verifyIdentifier(value.name),\\n            anonymous: value.anonymous,\\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\\n            type: \\\"event\\\"\\n        };\\n        return new EventFragment(_constructorGuard, params);\\n    };\\n    EventFragment.fromString = function (value) {\\n        var match = value.match(regexParen);\\n        if (!match) {\\n            logger.throwArgumentError(\\\"invalid event string\\\", \\\"value\\\", value);\\n        }\\n        var anonymous = false;\\n        match[3].split(\\\" \\\").forEach(function (modifier) {\\n            switch (modifier.trim()) {\\n                case \\\"anonymous\\\":\\n                    anonymous = true;\\n                    break;\\n                case \\\"\\\":\\n                    break;\\n                default:\\n                    logger.warn(\\\"unknown modifier: \\\" + modifier);\\n            }\\n        });\\n        return EventFragment.fromObject({\\n            name: match[1].trim(),\\n            anonymous: anonymous,\\n            inputs: parseParams(match[2], true),\\n            type: \\\"event\\\"\\n        });\\n    };\\n    EventFragment.isEventFragment = function (value) {\\n        return (value && value._isFragment && value.type === \\\"event\\\");\\n    };\\n    return EventFragment;\\n}(Fragment));\\nexports.EventFragment = EventFragment;\\nfunction parseGas(value, params) {\\n    params.gas = null;\\n    var comps = value.split(\\\"@\\\");\\n    if (comps.length !== 1) {\\n        if (comps.length > 2) {\\n            logger.throwArgumentError(\\\"invalid human-readable ABI signature\\\", \\\"value\\\", value);\\n        }\\n        if (!comps[1].match(/^[0-9]+$/)) {\\n            logger.throwArgumentError(\\\"invalid human-readable ABI signature gas\\\", \\\"value\\\", value);\\n        }\\n        params.gas = bignumber_1.BigNumber.from(comps[1]);\\n        return comps[0];\\n    }\\n    return value;\\n}\\nfunction parseModifiers(value, params) {\\n    params.constant = false;\\n    params.payable = false;\\n    params.stateMutability = \\\"nonpayable\\\";\\n    value.split(\\\" \\\").forEach(function (modifier) {\\n        switch (modifier.trim()) {\\n            case \\\"constant\\\":\\n                params.constant = true;\\n                break;\\n            case \\\"payable\\\":\\n                params.payable = true;\\n                params.stateMutability = \\\"payable\\\";\\n                break;\\n            case \\\"nonpayable\\\":\\n                params.payable = false;\\n                params.stateMutability = \\\"nonpayable\\\";\\n                break;\\n            case \\\"pure\\\":\\n                params.constant = true;\\n                params.stateMutability = \\\"pure\\\";\\n                break;\\n            case \\\"view\\\":\\n                params.constant = true;\\n                params.stateMutability = \\\"view\\\";\\n                break;\\n            case \\\"external\\\":\\n            case \\\"public\\\":\\n            case \\\"\\\":\\n                break;\\n            default:\\n                console.log(\\\"unknown modifier: \\\" + modifier);\\n        }\\n    });\\n}\\nfunction verifyState(value) {\\n    var result = {\\n        constant: false,\\n        payable: true,\\n        stateMutability: \\\"payable\\\"\\n    };\\n    if (value.stateMutability != null) {\\n        result.stateMutability = value.stateMutability;\\n        // Set (and check things are consistent) the constant property\\n        result.constant = (result.stateMutability === \\\"view\\\" || result.stateMutability === \\\"pure\\\");\\n        if (value.constant != null) {\\n            if ((!!value.constant) !== result.constant) {\\n                logger.throwArgumentError(\\\"cannot have constant function with mutability \\\" + result.stateMutability, \\\"value\\\", value);\\n            }\\n        }\\n        // Set (and check things are consistent) the payable property\\n        result.payable = (result.stateMutability === \\\"payable\\\");\\n        if (value.payable != null) {\\n            if ((!!value.payable) !== result.payable) {\\n                logger.throwArgumentError(\\\"cannot have payable function with mutability \\\" + result.stateMutability, \\\"value\\\", value);\\n            }\\n        }\\n    }\\n    else if (value.payable != null) {\\n        result.payable = !!value.payable;\\n        // If payable we can assume non-constant; otherwise we can't assume\\n        if (value.constant == null && !result.payable && value.type !== \\\"constructor\\\") {\\n            logger.throwArgumentError(\\\"unable to determine stateMutability\\\", \\\"value\\\", value);\\n        }\\n        result.constant = !!value.constant;\\n        if (result.constant) {\\n            result.stateMutability = \\\"view\\\";\\n        }\\n        else {\\n            result.stateMutability = (result.payable ? \\\"payable\\\" : \\\"nonpayable\\\");\\n        }\\n        if (result.payable && result.constant) {\\n            logger.throwArgumentError(\\\"cannot have constant payable function\\\", \\\"value\\\", value);\\n        }\\n    }\\n    else if (value.constant != null) {\\n        result.constant = !!value.constant;\\n        result.payable = !result.constant;\\n        result.stateMutability = (result.constant ? \\\"view\\\" : \\\"payable\\\");\\n    }\\n    else if (value.type !== \\\"constructor\\\") {\\n        logger.throwArgumentError(\\\"unable to determine stateMutability\\\", \\\"value\\\", value);\\n    }\\n    return result;\\n}\\nvar ConstructorFragment = /** @class */ (function (_super) {\\n    __extends(ConstructorFragment, _super);\\n    function ConstructorFragment() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    ConstructorFragment.prototype.format = function (format) {\\n        if (!format) {\\n            format = exports.FormatTypes.sighash;\\n        }\\n        if (!exports.FormatTypes[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === exports.FormatTypes.json) {\\n            return JSON.stringify({\\n                type: \\\"constructor\\\",\\n                stateMutability: ((this.stateMutability !== \\\"nonpayable\\\") ? this.stateMutability : undefined),\\n                payable: this.payable,\\n                gas: (this.gas ? this.gas.toNumber() : undefined),\\n                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\\n            });\\n        }\\n        if (format === exports.FormatTypes.sighash) {\\n            logger.throwError(\\\"cannot format a constructor for sighash\\\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\\n                operation: \\\"format(sighash)\\\"\\n            });\\n        }\\n        var result = \\\"constructor(\\\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \\\", \\\" : \\\",\\\") + \\\") \\\";\\n        if (this.stateMutability && this.stateMutability !== \\\"nonpayable\\\") {\\n            result += this.stateMutability + \\\" \\\";\\n        }\\n        return result.trim();\\n    };\\n    ConstructorFragment.from = function (value) {\\n        if (typeof (value) === \\\"string\\\") {\\n            return ConstructorFragment.fromString(value);\\n        }\\n        return ConstructorFragment.fromObject(value);\\n    };\\n    ConstructorFragment.fromObject = function (value) {\\n        if (ConstructorFragment.isConstructorFragment(value)) {\\n            return value;\\n        }\\n        if (value.type !== \\\"constructor\\\") {\\n            logger.throwArgumentError(\\\"invalid constructor object\\\", \\\"value\\\", value);\\n        }\\n        var state = verifyState(value);\\n        if (state.constant) {\\n            logger.throwArgumentError(\\\"constructor cannot be constant\\\", \\\"value\\\", value);\\n        }\\n        var params = {\\n            name: null,\\n            type: value.type,\\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\\n            payable: state.payable,\\n            stateMutability: state.stateMutability,\\n            gas: (value.gas ? bignumber_1.BigNumber.from(value.gas) : null)\\n        };\\n        return new ConstructorFragment(_constructorGuard, params);\\n    };\\n    ConstructorFragment.fromString = function (value) {\\n        var params = { type: \\\"constructor\\\" };\\n        value = parseGas(value, params);\\n        var parens = value.match(regexParen);\\n        if (!parens || parens[1].trim() !== \\\"constructor\\\") {\\n            logger.throwArgumentError(\\\"invalid constructor string\\\", \\\"value\\\", value);\\n        }\\n        params.inputs = parseParams(parens[2].trim(), false);\\n        parseModifiers(parens[3].trim(), params);\\n        return ConstructorFragment.fromObject(params);\\n    };\\n    ConstructorFragment.isConstructorFragment = function (value) {\\n        return (value && value._isFragment && value.type === \\\"constructor\\\");\\n    };\\n    return ConstructorFragment;\\n}(Fragment));\\nexports.ConstructorFragment = ConstructorFragment;\\nvar FunctionFragment = /** @class */ (function (_super) {\\n    __extends(FunctionFragment, _super);\\n    function FunctionFragment() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    FunctionFragment.prototype.format = function (format) {\\n        if (!format) {\\n            format = exports.FormatTypes.sighash;\\n        }\\n        if (!exports.FormatTypes[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === exports.FormatTypes.json) {\\n            return JSON.stringify({\\n                type: \\\"function\\\",\\n                name: this.name,\\n                constant: this.constant,\\n                stateMutability: ((this.stateMutability !== \\\"nonpayable\\\") ? this.stateMutability : undefined),\\n                payable: this.payable,\\n                gas: (this.gas ? this.gas.toNumber() : undefined),\\n                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),\\n                outputs: this.outputs.map(function (output) { return JSON.parse(output.format(format)); }),\\n            });\\n        }\\n        var result = \\\"\\\";\\n        if (format !== exports.FormatTypes.sighash) {\\n            result += \\\"function \\\";\\n        }\\n        result += this.name + \\\"(\\\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \\\", \\\" : \\\",\\\") + \\\") \\\";\\n        if (format !== exports.FormatTypes.sighash) {\\n            if (this.stateMutability) {\\n                if (this.stateMutability !== \\\"nonpayable\\\") {\\n                    result += (this.stateMutability + \\\" \\\");\\n                }\\n            }\\n            else if (this.constant) {\\n                result += \\\"view \\\";\\n            }\\n            if (this.outputs && this.outputs.length) {\\n                result += \\\"returns (\\\" + this.outputs.map(function (output) { return output.format(format); }).join(\\\", \\\") + \\\") \\\";\\n            }\\n            if (this.gas != null) {\\n                result += \\\"@\\\" + this.gas.toString() + \\\" \\\";\\n            }\\n        }\\n        return result.trim();\\n    };\\n    FunctionFragment.from = function (value) {\\n        if (typeof (value) === \\\"string\\\") {\\n            return FunctionFragment.fromString(value);\\n        }\\n        return FunctionFragment.fromObject(value);\\n    };\\n    FunctionFragment.fromObject = function (value) {\\n        if (FunctionFragment.isFunctionFragment(value)) {\\n            return value;\\n        }\\n        if (value.type !== \\\"function\\\") {\\n            logger.throwArgumentError(\\\"invalid function object\\\", \\\"value\\\", value);\\n        }\\n        var state = verifyState(value);\\n        var params = {\\n            type: value.type,\\n            name: verifyIdentifier(value.name),\\n            constant: state.constant,\\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\\n            payable: state.payable,\\n            stateMutability: state.stateMutability,\\n            gas: (value.gas ? bignumber_1.BigNumber.from(value.gas) : null)\\n        };\\n        return new FunctionFragment(_constructorGuard, params);\\n    };\\n    FunctionFragment.fromString = function (value) {\\n        var params = { type: \\\"function\\\" };\\n        value = parseGas(value, params);\\n        var comps = value.split(\\\" returns \\\");\\n        if (comps.length > 2) {\\n            logger.throwArgumentError(\\\"invalid function string\\\", \\\"value\\\", value);\\n        }\\n        var parens = comps[0].match(regexParen);\\n        if (!parens) {\\n            logger.throwArgumentError(\\\"invalid function signature\\\", \\\"value\\\", value);\\n        }\\n        params.name = parens[1].trim();\\n        if (params.name) {\\n            verifyIdentifier(params.name);\\n        }\\n        params.inputs = parseParams(parens[2], false);\\n        parseModifiers(parens[3].trim(), params);\\n        // We have outputs\\n        if (comps.length > 1) {\\n            var returns = comps[1].match(regexParen);\\n            if (returns[1].trim() != \\\"\\\" || returns[3].trim() != \\\"\\\") {\\n                logger.throwArgumentError(\\\"unexpected tokens\\\", \\\"value\\\", value);\\n            }\\n            params.outputs = parseParams(returns[2], false);\\n        }\\n        else {\\n            params.outputs = [];\\n        }\\n        return FunctionFragment.fromObject(params);\\n    };\\n    FunctionFragment.isFunctionFragment = function (value) {\\n        return (value && value._isFragment && value.type === \\\"function\\\");\\n    };\\n    return FunctionFragment;\\n}(ConstructorFragment));\\nexports.FunctionFragment = FunctionFragment;\\n//export class StructFragment extends Fragment {\\n//}\\nfunction checkForbidden(fragment) {\\n    var sig = fragment.format();\\n    if (sig === \\\"Error(string)\\\" || sig === \\\"Panic(uint256)\\\") {\\n        logger.throwArgumentError(\\\"cannot specify user defined \\\" + sig + \\\" error\\\", \\\"fragment\\\", fragment);\\n    }\\n    return fragment;\\n}\\nvar ErrorFragment = /** @class */ (function (_super) {\\n    __extends(ErrorFragment, _super);\\n    function ErrorFragment() {\\n        return _super !== null && _super.apply(this, arguments) || this;\\n    }\\n    ErrorFragment.prototype.format = function (format) {\\n        if (!format) {\\n            format = exports.FormatTypes.sighash;\\n        }\\n        if (!exports.FormatTypes[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === exports.FormatTypes.json) {\\n            return JSON.stringify({\\n                type: \\\"error\\\",\\n                name: this.name,\\n                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),\\n            });\\n        }\\n        var result = \\\"\\\";\\n        if (format !== exports.FormatTypes.sighash) {\\n            result += \\\"error \\\";\\n        }\\n        result += this.name + \\\"(\\\" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? \\\", \\\" : \\\",\\\") + \\\") \\\";\\n        return result.trim();\\n    };\\n    ErrorFragment.from = function (value) {\\n        if (typeof (value) === \\\"string\\\") {\\n            return ErrorFragment.fromString(value);\\n        }\\n        return ErrorFragment.fromObject(value);\\n    };\\n    ErrorFragment.fromObject = function (value) {\\n        if (ErrorFragment.isErrorFragment(value)) {\\n            return value;\\n        }\\n        if (value.type !== \\\"error\\\") {\\n            logger.throwArgumentError(\\\"invalid error object\\\", \\\"value\\\", value);\\n        }\\n        var params = {\\n            type: value.type,\\n            name: verifyIdentifier(value.name),\\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])\\n        };\\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\\n    };\\n    ErrorFragment.fromString = function (value) {\\n        var params = { type: \\\"error\\\" };\\n        var parens = value.match(regexParen);\\n        if (!parens) {\\n            logger.throwArgumentError(\\\"invalid error signature\\\", \\\"value\\\", value);\\n        }\\n        params.name = parens[1].trim();\\n        if (params.name) {\\n            verifyIdentifier(params.name);\\n        }\\n        params.inputs = parseParams(parens[2], false);\\n        return checkForbidden(ErrorFragment.fromObject(params));\\n    };\\n    ErrorFragment.isErrorFragment = function (value) {\\n        return (value && value._isFragment && value.type === \\\"error\\\");\\n    };\\n    return ErrorFragment;\\n}(Fragment));\\nexports.ErrorFragment = ErrorFragment;\\nfunction verifyType(type) {\\n    // These need to be transformed to their full description\\n    if (type.match(/^uint($|[^1-9])/)) {\\n        type = \\\"uint256\\\" + type.substring(4);\\n    }\\n    else if (type.match(/^int($|[^1-9])/)) {\\n        type = \\\"int256\\\" + type.substring(3);\\n    }\\n    // @TODO: more verification\\n    return type;\\n}\\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\\nvar regexIdentifier = new RegExp(\\\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\\\");\\nfunction verifyIdentifier(value) {\\n    if (!value || !value.match(regexIdentifier)) {\\n        logger.throwArgumentError(\\\"invalid identifier \\\\\\\"\\\" + value + \\\"\\\\\\\"\\\", \\\"value\\\", value);\\n    }\\n    return value;\\n}\\nvar regexParen = new RegExp(\\\"^([^)(]*)\\\\\\\\((.*)\\\\\\\\)([^)(]*)$\\\");\\nfunction splitNesting(value) {\\n    value = value.trim();\\n    var result = [];\\n    var accum = \\\"\\\";\\n    var depth = 0;\\n    for (var offset = 0; offset < value.length; offset++) {\\n        var c = value[offset];\\n        if (c === \\\",\\\" && depth === 0) {\\n            result.push(accum);\\n            accum = \\\"\\\";\\n        }\\n        else {\\n            accum += c;\\n            if (c === \\\"(\\\") {\\n                depth++;\\n            }\\n            else if (c === \\\")\\\") {\\n                depth--;\\n                if (depth === -1) {\\n                    logger.throwArgumentError(\\\"unbalanced parenthesis\\\", \\\"value\\\", value);\\n                }\\n            }\\n        }\\n    }\\n    if (accum) {\\n        result.push(accum);\\n    }\\n    return result;\\n}\\n//# sourceMappingURL=fragments.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"checkModifier\",\"type\",\"name\",\"ModifiersBytes\",\"indexOf\",\"ModifiersNest\",\"logger\",\"throwArgumentError\",\"parseParamType\",\"param\",\"allowIndexed\",\"throwError\",\"i\",\"newNode\",\"parent\",\"node\",\"state\",\"allowType\",\"indexed\",\"originalParam\",\"replace\",\"length\",\"c\",\"allowParams\",\"verifyType\",\"components\",\"child\",\"allowName\",\"allowArray\",\"sibling\",\"push\",\"readArray\",\"populate\",\"object\",\"params\",\"key\",\"properties_1\",\"defineReadOnly\",\"parseParams\",\"value\",\"allowIndex\",\"splitNesting\",\"map\",\"ParamType\",\"fromString\",\"parseGas\",\"gas\",\"comps\",\"split\",\"match\",\"bignumber_1\",\"BigNumber\",\"from\",\"parseModifiers\",\"constant\",\"payable\",\"stateMutability\",\"forEach\",\"modifier\",\"trim\",\"console\",\"log\",\"verifyState\",\"result\",\"checkForbidden\",\"fragment\",\"sig\",\"format\",\"substring\",\"verifyIdentifier\",\"regexIdentifier\",\"accum\",\"depth\",\"offset\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"Object\",\"setPrototypeOf\",\"__proto__\",\"Array\",\"p\",\"prototype\",\"hasOwnProperty\",\"call\",\"__\",\"constructor\",\"TypeError\",\"String\",\"create\",\"defineProperty\",\"ErrorFragment\",\"FunctionFragment\",\"ConstructorFragment\",\"EventFragment\",\"Fragment\",\"FormatTypes\",\"logger_1\",\"_version_1\",\"Logger\",\"version\",\"_constructorGuard\",\"calldata\",\"memory\",\"storage\",\"freeze\",\"sighash\",\"minimal\",\"full\",\"json\",\"paramTypeArray\",\"RegExp\",\"constructorGuard\",\"errors\",\"UNSUPPORTED_OPERATION\",\"operation\",\"arrayLength\",\"parseInt\",\"arrayChildren\",\"fromObject\",\"baseType\",\"_isParamType\",\"ParamType.prototype.format\",\"result_1\",\"undefined\",\"comp\",\"JSON\",\"parse\",\"stringify\",\"join\",\"ParamType.from\",\"ParamType.fromObject\",\"isParamType\",\"ParamType.fromString\",\"ParamType.isParamType\",\"_isFragment\",\"Fragment.from\",\"isFragment\",\"Fragment.fromObject\",\"Fragment.fromString\",\"Fragment.isFragment\",\"_super\",\"apply\",\"arguments\",\"EventFragment.prototype.format\",\"anonymous\",\"inputs\",\"input\",\"EventFragment.from\",\"EventFragment.fromObject\",\"isEventFragment\",\"EventFragment.fromString\",\"regexParen\",\"warn\",\"EventFragment.isEventFragment\",\"ConstructorFragment.prototype.format\",\"toNumber\",\"ConstructorFragment.from\",\"ConstructorFragment.fromObject\",\"isConstructorFragment\",\"ConstructorFragment.fromString\",\"parens\",\"ConstructorFragment.isConstructorFragment\",\"FunctionFragment.prototype.format\",\"outputs\",\"output\",\"toString\",\"FunctionFragment.from\",\"FunctionFragment.fromObject\",\"isFunctionFragment\",\"FunctionFragment.fromString\",\"returns\",\"FunctionFragment.isFunctionFragment\",\"ErrorFragment.prototype.format\",\"ErrorFragment.from\",\"ErrorFragment.fromObject\",\"isErrorFragment\",\"ErrorFragment.fromString\",\"ErrorFragment.isErrorFragment\"]\n}\n"]