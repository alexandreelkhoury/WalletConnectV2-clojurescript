["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/asn1_DOT_js/lib/asn1/decoders/der.js"],"~:js","shadow$provide[235]=function(S,A,V,q){function F(l){this.enc=\"der\";this.name=l.name;this.entity=l;this.tree=new G;this.tree._init(l.body)}function G(l){p.call(this,\"der\",l)}function r(l,h){let k=l.readUInt8(h);if(l.isError(k))return k;const t=n.tagClass[k>>6],B=0===(k&32);if(31===(k&31)){let E=k;for(k=0;128===(E&128);){E=l.readUInt8(h);if(l.isError(E))return E;k<<=7;k|=E&127}}else k&=31;return{cls:t,primitive:B,tag:k,tagStr:n.tag[k]}}function y(l,h,k){let t=l.readUInt8(k);if(l.isError(t))return t;\nif(!h&&128===t)return null;if(0===(t&128))return t;h=t&127;if(4<h)return l.error(\"length octect is too long\");t=0;for(let B=0;B<h;B++){t<<=8;const E=l.readUInt8(k);if(l.isError(E))return E;t|=E}return t}S=A(76);const e=A(226),u=A(229).DecoderBuffer,p=A(230),n=A(231);V.exports=F;F.prototype.decode=function(l,h){u.isDecoderBuffer(l)||(l=new u(l,h));return this.tree._decode(l,h)};S(G,p);G.prototype._peekTag=function(l,h,k){if(l.isEmpty())return!1;const t=l.save(),B=r(l,'Failed to peek tag: \"'+h+'\"');\nif(l.isError(B))return B;l.restore(t);return B.tag===h||B.tagStr===h||B.tagStr+\"of\"===h||k};G.prototype._decodeTag=function(l,h,k){const t=r(l,'Failed to decode tag of \"'+h+'\"');if(l.isError(t))return t;var B=y(l,t.primitive,'Failed to get length of \"'+h+'\"');if(l.isError(B))return B;if(!k&&t.tag!==h&&t.tagStr!==h&&t.tagStr+\"of\"!==h)return l.error('Failed to match tag: \"'+h+'\"');if(t.primitive||null!==B)return l.skip(B,'Failed to match body of: \"'+h+'\"');k=l.save();B=this._skipUntilEnd(l,'Failed to skip indefinite length body: \"'+\nthis.tag+'\"');if(l.isError(B))return B;B=l.offset-k.offset;l.restore(k);return l.skip(B,'Failed to match body of: \"'+h+'\"')};G.prototype._skipUntilEnd=function(l,h){for(;;){const t=r(l,h);if(l.isError(t))return t;var k=y(l,t.primitive,h);if(l.isError(k))return k;k=t.primitive||null!==k?l.skip(k):this._skipUntilEnd(l,h);if(l.isError(k))return k;if(\"end\"===t.tagStr)break}};G.prototype._decodeList=function(l,h,k,t){for(h=[];!l.isEmpty();){const B=this._peekTag(l,\"end\");if(l.isError(B))return B;const E=\nk.decode(l,\"der\",t);if(l.isError(E)&&B)break;h.push(E)}return h};G.prototype._decodeStr=function(l,h){if(\"bitstr\"===h)return h=l.readUInt8(),l.isError(h)?h:{unused:h,data:l.raw()};if(\"bmpstr\"===h){h=l.raw();if(1===h.length%2)return l.error(\"Decoding of string type: bmpstr length mismatch\");l=\"\";for(let k=0;k<h.length/2;k++)l+=String.fromCharCode(h.readUInt16BE(2*k));return l}return\"numstr\"===h?(h=l.raw().toString(\"ascii\"),this._isNumstr(h)?h:l.error(\"Decoding of string type: numstr unsupported characters\")):\n\"octstr\"===h||\"objDesc\"===h?l.raw():\"printstr\"===h?(h=l.raw().toString(\"ascii\"),this._isPrintstr(h)?h:l.error(\"Decoding of string type: printstr unsupported characters\")):/str$/.test(h)?l.raw().toString():l.error(\"Decoding of string type: \"+h+\" unsupported\")};G.prototype._decodeObjid=function(l,h,k){var t=[],B=0;let E=0;for(;!l.isEmpty();)E=l.readUInt8(),B<<=7,B|=E&127,0===(E&128)&&(t.push(B),B=0);E&128&&t.push(B);l=t[0]/40|0;B=t[0]%40;k=k?t:[l,B].concat(t.slice(1));h&&(t=h[k.join(\" \")],void 0===\nt&&(t=h[k.join(\".\")]),void 0!==t&&(k=t));return k};G.prototype._decodeTime=function(l,h){var k=l.raw().toString();let t,B,E;if(\"gentime\"===h)l=k.slice(0,4)|0,h=k.slice(4,6)|0,t=k.slice(6,8)|0,B=k.slice(8,10)|0,E=k.slice(10,12)|0,k=k.slice(12,14)|0;else if(\"utctime\"===h)l=k.slice(0,2)|0,h=k.slice(2,4)|0,t=k.slice(4,6)|0,B=k.slice(6,8)|0,E=k.slice(8,10)|0,k=k.slice(10,12)|0,l=70>l?2E3+l:1900+l;else return l.error(\"Decoding \"+h+\" time is not supported yet\");return Date.UTC(l,h-1,t,B,E,k,0)};G.prototype._decodeNull=\nfunction(){return null};G.prototype._decodeBool=function(l){const h=l.readUInt8();return l.isError(h)?h:0!==h};G.prototype._decodeInt=function(l,h){l=l.raw();l=new e(l);h&&(l=h[l.toString(10)]||l);return l};G.prototype._use=function(l,h){\"function\"===typeof l&&(l=l(h));return l._getDecoder(\"der\").tree}}","~:source","shadow$provide[235] = function(global,require,module,exports) {\n'use strict';\n\nconst inherits = require('inherits');\n\nconst bignum = require('bn.js');\nconst DecoderBuffer = require('../base/buffer').DecoderBuffer;\nconst Node = require('../base/node');\n\n// Import DER constants\nconst der = require('../constants/der');\n\nfunction DERDecoder(entity) {\n  this.enc = 'der';\n  this.name = entity.name;\n  this.entity = entity;\n\n  // Construct base tree\n  this.tree = new DERNode();\n  this.tree._init(entity.body);\n}\nmodule.exports = DERDecoder;\n\nDERDecoder.prototype.decode = function decode(data, options) {\n  if (!DecoderBuffer.isDecoderBuffer(data)) {\n    data = new DecoderBuffer(data, options);\n  }\n\n  return this.tree._decode(data, options);\n};\n\n// Tree methods\n\nfunction DERNode(parent) {\n  Node.call(this, 'der', parent);\n}\ninherits(DERNode, Node);\n\nDERNode.prototype._peekTag = function peekTag(buffer, tag, any) {\n  if (buffer.isEmpty())\n    return false;\n\n  const state = buffer.save();\n  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: \"' + tag + '\"');\n  if (buffer.isError(decodedTag))\n    return decodedTag;\n\n  buffer.restore(state);\n\n  return decodedTag.tag === tag || decodedTag.tagStr === tag ||\n    (decodedTag.tagStr + 'of') === tag || any;\n};\n\nDERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {\n  const decodedTag = derDecodeTag(buffer,\n    'Failed to decode tag of \"' + tag + '\"');\n  if (buffer.isError(decodedTag))\n    return decodedTag;\n\n  let len = derDecodeLen(buffer,\n    decodedTag.primitive,\n    'Failed to get length of \"' + tag + '\"');\n\n  // Failure\n  if (buffer.isError(len))\n    return len;\n\n  if (!any &&\n      decodedTag.tag !== tag &&\n      decodedTag.tagStr !== tag &&\n      decodedTag.tagStr + 'of' !== tag) {\n    return buffer.error('Failed to match tag: \"' + tag + '\"');\n  }\n\n  if (decodedTag.primitive || len !== null)\n    return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n\n  // Indefinite length... find END tag\n  const state = buffer.save();\n  const res = this._skipUntilEnd(\n    buffer,\n    'Failed to skip indefinite length body: \"' + this.tag + '\"');\n  if (buffer.isError(res))\n    return res;\n\n  len = buffer.offset - state.offset;\n  buffer.restore(state);\n  return buffer.skip(len, 'Failed to match body of: \"' + tag + '\"');\n};\n\nDERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {\n  for (;;) {\n    const tag = derDecodeTag(buffer, fail);\n    if (buffer.isError(tag))\n      return tag;\n    const len = derDecodeLen(buffer, tag.primitive, fail);\n    if (buffer.isError(len))\n      return len;\n\n    let res;\n    if (tag.primitive || len !== null)\n      res = buffer.skip(len);\n    else\n      res = this._skipUntilEnd(buffer, fail);\n\n    // Failure\n    if (buffer.isError(res))\n      return res;\n\n    if (tag.tagStr === 'end')\n      break;\n  }\n};\n\nDERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,\n  options) {\n  const result = [];\n  while (!buffer.isEmpty()) {\n    const possibleEnd = this._peekTag(buffer, 'end');\n    if (buffer.isError(possibleEnd))\n      return possibleEnd;\n\n    const res = decoder.decode(buffer, 'der', options);\n    if (buffer.isError(res) && possibleEnd)\n      break;\n    result.push(res);\n  }\n  return result;\n};\n\nDERNode.prototype._decodeStr = function decodeStr(buffer, tag) {\n  if (tag === 'bitstr') {\n    const unused = buffer.readUInt8();\n    if (buffer.isError(unused))\n      return unused;\n    return { unused: unused, data: buffer.raw() };\n  } else if (tag === 'bmpstr') {\n    const raw = buffer.raw();\n    if (raw.length % 2 === 1)\n      return buffer.error('Decoding of string type: bmpstr length mismatch');\n\n    let str = '';\n    for (let i = 0; i < raw.length / 2; i++) {\n      str += String.fromCharCode(raw.readUInt16BE(i * 2));\n    }\n    return str;\n  } else if (tag === 'numstr') {\n    const numstr = buffer.raw().toString('ascii');\n    if (!this._isNumstr(numstr)) {\n      return buffer.error('Decoding of string type: ' +\n                          'numstr unsupported characters');\n    }\n    return numstr;\n  } else if (tag === 'octstr') {\n    return buffer.raw();\n  } else if (tag === 'objDesc') {\n    return buffer.raw();\n  } else if (tag === 'printstr') {\n    const printstr = buffer.raw().toString('ascii');\n    if (!this._isPrintstr(printstr)) {\n      return buffer.error('Decoding of string type: ' +\n                          'printstr unsupported characters');\n    }\n    return printstr;\n  } else if (/str$/.test(tag)) {\n    return buffer.raw().toString();\n  } else {\n    return buffer.error('Decoding of string type: ' + tag + ' unsupported');\n  }\n};\n\nDERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {\n  let result;\n  const identifiers = [];\n  let ident = 0;\n  let subident = 0;\n  while (!buffer.isEmpty()) {\n    subident = buffer.readUInt8();\n    ident <<= 7;\n    ident |= subident & 0x7f;\n    if ((subident & 0x80) === 0) {\n      identifiers.push(ident);\n      ident = 0;\n    }\n  }\n  if (subident & 0x80)\n    identifiers.push(ident);\n\n  const first = (identifiers[0] / 40) | 0;\n  const second = identifiers[0] % 40;\n\n  if (relative)\n    result = identifiers;\n  else\n    result = [first, second].concat(identifiers.slice(1));\n\n  if (values) {\n    let tmp = values[result.join(' ')];\n    if (tmp === undefined)\n      tmp = values[result.join('.')];\n    if (tmp !== undefined)\n      result = tmp;\n  }\n\n  return result;\n};\n\nDERNode.prototype._decodeTime = function decodeTime(buffer, tag) {\n  const str = buffer.raw().toString();\n\n  let year;\n  let mon;\n  let day;\n  let hour;\n  let min;\n  let sec;\n  if (tag === 'gentime') {\n    year = str.slice(0, 4) | 0;\n    mon = str.slice(4, 6) | 0;\n    day = str.slice(6, 8) | 0;\n    hour = str.slice(8, 10) | 0;\n    min = str.slice(10, 12) | 0;\n    sec = str.slice(12, 14) | 0;\n  } else if (tag === 'utctime') {\n    year = str.slice(0, 2) | 0;\n    mon = str.slice(2, 4) | 0;\n    day = str.slice(4, 6) | 0;\n    hour = str.slice(6, 8) | 0;\n    min = str.slice(8, 10) | 0;\n    sec = str.slice(10, 12) | 0;\n    if (year < 70)\n      year = 2000 + year;\n    else\n      year = 1900 + year;\n  } else {\n    return buffer.error('Decoding ' + tag + ' time is not supported yet');\n  }\n\n  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);\n};\n\nDERNode.prototype._decodeNull = function decodeNull() {\n  return null;\n};\n\nDERNode.prototype._decodeBool = function decodeBool(buffer) {\n  const res = buffer.readUInt8();\n  if (buffer.isError(res))\n    return res;\n  else\n    return res !== 0;\n};\n\nDERNode.prototype._decodeInt = function decodeInt(buffer, values) {\n  // Bigint, return as it is (assume big endian)\n  const raw = buffer.raw();\n  let res = new bignum(raw);\n\n  if (values)\n    res = values[res.toString(10)] || res;\n\n  return res;\n};\n\nDERNode.prototype._use = function use(entity, obj) {\n  if (typeof entity === 'function')\n    entity = entity(obj);\n  return entity._getDecoder('der').tree;\n};\n\n// Utility methods\n\nfunction derDecodeTag(buf, fail) {\n  let tag = buf.readUInt8(fail);\n  if (buf.isError(tag))\n    return tag;\n\n  const cls = der.tagClass[tag >> 6];\n  const primitive = (tag & 0x20) === 0;\n\n  // Multi-octet tag - load\n  if ((tag & 0x1f) === 0x1f) {\n    let oct = tag;\n    tag = 0;\n    while ((oct & 0x80) === 0x80) {\n      oct = buf.readUInt8(fail);\n      if (buf.isError(oct))\n        return oct;\n\n      tag <<= 7;\n      tag |= oct & 0x7f;\n    }\n  } else {\n    tag &= 0x1f;\n  }\n  const tagStr = der.tag[tag];\n\n  return {\n    cls: cls,\n    primitive: primitive,\n    tag: tag,\n    tagStr: tagStr\n  };\n}\n\nfunction derDecodeLen(buf, primitive, fail) {\n  let len = buf.readUInt8(fail);\n  if (buf.isError(len))\n    return len;\n\n  // Indefinite form\n  if (!primitive && len === 0x80)\n    return null;\n\n  // Definite form\n  if ((len & 0x80) === 0) {\n    // Short form\n    return len;\n  }\n\n  // Long form\n  const num = len & 0x7f;\n  if (num > 4)\n    return buf.error('length octect is too long');\n\n  len = 0;\n  for (let i = 0; i < num; i++) {\n    len <<= 8;\n    const j = buf.readUInt8(fail);\n    if (buf.isError(j))\n      return j;\n    len |= j;\n  }\n\n  return len;\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$asn1_DOT_js$lib$asn1$base$node","~$module$node_modules$asn1_DOT_js$lib$asn1$base$buffer","~$shadow.js","~$module$node_modules$inherits$inherits_browser","~$module$node_modules$asn1_DOT_js$lib$asn1$constants$der","~$module$node_modules$asn1_DOT_js$node_modules$bn_js$lib$bn"]],"~:properties",["^5",["_decodeTag","_decodeNull","_decodeTime","_decodeStr","decode","_decodeInt","_decodeObjid","_peekTag","_decodeList","primitive","name","tag","tree","enc","_use","unused","_skipUntilEnd","cls","tagStr","_decodeBool","entity","data"]],"~:compiled-at",1695041440859,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$asn1_DOT_js$lib$asn1$decoders$der.js\",\n\"lineCount\":8,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAY9DC,QAASA,EAAU,CAACC,CAAD,CAAS,CAC1B,IAAKC,CAAAA,GAAL,CAAW,KACX,KAAKC,CAAAA,IAAL,CAAYF,CAAOE,CAAAA,IACnB,KAAKF,CAAAA,MAAL,CAAcA,CAGd,KAAKG,CAAAA,IAAL,CAAY,IAAIC,CAChB,KAAKD,CAAAA,IAAKE,CAAAA,KAAV,CAAgBL,CAAOM,CAAAA,IAAvB,CAP0B,CAqB5BF,QAASA,EAAO,CAACG,CAAD,CAAS,CACvBC,CAAKC,CAAAA,IAAL,CAAU,IAAV,CAAgB,KAAhB,CAAuBF,CAAvB,CADuB,CA+OzBG,QAASA,EAAY,CAACC,CAAD,CAAMC,CAAN,CAAY,CAC/B,IAAIC,EAAMF,CAAIG,CAAAA,SAAJ,CAAcF,CAAd,CACV,IAAID,CAAII,CAAAA,OAAJ,CAAYF,CAAZ,CAAJ,CACE,MAAOA,EAET,OAAMG,EAAMC,CAAIC,CAAAA,QAAJ,CAAaL,CAAb,EAAoB,CAApB,CAAZ,CACMM,EAA6B,CAA7BA,IAAaN,CAAbM,CAAmB,EAAnBA,CAGN,IAAqB,EAArB,IAAKN,CAAL,CAAW,EAAX,EAA2B,CACzB,IAAIO,EAAMP,CAEV,KADAA,CACA,CADM,CACN,CAAwB,GAAxB,IAAQO,CAAR,CAAc,GAAd,EAAA,CAA8B,CAC5BA,CAAA,CAAMT,CAAIG,CAAAA,SAAJ,CAAcF,CAAd,CACN,IAAID,CAAII,CAAAA,OAAJ,CAAYK,CAAZ,CAAJ,CACE,MAAOA,EAETP,EAAA,GAAQ,CACRA,EAAA,EAAOO,CAAP,CAAa,GANe,CAHL,CAA3B,IAYEP,EAAA,EAAO,EAIT,OAAO,CACLG,IAAKA,CADA,CAELG,UAAWA,CAFN,CAGLN,IAAKA,CAHA,CAILQ,OANaJ,CAAIJ,CAAAA,GAAJQ,CAAQR,CAARQ,CAER,CAzBwB,CAiCjCC,QAASA,EAAY,CAACX,CAAD,CAAMQ,CAAN,CAAiBP,CAAjB,CAAuB,CAC1C,IAAIW,EAAMZ,CAAIG,CAAAA,SAAJ,CAAcF,CAAd,CACV,IAAID,CAAII,CAAAA,OAAJ,CAAYQ,CAAZ,CAAJ,CACE,MAAOA,EAGT;GAAI,CAACJ,CAAL,EAA0B,GAA1B,GAAkBI,CAAlB,CACE,MAAO,KAGT,IAAqB,CAArB,IAAKA,CAAL,CAAW,GAAX,EAEE,MAAOA,EAIHC,EAAAA,CAAMD,CAANC,CAAY,GAClB,IAAU,CAAV,CAAIA,CAAJ,CACE,MAAOb,EAAIc,CAAAA,KAAJ,CAAU,2BAAV,CAETF,EAAA,CAAM,CACN,KAAK,IAAIG,EAAI,CAAb,CAAgBA,CAAhB,CAAoBF,CAApB,CAAyBE,CAAA,EAAzB,CAA8B,CAC5BH,CAAA,GAAQ,CACR,OAAMI,EAAIhB,CAAIG,CAAAA,SAAJ,CAAcF,CAAd,CACV,IAAID,CAAII,CAAAA,OAAJ,CAAYY,CAAZ,CAAJ,CACE,MAAOA,EACTJ,EAAA,EAAOI,CALqB,CAQ9B,MAAOJ,EA7BmC,CA9StCK,CAAAA,CAAWhC,CAAA,CAAQ,EAAR,CAEjB,OAAMiC,EAASjC,CAAA,CAAQ,GAAR,CAAf,CACMkC,EAAgBlC,CAAA,CAAQ,GAAR,CAA0BkC,CAAAA,aADhD,CAEMtB,EAAOZ,CAAA,CAAQ,GAAR,CAFb,CAKMqB,EAAMrB,CAAA,CAAQ,GAAR,CAWZC,EAAOC,CAAAA,OAAP,CAAiBC,CAEjBA,EAAWgC,CAAAA,SAAUC,CAAAA,MAArB,CAA8BC,QAAe,CAACC,CAAD,CAAOC,CAAP,CAAgB,CACtDL,CAAcM,CAAAA,eAAd,CAA8BF,CAA9B,CAAL,GACEA,CADF,CACS,IAAIJ,CAAJ,CAAkBI,CAAlB,CAAwBC,CAAxB,CADT,CAIA,OAAO,KAAKhC,CAAAA,IAAKkC,CAAAA,OAAV,CAAkBH,CAAlB,CAAwBC,CAAxB,CALoD,CAa7DP,EAAA,CAASxB,CAAT,CAAkBI,CAAlB,CAEAJ,EAAQ2B,CAAAA,SAAUO,CAAAA,QAAlB,CAA6BC,QAAgB,CAACC,CAAD,CAAS3B,CAAT,CAAc4B,CAAd,CAAmB,CAC9D,GAAID,CAAOE,CAAAA,OAAP,EAAJ,CACE,MAAO,CAAA,CAET,OAAMC,EAAQH,CAAOI,CAAAA,IAAP,EAAd,CACMC,EAAanC,CAAA,CAAa8B,CAAb,CAAqB,uBAArB,CAA+C3B,CAA/C,CAAqD,GAArD,CACnB;GAAI2B,CAAOzB,CAAAA,OAAP,CAAe8B,CAAf,CAAJ,CACE,MAAOA,EAETL,EAAOM,CAAAA,OAAP,CAAeH,CAAf,CAEA,OAAOE,EAAWhC,CAAAA,GAAlB,GAA0BA,CAA1B,EAAiCgC,CAAWxB,CAAAA,MAA5C,GAAuDR,CAAvD,EACGgC,CAAWxB,CAAAA,MADd,CACuB,IADvB,GACiCR,CADjC,EACwC4B,CAZsB,CAehErC,EAAQ2B,CAAAA,SAAUgB,CAAAA,UAAlB,CAA+BC,QAAkB,CAACR,CAAD,CAAS3B,CAAT,CAAc4B,CAAd,CAAmB,CAClE,MAAMI,EAAanC,CAAA,CAAa8B,CAAb,CACjB,2BADiB,CACa3B,CADb,CACmB,GADnB,CAEnB,IAAI2B,CAAOzB,CAAAA,OAAP,CAAe8B,CAAf,CAAJ,CACE,MAAOA,EAET,KAAItB,EAAMD,CAAA,CAAakB,CAAb,CACRK,CAAW1B,CAAAA,SADH,CAER,2BAFQ,CAEsBN,CAFtB,CAE4B,GAF5B,CAKV,IAAI2B,CAAOzB,CAAAA,OAAP,CAAeQ,CAAf,CAAJ,CACE,MAAOA,EAET,IAAI,CAACkB,CAAL,EACII,CAAWhC,CAAAA,GADf,GACuBA,CADvB,EAEIgC,CAAWxB,CAAAA,MAFf,GAE0BR,CAF1B,EAGIgC,CAAWxB,CAAAA,MAHf,CAGwB,IAHxB,GAGiCR,CAHjC,CAIE,MAAO2B,EAAOf,CAAAA,KAAP,CAAa,wBAAb,CAAwCZ,CAAxC,CAA8C,GAA9C,CAGT,IAAIgC,CAAW1B,CAAAA,SAAf,EAAoC,IAApC,GAA4BI,CAA5B,CACE,MAAOiB,EAAOS,CAAAA,IAAP,CAAY1B,CAAZ,CAAiB,4BAAjB,CAAgDV,CAAhD,CAAsD,GAAtD,CAGH8B,EAAAA,CAAQH,CAAOI,CAAAA,IAAP,EACRM,EAAAA,CAAM,IAAKC,CAAAA,aAAL,CACVX,CADU,CAEV,0CAFU;AAEmC,IAAK3B,CAAAA,GAFxC,CAE8C,GAF9C,CAGZ,IAAI2B,CAAOzB,CAAAA,OAAP,CAAemC,CAAf,CAAJ,CACE,MAAOA,EAET3B,EAAA,CAAMiB,CAAOY,CAAAA,MAAb,CAAsBT,CAAMS,CAAAA,MAC5BZ,EAAOM,CAAAA,OAAP,CAAeH,CAAf,CACA,OAAOH,EAAOS,CAAAA,IAAP,CAAY1B,CAAZ,CAAiB,4BAAjB,CAAgDV,CAAhD,CAAsD,GAAtD,CAlC2D,CAqCpET,EAAQ2B,CAAAA,SAAUoB,CAAAA,aAAlB,CAAkCE,QAAqB,CAACb,CAAD,CAAS5B,CAAT,CAAe,CACpE,IAAA,CAAA,CAAA,CAAS,CACP,MAAMC,EAAMH,CAAA,CAAa8B,CAAb,CAAqB5B,CAArB,CACZ,IAAI4B,CAAOzB,CAAAA,OAAP,CAAeF,CAAf,CAAJ,CACE,MAAOA,EACT,KAAMU,EAAMD,CAAA,CAAakB,CAAb,CAAqB3B,CAAIM,CAAAA,SAAzB,CAAoCP,CAApC,CACZ,IAAI4B,CAAOzB,CAAAA,OAAP,CAAeQ,CAAf,CAAJ,CACE,MAAOA,EAIP2B,EAAA,CADErC,CAAIM,CAAAA,SAAR,EAA6B,IAA7B,GAAqBI,CAArB,CACQiB,CAAOS,CAAAA,IAAP,CAAY1B,CAAZ,CADR,CAGQ,IAAK4B,CAAAA,aAAL,CAAmBX,CAAnB,CAA2B5B,CAA3B,CAGR,IAAI4B,CAAOzB,CAAAA,OAAP,CAAemC,CAAf,CAAJ,CACE,MAAOA,EAET,IAAmB,KAAnB,GAAIrC,CAAIQ,CAAAA,MAAR,CACE,KAnBK,CAD2D,CAwBtEjB,EAAQ2B,CAAAA,SAAUuB,CAAAA,WAAlB,CAAgCC,QAAmB,CAACf,CAAD,CAAS3B,CAAT,CAAc2C,CAAd,CACjDrB,CADiD,CACxC,CAET,IADMsB,CACN,CADe,EACf,CAAO,CAACjB,CAAOE,CAAAA,OAAP,EAAR,CAAA,CAA0B,CACxB,MAAMgB,EAAc,IAAKpB,CAAAA,QAAL,CAAcE,CAAd,CAAsB,KAAtB,CACpB,IAAIA,CAAOzB,CAAAA,OAAP,CAAe2C,CAAf,CAAJ,CACE,MAAOA,EAET,OAAMR;AAAMM,CAAQxB,CAAAA,MAAR,CAAeQ,CAAf,CAAuB,KAAvB,CAA8BL,CAA9B,CACZ,IAAIK,CAAOzB,CAAAA,OAAP,CAAemC,CAAf,CAAJ,EAA2BQ,CAA3B,CACE,KACFD,EAAOE,CAAAA,IAAP,CAAYT,CAAZ,CARwB,CAU1B,MAAOO,EAZE,CAeXrD,EAAQ2B,CAAAA,SAAU6B,CAAAA,UAAlB,CAA+BC,QAAkB,CAACrB,CAAD,CAAS3B,CAAT,CAAc,CAC7D,GAAY,QAAZ,GAAIA,CAAJ,CAEE,MADMiD,EACN,CADetB,CAAO1B,CAAAA,SAAP,EACf,CAAI0B,CAAOzB,CAAAA,OAAP,CAAe+C,CAAf,CAAJ,CACSA,CADT,CAEO,CAAEA,OAAQA,CAAV,CAAkB5B,KAAMM,CAAOuB,CAAAA,GAAP,EAAxB,CACF,IAAY,QAAZ,GAAIlD,CAAJ,CAAsB,CACrBkD,CAAAA,CAAMvB,CAAOuB,CAAAA,GAAP,EACZ,IAAuB,CAAvB,GAAIA,CAAIC,CAAAA,MAAR,CAAiB,CAAjB,CACE,MAAOxB,EAAOf,CAAAA,KAAP,CAAa,iDAAb,CAELwC,EAAAA,CAAM,EACV,KAAK,IAAIvC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBqC,CAAIC,CAAAA,MAAxB,CAAiC,CAAjC,CAAoCtC,CAAA,EAApC,CACEuC,CAAA,EAAOC,MAAOC,CAAAA,YAAP,CAAoBJ,CAAIK,CAAAA,YAAJ,CAAqB,CAArB,CAAiB1C,CAAjB,CAApB,CAET,OAAOuC,EAToB,CAUtB,MAAY,QAAZ,GAAIpD,CAAJ,EACCwD,CACN,CADe7B,CAAOuB,CAAAA,GAAP,EAAaO,CAAAA,QAAb,CAAsB,OAAtB,CACf,CAAK,IAAKC,CAAAA,SAAL,CAAeF,CAAf,CAAL,CAIOA,CAJP,CACS7B,CAAOf,CAAAA,KAAP,CAAa,wDAAb,CAHJ;AAOY,QAEZ,GAFIZ,CAEJ,EAAY,SAAZ,GAAIA,CAAJ,CACE2B,CAAOuB,CAAAA,GAAP,EADF,CAEY,UAAZ,GAAIlD,CAAJ,EACC2D,CACN,CADiBhC,CAAOuB,CAAAA,GAAP,EAAaO,CAAAA,QAAb,CAAsB,OAAtB,CACjB,CAAK,IAAKG,CAAAA,WAAL,CAAiBD,CAAjB,CAAL,CAIOA,CAJP,CACShC,CAAOf,CAAAA,KAAP,CAAa,0DAAb,CAHJ,EAOI,MAAOiD,CAAAA,IAAP,CAAY7D,CAAZ,CAAJ,CACE2B,CAAOuB,CAAAA,GAAP,EAAaO,CAAAA,QAAb,EADF,CAGE9B,CAAOf,CAAAA,KAAP,CAAa,2BAAb,CAA2CZ,CAA3C,CAAiD,cAAjD,CArCoD,CAyC/DT,EAAQ2B,CAAAA,SAAU4C,CAAAA,YAAlB,CAAiCC,QAAoB,CAACpC,CAAD,CAASqC,CAAT,CAAiBC,CAAjB,CAA2B,CAE9E,IAAMC,EAAc,EAApB,CACIC,EAAQ,CACZ,KAAIC,EAAW,CACf,KAAA,CAAO,CAACzC,CAAOE,CAAAA,OAAP,EAAR,CAAA,CACEuC,CAGA,CAHWzC,CAAO1B,CAAAA,SAAP,EAGX,CAFAkE,CAEA,GAFU,CAEV,CADAA,CACA,EADSC,CACT,CADoB,GACpB,CAA0B,CAA1B,IAAKA,CAAL,CAAgB,GAAhB,IACEF,CAAYpB,CAAAA,IAAZ,CAAiBqB,CAAjB,CACA,CAAAA,CAAA,CAAQ,CAFV,CAKEC,EAAJ,CAAe,GAAf,EACEF,CAAYpB,CAAAA,IAAZ,CAAiBqB,CAAjB,CAEIE,EAAAA,CAASH,CAAA,CAAY,CAAZ,CAATG,CAA0B,EAA1BA,CAAgC,CAChCC,EAAAA,CAASJ,CAAA,CAAY,CAAZ,CAATI,CAA0B,EAG9B1B,EAAA,CADEqB,CAAJ,CACWC,CADX,CAGW,CAACG,CAAD,CAAQC,CAAR,CAAgBC,CAAAA,MAAhB,CAAuBL,CAAYM,CAAAA,KAAZ,CAAkB,CAAlB,CAAvB,CAEPR,EAAJ,GACMS,CAGJ,CAHUT,CAAA,CAAOpB,CAAO8B,CAAAA,IAAP,CAAY,GAAZ,CAAP,CAGV,CAFYC,IAAAA,EAEZ;AAFIF,CAEJ,GADEA,CACF,CADQT,CAAA,CAAOpB,CAAO8B,CAAAA,IAAP,CAAY,GAAZ,CAAP,CACR,EAAYC,IAAAA,EAAZ,GAAIF,CAAJ,GACE7B,CADF,CACW6B,CADX,CAJF,CAQA,OAAO7B,EAjCuE,CAoChFrD,EAAQ2B,CAAAA,SAAU0D,CAAAA,WAAlB,CAAgCC,QAAmB,CAAClD,CAAD,CAAS3B,CAAT,CAAc,CAC/D,IAAMoD,EAAMzB,CAAOuB,CAAAA,GAAP,EAAaO,CAAAA,QAAb,EAIZ,KAAIqB,CAAJ,CACIC,CADJ,CAEIC,CAEJ,IAAY,SAAZ,GAAIhF,CAAJ,CACEiF,CAKA,CALO7B,CAAIoB,CAAAA,KAAJ,CAAU,CAAV,CAAa,CAAb,CAKP,CALyB,CAKzB,CAJAU,CAIA,CAJM9B,CAAIoB,CAAAA,KAAJ,CAAU,CAAV,CAAa,CAAb,CAIN,CAJwB,CAIxB,CAHAM,CAGA,CAHM1B,CAAIoB,CAAAA,KAAJ,CAAU,CAAV,CAAa,CAAb,CAGN,CAHwB,CAGxB,CAFAO,CAEA,CAFO3B,CAAIoB,CAAAA,KAAJ,CAAU,CAAV,CAAa,EAAb,CAEP,CAF0B,CAE1B,CADAQ,CACA,CADM5B,CAAIoB,CAAAA,KAAJ,CAAU,EAAV,CAAc,EAAd,CACN,CAD0B,CAC1B,CAAAW,CAAA,CAAM/B,CAAIoB,CAAAA,KAAJ,CAAU,EAAV,CAAc,EAAd,CAAN,CAA0B,CAN5B,KAOO,IAAY,SAAZ,GAAIxE,CAAJ,CACLiF,CAOE,CAPK7B,CAAIoB,CAAAA,KAAJ,CAAU,CAAV,CAAa,CAAb,CAOL,CAPuB,CAOvB,CANFU,CAME,CANI9B,CAAIoB,CAAAA,KAAJ,CAAU,CAAV,CAAa,CAAb,CAMJ,CANsB,CAMtB,CALFM,CAKE,CALI1B,CAAIoB,CAAAA,KAAJ,CAAU,CAAV,CAAa,CAAb,CAKJ,CALsB,CAKtB,CAJFO,CAIE,CAJK3B,CAAIoB,CAAAA,KAAJ,CAAU,CAAV,CAAa,CAAb,CAIL,CAJuB,CAIvB,CAHFQ,CAGE,CAHI5B,CAAIoB,CAAAA,KAAJ,CAAU,CAAV,CAAa,EAAb,CAGJ,CAHuB,CAGvB,CAFFW,CAEE,CAFI/B,CAAIoB,CAAAA,KAAJ,CAAU,EAAV,CAAc,EAAd,CAEJ,CAFwB,CAExB,CAAAS,CAAA,CADS,EAAX,CAAIA,CAAJ,CACS,GADT,CACgBA,CADhB,CAGS,IAHT,CAGgBA,CAVX,KAYL,OAAOtD,EAAOf,CAAAA,KAAP,CAAa,WAAb,CAA2BZ,CAA3B,CAAiC,4BAAjC,CAGT,OAAOoF,KAAKC,CAAAA,GAAL,CAASJ,CAAT,CAAeC,CAAf,CAAqB,CAArB,CAAwBJ,CAAxB,CAA6BC,CAA7B,CAAmCC,CAAnC,CAAwCG,CAAxC,CAA6C,CAA7C,CA/BwD,CAkCjE5F,EAAQ2B,CAAAA,SAAUoE,CAAAA,WAAlB;AAAgCC,QAAmB,EAAG,CACpD,MAAO,KAD6C,CAItDhG,EAAQ2B,CAAAA,SAAUsE,CAAAA,WAAlB,CAAgCC,QAAmB,CAAC9D,CAAD,CAAS,CAC1D,MAAMU,EAAMV,CAAO1B,CAAAA,SAAP,EACZ,OAAI0B,EAAOzB,CAAAA,OAAP,CAAemC,CAAf,CAAJ,CACSA,CADT,CAGiB,CAHjB,GAGSA,CALiD,CAQ5D9C,EAAQ2B,CAAAA,SAAUwE,CAAAA,UAAlB,CAA+BC,QAAkB,CAAChE,CAAD,CAASqC,CAAT,CAAiB,CAE1Dd,CAAAA,CAAMvB,CAAOuB,CAAAA,GAAP,EACRb,EAAAA,CAAM,IAAIrB,CAAJ,CAAWkC,CAAX,CAENc,EAAJ,GACE3B,CADF,CACQ2B,CAAA,CAAO3B,CAAIoB,CAAAA,QAAJ,CAAa,EAAb,CAAP,CADR,EACoCpB,CADpC,CAGA,OAAOA,EARyD,CAWlE9C,EAAQ2B,CAAAA,SAAU0E,CAAAA,IAAlB,CAAyBC,QAAY,CAAC1G,CAAD,CAAS2G,CAAT,CAAc,CAC3B,UAAtB,GAAI,MAAO3G,EAAX,GACEA,CADF,CACWA,CAAA,CAAO2G,CAAP,CADX,CAEA,OAAO3G,EAAO4G,CAAAA,WAAP,CAAmB,KAAnB,CAA0BzG,CAAAA,IAHgB,CAxQW;\",\n\"sources\":[\"node_modules/asn1_DOT_js/lib/asn1/decoders/der.js\"],\n\"sourcesContent\":[\"shadow$provide[235] = function(global,require,module,exports) {\\n'use strict';\\n\\nconst inherits = require('inherits');\\n\\nconst bignum = require('bn.js');\\nconst DecoderBuffer = require('../base/buffer').DecoderBuffer;\\nconst Node = require('../base/node');\\n\\n// Import DER constants\\nconst der = require('../constants/der');\\n\\nfunction DERDecoder(entity) {\\n  this.enc = 'der';\\n  this.name = entity.name;\\n  this.entity = entity;\\n\\n  // Construct base tree\\n  this.tree = new DERNode();\\n  this.tree._init(entity.body);\\n}\\nmodule.exports = DERDecoder;\\n\\nDERDecoder.prototype.decode = function decode(data, options) {\\n  if (!DecoderBuffer.isDecoderBuffer(data)) {\\n    data = new DecoderBuffer(data, options);\\n  }\\n\\n  return this.tree._decode(data, options);\\n};\\n\\n// Tree methods\\n\\nfunction DERNode(parent) {\\n  Node.call(this, 'der', parent);\\n}\\ninherits(DERNode, Node);\\n\\nDERNode.prototype._peekTag = function peekTag(buffer, tag, any) {\\n  if (buffer.isEmpty())\\n    return false;\\n\\n  const state = buffer.save();\\n  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: \\\"' + tag + '\\\"');\\n  if (buffer.isError(decodedTag))\\n    return decodedTag;\\n\\n  buffer.restore(state);\\n\\n  return decodedTag.tag === tag || decodedTag.tagStr === tag ||\\n    (decodedTag.tagStr + 'of') === tag || any;\\n};\\n\\nDERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {\\n  const decodedTag = derDecodeTag(buffer,\\n    'Failed to decode tag of \\\"' + tag + '\\\"');\\n  if (buffer.isError(decodedTag))\\n    return decodedTag;\\n\\n  let len = derDecodeLen(buffer,\\n    decodedTag.primitive,\\n    'Failed to get length of \\\"' + tag + '\\\"');\\n\\n  // Failure\\n  if (buffer.isError(len))\\n    return len;\\n\\n  if (!any &&\\n      decodedTag.tag !== tag &&\\n      decodedTag.tagStr !== tag &&\\n      decodedTag.tagStr + 'of' !== tag) {\\n    return buffer.error('Failed to match tag: \\\"' + tag + '\\\"');\\n  }\\n\\n  if (decodedTag.primitive || len !== null)\\n    return buffer.skip(len, 'Failed to match body of: \\\"' + tag + '\\\"');\\n\\n  // Indefinite length... find END tag\\n  const state = buffer.save();\\n  const res = this._skipUntilEnd(\\n    buffer,\\n    'Failed to skip indefinite length body: \\\"' + this.tag + '\\\"');\\n  if (buffer.isError(res))\\n    return res;\\n\\n  len = buffer.offset - state.offset;\\n  buffer.restore(state);\\n  return buffer.skip(len, 'Failed to match body of: \\\"' + tag + '\\\"');\\n};\\n\\nDERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {\\n  for (;;) {\\n    const tag = derDecodeTag(buffer, fail);\\n    if (buffer.isError(tag))\\n      return tag;\\n    const len = derDecodeLen(buffer, tag.primitive, fail);\\n    if (buffer.isError(len))\\n      return len;\\n\\n    let res;\\n    if (tag.primitive || len !== null)\\n      res = buffer.skip(len);\\n    else\\n      res = this._skipUntilEnd(buffer, fail);\\n\\n    // Failure\\n    if (buffer.isError(res))\\n      return res;\\n\\n    if (tag.tagStr === 'end')\\n      break;\\n  }\\n};\\n\\nDERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,\\n  options) {\\n  const result = [];\\n  while (!buffer.isEmpty()) {\\n    const possibleEnd = this._peekTag(buffer, 'end');\\n    if (buffer.isError(possibleEnd))\\n      return possibleEnd;\\n\\n    const res = decoder.decode(buffer, 'der', options);\\n    if (buffer.isError(res) && possibleEnd)\\n      break;\\n    result.push(res);\\n  }\\n  return result;\\n};\\n\\nDERNode.prototype._decodeStr = function decodeStr(buffer, tag) {\\n  if (tag === 'bitstr') {\\n    const unused = buffer.readUInt8();\\n    if (buffer.isError(unused))\\n      return unused;\\n    return { unused: unused, data: buffer.raw() };\\n  } else if (tag === 'bmpstr') {\\n    const raw = buffer.raw();\\n    if (raw.length % 2 === 1)\\n      return buffer.error('Decoding of string type: bmpstr length mismatch');\\n\\n    let str = '';\\n    for (let i = 0; i < raw.length / 2; i++) {\\n      str += String.fromCharCode(raw.readUInt16BE(i * 2));\\n    }\\n    return str;\\n  } else if (tag === 'numstr') {\\n    const numstr = buffer.raw().toString('ascii');\\n    if (!this._isNumstr(numstr)) {\\n      return buffer.error('Decoding of string type: ' +\\n                          'numstr unsupported characters');\\n    }\\n    return numstr;\\n  } else if (tag === 'octstr') {\\n    return buffer.raw();\\n  } else if (tag === 'objDesc') {\\n    return buffer.raw();\\n  } else if (tag === 'printstr') {\\n    const printstr = buffer.raw().toString('ascii');\\n    if (!this._isPrintstr(printstr)) {\\n      return buffer.error('Decoding of string type: ' +\\n                          'printstr unsupported characters');\\n    }\\n    return printstr;\\n  } else if (/str$/.test(tag)) {\\n    return buffer.raw().toString();\\n  } else {\\n    return buffer.error('Decoding of string type: ' + tag + ' unsupported');\\n  }\\n};\\n\\nDERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {\\n  let result;\\n  const identifiers = [];\\n  let ident = 0;\\n  let subident = 0;\\n  while (!buffer.isEmpty()) {\\n    subident = buffer.readUInt8();\\n    ident <<= 7;\\n    ident |= subident & 0x7f;\\n    if ((subident & 0x80) === 0) {\\n      identifiers.push(ident);\\n      ident = 0;\\n    }\\n  }\\n  if (subident & 0x80)\\n    identifiers.push(ident);\\n\\n  const first = (identifiers[0] / 40) | 0;\\n  const second = identifiers[0] % 40;\\n\\n  if (relative)\\n    result = identifiers;\\n  else\\n    result = [first, second].concat(identifiers.slice(1));\\n\\n  if (values) {\\n    let tmp = values[result.join(' ')];\\n    if (tmp === undefined)\\n      tmp = values[result.join('.')];\\n    if (tmp !== undefined)\\n      result = tmp;\\n  }\\n\\n  return result;\\n};\\n\\nDERNode.prototype._decodeTime = function decodeTime(buffer, tag) {\\n  const str = buffer.raw().toString();\\n\\n  let year;\\n  let mon;\\n  let day;\\n  let hour;\\n  let min;\\n  let sec;\\n  if (tag === 'gentime') {\\n    year = str.slice(0, 4) | 0;\\n    mon = str.slice(4, 6) | 0;\\n    day = str.slice(6, 8) | 0;\\n    hour = str.slice(8, 10) | 0;\\n    min = str.slice(10, 12) | 0;\\n    sec = str.slice(12, 14) | 0;\\n  } else if (tag === 'utctime') {\\n    year = str.slice(0, 2) | 0;\\n    mon = str.slice(2, 4) | 0;\\n    day = str.slice(4, 6) | 0;\\n    hour = str.slice(6, 8) | 0;\\n    min = str.slice(8, 10) | 0;\\n    sec = str.slice(10, 12) | 0;\\n    if (year < 70)\\n      year = 2000 + year;\\n    else\\n      year = 1900 + year;\\n  } else {\\n    return buffer.error('Decoding ' + tag + ' time is not supported yet');\\n  }\\n\\n  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);\\n};\\n\\nDERNode.prototype._decodeNull = function decodeNull() {\\n  return null;\\n};\\n\\nDERNode.prototype._decodeBool = function decodeBool(buffer) {\\n  const res = buffer.readUInt8();\\n  if (buffer.isError(res))\\n    return res;\\n  else\\n    return res !== 0;\\n};\\n\\nDERNode.prototype._decodeInt = function decodeInt(buffer, values) {\\n  // Bigint, return as it is (assume big endian)\\n  const raw = buffer.raw();\\n  let res = new bignum(raw);\\n\\n  if (values)\\n    res = values[res.toString(10)] || res;\\n\\n  return res;\\n};\\n\\nDERNode.prototype._use = function use(entity, obj) {\\n  if (typeof entity === 'function')\\n    entity = entity(obj);\\n  return entity._getDecoder('der').tree;\\n};\\n\\n// Utility methods\\n\\nfunction derDecodeTag(buf, fail) {\\n  let tag = buf.readUInt8(fail);\\n  if (buf.isError(tag))\\n    return tag;\\n\\n  const cls = der.tagClass[tag >> 6];\\n  const primitive = (tag & 0x20) === 0;\\n\\n  // Multi-octet tag - load\\n  if ((tag & 0x1f) === 0x1f) {\\n    let oct = tag;\\n    tag = 0;\\n    while ((oct & 0x80) === 0x80) {\\n      oct = buf.readUInt8(fail);\\n      if (buf.isError(oct))\\n        return oct;\\n\\n      tag <<= 7;\\n      tag |= oct & 0x7f;\\n    }\\n  } else {\\n    tag &= 0x1f;\\n  }\\n  const tagStr = der.tag[tag];\\n\\n  return {\\n    cls: cls,\\n    primitive: primitive,\\n    tag: tag,\\n    tagStr: tagStr\\n  };\\n}\\n\\nfunction derDecodeLen(buf, primitive, fail) {\\n  let len = buf.readUInt8(fail);\\n  if (buf.isError(len))\\n    return len;\\n\\n  // Indefinite form\\n  if (!primitive && len === 0x80)\\n    return null;\\n\\n  // Definite form\\n  if ((len & 0x80) === 0) {\\n    // Short form\\n    return len;\\n  }\\n\\n  // Long form\\n  const num = len & 0x7f;\\n  if (num > 4)\\n    return buf.error('length octect is too long');\\n\\n  len = 0;\\n  for (let i = 0; i < num; i++) {\\n    len <<= 8;\\n    const j = buf.readUInt8(fail);\\n    if (buf.isError(j))\\n      return j;\\n    len |= j;\\n  }\\n\\n  return len;\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"DERDecoder\",\"entity\",\"enc\",\"name\",\"tree\",\"DERNode\",\"_init\",\"body\",\"parent\",\"Node\",\"call\",\"derDecodeTag\",\"buf\",\"fail\",\"tag\",\"readUInt8\",\"isError\",\"cls\",\"der\",\"tagClass\",\"primitive\",\"oct\",\"tagStr\",\"derDecodeLen\",\"len\",\"num\",\"error\",\"i\",\"j\",\"inherits\",\"bignum\",\"DecoderBuffer\",\"prototype\",\"decode\",\"DERDecoder.prototype.decode\",\"data\",\"options\",\"isDecoderBuffer\",\"_decode\",\"_peekTag\",\"DERNode.prototype._peekTag\",\"buffer\",\"any\",\"isEmpty\",\"state\",\"save\",\"decodedTag\",\"restore\",\"_decodeTag\",\"DERNode.prototype._decodeTag\",\"skip\",\"res\",\"_skipUntilEnd\",\"offset\",\"DERNode.prototype._skipUntilEnd\",\"_decodeList\",\"DERNode.prototype._decodeList\",\"decoder\",\"result\",\"possibleEnd\",\"push\",\"_decodeStr\",\"DERNode.prototype._decodeStr\",\"unused\",\"raw\",\"length\",\"str\",\"String\",\"fromCharCode\",\"readUInt16BE\",\"numstr\",\"toString\",\"_isNumstr\",\"printstr\",\"_isPrintstr\",\"test\",\"_decodeObjid\",\"DERNode.prototype._decodeObjid\",\"values\",\"relative\",\"identifiers\",\"ident\",\"subident\",\"first\",\"second\",\"concat\",\"slice\",\"tmp\",\"join\",\"undefined\",\"_decodeTime\",\"DERNode.prototype._decodeTime\",\"day\",\"hour\",\"min\",\"year\",\"mon\",\"sec\",\"Date\",\"UTC\",\"_decodeNull\",\"DERNode.prototype._decodeNull\",\"_decodeBool\",\"DERNode.prototype._decodeBool\",\"_decodeInt\",\"DERNode.prototype._decodeInt\",\"_use\",\"DERNode.prototype._use\",\"obj\",\"_getDecoder\"]\n}\n"]