shadow$provide.module$node_modules$viem$_cjs$utils$rpc=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.rpc=exports.getSocket=exports.socketsCache=void 0;const isomorphic_ws_1=require("module$node_modules$viem$node_modules$isomorphic_ws$browser"),request_js_1=require("module$node_modules$viem$_cjs$errors$request"),createBatchScheduler_js_1=require("module$node_modules$viem$_cjs$utils$promise$createBatchScheduler"),withTimeout_js_1=require("module$node_modules$viem$_cjs$utils$promise$withTimeout"),
stringify_js_1=require("module$node_modules$viem$_cjs$utils$stringify");let id=0;exports.socketsCache=new Map;exports.getSocket=async function(url){let socket=exports.socketsCache.get(url);if(socket)return socket;var {schedule}=(0,createBatchScheduler_js_1.createBatchScheduler)({id:url,fn:async()=>{let WebSocket_=isomorphic_ws_1.default;isomorphic_ws_1.default.constructor||(WebSocket_=isomorphic_ws_1.default.WebSocket);const webSocket=new WebSocket_(url),requests=new Map,subscriptions=new Map,onMessage=
({data})=>{var message=JSON.parse(data);const isSubscription="eth_subscription"===message.method;message=isSubscription?message.params.subscription:message.id;const cache=isSubscription?subscriptions:requests,callback=cache.get(message);callback&&callback({data});isSubscription||cache.delete(message)},onClose=()=>{exports.socketsCache.delete(url);webSocket.removeEventListener("close",onClose);webSocket.removeEventListener("message",onMessage)};webSocket.addEventListener("close",onClose);webSocket.addEventListener("message",
onMessage);webSocket.readyState===isomorphic_ws_1.default.CONNECTING&&await new Promise((resolve,reject)=>{webSocket&&(webSocket.onopen=resolve,webSocket.onerror=reject)});socket=Object.assign(webSocket,{requests,subscriptions});exports.socketsCache.set(url,socket);return[socket]}});[,[schedule]]=await schedule();return schedule};exports.rpc={http:async function(url,{body:body$jscomp$0,fetchOptions={},timeout=1E4}){const {headers,method,signal:signal_}=fetchOptions;try{const response=await (0,withTimeout_js_1.withTimeout)(async({signal})=>
await fetch(url,{...fetchOptions,body:Array.isArray(body$jscomp$0)?(0,stringify_js_1.stringify)(body$jscomp$0.map(body=>({jsonrpc:"2.0",id:body.id??id++,...body}))):(0,stringify_js_1.stringify)({jsonrpc:"2.0",id:body$jscomp$0.id??id++,...body$jscomp$0}),headers:{...headers,"Content-Type":"application/json"},method:method||"POST",signal:signal_||(0<timeout?signal:void 0)}),{errorInstance:new request_js_1.TimeoutError({body:body$jscomp$0,url}),timeout,signal:!0});let data;data=response.headers.get("Content-Type")?.startsWith("application/json")?
await response.json():await response.text();if(!response.ok)throw new request_js_1.HttpRequestError({body:body$jscomp$0,details:(0,stringify_js_1.stringify)(data.error)||response.statusText,headers:response.headers,status:response.status,url});return data}catch(err){if(err instanceof request_js_1.HttpRequestError)throw err;if(err instanceof request_js_1.TimeoutError)throw err;throw new request_js_1.HttpRequestError({body:body$jscomp$0,details:err.message,url});}},webSocket:function(socket,{body,onResponse}){if(socket.readyState===
socket.CLOSED||socket.readyState===socket.CLOSING)throw new request_js_1.WebSocketRequestError({body,url:socket.url,details:"Socket is closed."});const id_=id++,callback=({data})=>{data=JSON.parse(data);if("number"!==typeof data.id||id_===data.id)onResponse?.(data),"eth_subscribe"===body.method&&"string"===typeof data.result&&socket.subscriptions.set(data.result,callback),"eth_unsubscribe"===body.method&&socket.subscriptions.delete(body.params?.[0])};socket.requests.set(id_,callback);socket.send(JSON.stringify({jsonrpc:"2.0",
...body,id:id_}));return socket},webSocketAsync:async function(socket,{body,timeout=1E4}){return(0,withTimeout_js_1.withTimeout)(()=>new Promise(onResponse=>exports.rpc.webSocket(socket,{body,onResponse})),{errorInstance:new request_js_1.TimeoutError({body,url:socket.url}),timeout})}}}
//# sourceMappingURL=module$node_modules$viem$_cjs$utils$rpc.js.map
