["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/public-encrypt/privateDecrypt.js"],"~:js","shadow$provide[258]=function(S,A,V,q){var F=A(246),G=A(253),r=A(254),y=A(255),e=A(225),u=A(163),p=A(256),n=A(111).Buffer;V.exports=function(l,h,k){var t=l.padding?l.padding:k?1:4;l=F(l);var B=l.modulus.byteLength();if(h.length>B||0<=(new y(h)).cmp(l.modulus))throw Error(\"decryption error\");h=k?p(new y(h),l):e(h,l);var E=n.alloc(B-h.length);h=n.concat([E,h],B);if(4===t){B=h;t=l.modulus.byteLength();l=u(\"sha1\").update(n.alloc(0)).digest();k=l.length;if(0!==B[0])throw Error(\"decryption error\");h=B.slice(1,\nk+1);B=B.slice(k+1);h=r(h,G(B,k));t=r(B,G(h,t-k-1));B=t.slice(0,k);l=n.from(l);B=n.from(B);h=0;E=l.length;l.length!==B.length&&(h++,E=Math.min(l.length,B.length));for(var H=-1;++H<E;)h+=l[H]^B[H];if(h)throw Error(\"decryption error\");for(;0===t[k];)k++;if(1!==t[k++])throw Error(\"decryption error\");return t.slice(k)}if(1===t){t=h;l=t.slice(0,2);B=2;for(h=0;0!==t[B++];)if(B>=t.length){h++;break}E=t.slice(2,B-1);(\"0002\"!==l.toString(\"hex\")&&!k||\"0001\"!==l.toString(\"hex\")&&k)&&h++;8>E.length&&h++;if(h)throw Error(\"decryption error\");\nreturn t.slice(B)}if(3===t)return h;throw Error(\"unknown padding\");}}","~:source","shadow$provide[258] = function(global,require,module,exports) {\nvar parseKeys = require('parse-asn1')\nvar mgf = require('./mgf')\nvar xor = require('./xor')\nvar BN = require('bn.js')\nvar crt = require('browserify-rsa')\nvar createHash = require('create-hash')\nvar withPublic = require('./withPublic')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function privateDecrypt (privateKey, enc, reverse) {\n  var padding\n  if (privateKey.padding) {\n    padding = privateKey.padding\n  } else if (reverse) {\n    padding = 1\n  } else {\n    padding = 4\n  }\n\n  var key = parseKeys(privateKey)\n  var k = key.modulus.byteLength()\n  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {\n    throw new Error('decryption error')\n  }\n  var msg\n  if (reverse) {\n    msg = withPublic(new BN(enc), key)\n  } else {\n    msg = crt(enc, key)\n  }\n  var zBuffer = Buffer.alloc(k - msg.length)\n  msg = Buffer.concat([zBuffer, msg], k)\n  if (padding === 4) {\n    return oaep(key, msg)\n  } else if (padding === 1) {\n    return pkcs1(key, msg, reverse)\n  } else if (padding === 3) {\n    return msg\n  } else {\n    throw new Error('unknown padding')\n  }\n}\n\nfunction oaep (key, msg) {\n  var k = key.modulus.byteLength()\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\n  var hLen = iHash.length\n  if (msg[0] !== 0) {\n    throw new Error('decryption error')\n  }\n  var maskedSeed = msg.slice(1, hLen + 1)\n  var maskedDb = msg.slice(hLen + 1)\n  var seed = xor(maskedSeed, mgf(maskedDb, hLen))\n  var db = xor(maskedDb, mgf(seed, k - hLen - 1))\n  if (compare(iHash, db.slice(0, hLen))) {\n    throw new Error('decryption error')\n  }\n  var i = hLen\n  while (db[i] === 0) {\n    i++\n  }\n  if (db[i++] !== 1) {\n    throw new Error('decryption error')\n  }\n  return db.slice(i)\n}\n\nfunction pkcs1 (key, msg, reverse) {\n  var p1 = msg.slice(0, 2)\n  var i = 2\n  var status = 0\n  while (msg[i++] !== 0) {\n    if (i >= msg.length) {\n      status++\n      break\n    }\n  }\n  var ps = msg.slice(2, i - 1)\n\n  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {\n    status++\n  }\n  if (ps.length < 8) {\n    status++\n  }\n  if (status) {\n    throw new Error('decryption error')\n  }\n  return msg.slice(i)\n}\nfunction compare (a, b) {\n  a = Buffer.from(a)\n  b = Buffer.from(b)\n  var dif = 0\n  var len = a.length\n  if (a.length !== b.length) {\n    dif++\n    len = Math.min(a.length, b.length)\n  }\n  var i = -1\n  while (++i < len) {\n    dif += (a[i] ^ b[i])\n  }\n  return dif\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$public_encrypt$withPublic","~$module$node_modules$public_encrypt$xor","~$module$node_modules$create_hash$browser","~$shadow.js","~$module$node_modules$safe_buffer$index","~$module$node_modules$parse_asn1$index","~$module$node_modules$public_encrypt$mgf","~$module$node_modules$public_encrypt$node_modules$bn_js$lib$bn","~$module$node_modules$browserify_rsa$index"]],"~:properties",["^5",[]],"~:compiled-at",1695041440876,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$public_encrypt$privateDecrypt.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAC9D,IAAIC,EAAYH,CAAA,CAAQ,GAAR,CAAhB,CACII,EAAMJ,CAAA,CAAQ,GAAR,CADV,CAEIK,EAAML,CAAA,CAAQ,GAAR,CAFV,CAGIM,EAAKN,CAAA,CAAQ,GAAR,CAHT,CAIIO,EAAMP,CAAA,CAAQ,GAAR,CAJV,CAKIQ,EAAaR,CAAA,CAAQ,GAAR,CALjB,CAMIS,EAAaT,CAAA,CAAQ,GAAR,CANjB,CAOIU,EAASV,CAAA,CAAQ,GAAR,CAAuBU,CAAAA,MAEpCT,EAAOC,CAAAA,OAAP,CAAiBS,QAAwB,CAACC,CAAD,CAAaC,CAAb,CAAkBC,CAAlB,CAA2B,CAGhE,IAAAC,EADEH,CAAWG,CAAAA,OAAf,CACYH,CAAWG,CAAAA,OADvB,CAEWD,CAAJ,CACK,CADL,CAGK,CAGRE,EAAAA,CAAMb,CAAA,CAAUS,CAAV,CACV,KAAIK,EAAID,CAAIE,CAAAA,OAAQC,CAAAA,UAAZ,EACR,IAAIN,CAAIO,CAAAA,MAAR,CAAiBH,CAAjB,EAAsD,CAAtD,EAAkCI,CAAZ,IAAIf,CAAJ,CAAOO,CAAP,CAAYQ,EAAAA,GAAZ,CAAgBL,CAAIE,CAAAA,OAApB,CAAtB,CACE,KAAUI,MAAJ,CAAU,kBAAV,CAAN,CAIAC,CAAA,CADET,CAAJ,CACQL,CAAA,CAAW,IAAIH,CAAJ,CAAOO,CAAP,CAAX,CAAwBG,CAAxB,CADR,CAGQT,CAAA,CAAIM,CAAJ,CAASG,CAAT,CAER,KAAIQ,EAAUd,CAAOe,CAAAA,KAAP,CAAaR,CAAb,CAAiBM,CAAIH,CAAAA,MAArB,CACdG,EAAA,CAAMb,CAAOgB,CAAAA,MAAP,CAAc,CAACF,CAAD,CAAUD,CAAV,CAAd,CAA8BN,CAA9B,CACN,IAAgB,CAAhB,GAAIF,CAAJ,CAAmB,CACAQ,CAAAA,CAAAA,CAWfN,EAAAA,CAXUD,CAWFE,CAAAA,OAAQC,CAAAA,UAAZ,EACJQ,EAAAA,CAAQnB,CAAA,CAAW,MAAX,CAAmBoB,CAAAA,MAAnB,CAA0BlB,CAAOe,CAAAA,KAAP,CAAa,CAAb,CAA1B,CAA2CI,CAAAA,MAA3C,EACRC,EAAAA,CAAOH,CAAMP,CAAAA,MACjB,IAAe,CAAf,GAAIG,CAAA,CAAI,CAAJ,CAAJ,CACE,KAAUD,MAAJ,CAAU,kBAAV,CAAN,CAEES,CAAAA,CAAaR,CAAIS,CAAAA,KAAJ,CAAU,CAAV;AAAaF,CAAb,CAAoB,CAApB,CACbG,EAAAA,CAAWV,CAAIS,CAAAA,KAAJ,CAAUF,CAAV,CAAiB,CAAjB,CACXI,EAAAA,CAAO7B,CAAA,CAAI0B,CAAJ,CAAgB3B,CAAA,CAAI6B,CAAJ,CAAcH,CAAd,CAAhB,CACPK,EAAAA,CAAK9B,CAAA,CAAI4B,CAAJ,CAAc7B,CAAA,CAAI8B,CAAJ,CAAUjB,CAAV,CAAca,CAAd,CAAqB,CAArB,CAAd,CACU,EAAA,CAAAK,CAAGH,CAAAA,KAAH,CAAS,CAAT,CAAYF,CAAZ,CAqCnBM,EAAA,CAAI1B,CAAO2B,CAAAA,IAAP,CAAYD,CAAZ,CACJE,EAAA,CAAI5B,CAAO2B,CAAAA,IAAP,CAAYC,CAAZ,CACAC,EAAAA,CAAM,CACNC,EAAAA,CAAMJ,CAAEhB,CAAAA,MACRgB,EAAEhB,CAAAA,MAAN,GAAiBkB,CAAElB,CAAAA,MAAnB,GACEmB,CAAA,EACA,CAAAC,CAAA,CAAMC,IAAKC,CAAAA,GAAL,CAASN,CAAEhB,CAAAA,MAAX,CAAmBkB,CAAElB,CAAAA,MAArB,CAFR,CAKA,KADA,IAAIuB,EAAI,CAAC,CACT,CAAO,EAAEA,CAAT,CAAaH,CAAb,CAAA,CACED,CAAA,EAAQH,CAAA,CAAEO,CAAF,CAAR,CAAeL,CAAA,CAAEK,CAAF,CA/CjB,IAiDOJ,CAjDP,CACE,KAAUjB,MAAJ,CAAU,kBAAV,CAAN,CAGF,IAAA,CAAiB,CAAjB,GAAOa,CAAA,CAAGQ,CAAH,CAAP,CAAA,CACEA,CAAA,EAEF,IAAgB,CAAhB,GAAIR,CAAA,CAAGQ,CAAA,EAAH,CAAJ,CACE,KAAUrB,MAAJ,CAAU,kBAAV,CAAN,CA7BA,MA+BKa,EAAGH,CAAAA,KAAH,CAASW,CAAT,CAhCY,CAEZ,GAAgB,CAAhB,GAAI5B,CAAJ,CAAmB,CACNQ,CAAAA,CAAAA,CAiChBqB,EAAAA,CAAKrB,CAAIS,CAAAA,KAAJ,CAAU,CAAV,CAAa,CAAb,CACLW,EAAAA,CAAI,CAER,KADIE,CACJ,CADa,CACb,CAAoB,CAApB,GAAOtB,CAAA,CAAIoB,CAAA,EAAJ,CAAP,CAAA,CACE,GAAIA,CAAJ,EAASpB,CAAIH,CAAAA,MAAb,CAAqB,CACnByB,CAAA,EACA,MAFmB,CAKnBC,CAAAA,CAAKvB,CAAIS,CAAAA,KAAJ,CAAU,CAAV,CAAaW,CAAb,CAAiB,CAAjB,CAET,EAA4B,MAA5B,GAAKC,CAAGG,CAAAA,QAAH,CAAY,KAAZ,CAAL,EAAsC,CA5CbjC,CA4CzB,EAA2E,MAA3E,GAAoD8B,CAAGG,CAAAA,QAAH,CAAY,KAAZ,CAApD,EA5CyBjC,CA4CzB,GACE+B,CAAA,EAEc,EAAhB,CAAIC,CAAG1B,CAAAA,MAAP,EACEyB,CAAA,EAEF,IAAIA,CAAJ,CACE,KAAUvB,MAAJ,CAAU,kBAAV,CAAN;AAnDA,MAqDKC,EAAIS,CAAAA,KAAJ,CAAUW,CAAV,CAtDmB,CAEnB,GAAgB,CAAhB,GAAI5B,CAAJ,CACL,MAAOQ,EAEP,MAAUD,MAAJ,CAAU,iBAAV,CAAN,CA9BgE,CAVN;\",\n\"sources\":[\"node_modules/public-encrypt/privateDecrypt.js\"],\n\"sourcesContent\":[\"shadow$provide[258] = function(global,require,module,exports) {\\nvar parseKeys = require('parse-asn1')\\nvar mgf = require('./mgf')\\nvar xor = require('./xor')\\nvar BN = require('bn.js')\\nvar crt = require('browserify-rsa')\\nvar createHash = require('create-hash')\\nvar withPublic = require('./withPublic')\\nvar Buffer = require('safe-buffer').Buffer\\n\\nmodule.exports = function privateDecrypt (privateKey, enc, reverse) {\\n  var padding\\n  if (privateKey.padding) {\\n    padding = privateKey.padding\\n  } else if (reverse) {\\n    padding = 1\\n  } else {\\n    padding = 4\\n  }\\n\\n  var key = parseKeys(privateKey)\\n  var k = key.modulus.byteLength()\\n  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {\\n    throw new Error('decryption error')\\n  }\\n  var msg\\n  if (reverse) {\\n    msg = withPublic(new BN(enc), key)\\n  } else {\\n    msg = crt(enc, key)\\n  }\\n  var zBuffer = Buffer.alloc(k - msg.length)\\n  msg = Buffer.concat([zBuffer, msg], k)\\n  if (padding === 4) {\\n    return oaep(key, msg)\\n  } else if (padding === 1) {\\n    return pkcs1(key, msg, reverse)\\n  } else if (padding === 3) {\\n    return msg\\n  } else {\\n    throw new Error('unknown padding')\\n  }\\n}\\n\\nfunction oaep (key, msg) {\\n  var k = key.modulus.byteLength()\\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\\n  var hLen = iHash.length\\n  if (msg[0] !== 0) {\\n    throw new Error('decryption error')\\n  }\\n  var maskedSeed = msg.slice(1, hLen + 1)\\n  var maskedDb = msg.slice(hLen + 1)\\n  var seed = xor(maskedSeed, mgf(maskedDb, hLen))\\n  var db = xor(maskedDb, mgf(seed, k - hLen - 1))\\n  if (compare(iHash, db.slice(0, hLen))) {\\n    throw new Error('decryption error')\\n  }\\n  var i = hLen\\n  while (db[i] === 0) {\\n    i++\\n  }\\n  if (db[i++] !== 1) {\\n    throw new Error('decryption error')\\n  }\\n  return db.slice(i)\\n}\\n\\nfunction pkcs1 (key, msg, reverse) {\\n  var p1 = msg.slice(0, 2)\\n  var i = 2\\n  var status = 0\\n  while (msg[i++] !== 0) {\\n    if (i >= msg.length) {\\n      status++\\n      break\\n    }\\n  }\\n  var ps = msg.slice(2, i - 1)\\n\\n  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {\\n    status++\\n  }\\n  if (ps.length < 8) {\\n    status++\\n  }\\n  if (status) {\\n    throw new Error('decryption error')\\n  }\\n  return msg.slice(i)\\n}\\nfunction compare (a, b) {\\n  a = Buffer.from(a)\\n  b = Buffer.from(b)\\n  var dif = 0\\n  var len = a.length\\n  if (a.length !== b.length) {\\n    dif++\\n    len = Math.min(a.length, b.length)\\n  }\\n  var i = -1\\n  while (++i < len) {\\n    dif += (a[i] ^ b[i])\\n  }\\n  return dif\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"parseKeys\",\"mgf\",\"xor\",\"BN\",\"crt\",\"createHash\",\"withPublic\",\"Buffer\",\"module.exports\",\"privateKey\",\"enc\",\"reverse\",\"padding\",\"key\",\"k\",\"modulus\",\"byteLength\",\"length\",\"cmp\",\"Error\",\"msg\",\"zBuffer\",\"alloc\",\"concat\",\"iHash\",\"update\",\"digest\",\"hLen\",\"maskedSeed\",\"slice\",\"maskedDb\",\"seed\",\"db\",\"a\",\"from\",\"b\",\"dif\",\"len\",\"Math\",\"min\",\"i\",\"p1\",\"status\",\"ps\",\"toString\"]\n}\n"]